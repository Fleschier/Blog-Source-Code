{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/README.MDOWN","path":"README.MDOWN","modified":1,"renderable":0},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/tag-icon.svg","path":"images/tag-icon.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/HTML/ul-li.png","path":"images/HTML/ul-li.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Hadoop/launch_info.png","path":"images/Hadoop/launch_info.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Hadoop/ssh_log.png","path":"images/Hadoop/ssh_log.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Hadoop/stop_all.png","path":"images/Hadoop/stop_all.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/JavaScript/001.png","path":"images/JavaScript/001.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/JavaScript/005.png","path":"images/JavaScript/005.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/JavaScript/007.png","path":"images/JavaScript/007.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Scala/Scala-test.jpg","path":"images/Scala/Scala-test.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Scala/create_1.png","path":"images/Scala/create_1.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Scala/create_2.png","path":"images/Scala/create_2.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Scala/flatten_test.jpg","path":"images/Scala/flatten_test.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/block_chain/structure.png","path":"images/block_chain/structure.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/linux-and-windows/bootice01.jpg","path":"images/linux-and-windows/bootice01.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/linux-and-windows/bootice02.jpg","path":"images/linux-and-windows/bootice02.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/linux-and-windows/refind-info.jpg","path":"images/linux-and-windows/refind-info.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/linux-and-windows/ubuntu-boot.jpg","path":"images/linux-and-windows/ubuntu-boot.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/node.js/info.png","path":"images/node.js/info.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/ssr/auto_switch_02.png","path":"images/ssr/auto_switch_02.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/ssr/gfwlist.png","path":"images/ssr/gfwlist.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Blog/jekyll_01.jpg","path":"images/Blog/jekyll_01.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Blog/jekyll_02.jpg","path":"images/Blog/jekyll_02.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/CSS/color_list.jpg","path":"images/CSS/color_list.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Hadoop/path.png","path":"images/Hadoop/path.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Hadoop/ssh_key.png","path":"images/Hadoop/ssh_key.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/JavaScript/004.png","path":"images/JavaScript/004.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Scala/first_program.png","path":"images/Scala/first_program.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Windows/atom.jpg","path":"images/Windows/atom.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/spark/集群文件系统的问题.png","path":"images/spark/集群文件系统的问题.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/ssr/auto_switch_01.png","path":"images/ssr/auto_switch_01.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/ssr/example.png","path":"images/ssr/example.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/ssr/systemset.png","path":"images/ssr/systemset.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Hadoop/datanode_info.png","path":"images/Hadoop/datanode_info.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/SQL/E-R graphe.png","path":"images/SQL/E-R graphe.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/block_chain/metacion_test_result.png","path":"images/block_chain/metacion_test_result.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/spark/spark-shell.png","path":"images/spark/spark-shell.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/CSS/color.jpg","path":"images/CSS/color.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/JavaScript/003.png","path":"images/JavaScript/003.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/JavaScript/002.png","path":"images/JavaScript/002.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/JavaScript/006.png","path":"images/JavaScript/006.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/linux-and-windows/opening-bg.jpg","path":"images/linux-and-windows/opening-bg.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/Scala/relation.jpg","path":"images/Scala/relation.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/SQL/TIM图片20180503210911.jpg","path":"images/SQL/TIM图片20180503210911.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"3ca8eaa89f4a8a02ea431a930de7716f88afc7fd","modified":1536067572074},{"_id":"source/README.MDOWN","hash":"fb71db3d41a6dbee36da75079da91d57ce637187","modified":1535966059230},{"_id":"source/offline.md","hash":"a4c914fc01f3f6954054eb0b9c73a26aff60022f","modified":1535962954056},{"_id":"themes/hexo-theme-next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1535960245229},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1535960245229},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1535960245229},{"_id":"themes/hexo-theme-next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1535960245229},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1535960245233},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1535960245233},{"_id":"themes/hexo-theme-next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1535960245229},{"_id":"themes/hexo-theme-next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1535960245233},{"_id":"themes/hexo-theme-next/README.md","hash":"c1d6d1c6b75736b892e179865833ea58da5ca9d2","modified":1535960245233},{"_id":"themes/hexo-theme-next/_config.yml","hash":"c1eca8c6a8025bc63a84a0c180b2e6b1ba5814b5","modified":1535961808725},{"_id":"themes/hexo-theme-next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1535960245233},{"_id":"themes/hexo-theme-next/bower.json","hash":"5391684ba84fe633bc7877ab711a7d8a0072ceda","modified":1535960245233},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1535960245233},{"_id":"themes/hexo-theme-next/package.json","hash":"9acf6b8c8194f8a366025c8aab64d236908e62a1","modified":1535960245237},{"_id":"source/_posts/2018-04-05-hello-2018.md","hash":"a6b62c40cfa05ec6bbb21d818d804a1b697de038","modified":1535964619774},{"_id":"source/_posts/2018-04-06-C++learning.md","hash":"ce594086c93c63083537da1de8a6dcf4983de434","modified":1535981199126},{"_id":"source/_posts/2018-04-06-Java-class.md","hash":"0896bdc2f1ba440f6479b7c0b61d00a6be38b2d3","modified":1535983312914},{"_id":"source/_posts/2018-04-06-Java-function.md","hash":"132c29fc9bc3dfb66b6b7bfdc7f528b591aaf9e3","modified":1535981160221},{"_id":"source/_posts/2018-04-06-Python-learning.md","hash":"e378c6d0f83e77277a14d1ae988c6d433baddf7e","modified":1535981110821},{"_id":"source/_posts/2018-04-06-Java-learning.md","hash":"46085ea449c0bda748773c6730a9f36a051e48ca","modified":1535981153625},{"_id":"source/_posts/2018-04-06-Scala-superior.md","hash":"172430787e14e84ec2bc157e8c0c36a7e72714df","modified":1535981012788},{"_id":"source/_posts/2018-04-06-Scala-learning.md","hash":"76a46e3b47394ec25844fe2e93df68e99d134596","modified":1535981063616},{"_id":"source/_posts/2018-04-06-Ubuntu-operation.md","hash":"62c58a6d9c020c6e0141128a1c2d892c5a82e03c","modified":1535980993035},{"_id":"source/_posts/2018-04-06-Ubuntu-order.md","hash":"6230df1b43da400764789519aebd338304808a6e","modified":1535980958768},{"_id":"source/_posts/2018-04-06-ubuntu-and-windows.md","hash":"7060df3847aba1f07d0172fe2b3eeb58191641de","modified":1535981003907},{"_id":"source/_posts/2018-04-07-SQL-quary.md","hash":"6c3664849fcc9efe128c319dfbcbc61de1e9a3e0","modified":1535980753490},{"_id":"source/_posts/2018-04-11-Git-and-Github.md","hash":"0327a052e0f972d2bfde615095bed7db2bea77d2","modified":1535980711941},{"_id":"source/_posts/2018-04-11-Spark-superior.md","hash":"d0fd4a0d2faadd3680f830077195f8bb26210a77","modified":1535980678256},{"_id":"source/_posts/2018-04-11-Spark-learning.md","hash":"d63e30062cc4ff6fe9e1fc1652384aaf2e190bbd","modified":1535980702362},{"_id":"source/_posts/2018-04-15-Block-Chain.md","hash":"ed63483a0235223e91344c7c97fcc458d58dc0bf","modified":1535964078601},{"_id":"source/_posts/2018-04-15-File-types.md","hash":"fa97dd35f87331814b249334fee8c0c219fc3588","modified":1535980665430},{"_id":"source/_posts/2018-04-19-Shaow-socks.md","hash":"89b9174f3d330c11669b6afdc96992905b9bbbd3","modified":1535980653983},{"_id":"source/_posts/2018-04-29-Python-superior.md","hash":"c5408a0edf0aed93eed1169ba67bd41c47fdce2c","modified":1535980645524},{"_id":"source/_posts/2018-05-03-Google-play-Android.md","hash":"5b640a0de76aa5e00fda464ae2b4502f33e71758","modified":1535964349019},{"_id":"source/_posts/2018-05-10-Ubuntu-18.md","hash":"951afab512c6ba521ded0f935a429c7e4522683e","modified":1535980629062},{"_id":"source/_posts/2018-05-17-BlockChain-concepts.md","hash":"63f7ee3da641aadf72112ce32625f988e2bb683a","modified":1535980614280},{"_id":"source/_posts/2018-05-21-NodeJS.md","hash":"5b357de6003180e3d4fb1e2dace4249d57265e11","modified":1535982115721},{"_id":"source/_posts/2018-05-23-Ethereum.md","hash":"8ca64f3a6cbb85b674a2726724705845adc4f018","modified":1535980584393},{"_id":"source/_posts/2018-05-25-jetbrains.md","hash":"1994618595ffa3f3b1d42c38a29c5dbd1182bcd6","modified":1535964430999},{"_id":"source/_posts/2018-05-30-Hadoop-usage.md","hash":"22fa7bff260655ca81963b1b686d7ec3579877bb","modified":1535980560761},{"_id":"source/_posts/2018-05-31-HDFS.md","hash":"c9c19016fd42b7aa9d4d163b0583415998826979","modified":1535980540361},{"_id":"source/_posts/2018-06-17-FrontEnd-CSS.md","hash":"d96ab3b695b21bc2fbe5718b8331fd09656570ce","modified":1535980521621},{"_id":"source/_posts/2018-06-17-FrontEnd-HTML.md","hash":"f532fef2074255d54860f1e0b35b8c2025232329","modified":1535980446827},{"_id":"source/_posts/2018-07-07-JavaScript.md","hash":"86342ebbbad81643e5f30006b3b742b7cd119925","modified":1535980388670},{"_id":"source/_posts/2018-07-08-Jekyll-usage.md","hash":"0c626fa03143ab88876dc5556d73aa9b0deb7899","modified":1535964612010},{"_id":"source/_posts/2018-07-12-Scala-infos.md","hash":"09e53fb5e417e3a4f662ff0a7e378788476324de","modified":1535980309120},{"_id":"source/_posts/2018-07-12-Scala-learning-01.md","hash":"97d26d352ad4cc637438f6f3a0e0add1506e49f6","modified":1535980278654},{"_id":"source/_posts/2018-07-19-scala-learning-02.md","hash":"6f59dcc319a0b0854734bbd8f4e68961b6b03c0f","modified":1535980244611},{"_id":"source/_posts/2018-07-20-cluster-usage.md","hash":"ce9f44cbb5d7e7d1ced2be10c8b256bef1450adb","modified":1535980189971},{"_id":"source/_posts/2018-07-23-scala-learning-03.md","hash":"7dd3684c44dd6349b7a6ca8d3388aae58bd55bf6","modified":1535981826158},{"_id":"source/_posts/2018-07-23-windows-realated.md","hash":"e0198708003101bc713367cce235ce892e50dfef","modified":1535964703173},{"_id":"source/_posts/2018-07-24-scala-learning-04.md","hash":"25f3024111eb3adbf2da7f7571731f023eeb864c","modified":1535980144291},{"_id":"source/_posts/2018-07-24-scala-learning-05.md","hash":"16c4ebb3a75896e17870b914113eb1c1b527c19e","modified":1535980112348},{"_id":"source/_posts/2018-09-03-Hexo-rebuild.md","hash":"16b4cec8b2ed0e08addd201c384c846f61a5d168","modified":1535984164187},{"_id":"source/about/index.md","hash":"b2bdba6545f3196dd33259f74868f412bef4c2c6","modified":1535964876905},{"_id":"source/categories/index.md","hash":"12565fd75ad1801ab9c1b3f4dbdd7fb38e85f281","modified":1535964889889},{"_id":"source/tags/index.md","hash":"a8de393cc8fab5adee322c5050850fcb76df7a27","modified":1535964898541},{"_id":"themes/hexo-theme-next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1535960245225},{"_id":"themes/hexo-theme-next/.git/config","hash":"3b4b49c81a087b713f254f0161071c41a4af10b7","modified":1535960245229},{"_id":"themes/hexo-theme-next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/index","hash":"0cab4ee92eac0212876483289bd9578ab5fe4b27","modified":1535960245277},{"_id":"themes/hexo-theme-next/.git/packed-refs","hash":"a6fb5bb176f6cd8bb8e097606334f32391d9b25d","modified":1535960245225},{"_id":"themes/hexo-theme-next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1535960245229},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1535960245229},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1535960245229},{"_id":"themes/hexo-theme-next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1535960245229},{"_id":"themes/hexo-theme-next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1535960245229},{"_id":"themes/hexo-theme-next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1535960245229},{"_id":"themes/hexo-theme-next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/MATH.md","hash":"0ae4258950de01a457ea8123a8d13ec6db496e53","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"1b59036ccb2ad571503b94587f458fad46775642","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"79040bae5ec14291441b33eea341a24a7c0e9f93","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"3e9cba5313bf3b98a38ccb6ef78b56ffa11d66ee","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1535960245237},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1535960245233},{"_id":"themes/hexo-theme-next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1535960245233},{"_id":"themes/hexo-theme-next/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1535960245237},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1535960245237},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1535960245237},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1535960245277},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1535960245277},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1535960245277},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535960245261},{"_id":"themes/hexo-theme-next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1535960209025},{"_id":"themes/hexo-theme-next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1535960209013},{"_id":"themes/hexo-theme-next/.git/logs/HEAD","hash":"3cb9f3ee43d0388050057e3254c14abfd97fbea3","modified":1535960245229},{"_id":"themes/hexo-theme-next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/ru/README.md","hash":"edfe0cfb8b2c9f0effd3beb868af9bfd0fabb3a6","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/zh-CN/MATH.md","hash":"e03607b608db4aa7d46f6726827c51ac16623339","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/zh-CN/README.md","hash":"46b264623af21211a0a9c4ba0cf1318a80eeb9fb","modified":1535960245233},{"_id":"themes/hexo-theme-next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"27922af64ecb9db9a28bcf1c98fb68b26bf0b67a","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"eafff2d623af8991844f34819a60e37ac11ef245","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"05cdaf9b6cb32afd442b228cd247aaf9468a31ed","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1535960245237},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1535960245237},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1535960245237},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1535960245237},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1535960245237},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"1d59b968af4b8d147f8bc9bc295d596e41be8348","modified":1535960245237},{"_id":"themes/hexo-theme-next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1535960245237},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1535960245237},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1535960245237},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1535960245237},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"c579ad35796681d28c6fb0ee775a1013f2fb4753","modified":1531812714796},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/tag-icon.svg","hash":"f6e87c0e961b3025ad0306efc901f9ebdeec0b25","modified":1525944490419},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535960245237},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535960245261},{"_id":"themes/hexo-theme-next/.git/refs/heads/master","hash":"ac845fb35dc632c804d5d2eebcd731ad4d4ddfac","modified":1535960245229},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1535960245233},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"67f0cb55e6702c492e99a9f697827629da036a0c","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"8878241797f8494a70968756c57cacdfc77b61c7","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1535960245237},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"51c2907e5c50c2614419b670fbdec183ae7f7f5d","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"0b43ddd92e395342703550f629699c5e591fd68b","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/HTML/ul-li.png","hash":"7992df8226d9d1014e6695352d251ce91de90c73","modified":1529215083606},{"_id":"themes/hexo-theme-next/source/images/Hadoop/launch_info.png","hash":"3b461f990583a0cff58ec04b08857c9b5726b91a","modified":1527736307082},{"_id":"themes/hexo-theme-next/source/images/Hadoop/ssh_log.png","hash":"5f5817976cc3695d85a0138349d3e5472a4287d4","modified":1527685361224},{"_id":"themes/hexo-theme-next/source/images/Hadoop/stop_all.png","hash":"6fd04fe8f4c2b7f981346234b3fd05cdabf6a403","modified":1527737202458},{"_id":"themes/hexo-theme-next/source/images/JavaScript/001.png","hash":"6e3db8cec41e62b30247e48731eb3f76cb436384","modified":1530934055479},{"_id":"themes/hexo-theme-next/source/images/JavaScript/005.png","hash":"301729a41c8bb85caf35794f61a2f32a323b47fd","modified":1530967824236},{"_id":"themes/hexo-theme-next/source/images/JavaScript/007.png","hash":"caa4ffded351198fa54e61c249927dc5afd62c96","modified":1531016183508},{"_id":"themes/hexo-theme-next/source/images/Scala/Scala-test.jpg","hash":"c45cd996cfda6f72dcb4cbd10a53342ce0c8112b","modified":1525944490415},{"_id":"themes/hexo-theme-next/source/images/Scala/create_1.png","hash":"0195543026e4cf6ee5eb90cf10771012a21aeb29","modified":1527429492123},{"_id":"themes/hexo-theme-next/source/images/Scala/create_2.png","hash":"d726f3a56ccf2a2ba4f118456d3e1dbc77e5380a","modified":1527429533620},{"_id":"themes/hexo-theme-next/source/images/Scala/flatten_test.jpg","hash":"89483140538346407dba053f053e9184b89909ab","modified":1535798747339},{"_id":"themes/hexo-theme-next/source/images/block_chain/structure.png","hash":"fe13f8c9d031bb3cb99f88e7f61c34e62ac7dce0","modified":1527079614697},{"_id":"themes/hexo-theme-next/source/images/linux-and-windows/bootice01.jpg","hash":"7fc2c6d3b3189eac96d1114b39c0818523e10361","modified":1525944490415},{"_id":"themes/hexo-theme-next/source/images/linux-and-windows/bootice02.jpg","hash":"87404fd027c37230f0bf94ce8c69c9db1b81281e","modified":1525944490415},{"_id":"themes/hexo-theme-next/source/images/linux-and-windows/refind-info.jpg","hash":"fa410b1b7f10861db287213b8b11a9da2f7b7903","modified":1525944490415},{"_id":"themes/hexo-theme-next/source/images/linux-and-windows/ubuntu-boot.jpg","hash":"3572a4d46560cb510f9a6497a07bec93d105ab70","modified":1525944490419},{"_id":"themes/hexo-theme-next/source/images/node.js/info.png","hash":"991955790bfbf3ecc625bd783f7f144c8ce605fd","modified":1527170837924},{"_id":"themes/hexo-theme-next/source/images/ssr/auto_switch_02.png","hash":"d1e2bd3e5712179c45ee15611531356a6963fc73","modified":1527491311722},{"_id":"themes/hexo-theme-next/source/images/ssr/gfwlist.png","hash":"370a50cb4a74c251752842b35304b76749ae5041","modified":1527491240719},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"52fd093cb96b68229b38436c9b8ebcefc7e12cb2","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"e829806d054991d0324a339993082206ca6026e5","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1535960245273},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1535960245277},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1535960245277},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-4bfbfc93c35a49a09aeda593e851f3b08f911eaf.idx","hash":"3b41c9927eda65ad812b43162c0b6073b013e31c","modified":1535960244225},{"_id":"themes/hexo-theme-next/source/images/Blog/jekyll_01.jpg","hash":"2a45bd01008d93234f62a5c92475b025269ffb9e","modified":1531280293214},{"_id":"themes/hexo-theme-next/source/images/Blog/jekyll_02.jpg","hash":"fdd4ed20e61ef9cac6a859152d395b76fab27705","modified":1531280293214},{"_id":"themes/hexo-theme-next/source/images/CSS/color_list.jpg","hash":"9281ef300cf266776e28e2ff1038e7c216cdda49","modified":1529293145957},{"_id":"themes/hexo-theme-next/source/images/Hadoop/path.png","hash":"86120ed4aa136b50cbcef74cbc180b66392387cd","modified":1527734008077},{"_id":"themes/hexo-theme-next/source/images/Hadoop/ssh_key.png","hash":"3eb1e7cd5c17adfc76720ae10bacdbb5dc9eeb48","modified":1527685437391},{"_id":"themes/hexo-theme-next/source/images/JavaScript/004.png","hash":"dfa3aa72a26d1f0f3f10cbfdb371d4433d0ead63","modified":1530967554017},{"_id":"themes/hexo-theme-next/source/images/Scala/first_program.png","hash":"fd76c30868c549dafd72967e05a779d162e88ea5","modified":1527429781971},{"_id":"themes/hexo-theme-next/source/images/Windows/atom.jpg","hash":"20d9821fbb3af0bf9a29a54b983deaff2152de24","modified":1532396321341},{"_id":"themes/hexo-theme-next/source/images/spark/集群文件系统的问题.png","hash":"3fd2ebcacd2b6bd35a583a8061af9da26d8ce8ae","modified":1528981144313},{"_id":"themes/hexo-theme-next/source/images/ssr/auto_switch_01.png","hash":"92d47c604cca1e1d95661eb0443fc82382cecf02","modified":1527491286954},{"_id":"themes/hexo-theme-next/source/images/ssr/example.png","hash":"5ae351adfe26ec6968e6812caa0a5d869c0c49f9","modified":1527491375574},{"_id":"themes/hexo-theme-next/source/images/ssr/systemset.png","hash":"aae5088739b62bb6200eefbd9e27a9960c544f2e","modified":1527492316229},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1535960245273},{"_id":"themes/hexo-theme-next/.git/logs/refs/heads/master","hash":"3cb9f3ee43d0388050057e3254c14abfd97fbea3","modified":1535960245229},{"_id":"themes/hexo-theme-next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1535960245225},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1535960245237},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1535960245237},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1535960245237},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1535960245237},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1535960245237},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1535960245237},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1535960245253},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"18309b68ff33163a6f76a39437e618bb6ed411f8","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"0810e7c43d6c8adc8434a8fa66eabe0436ab8178","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"fca5320e2644edcd663888863899d1b80352439b","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/images/Hadoop/datanode_info.png","hash":"d2996b0c0c08beba9e01d26c7cc97bb613bac259","modified":1527737088754},{"_id":"themes/hexo-theme-next/source/images/SQL/E-R graphe.png","hash":"7f88878c39e943b66e5b2614f259e61e30e37a60","modified":1525944490399},{"_id":"themes/hexo-theme-next/source/images/block_chain/metacion_test_result.png","hash":"156342863cce16e4fc88515dda6ad0e3244cfdcb","modified":1527397555285},{"_id":"themes/hexo-theme-next/source/images/spark/spark-shell.png","hash":"b7df18d79461c18e200febc13ac1457421a01d9f","modified":1527473279261},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"ab6f13fae0513a9b39f8d8c4c3a4e3928014f046","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1535960245265},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1535960245265},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1535960245273},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1535960245273},{"_id":"themes/hexo-theme-next/source/images/CSS/color.jpg","hash":"f6b5e0043566e6689a716927de04aaa6d1f383fa","modified":1529293077938},{"_id":"themes/hexo-theme-next/source/images/JavaScript/003.png","hash":"7bb1416032f6dc458969b8685bab4e589dda8b99","modified":1530954616696},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1535960245273},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1535960245265},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1535960245269},{"_id":"themes/hexo-theme-next/.git/logs/refs/remotes/origin/HEAD","hash":"3cb9f3ee43d0388050057e3254c14abfd97fbea3","modified":1535960245225},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"17b95828f9db7f131ec0361a8c0e89b0b5c9bff5","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"c0ac49fadd33ca4a9a0a04d5ff2ac6560d0ecd9e","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"ed9608d2740a33664eb703f806c218a4fc520087","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/exturl.styl","hash":"cf2185a0ea170fd8450f592e859a6c941141e5ee","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1535960245257},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1535960245261},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1535960245265},{"_id":"themes/hexo-theme-next/source/images/JavaScript/002.png","hash":"09250e5da9f7be12decc659bfb7424c3e99d3260","modified":1530948327053},{"_id":"themes/hexo-theme-next/source/images/JavaScript/006.png","hash":"76e839fa4c7312b36fffaa503a9f0ac45bddbae2","modified":1531014974806},{"_id":"themes/hexo-theme-next/source/images/linux-and-windows/opening-bg.jpg","hash":"9136db68b5228b8d7349908fba10fb66bb81b3c9","modified":1525944490415},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-4bfbfc93c35a49a09aeda593e851f3b08f911eaf.pack","hash":"530eff2ea5d1ea3e08dce1cc4831689ada7ff295","modified":1535960244225},{"_id":"themes/hexo-theme-next/source/images/Scala/relation.jpg","hash":"1ac606234360f316f9bc08c32a110828ef7d7add","modified":1532396321337},{"_id":"themes/hexo-theme-next/source/images/SQL/TIM图片20180503210911.jpg","hash":"edb805c7c5bbd4d28efd4b05ecb8449cdb45be4a","modified":1525944490415},{"_id":"public/404.html","hash":"e2350fb365c0373e5a404868561a5c07fd1262ba","modified":1536067648269},{"_id":"public/offline.html","hash":"7bf3361a82d4ad241c985bb1c3e61bd0f589b44c","modified":1536067648269},{"_id":"public/about/index.html","hash":"ef3d22e6101483f3882691b9937828893a7b66c0","modified":1536067648269},{"_id":"public/categories/index.html","hash":"ca2867bf5a836436fdadd8fe6faa83cddbcf974a","modified":1536067648269},{"_id":"public/tags/index.html","hash":"644e5207bf50acd155ca82ed30af84e291ae4841","modified":1536067648269},{"_id":"public/archives/2018/06/index.html","hash":"02c43ed7f892436b6d999c80dc6ec7e5e88d0810","modified":1536067648270},{"_id":"public/archives/2018/09/index.html","hash":"73e0067962ed1bc46db822538b051d26244e57fe","modified":1536067648270},{"_id":"public/categories/Personal-Blog/index.html","hash":"596727d38eb9bdff53f8544e0a0af0d217d37cd7","modified":1536067648270},{"_id":"public/categories/Computer-System/index.html","hash":"15f989e7fa7199f93b06e941f926ff7f62892113","modified":1536067648270},{"_id":"public/categories/ScientificSurfing/index.html","hash":"fb11666c06eed3a0b2ef23f3096e9d19e7e61ede","modified":1536067648270},{"_id":"public/categories/Computer/index.html","hash":"bdc488b714891fa78a8ad18f8581acf7350466df","modified":1536067648270},{"_id":"public/categories/FrontEnd/index.html","hash":"1b61d0a8f8f5951741326ac03188bffedf1d3c8f","modified":1536067648270},{"_id":"public/categories/Computer-Software/index.html","hash":"530f4b1e2cd31be575a7d4701fcb26352cda815a","modified":1536067648270},{"_id":"public/categories/Hadoop-CLuster/index.html","hash":"f7824337b5f13ca605c387402bac6b6106dd43be","modified":1536067648270},{"_id":"public/tags/๑C/index.html","hash":"1d744a7c939952794de7238858ee5c5779088297","modified":1536067648270},{"_id":"public/tags/๑Blog/index.html","hash":"59dfdc87b48fd13767c9996b563114fa61bb9c42","modified":1536067648270},{"_id":"public/tags/๑Java/index.html","hash":"16b3080bc779b5970ff6f2c684a793cbab06839e","modified":1536067648270},{"_id":"public/tags/๑Python/index.html","hash":"5d914092495a47281a503966a1e308dede43a1b9","modified":1536067648270},{"_id":"public/tags/๑Ubuntu/index.html","hash":"29ea5d1265319b6fe1b6a436a7455ea636f08434","modified":1536067648270},{"_id":"public/tags/๑Linux/index.html","hash":"ce047b7b0be9bb7c5aa63d0f2249d9c77b99b1b4","modified":1536067648270},{"_id":"public/tags/๑DualSystem/index.html","hash":"53bba76171baa005555e46a32dd652a6e0bb73cd","modified":1536067648270},{"_id":"public/tags/๑SQL/index.html","hash":"9945f12e57bf2afef5763ab2e56278d18a34ee09","modified":1536067648270},{"_id":"public/tags/๑Git/index.html","hash":"b78b97fe0e945bdab0eaa34ea10c45a31aa0223a","modified":1536067648270},{"_id":"public/tags/๑Spark/index.html","hash":"1b486ac6132b79d75c2f6ee465dc74efa08cbd07","modified":1536067648270},{"_id":"public/tags/๑BigData/index.html","hash":"2e35e5f223780f4db12bec1db22806a9856ede19","modified":1536067648271},{"_id":"public/tags/๑BlockChain/index.html","hash":"640b6583f8561e6d3f29dfb9386bfcab0e6d5a29","modified":1536067648271},{"_id":"public/tags/๑FileTypes/index.html","hash":"c945847923e5d6e32b0c939406c06bbfcbb34a50","modified":1536067648271},{"_id":"public/tags/๑ScientificSurfing/index.html","hash":"deace5725c21a378dc9712d136504358c689e32a","modified":1536067648271},{"_id":"public/tags/๑JS/index.html","hash":"71e23a7c5d30003736a44b812e50364cb3ac4766","modified":1536067648271},{"_id":"public/tags/๑FrontEnd/index.html","hash":"877f78122cb1e3cc2fb087c4b0a833915dce7892","modified":1536067648271},{"_id":"public/tags/๑JetBrains/index.html","hash":"3afbff76002f464590eb3b6c007acd216f8903ef","modified":1536067648271},{"_id":"public/tags/๑Hadoop/index.html","hash":"a641834c4aa646385af327e3160bb92c1e7eec1a","modified":1536067648271},{"_id":"public/tags/๑HDFS/index.html","hash":"5702230197b796a0e36f097e623b4d389a6dd20f","modified":1536067648271},{"_id":"public/tags/๑CSS/index.html","hash":"052a5e1ada5d98a4a85d18ed5e52426ce93ece78","modified":1536067648271},{"_id":"public/tags/๑Html/index.html","hash":"c5fe40742f86a6070eed74e98ebe092771e32d54","modified":1536067648271},{"_id":"public/tags/๑JavaScrpt/index.html","hash":"7d5f8d7cfd02496f1ec88c9218df314e9beadeab","modified":1536067648271},{"_id":"public/tags/๑CLuster/index.html","hash":"f5c70e192c5870f337cfbbd751c0fde3078d5f0a","modified":1536067648271},{"_id":"public/tags/๑Windows/index.html","hash":"03485a796ee140ca9ba39ea8c7d781fd9baabecd","modified":1536067648271},{"_id":"public/2018/09/03/2018-09-03-Hexo-rebuild/index.html","hash":"859000c669f6a8d1fe0fa04c18362121effee872","modified":1536067648271},{"_id":"public/2018/07/24/2018-07-24-scala-learning-04/index.html","hash":"a3985562af5645e8e0c8eea59441ad6bc6ca9473","modified":1536067648271},{"_id":"public/2018/07/24/2018-07-24-scala-learning-05/index.html","hash":"30c4039fd1a65bec3965c72ae9cd602ea41d3225","modified":1536067648271},{"_id":"public/2018/07/23/2018-07-23-windows-realated/index.html","hash":"48664bcda64629e6e2cfd08cc076250db0be22cc","modified":1536067648271},{"_id":"public/2018/07/23/2018-07-23-scala-learning-03/index.html","hash":"9adfe766fa1bf556803fb48b47e6ce6b3ea2b675","modified":1536067648271},{"_id":"public/2018/07/20/2018-07-20-cluster-usage/index.html","hash":"9c45c41db2a367b268954669a347b9ad9fba2205","modified":1536067648272},{"_id":"public/2018/07/19/2018-07-19-scala-learning-02/index.html","hash":"bdad2e9779084fb8555e4c2949014191f77da536","modified":1536067648272},{"_id":"public/2018/07/12/2018-07-12-Scala-learning-01/index.html","hash":"33889e58080311c92245b93342af7c0267708ddf","modified":1536067648272},{"_id":"public/2018/07/12/2018-07-12-Scala-infos/index.html","hash":"a9b5d6673108258ad4a6edbe126768e4e1859ab3","modified":1536067648272},{"_id":"public/2018/07/08/2018-07-08-Jekyll-usage/index.html","hash":"e9ef6e2c44e8d803e8c4cd5717b605d160864647","modified":1536067648272},{"_id":"public/2018/07/07/2018-07-07-JavaScript/index.html","hash":"9ab52a07f6620e267720b7523e0cd5f980c3a8b2","modified":1536067648272},{"_id":"public/2018/06/17/2018-06-17-FrontEnd-CSS/index.html","hash":"aa59ca2f595b12881b0153e7c6b2a4ba2534b0e0","modified":1536067648272},{"_id":"public/2018/06/17/2018-06-17-FrontEnd-HTML/index.html","hash":"62700b8fe0705aded465ec90a3a769e622d27e8c","modified":1536067648272},{"_id":"public/2018/05/30/2018-05-31-HDFS/index.html","hash":"561c0de135656bae298a1221bd6fd709529b02e4","modified":1536067648272},{"_id":"public/2018/05/30/2018-05-30-Hadoop-usage/index.html","hash":"2b7f8e0a2c3d489d997f4977696b944a6b4721ab","modified":1536067648272},{"_id":"public/2018/05/28/2018-04-19-Shaow-socks/index.html","hash":"d55b6f65f80fdd585ac0405b19fcb208ee515da9","modified":1536067648272},{"_id":"public/2018/05/25/2018-05-25-jetbrains/index.html","hash":"115a32ecff8e08421ea2129e03d071776811c7c4","modified":1536067648272},{"_id":"public/2018/05/23/2018-05-23-Ethereum/index.html","hash":"6177f457753aad60eb2999d17f663b60ed4108cb","modified":1536067648272},{"_id":"public/2018/05/21/2018-05-21-NodeJS/index.html","hash":"70141f3589926c12696df88d89fa3917c796f64c","modified":1536067648272},{"_id":"public/2018/05/17/2018-05-17-BlockChain-concepts/index.html","hash":"8369f96a37d224ecf429f399952de3f2f9f24faa","modified":1536067648272},{"_id":"public/2018/05/10/2018-05-10-Ubuntu-18/index.html","hash":"8f00b0868d98d09fa981d5d7222c947d34660e5c","modified":1536067648272},{"_id":"public/2018/05/03/2018-05-03-Google-play-Android/index.html","hash":"2f2fccdd82d5631190a96806e326a00914977edd","modified":1536067648272},{"_id":"public/2018/04/29/2018-04-29-Python-superior/index.html","hash":"f79d21506feb3b629c7000238d34a69142d88581","modified":1536067648272},{"_id":"public/2018/04/18/2018-04-06-Java-function/index.html","hash":"ad075bf2e02258a65064aca85a8cd188edcf6e75","modified":1536067648272},{"_id":"public/2018/04/18/2018-04-06-Java-class/index.html","hash":"e94a3a320e99dfb0c1ad4373f490e2a131ac6c22","modified":1536067648272},{"_id":"public/2018/04/15/2018-04-15-Block-Chain/index.html","hash":"8cc07640bb15a2762ce643ba7a52f37d4b2443a5","modified":1536067648273},{"_id":"public/2018/04/15/2018-04-15-File-types/index.html","hash":"2b334c911256206f713648aa454285628f29dab2","modified":1536067648273},{"_id":"public/2018/04/11/2018-04-11-Git-and-Github/index.html","hash":"d4fddc4e24774660115ab65c7f051cd6c0e3ed87","modified":1536067648273},{"_id":"public/2018/04/11/2018-04-11-Spark-learning/index.html","hash":"7ae39fd1e3522a2bc8e38c3316f7c315e75969ab","modified":1536067648273},{"_id":"public/2018/04/11/2018-04-11-Spark-superior/index.html","hash":"ac74ae7432a81f406141142c70a95a8a73d2783e","modified":1536067648273},{"_id":"public/2018/04/07/2018-04-07-SQL-quary/index.html","hash":"98fdb12518d4c2726859747cc2a3a5944991af09","modified":1536067648273},{"_id":"public/2018/04/06/2018-04-06-C++learning/index.html","hash":"58b01f82cd1f51a877977bea20c4b725be2faac9","modified":1536067648273},{"_id":"public/2018/04/06/2018-04-06-Scala-learning/index.html","hash":"823b472a746685780995f0d33d03e42e16091afc","modified":1536067648273},{"_id":"public/2018/04/06/2018-04-06-Scala-superior/index.html","hash":"62d392a2a22f48415256e475f39ccb3e0748631c","modified":1536067648273},{"_id":"public/2018/04/06/2018-04-06-Java-learning/index.html","hash":"6f4eaa3742e412b43b3eb77259c26c7f6b0dd1d6","modified":1536067648273},{"_id":"public/2018/04/06/2018-04-06-Python-learning/index.html","hash":"4a569fce58f5efe0ad46ae794b2efeb39399f1bc","modified":1536067648273},{"_id":"public/2018/04/06/2018-04-06-Ubuntu-order/index.html","hash":"458af436985e379d862adf43bdbff7b5f6f3af93","modified":1536067648273},{"_id":"public/2018/04/06/2018-04-06-Ubuntu-operation/index.html","hash":"54fa596c8da0ccb60622627c3edb6f25e3f05955","modified":1536067648273},{"_id":"public/2018/04/06/2018-04-06-ubuntu-and-windows/index.html","hash":"9473b40e27f0ff6344f095f5cf899d86eb7731a0","modified":1536067648273},{"_id":"public/2018/04/05/2018-04-05-hello-2018/index.html","hash":"274461aae393b7d2603c17e7d380f99700ff7b26","modified":1536067648273},{"_id":"public/archives/index.html","hash":"66e61ed221dcbdfb557a312ad916e314dd5a6fee","modified":1536067648273},{"_id":"public/archives/page/2/index.html","hash":"1adb4d6b9d2a291e2eebf4b1c4ccd3a762664388","modified":1536067648273},{"_id":"public/archives/page/3/index.html","hash":"8d09f48634a5bc2e7e200b0a0d4b82fa4d8fe2fb","modified":1536067648274},{"_id":"public/archives/page/4/index.html","hash":"998c95e28d95e5a8e357cccd1b4deb221b344a60","modified":1536067648274},{"_id":"public/archives/2018/index.html","hash":"84c2224dbac4f68be5886789e89da2b634516df9","modified":1536067648274},{"_id":"public/archives/2018/page/2/index.html","hash":"f1d8edaba289712bd5a53844f188bfc8157519e1","modified":1536067648274},{"_id":"public/archives/2018/page/3/index.html","hash":"a06ea4382a005b8975d19fd3a9d7917043ac4509","modified":1536067648274},{"_id":"public/archives/2018/page/4/index.html","hash":"d2c4433e3a16da39ae36abe546b4767d24e2d4c9","modified":1536067648274},{"_id":"public/archives/2018/04/index.html","hash":"cc4782465bad4a48877029b1ed0f3759564e4cc4","modified":1536067648274},{"_id":"public/archives/2018/04/page/2/index.html","hash":"73ce81cb6602a2efb6fc586e326ee18351c54245","modified":1536067648274},{"_id":"public/archives/2018/05/index.html","hash":"6ac85decd2574a282815c3d54d6c8c3b7ca5f48e","modified":1536067648274},{"_id":"public/archives/2018/07/index.html","hash":"a46c64304dea4c2b5160f733291e26d9c7464f73","modified":1536067648274},{"_id":"public/categories/Computer-Programes/index.html","hash":"700cfc9a0062513644235be4787805cfe2b241cb","modified":1536067648274},{"_id":"public/categories/Computer-Programes/page/2/index.html","hash":"cfad5cb7eafb3b81d2820dd2643bac4704a77328","modified":1536067648274},{"_id":"public/tags/๑Scala/index.html","hash":"40425354e47976fd7217e0d1c9bb3d517b4c0ce1","modified":1536067648274},{"_id":"public/index.html","hash":"e0121b0bc57d84d19ad97191078b834fb095dfb9","modified":1536067648274},{"_id":"public/page/2/index.html","hash":"c4b308bfa313e3be30675e6d9d4fe77302abdd21","modified":1536067648274},{"_id":"public/page/3/index.html","hash":"ccd4e09fadadb349da8c0d30e4d4ac413f31b220","modified":1536067648274},{"_id":"public/page/4/index.html","hash":"a34088b9eacc97b0137e73ecb26a5318acb3f40f","modified":1536067648274},{"_id":"public/README.MDOWN","hash":"fb71db3d41a6dbee36da75079da91d57ce637187","modified":1536067648282},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1536067648282},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1536067648282},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1536067648282},{"_id":"public/images/avatar.gif","hash":"c579ad35796681d28c6fb0ee775a1013f2fb4753","modified":1536067648282},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1536067648282},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1536067648282},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1536067648283},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1536067648283},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1536067648283},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1536067648283},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1536067648283},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1536067648283},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1536067648283},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1536067648283},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1536067648283},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1536067648283},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1536067648283},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1536067648283},{"_id":"public/images/tag-icon.svg","hash":"f6e87c0e961b3025ad0306efc901f9ebdeec0b25","modified":1536067648283},{"_id":"public/images/HTML/ul-li.png","hash":"7992df8226d9d1014e6695352d251ce91de90c73","modified":1536067648283},{"_id":"public/images/Hadoop/launch_info.png","hash":"3b461f990583a0cff58ec04b08857c9b5726b91a","modified":1536067648283},{"_id":"public/images/Hadoop/ssh_log.png","hash":"5f5817976cc3695d85a0138349d3e5472a4287d4","modified":1536067648283},{"_id":"public/images/Hadoop/stop_all.png","hash":"6fd04fe8f4c2b7f981346234b3fd05cdabf6a403","modified":1536067648283},{"_id":"public/images/JavaScript/001.png","hash":"6e3db8cec41e62b30247e48731eb3f76cb436384","modified":1536067648283},{"_id":"public/images/JavaScript/005.png","hash":"301729a41c8bb85caf35794f61a2f32a323b47fd","modified":1536067648283},{"_id":"public/images/JavaScript/007.png","hash":"caa4ffded351198fa54e61c249927dc5afd62c96","modified":1536067648284},{"_id":"public/images/Scala/Scala-test.jpg","hash":"c45cd996cfda6f72dcb4cbd10a53342ce0c8112b","modified":1536067648284},{"_id":"public/images/Scala/create_1.png","hash":"0195543026e4cf6ee5eb90cf10771012a21aeb29","modified":1536067648284},{"_id":"public/images/Scala/create_2.png","hash":"d726f3a56ccf2a2ba4f118456d3e1dbc77e5380a","modified":1536067648284},{"_id":"public/images/Scala/flatten_test.jpg","hash":"89483140538346407dba053f053e9184b89909ab","modified":1536067648284},{"_id":"public/images/linux-and-windows/bootice01.jpg","hash":"7fc2c6d3b3189eac96d1114b39c0818523e10361","modified":1536067648284},{"_id":"public/images/block_chain/structure.png","hash":"fe13f8c9d031bb3cb99f88e7f61c34e62ac7dce0","modified":1536067648284},{"_id":"public/images/linux-and-windows/bootice02.jpg","hash":"87404fd027c37230f0bf94ce8c69c9db1b81281e","modified":1536067648284},{"_id":"public/images/linux-and-windows/refind-info.jpg","hash":"fa410b1b7f10861db287213b8b11a9da2f7b7903","modified":1536067648284},{"_id":"public/images/linux-and-windows/ubuntu-boot.jpg","hash":"3572a4d46560cb510f9a6497a07bec93d105ab70","modified":1536067648284},{"_id":"public/images/node.js/info.png","hash":"991955790bfbf3ecc625bd783f7f144c8ce605fd","modified":1536067648284},{"_id":"public/images/ssr/auto_switch_02.png","hash":"d1e2bd3e5712179c45ee15611531356a6963fc73","modified":1536067648284},{"_id":"public/images/ssr/gfwlist.png","hash":"370a50cb4a74c251752842b35304b76749ae5041","modified":1536067648284},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1536067648284},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1536067648284},{"_id":"public/images/Blog/jekyll_01.jpg","hash":"2a45bd01008d93234f62a5c92475b025269ffb9e","modified":1536067648618},{"_id":"public/images/Blog/jekyll_02.jpg","hash":"fdd4ed20e61ef9cac6a859152d395b76fab27705","modified":1536067648620},{"_id":"public/images/CSS/color_list.jpg","hash":"9281ef300cf266776e28e2ff1038e7c216cdda49","modified":1536067648621},{"_id":"public/images/Hadoop/path.png","hash":"86120ed4aa136b50cbcef74cbc180b66392387cd","modified":1536067648621},{"_id":"public/images/Hadoop/ssh_key.png","hash":"3eb1e7cd5c17adfc76720ae10bacdbb5dc9eeb48","modified":1536067648621},{"_id":"public/images/JavaScript/004.png","hash":"dfa3aa72a26d1f0f3f10cbfdb371d4433d0ead63","modified":1536067648621},{"_id":"public/images/Scala/first_program.png","hash":"fd76c30868c549dafd72967e05a779d162e88ea5","modified":1536067648621},{"_id":"public/images/Windows/atom.jpg","hash":"20d9821fbb3af0bf9a29a54b983deaff2152de24","modified":1536067648621},{"_id":"public/images/spark/集群文件系统的问题.png","hash":"3fd2ebcacd2b6bd35a583a8061af9da26d8ce8ae","modified":1536067648621},{"_id":"public/images/ssr/auto_switch_01.png","hash":"92d47c604cca1e1d95661eb0443fc82382cecf02","modified":1536067648621},{"_id":"public/images/ssr/example.png","hash":"5ae351adfe26ec6968e6812caa0a5d869c0c49f9","modified":1536067648621},{"_id":"public/images/ssr/systemset.png","hash":"aae5088739b62bb6200eefbd9e27a9960c544f2e","modified":1536067648621},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1536067648621},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1536067648621},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1536067648627},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1536067648627},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1536067648627},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1536067648627},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1536067648627},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1536067648627},{"_id":"public/js/src/motion.js","hash":"52fd093cb96b68229b38436c9b8ebcefc7e12cb2","modified":1536067648627},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1536067648627},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1536067648627},{"_id":"public/js/src/utils.js","hash":"e829806d054991d0324a339993082206ca6026e5","modified":1536067648627},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1536067648627},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1536067648627},{"_id":"public/js/src/schemes/pisces.js","hash":"ab6f13fae0513a9b39f8d8c4c3a4e3928014f046","modified":1536067648627},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1536067648627},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1536067648627},{"_id":"public/css/main.css","hash":"b71ceed72abba0b32132a326f9be0a63012996c4","modified":1536067648628},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1536067648628},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1536067648628},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1536067648628},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1536067648628},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1536067648628},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1536067648628},{"_id":"public/images/SQL/E-R graphe.png","hash":"7f88878c39e943b66e5b2614f259e61e30e37a60","modified":1536067648628},{"_id":"public/images/Hadoop/datanode_info.png","hash":"d2996b0c0c08beba9e01d26c7cc97bb613bac259","modified":1536067648628},{"_id":"public/images/block_chain/metacion_test_result.png","hash":"156342863cce16e4fc88515dda6ad0e3244cfdcb","modified":1536067648628},{"_id":"public/images/spark/spark-shell.png","hash":"b7df18d79461c18e200febc13ac1457421a01d9f","modified":1536067648629},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1536067648629},{"_id":"public/images/CSS/color.jpg","hash":"f6b5e0043566e6689a716927de04aaa6d1f383fa","modified":1536067648633},{"_id":"public/images/JavaScript/003.png","hash":"7bb1416032f6dc458969b8685bab4e589dda8b99","modified":1536067648633},{"_id":"public/images/JavaScript/002.png","hash":"09250e5da9f7be12decc659bfb7424c3e99d3260","modified":1536067648642},{"_id":"public/images/JavaScript/006.png","hash":"76e839fa4c7312b36fffaa503a9f0ac45bddbae2","modified":1536067648650},{"_id":"public/images/linux-and-windows/opening-bg.jpg","hash":"9136db68b5228b8d7349908fba10fb66bb81b3c9","modified":1536067648653},{"_id":"public/images/Scala/relation.jpg","hash":"1ac606234360f316f9bc08c32a110828ef7d7add","modified":1536067648673},{"_id":"public/images/SQL/TIM图片20180503210911.jpg","hash":"edb805c7c5bbd4d28efd4b05ecb8449cdb45be4a","modified":1536067648676}],"Category":[{"name":"Computer Programes","_id":"cjlnr0j4100061m0okb7hgbbz"},{"name":"Personal Blog","_id":"cjlnr0j46000b1m0ouq8gppxy"},{"name":"Computer System","_id":"cjlnr0j4g000s1m0os6mya4qp"},{"name":"Computer","_id":"cjlnr0j4o001e1m0om6licqzg"},{"name":"ScientificSurfing","_id":"cjlnr0j4v001z1m0osyp1i4fn"},{"name":"FrontEnd","_id":"cjlnr0j51002e1m0ois8ngr37"},{"name":"Computer Software","_id":"cjlnr0j55002l1m0omf9ikx7y"},{"name":"Hadoop CLuster","_id":"cjlnr0j57002t1m0oguba0ubw"}],"Data":[],"Page":[{"title":"404-找不到页面","date":"2016-09-03T09:17:18.000Z","comments":0,"_content":"<center>404 Not Found<center>\n---\n<center>\n对不起，您所访问的页面不存在或者已删除\n你可以[点击此处](https://Fleschier.github.io)返回首页.\n我的Github：[http://github.com/Neveryu](http://github.com/Fleschier)\n\n</center>\n<blockquote class=\"blockquote-center\">\n    你来到了没有知识的荒原\n</blockquote>\n","source":"404.md","raw":"---\ntitle: 404-找不到页面\ndate: 2016-09-03 17:17:18\ncomments: false\n---\n<center>404 Not Found<center>\n---\n<center>\n对不起，您所访问的页面不存在或者已删除\n你可以[点击此处](https://Fleschier.github.io)返回首页.\n我的Github：[http://github.com/Neveryu](http://github.com/Fleschier)\n\n</center>\n<blockquote class=\"blockquote-center\">\n    你来到了没有知识的荒原\n</blockquote>\n","updated":"2018-09-04T13:26:12.074Z","path":"404.html","layout":"page","_id":"cjlnr0j1o00001m0op8o1eiaa","content":"<h2 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a><center>404 Not Found<center></center></center></h2><p><center><br>对不起，您所访问的页面不存在或者已删除<br>你可以<a href=\"https://Fleschier.github.io\" target=\"_blank\" rel=\"noopener\">点击此处</a>返回首页.<br>我的Github：<a href=\"http://github.com/Fleschier\" target=\"_blank\" rel=\"noopener\">http://github.com/Neveryu</a></center></p>\n<p></p>\n<blockquote class=\"blockquote-center\"><br>    你来到了没有知识的荒原<br></blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a><center>404 Not Found<center></center></center></h2><p><center><br>对不起，您所访问的页面不存在或者已删除<br>你可以<a href=\"https://Fleschier.github.io\" target=\"_blank\" rel=\"noopener\">点击此处</a>返回首页.<br>我的Github：<a href=\"http://github.com/Fleschier\" target=\"_blank\" rel=\"noopener\">http://github.com/Neveryu</a></center></p>\n<p></p>\n<blockquote class=\"blockquote-center\"><br>    你来到了没有知识的荒原<br></blockquote>\n"},{"title":"离线页面","date":"2017-06-28T13:46:18.000Z","comments":0,"_content":"<center>404 Not Found<center>\n---\n<center>\n对不起，没有检测到网络连接\n你可以[点击此处](https://Neveryu.github.io)返回首页.\n\n</center>\n<blockquote class=\"blockquote-center\">\n   \n</blockquote>\n\n","source":"offline.md","raw":"---\ntitle: 离线页面\ndate: 2017-06-28 21:46:18\ncomments: false\n---\n<center>404 Not Found<center>\n---\n<center>\n对不起，没有检测到网络连接\n你可以[点击此处](https://Neveryu.github.io)返回首页.\n\n</center>\n<blockquote class=\"blockquote-center\">\n   \n</blockquote>\n\n","updated":"2018-09-03T08:22:34.056Z","path":"offline.html","layout":"page","_id":"cjlnr0j1p00011m0org99u00h","content":"<h2 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a><center>404 Not Found<center></center></center></h2><p><center><br>对不起，没有检测到网络连接<br>你可以<a href=\"https://Neveryu.github.io\" target=\"_blank\" rel=\"noopener\">点击此处</a>返回首页.</center></p>\n<p></p>\n<blockquote class=\"blockquote-center\"><br><br></blockquote>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a><center>404 Not Found<center></center></center></h2><p><center><br>对不起，没有检测到网络连接<br>你可以<a href=\"https://Neveryu.github.io\" target=\"_blank\" rel=\"noopener\">点击此处</a>返回首页.</center></p>\n<p></p>\n<blockquote class=\"blockquote-center\"><br><br></blockquote>\n\n"},{"title":"About","date":"2018-09-03T15:42:06.000Z","comments":0,"_content":"\n# 联系方式\nEmail: Fleschierchan@gmail.com\n\n\n# 基本信息\n\n目前所在城市：苏州\n","source":"about/index.md","raw":"---\ntitle: About\ndate: 2018-09-03 23:42:06\ncomments: false\n---\n\n# 联系方式\nEmail: Fleschierchan@gmail.com\n\n\n# 基本信息\n\n目前所在城市：苏州\n","updated":"2018-09-03T08:54:36.905Z","path":"about/index.html","layout":"page","_id":"cjlnr0j3y00031m0obfwrwhh2","content":"<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><p>Email: <a href=\"mailto:Fleschierchan@gmail.com\" target=\"_blank\" rel=\"noopener\">Fleschierchan@gmail.com</a></p>\n<h1 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h1><p>目前所在城市：苏州</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><p>Email: <a href=\"mailto:Fleschierchan@gmail.com\" target=\"_blank\" rel=\"noopener\">Fleschierchan@gmail.com</a></p>\n<h1 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h1><p>目前所在城市：苏州</p>\n"},{"title":"Categories","date":"2016-09-05T15:41:55.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: Categories\ndate: 2016-09-05 23:41:55\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-09-03T08:54:49.889Z","path":"categories/index.html","layout":"page","_id":"cjlnr0j4000051m0o1p70uo42","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","date":"2016-09-05T15:41:32.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ndate: 2016-09-05 23:41:32\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-09-03T08:54:58.541Z","path":"tags/index.html","layout":"page","_id":"cjlnr0jal005v1m0o9cjb9on2","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"C++学习笔记——类","date":"2018-04-06T08:47:00.000Z","_content":"\n> 不适合人类阅读的学习笔记  \n\n## 类\n---\n\n### 模板类\n\n- 示例：\n```\ntemplate <class T> //声明一个模板，虚拟类型名为T。注意：这里没有分号。  \nclass T_Class //类模板名为Compare  \n{  \npublic :  \n   Compare(T a,T b){  \n      x=a;y=b;  \n   }  \n   T max( ){  \n      return (x>y)?x:y;  \n   }  \n   T min( ){  \n      return (x<y)?x:y;  \n   }  \nprivate :  \n   T x,y;  \n};  \n```\n\n- 模板类所有的函数，如果在类外面实现的话，需要写成如下形式：\n```\ntemplate <class T>\nT_Class<T>::max( ){  \n     return (x > y)? x : y;  \n}  \n```\n\n- **模板类不能将类的声明写在头文件而定义写在源文件中**，这样会出现无法辨析的编译错误。\n\n\n<br>\n\n> 最后更新于2018.4.6\n","source":"_posts/2018-04-06-C++learning.md","raw":"---\nlayout:     post\ntitle:      \"C++学习笔记——类\"\ndate:       2018-04-6 16:47:00\ncategories: Computer Programes\ntags: ๑C++\n---\n\n> 不适合人类阅读的学习笔记  \n\n## 类\n---\n\n### 模板类\n\n- 示例：\n```\ntemplate <class T> //声明一个模板，虚拟类型名为T。注意：这里没有分号。  \nclass T_Class //类模板名为Compare  \n{  \npublic :  \n   Compare(T a,T b){  \n      x=a;y=b;  \n   }  \n   T max( ){  \n      return (x>y)?x:y;  \n   }  \n   T min( ){  \n      return (x<y)?x:y;  \n   }  \nprivate :  \n   T x,y;  \n};  \n```\n\n- 模板类所有的函数，如果在类外面实现的话，需要写成如下形式：\n```\ntemplate <class T>\nT_Class<T>::max( ){  \n     return (x > y)? x : y;  \n}  \n```\n\n- **模板类不能将类的声明写在头文件而定义写在源文件中**，这样会出现无法辨析的编译错误。\n\n\n<br>\n\n> 最后更新于2018.4.6\n","slug":"2018-04-06-C++learning","published":1,"updated":"2018-09-03T13:26:39.126Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j3t00021m0o0wsj412v","content":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><hr>\n<h3 id=\"模板类\"><a href=\"#模板类\" class=\"headerlink\" title=\"模板类\"></a>模板类</h3><ul>\n<li><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt; //声明一个模板，虚拟类型名为T。注意：这里没有分号。  </span><br><span class=\"line\">class T_Class //类模板名为Compare  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">public :  </span><br><span class=\"line\">   Compare(T a,T b)&#123;  </span><br><span class=\"line\">      x=a;y=b;  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">   T max( )&#123;  </span><br><span class=\"line\">      return (x&gt;y)?x:y;  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">   T min( )&#123;  </span><br><span class=\"line\">      return (x&lt;y)?x:y;  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">private :  </span><br><span class=\"line\">   T x,y;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模板类所有的函数，如果在类外面实现的话，需要写成如下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">T_Class&lt;T&gt;::max( )&#123;  </span><br><span class=\"line\">     return (x &gt; y)? x : y;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>模板类不能将类的声明写在头文件而定义写在源文件中</strong>，这样会出现无法辨析的编译错误。</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.6</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><hr>\n<h3 id=\"模板类\"><a href=\"#模板类\" class=\"headerlink\" title=\"模板类\"></a>模板类</h3><ul>\n<li><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt; //声明一个模板，虚拟类型名为T。注意：这里没有分号。  </span><br><span class=\"line\">class T_Class //类模板名为Compare  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">public :  </span><br><span class=\"line\">   Compare(T a,T b)&#123;  </span><br><span class=\"line\">      x=a;y=b;  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">   T max( )&#123;  </span><br><span class=\"line\">      return (x&gt;y)?x:y;  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">   T min( )&#123;  </span><br><span class=\"line\">      return (x&lt;y)?x:y;  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">private :  </span><br><span class=\"line\">   T x,y;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模板类所有的函数，如果在类外面实现的话，需要写成如下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">T_Class&lt;T&gt;::max( )&#123;  </span><br><span class=\"line\">     return (x &gt; y)? x : y;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>模板类不能将类的声明写在头文件而定义写在源文件中</strong>，这样会出现无法辨析的编译错误。</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.6</p>\n</blockquote>\n"},{"layout":"post","title":"Welcome to Fleschier Blog","date":"2018-04-05T14:47:00.000Z","_content":"\n> “It's just a begining.”\n\n\n## 前言\n\n- 渐寒 的 博客终于开通了。\n\n- 几经辗转，在github上发现了自定义的博客这一功能，终于可以自己写一些东西了。然而对于我这样一个对前端没啥了解的人来说，只能借用别人造好的轮子来自定义博客的风格。这一点等以后啥时候有兴趣学前端了再自己DIY吧。\n\n---\n\n## 正文\n\n- 第一次自己写博客还是很有新鲜感的。\n\n- 搭建自己在github上的博客需要创建一个名为*yourusername.github.io*的repository，然后你需要选择一款Jekyll主题来使你的博客更加个性化。*（当然像我一样的小白就先借用别人写好的框架来吧）*。在创建好repository之后最好先clone到本地，这样便于后面的更改直接在本地进行然后通过git来提交就好了。在github上选择一个别人写好的，你比较中意的主题，然后clone下来，将其中你需要的文件加到你自己的库当中。*（其中可能会包含别人写的文章啊，一些图片什么的，这些都可以删掉或者替换掉）*。这里附上一个相对比较详细的教程——[如何快速搭建自己的github.io博客](https://blog.csdn.net/walkerhau/article/details/77394659?utm_source=debugrun&utm_medium=referral)。\n当然这里不可能把所有的细节都写清楚，有很多有趣的东西会在你尝试的过程中不断涌现出来，大胆的去尝试吧。\n\n\n- 博文都是需要通过markdown编辑器来编写的。当然这也很简单，推荐使用的软件是[MarkdownPad2](http://markdownpad.com/)。如果需要激活秘钥什么的直接百度吧（滑稽）。这里需要补充一下的是，MarkdownPad2 这款软件使用时会产生bug，官方的说法是从 Win 8 开始就有这个问题了(我用的是win10)，解决办法就是安装 [Awesomium 1.6.6 SDK](http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe)。如果还是不行就再安装 [Microsoft's DirectX End-User Runtimes (June 2010)](http://www.microsoft.com/en-us/download/details.aspx?id=8109)。下面是官方的原文：\n>\nLivePreview is not working - it displays an error message stating This view has crashed!\n>  \nThis issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane.\n>\nTo fix this issue, please try installing the Awesomium 1.6.6 SDK.\n>\nIf you continue to experience issues, please install Microsoft's DirectX End-User Runtimes (June 2010).\n\n- 对于提交的 XXX.markdown格式的文章，必须要放在`_posts`文件夹下，命名的格式必须为`YEAR-MONTH-DAY-title.markdown`\n并且title也必须用-来连接而*不要用下划线，不要用下划线，不要用下划线...*\n\n- 最后附上markdown的简单教程，很简单，一个小时之内上手完全没问题。[献给写作者的 Markdown 新手指南](https://www.jianshu.com/p/q81RER)。\n\n## 关于多个标签\n---\n\n- 如果一篇博客归属于多个标签，则在tags一栏以 **空格** 分割各个标签。\n\n## 使用jekyll本地预览网页\n---\n\n- 参考[我的另一个博客——Ubuntu下使用jekyll本地预览博客效果](https://fleschier.github.io/2018/07/Jekyll-usage/)\n\n- [更详细的一个博客](https://github.com/uolcano/blog/issues/11)\n\n## 关于表格对齐的问题\n---\n\n- 在表格的第二行：`|---|---|...|`这样的格式里，如果某个单元格写成`|---|`，则表示居中。如果写成`|:---|`则表示左对齐。\n\n<br>\n\n> 最后更新于2018.7.12\n","source":"_posts/2018-04-05-hello-2018.md","raw":"---\nlayout:     post\ntitle:      \"Welcome to Fleschier Blog\"\ndate:       2018-04-5 22:47:00\ncategories: Personal Blog\ntags: ๑Blog\n---\n\n> “It's just a begining.”\n\n\n## 前言\n\n- 渐寒 的 博客终于开通了。\n\n- 几经辗转，在github上发现了自定义的博客这一功能，终于可以自己写一些东西了。然而对于我这样一个对前端没啥了解的人来说，只能借用别人造好的轮子来自定义博客的风格。这一点等以后啥时候有兴趣学前端了再自己DIY吧。\n\n---\n\n## 正文\n\n- 第一次自己写博客还是很有新鲜感的。\n\n- 搭建自己在github上的博客需要创建一个名为*yourusername.github.io*的repository，然后你需要选择一款Jekyll主题来使你的博客更加个性化。*（当然像我一样的小白就先借用别人写好的框架来吧）*。在创建好repository之后最好先clone到本地，这样便于后面的更改直接在本地进行然后通过git来提交就好了。在github上选择一个别人写好的，你比较中意的主题，然后clone下来，将其中你需要的文件加到你自己的库当中。*（其中可能会包含别人写的文章啊，一些图片什么的，这些都可以删掉或者替换掉）*。这里附上一个相对比较详细的教程——[如何快速搭建自己的github.io博客](https://blog.csdn.net/walkerhau/article/details/77394659?utm_source=debugrun&utm_medium=referral)。\n当然这里不可能把所有的细节都写清楚，有很多有趣的东西会在你尝试的过程中不断涌现出来，大胆的去尝试吧。\n\n\n- 博文都是需要通过markdown编辑器来编写的。当然这也很简单，推荐使用的软件是[MarkdownPad2](http://markdownpad.com/)。如果需要激活秘钥什么的直接百度吧（滑稽）。这里需要补充一下的是，MarkdownPad2 这款软件使用时会产生bug，官方的说法是从 Win 8 开始就有这个问题了(我用的是win10)，解决办法就是安装 [Awesomium 1.6.6 SDK](http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe)。如果还是不行就再安装 [Microsoft's DirectX End-User Runtimes (June 2010)](http://www.microsoft.com/en-us/download/details.aspx?id=8109)。下面是官方的原文：\n>\nLivePreview is not working - it displays an error message stating This view has crashed!\n>  \nThis issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane.\n>\nTo fix this issue, please try installing the Awesomium 1.6.6 SDK.\n>\nIf you continue to experience issues, please install Microsoft's DirectX End-User Runtimes (June 2010).\n\n- 对于提交的 XXX.markdown格式的文章，必须要放在`_posts`文件夹下，命名的格式必须为`YEAR-MONTH-DAY-title.markdown`\n并且title也必须用-来连接而*不要用下划线，不要用下划线，不要用下划线...*\n\n- 最后附上markdown的简单教程，很简单，一个小时之内上手完全没问题。[献给写作者的 Markdown 新手指南](https://www.jianshu.com/p/q81RER)。\n\n## 关于多个标签\n---\n\n- 如果一篇博客归属于多个标签，则在tags一栏以 **空格** 分割各个标签。\n\n## 使用jekyll本地预览网页\n---\n\n- 参考[我的另一个博客——Ubuntu下使用jekyll本地预览博客效果](https://fleschier.github.io/2018/07/Jekyll-usage/)\n\n- [更详细的一个博客](https://github.com/uolcano/blog/issues/11)\n\n## 关于表格对齐的问题\n---\n\n- 在表格的第二行：`|---|---|...|`这样的格式里，如果某个单元格写成`|---|`，则表示居中。如果写成`|:---|`则表示左对齐。\n\n<br>\n\n> 最后更新于2018.7.12\n","slug":"2018-04-05-hello-2018","published":1,"updated":"2018-09-03T08:50:19.774Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j3z00041m0of12ix1u1","content":"<blockquote>\n<p>“It’s just a begining.”</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li><p>渐寒 的 博客终于开通了。</p>\n</li>\n<li><p>几经辗转，在github上发现了自定义的博客这一功能，终于可以自己写一些东西了。然而对于我这样一个对前端没啥了解的人来说，只能借用别人造好的轮子来自定义博客的风格。这一点等以后啥时候有兴趣学前端了再自己DIY吧。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><ul>\n<li><p>第一次自己写博客还是很有新鲜感的。</p>\n</li>\n<li><p>搭建自己在github上的博客需要创建一个名为<em>yourusername.github.io</em>的repository，然后你需要选择一款Jekyll主题来使你的博客更加个性化。<em>（当然像我一样的小白就先借用别人写好的框架来吧）</em>。在创建好repository之后最好先clone到本地，这样便于后面的更改直接在本地进行然后通过git来提交就好了。在github上选择一个别人写好的，你比较中意的主题，然后clone下来，将其中你需要的文件加到你自己的库当中。<em>（其中可能会包含别人写的文章啊，一些图片什么的，这些都可以删掉或者替换掉）</em>。这里附上一个相对比较详细的教程——<a href=\"https://blog.csdn.net/walkerhau/article/details/77394659?utm_source=debugrun&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">如何快速搭建自己的github.io博客</a>。<br>当然这里不可能把所有的细节都写清楚，有很多有趣的东西会在你尝试的过程中不断涌现出来，大胆的去尝试吧。</p>\n</li>\n</ul>\n<ul>\n<li><p>博文都是需要通过markdown编辑器来编写的。当然这也很简单，推荐使用的软件是<a href=\"http://markdownpad.com/\" target=\"_blank\" rel=\"noopener\">MarkdownPad2</a>。如果需要激活秘钥什么的直接百度吧（滑稽）。这里需要补充一下的是，MarkdownPad2 这款软件使用时会产生bug，官方的说法是从 Win 8 开始就有这个问题了(我用的是win10)，解决办法就是安装 <a href=\"http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe\" target=\"_blank\" rel=\"noopener\">Awesomium 1.6.6 SDK</a>。如果还是不行就再安装 <a href=\"http://www.microsoft.com/en-us/download/details.aspx?id=8109\" target=\"_blank\" rel=\"noopener\">Microsoft’s DirectX End-User Runtimes (June 2010)</a>。下面是官方的原文：</p>\n<blockquote>\n</blockquote>\n<p>LivePreview is not working - it displays an error message stating This view has crashed!</p>\n<blockquote>\n<p>This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane.</p>\n</blockquote>\n<p>To fix this issue, please try installing the Awesomium 1.6.6 SDK.</p>\n<blockquote>\n</blockquote>\n<p>If you continue to experience issues, please install Microsoft’s DirectX End-User Runtimes (June 2010).</p>\n</li>\n<li><p>对于提交的 XXX.markdown格式的文章，必须要放在<code>_posts</code>文件夹下，命名的格式必须为<code>YEAR-MONTH-DAY-title.markdown</code><br>并且title也必须用-来连接而<em>不要用下划线，不要用下划线，不要用下划线…</em></p>\n</li>\n<li><p>最后附上markdown的简单教程，很简单，一个小时之内上手完全没问题。<a href=\"https://www.jianshu.com/p/q81RER\" target=\"_blank\" rel=\"noopener\">献给写作者的 Markdown 新手指南</a>。</p>\n</li>\n</ul>\n<h2 id=\"关于多个标签\"><a href=\"#关于多个标签\" class=\"headerlink\" title=\"关于多个标签\"></a>关于多个标签</h2><hr>\n<ul>\n<li>如果一篇博客归属于多个标签，则在tags一栏以 <strong>空格</strong> 分割各个标签。</li>\n</ul>\n<h2 id=\"使用jekyll本地预览网页\"><a href=\"#使用jekyll本地预览网页\" class=\"headerlink\" title=\"使用jekyll本地预览网页\"></a>使用jekyll本地预览网页</h2><hr>\n<ul>\n<li><p>参考<a href=\"https://fleschier.github.io/2018/07/Jekyll-usage/\" target=\"_blank\" rel=\"noopener\">我的另一个博客——Ubuntu下使用jekyll本地预览博客效果</a></p>\n</li>\n<li><p><a href=\"https://github.com/uolcano/blog/issues/11\" target=\"_blank\" rel=\"noopener\">更详细的一个博客</a></p>\n</li>\n</ul>\n<h2 id=\"关于表格对齐的问题\"><a href=\"#关于表格对齐的问题\" class=\"headerlink\" title=\"关于表格对齐的问题\"></a>关于表格对齐的问题</h2><hr>\n<ul>\n<li>在表格的第二行：<code>|---|---|...|</code>这样的格式里，如果某个单元格写成<code>|---|</code>，则表示居中。如果写成<code>|:---|</code>则表示左对齐。</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.12</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>“It’s just a begining.”</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li><p>渐寒 的 博客终于开通了。</p>\n</li>\n<li><p>几经辗转，在github上发现了自定义的博客这一功能，终于可以自己写一些东西了。然而对于我这样一个对前端没啥了解的人来说，只能借用别人造好的轮子来自定义博客的风格。这一点等以后啥时候有兴趣学前端了再自己DIY吧。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><ul>\n<li><p>第一次自己写博客还是很有新鲜感的。</p>\n</li>\n<li><p>搭建自己在github上的博客需要创建一个名为<em>yourusername.github.io</em>的repository，然后你需要选择一款Jekyll主题来使你的博客更加个性化。<em>（当然像我一样的小白就先借用别人写好的框架来吧）</em>。在创建好repository之后最好先clone到本地，这样便于后面的更改直接在本地进行然后通过git来提交就好了。在github上选择一个别人写好的，你比较中意的主题，然后clone下来，将其中你需要的文件加到你自己的库当中。<em>（其中可能会包含别人写的文章啊，一些图片什么的，这些都可以删掉或者替换掉）</em>。这里附上一个相对比较详细的教程——<a href=\"https://blog.csdn.net/walkerhau/article/details/77394659?utm_source=debugrun&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">如何快速搭建自己的github.io博客</a>。<br>当然这里不可能把所有的细节都写清楚，有很多有趣的东西会在你尝试的过程中不断涌现出来，大胆的去尝试吧。</p>\n</li>\n</ul>\n<ul>\n<li><p>博文都是需要通过markdown编辑器来编写的。当然这也很简单，推荐使用的软件是<a href=\"http://markdownpad.com/\" target=\"_blank\" rel=\"noopener\">MarkdownPad2</a>。如果需要激活秘钥什么的直接百度吧（滑稽）。这里需要补充一下的是，MarkdownPad2 这款软件使用时会产生bug，官方的说法是从 Win 8 开始就有这个问题了(我用的是win10)，解决办法就是安装 <a href=\"http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe\" target=\"_blank\" rel=\"noopener\">Awesomium 1.6.6 SDK</a>。如果还是不行就再安装 <a href=\"http://www.microsoft.com/en-us/download/details.aspx?id=8109\" target=\"_blank\" rel=\"noopener\">Microsoft’s DirectX End-User Runtimes (June 2010)</a>。下面是官方的原文：</p>\n<blockquote>\n</blockquote>\n<p>LivePreview is not working - it displays an error message stating This view has crashed!</p>\n<blockquote>\n<p>This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane.</p>\n</blockquote>\n<p>To fix this issue, please try installing the Awesomium 1.6.6 SDK.</p>\n<blockquote>\n</blockquote>\n<p>If you continue to experience issues, please install Microsoft’s DirectX End-User Runtimes (June 2010).</p>\n</li>\n<li><p>对于提交的 XXX.markdown格式的文章，必须要放在<code>_posts</code>文件夹下，命名的格式必须为<code>YEAR-MONTH-DAY-title.markdown</code><br>并且title也必须用-来连接而<em>不要用下划线，不要用下划线，不要用下划线…</em></p>\n</li>\n<li><p>最后附上markdown的简单教程，很简单，一个小时之内上手完全没问题。<a href=\"https://www.jianshu.com/p/q81RER\" target=\"_blank\" rel=\"noopener\">献给写作者的 Markdown 新手指南</a>。</p>\n</li>\n</ul>\n<h2 id=\"关于多个标签\"><a href=\"#关于多个标签\" class=\"headerlink\" title=\"关于多个标签\"></a>关于多个标签</h2><hr>\n<ul>\n<li>如果一篇博客归属于多个标签，则在tags一栏以 <strong>空格</strong> 分割各个标签。</li>\n</ul>\n<h2 id=\"使用jekyll本地预览网页\"><a href=\"#使用jekyll本地预览网页\" class=\"headerlink\" title=\"使用jekyll本地预览网页\"></a>使用jekyll本地预览网页</h2><hr>\n<ul>\n<li><p>参考<a href=\"https://fleschier.github.io/2018/07/Jekyll-usage/\" target=\"_blank\" rel=\"noopener\">我的另一个博客——Ubuntu下使用jekyll本地预览博客效果</a></p>\n</li>\n<li><p><a href=\"https://github.com/uolcano/blog/issues/11\" target=\"_blank\" rel=\"noopener\">更详细的一个博客</a></p>\n</li>\n</ul>\n<h2 id=\"关于表格对齐的问题\"><a href=\"#关于表格对齐的问题\" class=\"headerlink\" title=\"关于表格对齐的问题\"></a>关于表格对齐的问题</h2><hr>\n<ul>\n<li>在表格的第二行：<code>|---|---|...|</code>这样的格式里，如果某个单元格写成<code>|---|</code>，则表示居中。如果写成<code>|:---|</code>则表示左对齐。</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.12</p>\n</blockquote>\n"},{"layout":"post","title":"Java学习笔记——类与继承","date":"2018-04-18T08:47:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n## Java的类，继承与接口\n---\n\n### 类的定义\n\n- 类的修饰符有两种：public 和 缺省。public表示共有的访问级别，即任何类都可以访问它。缺省只允许同一个包中的类来访问它。\n\n- 类的类型修饰符：缺省、abstract及final三种。abstract表示这是一个抽象类，**有些方法** 还没有实现。final表示这是一个最终类，不能被其他的类继承。\n\n- *类是对象的模板，对象是类的实例化*\n\n#### 一个类可以包含以下类型变量\n\n- 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。\n\n- 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。\n\n- **类变量**：类变量也声明在类中，方法体之外，但必须声明为static类型。（**同C++中的静态变量**）\n\n- 最终变量：即**常量**，用final关键字修饰。一般与static关键字连用，例如定义PI、E等。\n\n- 默认构造函数：java的类与C++一样可以写默认构造参数，格式也与C++一样，没有返回值，函数名与类名相同。有参数的构造函数也一样。\n\n### 源文件声明规则\n\n- 一个源文件中只能有一个public类\n\n- 一个源文件可以有多个非public类\n\n- 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。\n\n- 如果一个类定义在某个包中，那么package语句应该在源文件的首行。\n\n- 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。\nimport语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。\n\n- 类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。\n\n- 除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。\n\n## 对象\n\n### 对象的引用\n- 创建对象后，可以将对象的引用赋值给其他对象变量。\n\n- 例如下面的程序\n```\npublic class test{\n\tpublic static void main(String[] args){\n\t\tStringBuffer s;\n\t\ts= new StringBuffer(\"AAAAA\");\n\t\tStringBuffer s1 = s; //此句会使得s1和s指向同一个对象\n\t\ts1.append(\"BBBB\");\n\t\tSyetem.out.println(\"s = \" + s.toString());\n\t\tSyetem.out.println(\"s1 = \" + s1.toString());\n\t}\n}\n```\n- 输出结果为：\n```\ns = AAAAABBBB\ns1 = AAAAABBBB\n```\n\n### 方法参数传递\n\n#### 按值传递(一般的函数参数)\n\n- 传入方法中的参数是一份拷贝，对其的修改不会影响其本身\n```\nclass Printer{\n\tpublic void printinfo(String name, int age){\n\t\tage ++;\n\t\tSystem.out.println(\"Hello! My name is\" + name + \"and I'm \" + age);\n\t}\n\tpublic static void main(String args[]){\n\t\tPrinter p = new Printer();\n\t\tint age = 20;\n\t\tp.printinfo(\"Mike\",age);\n\t\tSystem.out.println(\"Now the initial age = \" + age);\n\t}\n}\n```\n\n#### 按引用传递\n\n- 调用方法时，**如果传递的是一个对象、接口或数组时**，实际上传递的是对象的、接口或者数组的引用。因此如果方法中对参数进行了修改，那么原来的数据也会受到影响。\n\n## 继承\n\n- 类的继承格式：\n```\nclass 父类{\n\t...\n}\nclass 子类 extends 父类{\n\t...\n}\n```\n\n### 继承的特性\n\n- 子类拥有父类非private的属性，方法。\n\n- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n\n- 子类可以用自己的方式实现父类的方法。\n\n- Java的继承是单继承，但是可以多重继承，java的多继承通过接口来实现。\n\n- **关键字super和this在java的类中分别可以指代父类和类本身。**\n\n\n\n## 多继承的实现\n---\n\n### 抽象类\n\n- 抽象类的定义：\n```\n[访问修饰符] <abstract> class <类名>{\n\t[成员变量声明]\n\t[方法定义]\n}\n```\n- 抽象方法的定义：抽象方法是指只有声明而没有实现方法，用abstract修饰，一般格式如下：\n```\n[访问修饰符] <abstract> 返回类型 方法名(参数列表);\n```\n>注意抽象类不能定义为final类，因为抽象类不能实例化。抽象方法也不能声明为final方法，因为要在子类中实现该抽象方法。\n\n- **抽象类不能被实例化，实例化的工作应该交由它的子类来完成**，它只需要有一个引用即可。\n\n- 抽象方法必须由子类来进行重写。\n\n- **只要包含了抽象方法的类，该类必须要定义成抽象类，不管是否还包含有其他已经实现了的方法**。\n\n- 抽象类中可以包含具体的方法，**当然也可以不包含抽象方法**。\n\n- 子类中的抽象方法不能与父类的抽象方法同名。\n\n- abstract 不能与private、static、final或native并列修饰同一个方法。\n\n### 接口\n- 接口用interface来定义\n\n- **抽象类是对类抽象，而接口是对行为的抽象**。\n\n- 接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name\n\n- 接口实质也是一个抽象类，但与抽象类不同的是**接口中只能包含常量的定义和方法的声明**。接口只关心功能，而不关心功能的具体实现。\n\n- **接口中的常量在声明时必须对它赋初始值**。\n\n- 一般的继承使用extends作为关键字，只能单继承。接口使用implements作为关键字。可以接受多继承。\n\n- 接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷。\n\n- 接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口。\n\n- 接口的使用格式：\n `[访问修饰符][类型修饰符] class 类名 implements 接口名1,接口名2,......`\n\n- 一个类如果继承了某个接口，那么它就要实现这个接口的所有方法，否则这个类要定义为抽象类。\n>需要注意的是，接口中的方法默认是public，所以在类中实现接口时，必须使用public来修饰方法。如果接口中某个方法返回为void，则在类中实现该方法时，方法体可以为空，即只有两个大括号。\n\n- 接口使用示例：\n```\ninterface Computable{\n\tfinal int x = 10;\n\tint add();\n\tvoid point();\n}\nclass TESt implements Computable{\n\tprivate int y;\n\tpublic TEST(int y){\n\t\tthis.y = y;\n\t}\n\tpublic int add(){ //实现抽象方法时添加public 和 return 语句\n\t\treturn x + y;\n\t}\n\tpublic void print(){} //返回类型为void方法体可以留空\n}\n```\n\n- 接口之间也可以继承，用关键字extends，但是一个接口可以同时extends多个接口，之间以逗号间隔。\n>如果一个接口继承了别的几个接口，那么实现这个接口的类同时也要实现被这个接口继承的几个接口的所有方法。\n\n## Java中预定义的注释\n---\n\n- 形如 `@Override`等等在类方法之前的修饰就是预定义注释\n\n- 预定义注释不仅仅是给人看的，编译器也会读取，会有相应的约束\n\n- 预定义注释一共分为三种：`Override、Deprecated和SuppressWarnings `\n\n- 我们平常一般 **只会用到第一个**，后两个对于我们没有太多的用处。\n\n### Override\n\n-  这个注释的作用是标识某一个方法是否覆盖了它的父类的方法。\n\n- 如果加了这个标识，那么这个类方法则必须要覆盖父类的同名方法，即被Override注释的方法必须在父类中存在同样的方法程序才能编译通过。\n\n- 这样做的目的是，防止在子类中覆写父类的方法时，写错方法名导致最后子类的实例对象调用的还是父类的方法，这样就可能产生bug。\n\n### Deprecated\n\n- 这个对类方法的注释主要是开发者用的。\n\n- 这个注释不会产生什么实际的影响，但是被这个注释过的类方法如果被使用到的话，在编译时就会留下一些warning，警告内容是：这个方法现在还能用，但是下面版本的java可能会将它删除，也就是不推荐继续使用这个方法。\n\n- 出现如下警告：\n\n>    注意：test.java 使用或覆盖了已过时的 API。\n\n>    注意：要了解详细信息，请使用 -Xlint:deprecation 重新编译\n\n>    使用-Xlint:deprecation显示更详细的警告信息： .....\n\n### SuppressWarnings\n\n- 这个世界的事物总是成对出现。即然有使编译器产生警告信息的，那么就有抑制编译器产生警告信息的。 SuppressWarnings注释就是为了这样一个目的而存在的。\n\n- 这个注释可以抑制编译器产生一些警告信息。\n\n### 用户自定义注释\n\n- 详细了解——[博客](https://blog.csdn.net/softwave/article/details/6991913)\n\n<br>\n> 最后更新于2018.6.15\n","source":"_posts/2018-04-06-Java-class.md","raw":"---\nlayout:     post\ntitle:      \"Java学习笔记——类与继承\"\ndate:       2018-04-18 16:47:00\ncategories: Computer Programes\ntags: ๑Java\n---\n\n> 不适合人类阅读的学习笔记\n\n## Java的类，继承与接口\n---\n\n### 类的定义\n\n- 类的修饰符有两种：public 和 缺省。public表示共有的访问级别，即任何类都可以访问它。缺省只允许同一个包中的类来访问它。\n\n- 类的类型修饰符：缺省、abstract及final三种。abstract表示这是一个抽象类，**有些方法** 还没有实现。final表示这是一个最终类，不能被其他的类继承。\n\n- *类是对象的模板，对象是类的实例化*\n\n#### 一个类可以包含以下类型变量\n\n- 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。\n\n- 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。\n\n- **类变量**：类变量也声明在类中，方法体之外，但必须声明为static类型。（**同C++中的静态变量**）\n\n- 最终变量：即**常量**，用final关键字修饰。一般与static关键字连用，例如定义PI、E等。\n\n- 默认构造函数：java的类与C++一样可以写默认构造参数，格式也与C++一样，没有返回值，函数名与类名相同。有参数的构造函数也一样。\n\n### 源文件声明规则\n\n- 一个源文件中只能有一个public类\n\n- 一个源文件可以有多个非public类\n\n- 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。\n\n- 如果一个类定义在某个包中，那么package语句应该在源文件的首行。\n\n- 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。\nimport语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。\n\n- 类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。\n\n- 除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。\n\n## 对象\n\n### 对象的引用\n- 创建对象后，可以将对象的引用赋值给其他对象变量。\n\n- 例如下面的程序\n```\npublic class test{\n\tpublic static void main(String[] args){\n\t\tStringBuffer s;\n\t\ts= new StringBuffer(\"AAAAA\");\n\t\tStringBuffer s1 = s; //此句会使得s1和s指向同一个对象\n\t\ts1.append(\"BBBB\");\n\t\tSyetem.out.println(\"s = \" + s.toString());\n\t\tSyetem.out.println(\"s1 = \" + s1.toString());\n\t}\n}\n```\n- 输出结果为：\n```\ns = AAAAABBBB\ns1 = AAAAABBBB\n```\n\n### 方法参数传递\n\n#### 按值传递(一般的函数参数)\n\n- 传入方法中的参数是一份拷贝，对其的修改不会影响其本身\n```\nclass Printer{\n\tpublic void printinfo(String name, int age){\n\t\tage ++;\n\t\tSystem.out.println(\"Hello! My name is\" + name + \"and I'm \" + age);\n\t}\n\tpublic static void main(String args[]){\n\t\tPrinter p = new Printer();\n\t\tint age = 20;\n\t\tp.printinfo(\"Mike\",age);\n\t\tSystem.out.println(\"Now the initial age = \" + age);\n\t}\n}\n```\n\n#### 按引用传递\n\n- 调用方法时，**如果传递的是一个对象、接口或数组时**，实际上传递的是对象的、接口或者数组的引用。因此如果方法中对参数进行了修改，那么原来的数据也会受到影响。\n\n## 继承\n\n- 类的继承格式：\n```\nclass 父类{\n\t...\n}\nclass 子类 extends 父类{\n\t...\n}\n```\n\n### 继承的特性\n\n- 子类拥有父类非private的属性，方法。\n\n- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n\n- 子类可以用自己的方式实现父类的方法。\n\n- Java的继承是单继承，但是可以多重继承，java的多继承通过接口来实现。\n\n- **关键字super和this在java的类中分别可以指代父类和类本身。**\n\n\n\n## 多继承的实现\n---\n\n### 抽象类\n\n- 抽象类的定义：\n```\n[访问修饰符] <abstract> class <类名>{\n\t[成员变量声明]\n\t[方法定义]\n}\n```\n- 抽象方法的定义：抽象方法是指只有声明而没有实现方法，用abstract修饰，一般格式如下：\n```\n[访问修饰符] <abstract> 返回类型 方法名(参数列表);\n```\n>注意抽象类不能定义为final类，因为抽象类不能实例化。抽象方法也不能声明为final方法，因为要在子类中实现该抽象方法。\n\n- **抽象类不能被实例化，实例化的工作应该交由它的子类来完成**，它只需要有一个引用即可。\n\n- 抽象方法必须由子类来进行重写。\n\n- **只要包含了抽象方法的类，该类必须要定义成抽象类，不管是否还包含有其他已经实现了的方法**。\n\n- 抽象类中可以包含具体的方法，**当然也可以不包含抽象方法**。\n\n- 子类中的抽象方法不能与父类的抽象方法同名。\n\n- abstract 不能与private、static、final或native并列修饰同一个方法。\n\n### 接口\n- 接口用interface来定义\n\n- **抽象类是对类抽象，而接口是对行为的抽象**。\n\n- 接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name\n\n- 接口实质也是一个抽象类，但与抽象类不同的是**接口中只能包含常量的定义和方法的声明**。接口只关心功能，而不关心功能的具体实现。\n\n- **接口中的常量在声明时必须对它赋初始值**。\n\n- 一般的继承使用extends作为关键字，只能单继承。接口使用implements作为关键字。可以接受多继承。\n\n- 接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷。\n\n- 接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口。\n\n- 接口的使用格式：\n `[访问修饰符][类型修饰符] class 类名 implements 接口名1,接口名2,......`\n\n- 一个类如果继承了某个接口，那么它就要实现这个接口的所有方法，否则这个类要定义为抽象类。\n>需要注意的是，接口中的方法默认是public，所以在类中实现接口时，必须使用public来修饰方法。如果接口中某个方法返回为void，则在类中实现该方法时，方法体可以为空，即只有两个大括号。\n\n- 接口使用示例：\n```\ninterface Computable{\n\tfinal int x = 10;\n\tint add();\n\tvoid point();\n}\nclass TESt implements Computable{\n\tprivate int y;\n\tpublic TEST(int y){\n\t\tthis.y = y;\n\t}\n\tpublic int add(){ //实现抽象方法时添加public 和 return 语句\n\t\treturn x + y;\n\t}\n\tpublic void print(){} //返回类型为void方法体可以留空\n}\n```\n\n- 接口之间也可以继承，用关键字extends，但是一个接口可以同时extends多个接口，之间以逗号间隔。\n>如果一个接口继承了别的几个接口，那么实现这个接口的类同时也要实现被这个接口继承的几个接口的所有方法。\n\n## Java中预定义的注释\n---\n\n- 形如 `@Override`等等在类方法之前的修饰就是预定义注释\n\n- 预定义注释不仅仅是给人看的，编译器也会读取，会有相应的约束\n\n- 预定义注释一共分为三种：`Override、Deprecated和SuppressWarnings `\n\n- 我们平常一般 **只会用到第一个**，后两个对于我们没有太多的用处。\n\n### Override\n\n-  这个注释的作用是标识某一个方法是否覆盖了它的父类的方法。\n\n- 如果加了这个标识，那么这个类方法则必须要覆盖父类的同名方法，即被Override注释的方法必须在父类中存在同样的方法程序才能编译通过。\n\n- 这样做的目的是，防止在子类中覆写父类的方法时，写错方法名导致最后子类的实例对象调用的还是父类的方法，这样就可能产生bug。\n\n### Deprecated\n\n- 这个对类方法的注释主要是开发者用的。\n\n- 这个注释不会产生什么实际的影响，但是被这个注释过的类方法如果被使用到的话，在编译时就会留下一些warning，警告内容是：这个方法现在还能用，但是下面版本的java可能会将它删除，也就是不推荐继续使用这个方法。\n\n- 出现如下警告：\n\n>    注意：test.java 使用或覆盖了已过时的 API。\n\n>    注意：要了解详细信息，请使用 -Xlint:deprecation 重新编译\n\n>    使用-Xlint:deprecation显示更详细的警告信息： .....\n\n### SuppressWarnings\n\n- 这个世界的事物总是成对出现。即然有使编译器产生警告信息的，那么就有抑制编译器产生警告信息的。 SuppressWarnings注释就是为了这样一个目的而存在的。\n\n- 这个注释可以抑制编译器产生一些警告信息。\n\n### 用户自定义注释\n\n- 详细了解——[博客](https://blog.csdn.net/softwave/article/details/6991913)\n\n<br>\n> 最后更新于2018.6.15\n","slug":"2018-04-06-Java-class","published":1,"updated":"2018-09-03T14:01:52.914Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4300081m0o0ybtww4y","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"Java的类，继承与接口\"><a href=\"#Java的类，继承与接口\" class=\"headerlink\" title=\"Java的类，继承与接口\"></a>Java的类，继承与接口</h2><hr>\n<h3 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h3><ul>\n<li><p>类的修饰符有两种：public 和 缺省。public表示共有的访问级别，即任何类都可以访问它。缺省只允许同一个包中的类来访问它。</p>\n</li>\n<li><p>类的类型修饰符：缺省、abstract及final三种。abstract表示这是一个抽象类，<strong>有些方法</strong> 还没有实现。final表示这是一个最终类，不能被其他的类继承。</p>\n</li>\n<li><p><em>类是对象的模板，对象是类的实例化</em></p>\n</li>\n</ul>\n<h4 id=\"一个类可以包含以下类型变量\"><a href=\"#一个类可以包含以下类型变量\" class=\"headerlink\" title=\"一个类可以包含以下类型变量\"></a>一个类可以包含以下类型变量</h4><ul>\n<li><p>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</p>\n</li>\n<li><p>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</p>\n</li>\n<li><p><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为static类型。（<strong>同C++中的静态变量</strong>）</p>\n</li>\n<li><p>最终变量：即<strong>常量</strong>，用final关键字修饰。一般与static关键字连用，例如定义PI、E等。</p>\n</li>\n<li><p>默认构造函数：java的类与C++一样可以写默认构造参数，格式也与C++一样，没有返回值，函数名与类名相同。有参数的构造函数也一样。</p>\n</li>\n</ul>\n<h3 id=\"源文件声明规则\"><a href=\"#源文件声明规则\" class=\"headerlink\" title=\"源文件声明规则\"></a>源文件声明规则</h3><ul>\n<li><p>一个源文件中只能有一个public类</p>\n</li>\n<li><p>一个源文件可以有多个非public类</p>\n</li>\n<li><p>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</p>\n</li>\n<li><p>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</p>\n</li>\n<li><p>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。<br>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</p>\n</li>\n<li><p>类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。</p>\n</li>\n<li><p>除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。</p>\n</li>\n</ul>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"对象的引用\"><a href=\"#对象的引用\" class=\"headerlink\" title=\"对象的引用\"></a>对象的引用</h3><ul>\n<li><p>创建对象后，可以将对象的引用赋值给其他对象变量。</p>\n</li>\n<li><p>例如下面的程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class test&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tStringBuffer s;</span><br><span class=\"line\">\t\ts= new StringBuffer(&quot;AAAAA&quot;);</span><br><span class=\"line\">\t\tStringBuffer s1 = s; //此句会使得s1和s指向同一个对象</span><br><span class=\"line\">\t\ts1.append(&quot;BBBB&quot;);</span><br><span class=\"line\">\t\tSyetem.out.println(&quot;s = &quot; + s.toString());</span><br><span class=\"line\">\t\tSyetem.out.println(&quot;s1 = &quot; + s1.toString());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输出结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = AAAAABBBB</span><br><span class=\"line\">s1 = AAAAABBBB</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"方法参数传递\"><a href=\"#方法参数传递\" class=\"headerlink\" title=\"方法参数传递\"></a>方法参数传递</h3><h4 id=\"按值传递-一般的函数参数\"><a href=\"#按值传递-一般的函数参数\" class=\"headerlink\" title=\"按值传递(一般的函数参数)\"></a>按值传递(一般的函数参数)</h4><ul>\n<li>传入方法中的参数是一份拷贝，对其的修改不会影响其本身<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Printer&#123;</span><br><span class=\"line\">\tpublic void printinfo(String name, int age)&#123;</span><br><span class=\"line\">\t\tage ++;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Hello! My name is&quot; + name + &quot;and I&apos;m &quot; + age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static void main(String args[])&#123;</span><br><span class=\"line\">\t\tPrinter p = new Printer();</span><br><span class=\"line\">\t\tint age = 20;</span><br><span class=\"line\">\t\tp.printinfo(&quot;Mike&quot;,age);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Now the initial age = &quot; + age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"按引用传递\"><a href=\"#按引用传递\" class=\"headerlink\" title=\"按引用传递\"></a>按引用传递</h4><ul>\n<li>调用方法时，<strong>如果传递的是一个对象、接口或数组时</strong>，实际上传递的是对象的、接口或者数组的引用。因此如果方法中对参数进行了修改，那么原来的数据也会受到影响。</li>\n</ul>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><ul>\n<li>类的继承格式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 父类&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class 子类 extends 父类&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"继承的特性\"><a href=\"#继承的特性\" class=\"headerlink\" title=\"继承的特性\"></a>继承的特性</h3><ul>\n<li><p>子类拥有父类非private的属性，方法。</p>\n</li>\n<li><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p>\n</li>\n<li><p>子类可以用自己的方式实现父类的方法。</p>\n</li>\n<li><p>Java的继承是单继承，但是可以多重继承，java的多继承通过接口来实现。</p>\n</li>\n<li><p><strong>关键字super和this在java的类中分别可以指代父类和类本身。</strong></p>\n</li>\n</ul>\n<h2 id=\"多继承的实现\"><a href=\"#多继承的实现\" class=\"headerlink\" title=\"多继承的实现\"></a>多继承的实现</h2><hr>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li><p>抽象类的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[访问修饰符] &lt;abstract&gt; class &lt;类名&gt;&#123;</span><br><span class=\"line\">\t[成员变量声明]</span><br><span class=\"line\">\t[方法定义]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>抽象方法的定义：抽象方法是指只有声明而没有实现方法，用abstract修饰，一般格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[访问修饰符] &lt;abstract&gt; 返回类型 方法名(参数列表);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>注意抽象类不能定义为final类，因为抽象类不能实例化。抽象方法也不能声明为final方法，因为要在子类中实现该抽象方法。</p>\n</blockquote>\n<ul>\n<li><p><strong>抽象类不能被实例化，实例化的工作应该交由它的子类来完成</strong>，它只需要有一个引用即可。</p>\n</li>\n<li><p>抽象方法必须由子类来进行重写。</p>\n</li>\n<li><p><strong>只要包含了抽象方法的类，该类必须要定义成抽象类，不管是否还包含有其他已经实现了的方法</strong>。</p>\n</li>\n<li><p>抽象类中可以包含具体的方法，<strong>当然也可以不包含抽象方法</strong>。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名。</p>\n</li>\n<li><p>abstract 不能与private、static、final或native并列修饰同一个方法。</p>\n</li>\n</ul>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><ul>\n<li><p>接口用interface来定义</p>\n</li>\n<li><p><strong>抽象类是对类抽象，而接口是对行为的抽象</strong>。</p>\n</li>\n<li><p>接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name</p>\n</li>\n<li><p>接口实质也是一个抽象类，但与抽象类不同的是<strong>接口中只能包含常量的定义和方法的声明</strong>。接口只关心功能，而不关心功能的具体实现。</p>\n</li>\n<li><p><strong>接口中的常量在声明时必须对它赋初始值</strong>。</p>\n</li>\n<li><p>一般的继承使用extends作为关键字，只能单继承。接口使用implements作为关键字。可以接受多继承。</p>\n</li>\n<li><p>接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷。</p>\n</li>\n<li><p>接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口。</p>\n</li>\n<li><p>接口的使用格式：<br><code>[访问修饰符][类型修饰符] class 类名 implements 接口名1,接口名2,......</code></p>\n</li>\n<li><p>一个类如果继承了某个接口，那么它就要实现这个接口的所有方法，否则这个类要定义为抽象类。</p>\n<blockquote>\n<p>需要注意的是，接口中的方法默认是public，所以在类中实现接口时，必须使用public来修饰方法。如果接口中某个方法返回为void，则在类中实现该方法时，方法体可以为空，即只有两个大括号。</p>\n</blockquote>\n</li>\n<li><p>接口使用示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Computable&#123;</span><br><span class=\"line\">\tfinal int x = 10;</span><br><span class=\"line\">\tint add();</span><br><span class=\"line\">\tvoid point();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class TESt implements Computable&#123;</span><br><span class=\"line\">\tprivate int y;</span><br><span class=\"line\">\tpublic TEST(int y)&#123;</span><br><span class=\"line\">\t\tthis.y = y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic int add()&#123; //实现抽象方法时添加public 和 return 语句</span><br><span class=\"line\">\t\treturn x + y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void print()&#123;&#125; //返回类型为void方法体可以留空</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接口之间也可以继承，用关键字extends，但是一个接口可以同时extends多个接口，之间以逗号间隔。</p>\n<blockquote>\n<p>如果一个接口继承了别的几个接口，那么实现这个接口的类同时也要实现被这个接口继承的几个接口的所有方法。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Java中预定义的注释\"><a href=\"#Java中预定义的注释\" class=\"headerlink\" title=\"Java中预定义的注释\"></a>Java中预定义的注释</h2><hr>\n<ul>\n<li><p>形如 <code>@Override</code>等等在类方法之前的修饰就是预定义注释</p>\n</li>\n<li><p>预定义注释不仅仅是给人看的，编译器也会读取，会有相应的约束</p>\n</li>\n<li><p>预定义注释一共分为三种：<code>Override、Deprecated和SuppressWarnings</code></p>\n</li>\n<li><p>我们平常一般 <strong>只会用到第一个</strong>，后两个对于我们没有太多的用处。</p>\n</li>\n</ul>\n<h3 id=\"Override\"><a href=\"#Override\" class=\"headerlink\" title=\"Override\"></a>Override</h3><ul>\n<li><p>这个注释的作用是标识某一个方法是否覆盖了它的父类的方法。</p>\n</li>\n<li><p>如果加了这个标识，那么这个类方法则必须要覆盖父类的同名方法，即被Override注释的方法必须在父类中存在同样的方法程序才能编译通过。</p>\n</li>\n<li><p>这样做的目的是，防止在子类中覆写父类的方法时，写错方法名导致最后子类的实例对象调用的还是父类的方法，这样就可能产生bug。</p>\n</li>\n</ul>\n<h3 id=\"Deprecated\"><a href=\"#Deprecated\" class=\"headerlink\" title=\"Deprecated\"></a>Deprecated</h3><ul>\n<li><p>这个对类方法的注释主要是开发者用的。</p>\n</li>\n<li><p>这个注释不会产生什么实际的影响，但是被这个注释过的类方法如果被使用到的话，在编译时就会留下一些warning，警告内容是：这个方法现在还能用，但是下面版本的java可能会将它删除，也就是不推荐继续使用这个方法。</p>\n</li>\n<li><p>出现如下警告：</p>\n</li>\n</ul>\n<blockquote>\n<p>   注意：test.java 使用或覆盖了已过时的 API。</p>\n</blockquote>\n<blockquote>\n<p>   注意：要了解详细信息，请使用 -Xlint:deprecation 重新编译</p>\n</blockquote>\n<blockquote>\n<p>   使用-Xlint:deprecation显示更详细的警告信息： …..</p>\n</blockquote>\n<h3 id=\"SuppressWarnings\"><a href=\"#SuppressWarnings\" class=\"headerlink\" title=\"SuppressWarnings\"></a>SuppressWarnings</h3><ul>\n<li><p>这个世界的事物总是成对出现。即然有使编译器产生警告信息的，那么就有抑制编译器产生警告信息的。 SuppressWarnings注释就是为了这样一个目的而存在的。</p>\n</li>\n<li><p>这个注释可以抑制编译器产生一些警告信息。</p>\n</li>\n</ul>\n<h3 id=\"用户自定义注释\"><a href=\"#用户自定义注释\" class=\"headerlink\" title=\"用户自定义注释\"></a>用户自定义注释</h3><ul>\n<li>详细了解——<a href=\"https://blog.csdn.net/softwave/article/details/6991913\" target=\"_blank\" rel=\"noopener\">博客</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.6.15</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"Java的类，继承与接口\"><a href=\"#Java的类，继承与接口\" class=\"headerlink\" title=\"Java的类，继承与接口\"></a>Java的类，继承与接口</h2><hr>\n<h3 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h3><ul>\n<li><p>类的修饰符有两种：public 和 缺省。public表示共有的访问级别，即任何类都可以访问它。缺省只允许同一个包中的类来访问它。</p>\n</li>\n<li><p>类的类型修饰符：缺省、abstract及final三种。abstract表示这是一个抽象类，<strong>有些方法</strong> 还没有实现。final表示这是一个最终类，不能被其他的类继承。</p>\n</li>\n<li><p><em>类是对象的模板，对象是类的实例化</em></p>\n</li>\n</ul>\n<h4 id=\"一个类可以包含以下类型变量\"><a href=\"#一个类可以包含以下类型变量\" class=\"headerlink\" title=\"一个类可以包含以下类型变量\"></a>一个类可以包含以下类型变量</h4><ul>\n<li><p>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</p>\n</li>\n<li><p>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</p>\n</li>\n<li><p><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为static类型。（<strong>同C++中的静态变量</strong>）</p>\n</li>\n<li><p>最终变量：即<strong>常量</strong>，用final关键字修饰。一般与static关键字连用，例如定义PI、E等。</p>\n</li>\n<li><p>默认构造函数：java的类与C++一样可以写默认构造参数，格式也与C++一样，没有返回值，函数名与类名相同。有参数的构造函数也一样。</p>\n</li>\n</ul>\n<h3 id=\"源文件声明规则\"><a href=\"#源文件声明规则\" class=\"headerlink\" title=\"源文件声明规则\"></a>源文件声明规则</h3><ul>\n<li><p>一个源文件中只能有一个public类</p>\n</li>\n<li><p>一个源文件可以有多个非public类</p>\n</li>\n<li><p>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</p>\n</li>\n<li><p>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</p>\n</li>\n<li><p>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。<br>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</p>\n</li>\n<li><p>类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。</p>\n</li>\n<li><p>除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。</p>\n</li>\n</ul>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"对象的引用\"><a href=\"#对象的引用\" class=\"headerlink\" title=\"对象的引用\"></a>对象的引用</h3><ul>\n<li><p>创建对象后，可以将对象的引用赋值给其他对象变量。</p>\n</li>\n<li><p>例如下面的程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class test&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tStringBuffer s;</span><br><span class=\"line\">\t\ts= new StringBuffer(&quot;AAAAA&quot;);</span><br><span class=\"line\">\t\tStringBuffer s1 = s; //此句会使得s1和s指向同一个对象</span><br><span class=\"line\">\t\ts1.append(&quot;BBBB&quot;);</span><br><span class=\"line\">\t\tSyetem.out.println(&quot;s = &quot; + s.toString());</span><br><span class=\"line\">\t\tSyetem.out.println(&quot;s1 = &quot; + s1.toString());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输出结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = AAAAABBBB</span><br><span class=\"line\">s1 = AAAAABBBB</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"方法参数传递\"><a href=\"#方法参数传递\" class=\"headerlink\" title=\"方法参数传递\"></a>方法参数传递</h3><h4 id=\"按值传递-一般的函数参数\"><a href=\"#按值传递-一般的函数参数\" class=\"headerlink\" title=\"按值传递(一般的函数参数)\"></a>按值传递(一般的函数参数)</h4><ul>\n<li>传入方法中的参数是一份拷贝，对其的修改不会影响其本身<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Printer&#123;</span><br><span class=\"line\">\tpublic void printinfo(String name, int age)&#123;</span><br><span class=\"line\">\t\tage ++;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Hello! My name is&quot; + name + &quot;and I&apos;m &quot; + age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static void main(String args[])&#123;</span><br><span class=\"line\">\t\tPrinter p = new Printer();</span><br><span class=\"line\">\t\tint age = 20;</span><br><span class=\"line\">\t\tp.printinfo(&quot;Mike&quot;,age);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Now the initial age = &quot; + age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"按引用传递\"><a href=\"#按引用传递\" class=\"headerlink\" title=\"按引用传递\"></a>按引用传递</h4><ul>\n<li>调用方法时，<strong>如果传递的是一个对象、接口或数组时</strong>，实际上传递的是对象的、接口或者数组的引用。因此如果方法中对参数进行了修改，那么原来的数据也会受到影响。</li>\n</ul>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><ul>\n<li>类的继承格式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 父类&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class 子类 extends 父类&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"继承的特性\"><a href=\"#继承的特性\" class=\"headerlink\" title=\"继承的特性\"></a>继承的特性</h3><ul>\n<li><p>子类拥有父类非private的属性，方法。</p>\n</li>\n<li><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p>\n</li>\n<li><p>子类可以用自己的方式实现父类的方法。</p>\n</li>\n<li><p>Java的继承是单继承，但是可以多重继承，java的多继承通过接口来实现。</p>\n</li>\n<li><p><strong>关键字super和this在java的类中分别可以指代父类和类本身。</strong></p>\n</li>\n</ul>\n<h2 id=\"多继承的实现\"><a href=\"#多继承的实现\" class=\"headerlink\" title=\"多继承的实现\"></a>多继承的实现</h2><hr>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li><p>抽象类的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[访问修饰符] &lt;abstract&gt; class &lt;类名&gt;&#123;</span><br><span class=\"line\">\t[成员变量声明]</span><br><span class=\"line\">\t[方法定义]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>抽象方法的定义：抽象方法是指只有声明而没有实现方法，用abstract修饰，一般格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[访问修饰符] &lt;abstract&gt; 返回类型 方法名(参数列表);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>注意抽象类不能定义为final类，因为抽象类不能实例化。抽象方法也不能声明为final方法，因为要在子类中实现该抽象方法。</p>\n</blockquote>\n<ul>\n<li><p><strong>抽象类不能被实例化，实例化的工作应该交由它的子类来完成</strong>，它只需要有一个引用即可。</p>\n</li>\n<li><p>抽象方法必须由子类来进行重写。</p>\n</li>\n<li><p><strong>只要包含了抽象方法的类，该类必须要定义成抽象类，不管是否还包含有其他已经实现了的方法</strong>。</p>\n</li>\n<li><p>抽象类中可以包含具体的方法，<strong>当然也可以不包含抽象方法</strong>。</p>\n</li>\n<li><p>子类中的抽象方法不能与父类的抽象方法同名。</p>\n</li>\n<li><p>abstract 不能与private、static、final或native并列修饰同一个方法。</p>\n</li>\n</ul>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><ul>\n<li><p>接口用interface来定义</p>\n</li>\n<li><p><strong>抽象类是对类抽象，而接口是对行为的抽象</strong>。</p>\n</li>\n<li><p>接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name</p>\n</li>\n<li><p>接口实质也是一个抽象类，但与抽象类不同的是<strong>接口中只能包含常量的定义和方法的声明</strong>。接口只关心功能，而不关心功能的具体实现。</p>\n</li>\n<li><p><strong>接口中的常量在声明时必须对它赋初始值</strong>。</p>\n</li>\n<li><p>一般的继承使用extends作为关键字，只能单继承。接口使用implements作为关键字。可以接受多继承。</p>\n</li>\n<li><p>接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷。</p>\n</li>\n<li><p>接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口。</p>\n</li>\n<li><p>接口的使用格式：<br><code>[访问修饰符][类型修饰符] class 类名 implements 接口名1,接口名2,......</code></p>\n</li>\n<li><p>一个类如果继承了某个接口，那么它就要实现这个接口的所有方法，否则这个类要定义为抽象类。</p>\n<blockquote>\n<p>需要注意的是，接口中的方法默认是public，所以在类中实现接口时，必须使用public来修饰方法。如果接口中某个方法返回为void，则在类中实现该方法时，方法体可以为空，即只有两个大括号。</p>\n</blockquote>\n</li>\n<li><p>接口使用示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Computable&#123;</span><br><span class=\"line\">\tfinal int x = 10;</span><br><span class=\"line\">\tint add();</span><br><span class=\"line\">\tvoid point();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class TESt implements Computable&#123;</span><br><span class=\"line\">\tprivate int y;</span><br><span class=\"line\">\tpublic TEST(int y)&#123;</span><br><span class=\"line\">\t\tthis.y = y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic int add()&#123; //实现抽象方法时添加public 和 return 语句</span><br><span class=\"line\">\t\treturn x + y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void print()&#123;&#125; //返回类型为void方法体可以留空</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接口之间也可以继承，用关键字extends，但是一个接口可以同时extends多个接口，之间以逗号间隔。</p>\n<blockquote>\n<p>如果一个接口继承了别的几个接口，那么实现这个接口的类同时也要实现被这个接口继承的几个接口的所有方法。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Java中预定义的注释\"><a href=\"#Java中预定义的注释\" class=\"headerlink\" title=\"Java中预定义的注释\"></a>Java中预定义的注释</h2><hr>\n<ul>\n<li><p>形如 <code>@Override</code>等等在类方法之前的修饰就是预定义注释</p>\n</li>\n<li><p>预定义注释不仅仅是给人看的，编译器也会读取，会有相应的约束</p>\n</li>\n<li><p>预定义注释一共分为三种：<code>Override、Deprecated和SuppressWarnings</code></p>\n</li>\n<li><p>我们平常一般 <strong>只会用到第一个</strong>，后两个对于我们没有太多的用处。</p>\n</li>\n</ul>\n<h3 id=\"Override\"><a href=\"#Override\" class=\"headerlink\" title=\"Override\"></a>Override</h3><ul>\n<li><p>这个注释的作用是标识某一个方法是否覆盖了它的父类的方法。</p>\n</li>\n<li><p>如果加了这个标识，那么这个类方法则必须要覆盖父类的同名方法，即被Override注释的方法必须在父类中存在同样的方法程序才能编译通过。</p>\n</li>\n<li><p>这样做的目的是，防止在子类中覆写父类的方法时，写错方法名导致最后子类的实例对象调用的还是父类的方法，这样就可能产生bug。</p>\n</li>\n</ul>\n<h3 id=\"Deprecated\"><a href=\"#Deprecated\" class=\"headerlink\" title=\"Deprecated\"></a>Deprecated</h3><ul>\n<li><p>这个对类方法的注释主要是开发者用的。</p>\n</li>\n<li><p>这个注释不会产生什么实际的影响，但是被这个注释过的类方法如果被使用到的话，在编译时就会留下一些warning，警告内容是：这个方法现在还能用，但是下面版本的java可能会将它删除，也就是不推荐继续使用这个方法。</p>\n</li>\n<li><p>出现如下警告：</p>\n</li>\n</ul>\n<blockquote>\n<p>   注意：test.java 使用或覆盖了已过时的 API。</p>\n</blockquote>\n<blockquote>\n<p>   注意：要了解详细信息，请使用 -Xlint:deprecation 重新编译</p>\n</blockquote>\n<blockquote>\n<p>   使用-Xlint:deprecation显示更详细的警告信息： …..</p>\n</blockquote>\n<h3 id=\"SuppressWarnings\"><a href=\"#SuppressWarnings\" class=\"headerlink\" title=\"SuppressWarnings\"></a>SuppressWarnings</h3><ul>\n<li><p>这个世界的事物总是成对出现。即然有使编译器产生警告信息的，那么就有抑制编译器产生警告信息的。 SuppressWarnings注释就是为了这样一个目的而存在的。</p>\n</li>\n<li><p>这个注释可以抑制编译器产生一些警告信息。</p>\n</li>\n</ul>\n<h3 id=\"用户自定义注释\"><a href=\"#用户自定义注释\" class=\"headerlink\" title=\"用户自定义注释\"></a>用户自定义注释</h3><ul>\n<li>详细了解——<a href=\"https://blog.csdn.net/softwave/article/details/6991913\" target=\"_blank\" rel=\"noopener\">博客</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.6.15</p>\n</blockquote>\n"},{"layout":"post","title":"Java学习笔记——方法","date":"2018-04-18T08:47:00.000Z","_content":"\n> 不适合人类阅读的学习笔记  \n\n## 函数\n---\n\n- **Java中的函数没有默认参数，通过函数重载间接实现这个功能。**\n\n- java没有在类外面定义的函数，所以一般都是方法。\n\n### 工具类函数的使用\n\n- 如果要自己写一些可以复用的工具函数，可以新建一个class：\n```\nclass myUtils{\n  static void func(...){...}\n}\n```\n- 在这个类中将要用的工具函数用static来修饰，然后将函数的参数弄好之后，就可以在不用新建对象的情况下使用这个方法了。\n\n\n<br>\n\n> 最后更新于2018.6.6\n","source":"_posts/2018-04-06-Java-function.md","raw":"---\nlayout:     post\ntitle:      \"Java学习笔记——方法\"\ndate:       2018-04-18 16:47:00\ncategories: Computer Programes\ntags: ๑Java\n---\n\n> 不适合人类阅读的学习笔记  \n\n## 函数\n---\n\n- **Java中的函数没有默认参数，通过函数重载间接实现这个功能。**\n\n- java没有在类外面定义的函数，所以一般都是方法。\n\n### 工具类函数的使用\n\n- 如果要自己写一些可以复用的工具函数，可以新建一个class：\n```\nclass myUtils{\n  static void func(...){...}\n}\n```\n- 在这个类中将要用的工具函数用static来修饰，然后将函数的参数弄好之后，就可以在不用新建对象的情况下使用这个方法了。\n\n\n<br>\n\n> 最后更新于2018.6.6\n","slug":"2018-04-06-Java-function","published":1,"updated":"2018-09-03T13:26:00.221Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4400091m0or4lk3dgw","content":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><hr>\n<ul>\n<li><p><strong>Java中的函数没有默认参数，通过函数重载间接实现这个功能。</strong></p>\n</li>\n<li><p>java没有在类外面定义的函数，所以一般都是方法。</p>\n</li>\n</ul>\n<h3 id=\"工具类函数的使用\"><a href=\"#工具类函数的使用\" class=\"headerlink\" title=\"工具类函数的使用\"></a>工具类函数的使用</h3><ul>\n<li><p>如果要自己写一些可以复用的工具函数，可以新建一个class：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class myUtils&#123;</span><br><span class=\"line\">  static void func(...)&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在这个类中将要用的工具函数用static来修饰，然后将函数的参数弄好之后，就可以在不用新建对象的情况下使用这个方法了。</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.6.6</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><hr>\n<ul>\n<li><p><strong>Java中的函数没有默认参数，通过函数重载间接实现这个功能。</strong></p>\n</li>\n<li><p>java没有在类外面定义的函数，所以一般都是方法。</p>\n</li>\n</ul>\n<h3 id=\"工具类函数的使用\"><a href=\"#工具类函数的使用\" class=\"headerlink\" title=\"工具类函数的使用\"></a>工具类函数的使用</h3><ul>\n<li><p>如果要自己写一些可以复用的工具函数，可以新建一个class：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class myUtils&#123;</span><br><span class=\"line\">  static void func(...)&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在这个类中将要用的工具函数用static来修饰，然后将函数的参数弄好之后，就可以在不用新建对象的情况下使用这个方法了。</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.6.6</p>\n</blockquote>\n"},{"layout":"post","title":"Python学习笔记——基础","date":"2018-04-06T08:47:00.000Z","_content":"\n> 不适合人类阅读的学习笔记  \n\n- **Python语句不需要分号分割，但是Python各语句严格按照缩进对其方式运行**\n\n- 与C++一样，可以将一些非空，非零的值作为bool值的真，其余的为假\n\n- Python中以 `#`作为注释的开始，多行注释可以用三引号对。\n\n## 环境\n---\n\n- Python推荐使用jetbrain公司的pycharm\n\n- Python可以直接使用自带的IDE逐句执行，方便测试\n\n\n## 基础\n---\n\n- **Python中不需要声明变量类型，编译器会根据赋值自动判别，但是作为程序的编写者，我们需要清楚某个变量究竟是什么类型的**\n\n- Python中单独的下划线是特殊的变量，表示上一次运算的结果。\n\n### 输出\n\n- 标准输出格式： `print([输出1，输出2,....,输出n][,sep = 分隔符][,end = 结束符])`\n> 默认以空格分割，换行符结尾\n\n- 各个输出之间以逗号间隔\n\n- `print()`函数不写参数即默认输出一个空行。在一批数据输出结束后，好的编程习惯是在末尾加上一个`print()`，使得输出美观。\n\n- Python的输出可以有运算在里面，例如：`print(5 * '*')` 则会打印出 `*****`\n\n- 在输出字符串时，可以在字符串的引号前加一个 `r` 使得转义字符 `\\` 失效。\n\n### 输入\n\n- 相比较于java，Python的输入可以说是非常灵活而且简便了\n```\na = input()   #若调用此函数，就算输入的是数字，a的数据类型仍然为str，Python默认将命令行读入的数据作为str类型，因为str是万能的~\n```\n\n- 但是，对于如下的情况：\n```\na =eval(input())    #eval() 函数用来执行一个字符串表达式，并返回表达式的值.例如 eval('2 * 3')返回 6\n#此时只能输入数字，且a是整型还是浮点型由输入数据的特征决定\n```\n\n- 如果想要同时为多个变量赋值，则只能使用`eval()`函数了\n```\nx,y = eval(input())  #输入时以逗号间隔\n```\n- 对于eval()函数的使用，一定要确保参数去掉引号之后的值是有意义的\n\n## 一些数据类型\n\n### 综述一些注意点\n\n- 序列的概念：序列是一个排序的项目 **容器**，按 **非负整数索引**。Python提供的内置序列包包括字符串，元组和列表。(序列就是可以通过索引或者切片访问的容器)\n\n- 所有的序列都是可以迭代的，即可以作为循环的迭代器。\n\n- 内置函数`len()`可以将任意一个容器作为参数，并返回该容器中元素的数量\n\n- 内置函数`min()`和`max()`以一个可以比较的非空容器作为参数，返回其最小最大值。(如果给的参数不止一个，则返回最大或最小的 **参数**)\n\n- 对于字典使用`min()`和`max()`则会返回字典最大或最小的 **键**。\n\n- 关键字 `in` 可以检查某个元素是否在一个容器中。例如`k in D`(D是一个字典)则检查k是不是D当中的一个关键字。\n\n- `reversed(seq)`函数： seq代表一个可迭代对象，比如列表\n```\n>>> a = [1,2,3,4,5]\n>>> b = reversed(a)  #此时b为一个迭代器\n>>> b1 = list(b)    #将这个迭代器转化为列表\n>>> b1\n>>> [5,4,3,2,1]\n```\n\n- `sum()`函数：\n```\nsum(seq, start = m)   #sum()有两个参数，第二个为可选参数\n# 返回可迭代对象中的所有项目的和再加上start的值\n```\n\n### 一些基础数据类型的注意点\n\n- 输入一个数，获取其各个位的数值的方法：**注意Python的整除符号与别的编程语言不同**\n```\n假设 x = 123\n个位  = x % 10\n十位  = x // 10 % 10   (注意，Python与其他编程语言的整除符号不同，比如C++就是 '/' 即表示整除，而Python为 '//')\n百位 = x //100 % 10\n```\n\n- 复数：\n```\na = complex(2,3)\nb = 1 + 2j\nc = 3 - 5j\n#a,b,c都是复数\n#要获取复数的实部和虚部，可使用例如：a.real(a的实部), a.imag(a的虚部)，结果都是浮点型\n```\n- `45e15`表示45*10^15，这是科学计数法的写法\n\n- 要判断两个浮点数是否相等，如果不确定精度的情况下，最好不要使用`==`来判断。因为可能存在看起来一样的数实际上因为精度不同而被判定为不等。解决的方法是`abs(x - y) < 1.0e-15`，即是用两数之差的绝对值小于一个很小的数，即可判断两数近似相等。\n\n- 关于Python中的bool类型，与C++类似，非零数或非空容器为真，0，None和空容器为假\n\n### List\n\n> Python中list里的元素允许是不同的数据类型，这一点完全打破了C和C++体系的传统，所以平常编写程序不推荐这样做。list中也允许某个元素是list或者元组什么的。\n\n- 例： `classmates = [\"Mike\",\"Davaid\"]`\n\n- `len()`函数可以获得list中的元素个数\n\n- 与其他编程语言不同的是，Python的list下标允许负数的index，例如： `classmates[-1]`就表示这个list的最后一个元素，以此类推。\n\n- `append()`方法：在list末尾末尾添加元素：`classmates.append(\"Alex\")`\n\n- 把元素插入到指定的位置，比如索引号为1的位置：`classmates.insert(1, 'Jack')` 这样Jack的位置索引即为1，原来索引为1的元素及后面的元素依次后移。\n\n- 删除list末尾的元素，使用`.pop()`方法，要删除指定位置的元素，使用`.pop(i)`的方法，i为元素的索引。\n\n### tuple\n\n- 元组与；list非常类似，但是tuple一经初始化其内容便不允许修改，不允许插入和删除等操作。\n\n- 元组一般用来保存那些不允许修改的数据以保障安全。\n\n- 但是如果tuple中某个元素是list时，这个list中的元素还是可以修改的。\n\n### disk\n\n> disk（字典）是一种键-值对类型的数据结构，在其他语言中会被称为map。dict的key必须为不可变的量\n\n> 注意，Python中的dick类型是以hash方式存储的，读取速度非常快。\n\n- 将数据添加进dick的方式，除了初始化时设定之外，还可以直接给一个键赋值的方式添加，例如：\n```\nd = {'A': 95, 'B': 75, 'C': 85} #初始化添加元素\nd['E'] = 100   #直接赋值添加元素\n```\n\n- 判断一个key是否存在的方法：\n\n1. `\"Thomas\" in d`\t\t#若不存在会返回false\n2. `d.get(\"Thomas\")`  #若不存在返回null\n3. `d.get(\"Thomas\",-1)`  #自己指定返回的值\n\n### set\n\n> set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n\n- 通过`.add(key)`的方法添加元素。\n\n- 通过`.remove(key)`的方法删除元素。\n\n- 符号 `&` 和 `|` 分别表示集合的交和并\n\n- list的简单的去重：\n```\n>>> a = [1,2,2,3,4,5,5,6,1]\n>>> b= set(a)\n>>> b\n>>>{1,2,3,4,5,6}\n>>>a =list(b)\n>>>a\n>>>[1,2,3,4,5,6]\n```\n\n## 条件判断\n\n- Python的if判断语句的判断条件部分不需要用括号括起来，这与其他的大多数语言均不同\n\n- 格式：\n```\nif <条件判断1>:\n    <执行1>\nelif <条件判断2>:\n    <执行2>\nelif <条件判断3>:\n    <执行3>\nelse:\n    <执行4>\n```\n- 例：\n```\nage = 20\nif age >= 6 and age <= 30:  #多条件判断用 and 链接\n    print('teenager')\nelif not (age >= 18):     #not相当于 非，后面的内容用括号括起来\n    print('adult')\nelse:\n    print('kid')\n```\n\n- 与input结合（涉及数据类型转换）：\n```\ns = input('birth: ')\nbirth = int(s) \t\t#如果没有这句转换会报错，因为input进来的是str，不能直接和int比较，因此要先转换为int再比较。\n#但是如果此处的输入不是一个数值类型，int函数无法强制转化便会报错。\nif birth < 2000:\n    print('00前')\nelse:\n    print('00后')\n```\n\n- 利用运算符优先级： z = x if x > y else y\n\n\n### 循环\n\n- 例（求和）：\n```\nfor x in [1,2,3,4,5,6]:\n\tsum = sum + x\nprint(sum)\n```\n- `range()`函数： 生成从0 - **输入数值-1** 的一个迭代器，可用作循环条件。例`list(range(5))`的结果为 `[0,1,2,3,4]`\n\n\n- 例求 1- 100 的和：\n```\nsum = 0\nfor x in range(101):\n    sum = sum + x\nprint(sum)\n```\n\n- while循环示例：(素数的判断)\n```\nimport math\nm = int(input(\"Please enter a num: \"))  #待判断的数 m\ni,j = 2, int(math.sqrt(m))       #只需要计算 2 到 根号m 范围内是否有m的因数即可，后面的计算均为重复计算\nflag = 1                        #素数标志\nwhile i < j and flag == 1:\n  if m % 1 == 0\n    flag = 0                    #不是素数的标志\n  i += 1\nif flag and m > 1:              #素数必须大于1\n  print(m, \"是素数\")\nelse:\n  print(m, \"不是素数\")\n```\n\n- **while和for语句使用拖尾的else子句**：\n```\nfor ... :\n  ...\n  ...\nelse ...   #注意这个else是与for对齐的\n```\n这种写法的else子句块会在循环 **正常终止时执行**。意思就是，如果循环中的break语句生效而导致的循环终止，是不会触发这个else子句的执行的。因此这种写法可以 **优雅地判断一个循环是正常结束还是break掉了**。\n\n- 在循环中使用print()输出时，注意Print之后是否正确地结束循环或者进入下一个输出，否则可能出现重复输出大量重复数据的可能。\n\n- 求两个数的最大公约数(辗转相除法):\n```\na,b = eval(input(\"请输入两个整数: \"))\nif a > b : a,b = b,a   #Python中可以简便地交换两个变量的值\nr = a % b\nwhile r != 0\n  a,b = b,r\n  r = a % b\nprint(\"最大公约数是：\",b)\nprint()\n```\n\n- 输出[100,1000]以内的所有素数\n```\nimport math\nn = 0\nfor m in range(101,1000,2)    #直接去掉100和1000，这两个肯定不是素数\n  i,j = 2, int(math.sqrt(m))\n  while i <= j:\n    if not(m % j):      #如果 m % j == 0 就是找到因数了，直接退出这一次循环，进入下一个循环\n      break\n    else:\n      i = i + 1\n  else:\n    print(m, end = \" \")\n    n += 1\n    if n % 10 == 0: print(\"\\n\")    #每输出10个数就换行\nprint()\n```\n\n## 函数\n---\n\n### 函数定义的格式\n```\ndef 函数名([参数1,参数2,参数3...]):   #参数没有参数类型，如果要设置参数的默认值则要满足从右向左的原则\n\t[函数体]\n\t[return [返回值]] \t\t#没有写return或者直接写return都是返回None\n```\n\n- Python中可以让函数返回一个有多个元素的tuple来实现返回多个值的要求。\n\n\n\n## 一些注意点\n---\n\n- `abs()` 函数的返回值与参数一致，而`fabs()` 的返回值均为浮点型\n\n- Python支持连续的不等式，例如`a > b > c` 等价于 `a > b && b > c`\n\n<br>\n\n> 最后更新于2018.4.28\n","source":"_posts/2018-04-06-Python-learning.md","raw":"---\nlayout:     post\ntitle:      \"Python学习笔记——基础\"\ndate:       2018-04-06 16:47:00\ncategories: Computer Programes\ntags: ๑Python\n---\n\n> 不适合人类阅读的学习笔记  \n\n- **Python语句不需要分号分割，但是Python各语句严格按照缩进对其方式运行**\n\n- 与C++一样，可以将一些非空，非零的值作为bool值的真，其余的为假\n\n- Python中以 `#`作为注释的开始，多行注释可以用三引号对。\n\n## 环境\n---\n\n- Python推荐使用jetbrain公司的pycharm\n\n- Python可以直接使用自带的IDE逐句执行，方便测试\n\n\n## 基础\n---\n\n- **Python中不需要声明变量类型，编译器会根据赋值自动判别，但是作为程序的编写者，我们需要清楚某个变量究竟是什么类型的**\n\n- Python中单独的下划线是特殊的变量，表示上一次运算的结果。\n\n### 输出\n\n- 标准输出格式： `print([输出1，输出2,....,输出n][,sep = 分隔符][,end = 结束符])`\n> 默认以空格分割，换行符结尾\n\n- 各个输出之间以逗号间隔\n\n- `print()`函数不写参数即默认输出一个空行。在一批数据输出结束后，好的编程习惯是在末尾加上一个`print()`，使得输出美观。\n\n- Python的输出可以有运算在里面，例如：`print(5 * '*')` 则会打印出 `*****`\n\n- 在输出字符串时，可以在字符串的引号前加一个 `r` 使得转义字符 `\\` 失效。\n\n### 输入\n\n- 相比较于java，Python的输入可以说是非常灵活而且简便了\n```\na = input()   #若调用此函数，就算输入的是数字，a的数据类型仍然为str，Python默认将命令行读入的数据作为str类型，因为str是万能的~\n```\n\n- 但是，对于如下的情况：\n```\na =eval(input())    #eval() 函数用来执行一个字符串表达式，并返回表达式的值.例如 eval('2 * 3')返回 6\n#此时只能输入数字，且a是整型还是浮点型由输入数据的特征决定\n```\n\n- 如果想要同时为多个变量赋值，则只能使用`eval()`函数了\n```\nx,y = eval(input())  #输入时以逗号间隔\n```\n- 对于eval()函数的使用，一定要确保参数去掉引号之后的值是有意义的\n\n## 一些数据类型\n\n### 综述一些注意点\n\n- 序列的概念：序列是一个排序的项目 **容器**，按 **非负整数索引**。Python提供的内置序列包包括字符串，元组和列表。(序列就是可以通过索引或者切片访问的容器)\n\n- 所有的序列都是可以迭代的，即可以作为循环的迭代器。\n\n- 内置函数`len()`可以将任意一个容器作为参数，并返回该容器中元素的数量\n\n- 内置函数`min()`和`max()`以一个可以比较的非空容器作为参数，返回其最小最大值。(如果给的参数不止一个，则返回最大或最小的 **参数**)\n\n- 对于字典使用`min()`和`max()`则会返回字典最大或最小的 **键**。\n\n- 关键字 `in` 可以检查某个元素是否在一个容器中。例如`k in D`(D是一个字典)则检查k是不是D当中的一个关键字。\n\n- `reversed(seq)`函数： seq代表一个可迭代对象，比如列表\n```\n>>> a = [1,2,3,4,5]\n>>> b = reversed(a)  #此时b为一个迭代器\n>>> b1 = list(b)    #将这个迭代器转化为列表\n>>> b1\n>>> [5,4,3,2,1]\n```\n\n- `sum()`函数：\n```\nsum(seq, start = m)   #sum()有两个参数，第二个为可选参数\n# 返回可迭代对象中的所有项目的和再加上start的值\n```\n\n### 一些基础数据类型的注意点\n\n- 输入一个数，获取其各个位的数值的方法：**注意Python的整除符号与别的编程语言不同**\n```\n假设 x = 123\n个位  = x % 10\n十位  = x // 10 % 10   (注意，Python与其他编程语言的整除符号不同，比如C++就是 '/' 即表示整除，而Python为 '//')\n百位 = x //100 % 10\n```\n\n- 复数：\n```\na = complex(2,3)\nb = 1 + 2j\nc = 3 - 5j\n#a,b,c都是复数\n#要获取复数的实部和虚部，可使用例如：a.real(a的实部), a.imag(a的虚部)，结果都是浮点型\n```\n- `45e15`表示45*10^15，这是科学计数法的写法\n\n- 要判断两个浮点数是否相等，如果不确定精度的情况下，最好不要使用`==`来判断。因为可能存在看起来一样的数实际上因为精度不同而被判定为不等。解决的方法是`abs(x - y) < 1.0e-15`，即是用两数之差的绝对值小于一个很小的数，即可判断两数近似相等。\n\n- 关于Python中的bool类型，与C++类似，非零数或非空容器为真，0，None和空容器为假\n\n### List\n\n> Python中list里的元素允许是不同的数据类型，这一点完全打破了C和C++体系的传统，所以平常编写程序不推荐这样做。list中也允许某个元素是list或者元组什么的。\n\n- 例： `classmates = [\"Mike\",\"Davaid\"]`\n\n- `len()`函数可以获得list中的元素个数\n\n- 与其他编程语言不同的是，Python的list下标允许负数的index，例如： `classmates[-1]`就表示这个list的最后一个元素，以此类推。\n\n- `append()`方法：在list末尾末尾添加元素：`classmates.append(\"Alex\")`\n\n- 把元素插入到指定的位置，比如索引号为1的位置：`classmates.insert(1, 'Jack')` 这样Jack的位置索引即为1，原来索引为1的元素及后面的元素依次后移。\n\n- 删除list末尾的元素，使用`.pop()`方法，要删除指定位置的元素，使用`.pop(i)`的方法，i为元素的索引。\n\n### tuple\n\n- 元组与；list非常类似，但是tuple一经初始化其内容便不允许修改，不允许插入和删除等操作。\n\n- 元组一般用来保存那些不允许修改的数据以保障安全。\n\n- 但是如果tuple中某个元素是list时，这个list中的元素还是可以修改的。\n\n### disk\n\n> disk（字典）是一种键-值对类型的数据结构，在其他语言中会被称为map。dict的key必须为不可变的量\n\n> 注意，Python中的dick类型是以hash方式存储的，读取速度非常快。\n\n- 将数据添加进dick的方式，除了初始化时设定之外，还可以直接给一个键赋值的方式添加，例如：\n```\nd = {'A': 95, 'B': 75, 'C': 85} #初始化添加元素\nd['E'] = 100   #直接赋值添加元素\n```\n\n- 判断一个key是否存在的方法：\n\n1. `\"Thomas\" in d`\t\t#若不存在会返回false\n2. `d.get(\"Thomas\")`  #若不存在返回null\n3. `d.get(\"Thomas\",-1)`  #自己指定返回的值\n\n### set\n\n> set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n\n- 通过`.add(key)`的方法添加元素。\n\n- 通过`.remove(key)`的方法删除元素。\n\n- 符号 `&` 和 `|` 分别表示集合的交和并\n\n- list的简单的去重：\n```\n>>> a = [1,2,2,3,4,5,5,6,1]\n>>> b= set(a)\n>>> b\n>>>{1,2,3,4,5,6}\n>>>a =list(b)\n>>>a\n>>>[1,2,3,4,5,6]\n```\n\n## 条件判断\n\n- Python的if判断语句的判断条件部分不需要用括号括起来，这与其他的大多数语言均不同\n\n- 格式：\n```\nif <条件判断1>:\n    <执行1>\nelif <条件判断2>:\n    <执行2>\nelif <条件判断3>:\n    <执行3>\nelse:\n    <执行4>\n```\n- 例：\n```\nage = 20\nif age >= 6 and age <= 30:  #多条件判断用 and 链接\n    print('teenager')\nelif not (age >= 18):     #not相当于 非，后面的内容用括号括起来\n    print('adult')\nelse:\n    print('kid')\n```\n\n- 与input结合（涉及数据类型转换）：\n```\ns = input('birth: ')\nbirth = int(s) \t\t#如果没有这句转换会报错，因为input进来的是str，不能直接和int比较，因此要先转换为int再比较。\n#但是如果此处的输入不是一个数值类型，int函数无法强制转化便会报错。\nif birth < 2000:\n    print('00前')\nelse:\n    print('00后')\n```\n\n- 利用运算符优先级： z = x if x > y else y\n\n\n### 循环\n\n- 例（求和）：\n```\nfor x in [1,2,3,4,5,6]:\n\tsum = sum + x\nprint(sum)\n```\n- `range()`函数： 生成从0 - **输入数值-1** 的一个迭代器，可用作循环条件。例`list(range(5))`的结果为 `[0,1,2,3,4]`\n\n\n- 例求 1- 100 的和：\n```\nsum = 0\nfor x in range(101):\n    sum = sum + x\nprint(sum)\n```\n\n- while循环示例：(素数的判断)\n```\nimport math\nm = int(input(\"Please enter a num: \"))  #待判断的数 m\ni,j = 2, int(math.sqrt(m))       #只需要计算 2 到 根号m 范围内是否有m的因数即可，后面的计算均为重复计算\nflag = 1                        #素数标志\nwhile i < j and flag == 1:\n  if m % 1 == 0\n    flag = 0                    #不是素数的标志\n  i += 1\nif flag and m > 1:              #素数必须大于1\n  print(m, \"是素数\")\nelse:\n  print(m, \"不是素数\")\n```\n\n- **while和for语句使用拖尾的else子句**：\n```\nfor ... :\n  ...\n  ...\nelse ...   #注意这个else是与for对齐的\n```\n这种写法的else子句块会在循环 **正常终止时执行**。意思就是，如果循环中的break语句生效而导致的循环终止，是不会触发这个else子句的执行的。因此这种写法可以 **优雅地判断一个循环是正常结束还是break掉了**。\n\n- 在循环中使用print()输出时，注意Print之后是否正确地结束循环或者进入下一个输出，否则可能出现重复输出大量重复数据的可能。\n\n- 求两个数的最大公约数(辗转相除法):\n```\na,b = eval(input(\"请输入两个整数: \"))\nif a > b : a,b = b,a   #Python中可以简便地交换两个变量的值\nr = a % b\nwhile r != 0\n  a,b = b,r\n  r = a % b\nprint(\"最大公约数是：\",b)\nprint()\n```\n\n- 输出[100,1000]以内的所有素数\n```\nimport math\nn = 0\nfor m in range(101,1000,2)    #直接去掉100和1000，这两个肯定不是素数\n  i,j = 2, int(math.sqrt(m))\n  while i <= j:\n    if not(m % j):      #如果 m % j == 0 就是找到因数了，直接退出这一次循环，进入下一个循环\n      break\n    else:\n      i = i + 1\n  else:\n    print(m, end = \" \")\n    n += 1\n    if n % 10 == 0: print(\"\\n\")    #每输出10个数就换行\nprint()\n```\n\n## 函数\n---\n\n### 函数定义的格式\n```\ndef 函数名([参数1,参数2,参数3...]):   #参数没有参数类型，如果要设置参数的默认值则要满足从右向左的原则\n\t[函数体]\n\t[return [返回值]] \t\t#没有写return或者直接写return都是返回None\n```\n\n- Python中可以让函数返回一个有多个元素的tuple来实现返回多个值的要求。\n\n\n\n## 一些注意点\n---\n\n- `abs()` 函数的返回值与参数一致，而`fabs()` 的返回值均为浮点型\n\n- Python支持连续的不等式，例如`a > b > c` 等价于 `a > b && b > c`\n\n<br>\n\n> 最后更新于2018.4.28\n","slug":"2018-04-06-Python-learning","published":1,"updated":"2018-09-03T13:25:10.821Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j45000a1m0oydwqvu8e","content":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<ul>\n<li><p><strong>Python语句不需要分号分割，但是Python各语句严格按照缩进对其方式运行</strong></p>\n</li>\n<li><p>与C++一样，可以将一些非空，非零的值作为bool值的真，其余的为假</p>\n</li>\n<li><p>Python中以 <code>#</code>作为注释的开始，多行注释可以用三引号对。</p>\n</li>\n</ul>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><hr>\n<ul>\n<li><p>Python推荐使用jetbrain公司的pycharm</p>\n</li>\n<li><p>Python可以直接使用自带的IDE逐句执行，方便测试</p>\n</li>\n</ul>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><hr>\n<ul>\n<li><p><strong>Python中不需要声明变量类型，编译器会根据赋值自动判别，但是作为程序的编写者，我们需要清楚某个变量究竟是什么类型的</strong></p>\n</li>\n<li><p>Python中单独的下划线是特殊的变量，表示上一次运算的结果。</p>\n</li>\n</ul>\n<h3 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h3><ul>\n<li><p>标准输出格式： <code>print([输出1，输出2,....,输出n][,sep = 分隔符][,end = 结束符])</code></p>\n<blockquote>\n<p>默认以空格分割，换行符结尾</p>\n</blockquote>\n</li>\n<li><p>各个输出之间以逗号间隔</p>\n</li>\n<li><p><code>print()</code>函数不写参数即默认输出一个空行。在一批数据输出结束后，好的编程习惯是在末尾加上一个<code>print()</code>，使得输出美观。</p>\n</li>\n<li><p>Python的输出可以有运算在里面，例如：<code>print(5 * &#39;*&#39;)</code> 则会打印出 <code>*****</code></p>\n</li>\n<li><p>在输出字符串时，可以在字符串的引号前加一个 <code>r</code> 使得转义字符 <code>\\</code> 失效。</p>\n</li>\n</ul>\n<h3 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h3><ul>\n<li><p>相比较于java，Python的输入可以说是非常灵活而且简便了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = input()   #若调用此函数，就算输入的是数字，a的数据类型仍然为str，Python默认将命令行读入的数据作为str类型，因为str是万能的~</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>但是，对于如下的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a =eval(input())    #eval() 函数用来执行一个字符串表达式，并返回表达式的值.例如 eval(&apos;2 * 3&apos;)返回 6</span><br><span class=\"line\">#此时只能输入数字，且a是整型还是浮点型由输入数据的特征决定</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果想要同时为多个变量赋值，则只能使用<code>eval()</code>函数了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x,y = eval(input())  #输入时以逗号间隔</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于eval()函数的使用，一定要确保参数去掉引号之后的值是有意义的</p>\n</li>\n</ul>\n<h2 id=\"一些数据类型\"><a href=\"#一些数据类型\" class=\"headerlink\" title=\"一些数据类型\"></a>一些数据类型</h2><h3 id=\"综述一些注意点\"><a href=\"#综述一些注意点\" class=\"headerlink\" title=\"综述一些注意点\"></a>综述一些注意点</h3><ul>\n<li><p>序列的概念：序列是一个排序的项目 <strong>容器</strong>，按 <strong>非负整数索引</strong>。Python提供的内置序列包包括字符串，元组和列表。(序列就是可以通过索引或者切片访问的容器)</p>\n</li>\n<li><p>所有的序列都是可以迭代的，即可以作为循环的迭代器。</p>\n</li>\n<li><p>内置函数<code>len()</code>可以将任意一个容器作为参数，并返回该容器中元素的数量</p>\n</li>\n<li><p>内置函数<code>min()</code>和<code>max()</code>以一个可以比较的非空容器作为参数，返回其最小最大值。(如果给的参数不止一个，则返回最大或最小的 <strong>参数</strong>)</p>\n</li>\n<li><p>对于字典使用<code>min()</code>和<code>max()</code>则会返回字典最大或最小的 <strong>键</strong>。</p>\n</li>\n<li><p>关键字 <code>in</code> 可以检查某个元素是否在一个容器中。例如<code>k in D</code>(D是一个字典)则检查k是不是D当中的一个关键字。</p>\n</li>\n<li><p><code>reversed(seq)</code>函数： seq代表一个可迭代对象，比如列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; a = [1,2,3,4,5]</span><br><span class=\"line\">&gt;&gt;&gt; b = reversed(a)  #此时b为一个迭代器</span><br><span class=\"line\">&gt;&gt;&gt; b1 = list(b)    #将这个迭代器转化为列表</span><br><span class=\"line\">&gt;&gt;&gt; b1</span><br><span class=\"line\">&gt;&gt;&gt; [5,4,3,2,1]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>sum()</code>函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(seq, start = m)   #sum()有两个参数，第二个为可选参数</span><br><span class=\"line\"># 返回可迭代对象中的所有项目的和再加上start的值</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"一些基础数据类型的注意点\"><a href=\"#一些基础数据类型的注意点\" class=\"headerlink\" title=\"一些基础数据类型的注意点\"></a>一些基础数据类型的注意点</h3><ul>\n<li><p>输入一个数，获取其各个位的数值的方法：<strong>注意Python的整除符号与别的编程语言不同</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设 x = 123</span><br><span class=\"line\">个位  = x % 10</span><br><span class=\"line\">十位  = x // 10 % 10   (注意，Python与其他编程语言的整除符号不同，比如C++就是 &apos;/&apos; 即表示整除，而Python为 &apos;//&apos;)</span><br><span class=\"line\">百位 = x //100 % 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>复数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = complex(2,3)</span><br><span class=\"line\">b = 1 + 2j</span><br><span class=\"line\">c = 3 - 5j</span><br><span class=\"line\">#a,b,c都是复数</span><br><span class=\"line\">#要获取复数的实部和虚部，可使用例如：a.real(a的实部), a.imag(a的虚部)，结果都是浮点型</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>45e15</code>表示45*10^15，这是科学计数法的写法</p>\n</li>\n<li><p>要判断两个浮点数是否相等，如果不确定精度的情况下，最好不要使用<code>==</code>来判断。因为可能存在看起来一样的数实际上因为精度不同而被判定为不等。解决的方法是<code>abs(x - y) &lt; 1.0e-15</code>，即是用两数之差的绝对值小于一个很小的数，即可判断两数近似相等。</p>\n</li>\n<li><p>关于Python中的bool类型，与C++类似，非零数或非空容器为真，0，None和空容器为假</p>\n</li>\n</ul>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><blockquote>\n<p>Python中list里的元素允许是不同的数据类型，这一点完全打破了C和C++体系的传统，所以平常编写程序不推荐这样做。list中也允许某个元素是list或者元组什么的。</p>\n</blockquote>\n<ul>\n<li><p>例： <code>classmates = [&quot;Mike&quot;,&quot;Davaid&quot;]</code></p>\n</li>\n<li><p><code>len()</code>函数可以获得list中的元素个数</p>\n</li>\n<li><p>与其他编程语言不同的是，Python的list下标允许负数的index，例如： <code>classmates[-1]</code>就表示这个list的最后一个元素，以此类推。</p>\n</li>\n<li><p><code>append()</code>方法：在list末尾末尾添加元素：<code>classmates.append(&quot;Alex&quot;)</code></p>\n</li>\n<li><p>把元素插入到指定的位置，比如索引号为1的位置：<code>classmates.insert(1, &#39;Jack&#39;)</code> 这样Jack的位置索引即为1，原来索引为1的元素及后面的元素依次后移。</p>\n</li>\n<li><p>删除list末尾的元素，使用<code>.pop()</code>方法，要删除指定位置的元素，使用<code>.pop(i)</code>的方法，i为元素的索引。</p>\n</li>\n</ul>\n<h3 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h3><ul>\n<li><p>元组与；list非常类似，但是tuple一经初始化其内容便不允许修改，不允许插入和删除等操作。</p>\n</li>\n<li><p>元组一般用来保存那些不允许修改的数据以保障安全。</p>\n</li>\n<li><p>但是如果tuple中某个元素是list时，这个list中的元素还是可以修改的。</p>\n</li>\n</ul>\n<h3 id=\"disk\"><a href=\"#disk\" class=\"headerlink\" title=\"disk\"></a>disk</h3><blockquote>\n<p>disk（字典）是一种键-值对类型的数据结构，在其他语言中会被称为map。dict的key必须为不可变的量</p>\n</blockquote>\n<blockquote>\n<p>注意，Python中的dick类型是以hash方式存储的，读取速度非常快。</p>\n</blockquote>\n<ul>\n<li><p>将数据添加进dick的方式，除了初始化时设定之外，还可以直接给一个键赋值的方式添加，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;&apos;A&apos;: 95, &apos;B&apos;: 75, &apos;C&apos;: 85&#125; #初始化添加元素</span><br><span class=\"line\">d[&apos;E&apos;] = 100   #直接赋值添加元素</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断一个key是否存在的方法：</p>\n</li>\n</ul>\n<ol>\n<li><code>&quot;Thomas&quot; in d</code>        #若不存在会返回false</li>\n<li><code>d.get(&quot;Thomas&quot;)</code>  #若不存在返回null</li>\n<li><code>d.get(&quot;Thomas&quot;,-1)</code>  #自己指定返回的值</li>\n</ol>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><blockquote>\n<p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>\n</blockquote>\n<ul>\n<li><p>通过<code>.add(key)</code>的方法添加元素。</p>\n</li>\n<li><p>通过<code>.remove(key)</code>的方法删除元素。</p>\n</li>\n<li><p>符号 <code>&amp;</code> 和 <code>|</code> 分别表示集合的交和并</p>\n</li>\n<li><p>list的简单的去重：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; a = [1,2,2,3,4,5,5,6,1]</span><br><span class=\"line\">&gt;&gt;&gt; b= set(a)</span><br><span class=\"line\">&gt;&gt;&gt; b</span><br><span class=\"line\">&gt;&gt;&gt;&#123;1,2,3,4,5,6&#125;</span><br><span class=\"line\">&gt;&gt;&gt;a =list(b)</span><br><span class=\"line\">&gt;&gt;&gt;a</span><br><span class=\"line\">&gt;&gt;&gt;[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h2><ul>\n<li><p>Python的if判断语句的判断条件部分不需要用括号括起来，这与其他的大多数语言均不同</p>\n</li>\n<li><p>格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if &lt;条件判断1&gt;:</span><br><span class=\"line\">    &lt;执行1&gt;</span><br><span class=\"line\">elif &lt;条件判断2&gt;:</span><br><span class=\"line\">    &lt;执行2&gt;</span><br><span class=\"line\">elif &lt;条件判断3&gt;:</span><br><span class=\"line\">    &lt;执行3&gt;</span><br><span class=\"line\">else:</span><br><span class=\"line\">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age = 20</span><br><span class=\"line\">if age &gt;= 6 and age &lt;= 30:  #多条件判断用 and 链接</span><br><span class=\"line\">    print(&apos;teenager&apos;)</span><br><span class=\"line\">elif not (age &gt;= 18):     #not相当于 非，后面的内容用括号括起来</span><br><span class=\"line\">    print(&apos;adult&apos;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&apos;kid&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>与input结合（涉及数据类型转换）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = input(&apos;birth: &apos;)</span><br><span class=\"line\">birth = int(s) \t\t#如果没有这句转换会报错，因为input进来的是str，不能直接和int比较，因此要先转换为int再比较。</span><br><span class=\"line\">#但是如果此处的输入不是一个数值类型，int函数无法强制转化便会报错。</span><br><span class=\"line\">if birth &lt; 2000:</span><br><span class=\"line\">    print(&apos;00前&apos;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&apos;00后&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>利用运算符优先级： z = x if x &gt; y else y</p>\n</li>\n</ul>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><ul>\n<li><p>例（求和）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for x in [1,2,3,4,5,6]:</span><br><span class=\"line\">\tsum = sum + x</span><br><span class=\"line\">print(sum)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>range()</code>函数： 生成从0 - <strong>输入数值-1</strong> 的一个迭代器，可用作循环条件。例<code>list(range(5))</code>的结果为 <code>[0,1,2,3,4]</code></p>\n</li>\n</ul>\n<ul>\n<li><p>例求 1- 100 的和：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum = 0</span><br><span class=\"line\">for x in range(101):</span><br><span class=\"line\">    sum = sum + x</span><br><span class=\"line\">print(sum)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>while循环示例：(素数的判断)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import math</span><br><span class=\"line\">m = int(input(&quot;Please enter a num: &quot;))  #待判断的数 m</span><br><span class=\"line\">i,j = 2, int(math.sqrt(m))       #只需要计算 2 到 根号m 范围内是否有m的因数即可，后面的计算均为重复计算</span><br><span class=\"line\">flag = 1                        #素数标志</span><br><span class=\"line\">while i &lt; j and flag == 1:</span><br><span class=\"line\">  if m % 1 == 0</span><br><span class=\"line\">    flag = 0                    #不是素数的标志</span><br><span class=\"line\">  i += 1</span><br><span class=\"line\">if flag and m &gt; 1:              #素数必须大于1</span><br><span class=\"line\">  print(m, &quot;是素数&quot;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">  print(m, &quot;不是素数&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>while和for语句使用拖尾的else子句</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for ... :</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  ...</span><br><span class=\"line\">else ...   #注意这个else是与for对齐的</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这种写法的else子句块会在循环 <strong>正常终止时执行</strong>。意思就是，如果循环中的break语句生效而导致的循环终止，是不会触发这个else子句的执行的。因此这种写法可以 <strong>优雅地判断一个循环是正常结束还是break掉了</strong>。</p>\n<ul>\n<li><p>在循环中使用print()输出时，注意Print之后是否正确地结束循环或者进入下一个输出，否则可能出现重复输出大量重复数据的可能。</p>\n</li>\n<li><p>求两个数的最大公约数(辗转相除法):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a,b = eval(input(&quot;请输入两个整数: &quot;))</span><br><span class=\"line\">if a &gt; b : a,b = b,a   #Python中可以简便地交换两个变量的值</span><br><span class=\"line\">r = a % b</span><br><span class=\"line\">while r != 0</span><br><span class=\"line\">  a,b = b,r</span><br><span class=\"line\">  r = a % b</span><br><span class=\"line\">print(&quot;最大公约数是：&quot;,b)</span><br><span class=\"line\">print()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输出[100,1000]以内的所有素数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import math</span><br><span class=\"line\">n = 0</span><br><span class=\"line\">for m in range(101,1000,2)    #直接去掉100和1000，这两个肯定不是素数</span><br><span class=\"line\">  i,j = 2, int(math.sqrt(m))</span><br><span class=\"line\">  while i &lt;= j:</span><br><span class=\"line\">    if not(m % j):      #如果 m % j == 0 就是找到因数了，直接退出这一次循环，进入下一个循环</span><br><span class=\"line\">      break</span><br><span class=\"line\">    else:</span><br><span class=\"line\">      i = i + 1</span><br><span class=\"line\">  else:</span><br><span class=\"line\">    print(m, end = &quot; &quot;)</span><br><span class=\"line\">    n += 1</span><br><span class=\"line\">    if n % 10 == 0: print(&quot;\\n&quot;)    #每输出10个数就换行</span><br><span class=\"line\">print()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><hr>\n<h3 id=\"函数定义的格式\"><a href=\"#函数定义的格式\" class=\"headerlink\" title=\"函数定义的格式\"></a>函数定义的格式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def 函数名([参数1,参数2,参数3...]):   #参数没有参数类型，如果要设置参数的默认值则要满足从右向左的原则</span><br><span class=\"line\">\t[函数体]</span><br><span class=\"line\">\t[return [返回值]] \t\t#没有写return或者直接写return都是返回None</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Python中可以让函数返回一个有多个元素的tuple来实现返回多个值的要求。</li>\n</ul>\n<h2 id=\"一些注意点\"><a href=\"#一些注意点\" class=\"headerlink\" title=\"一些注意点\"></a>一些注意点</h2><hr>\n<ul>\n<li><p><code>abs()</code> 函数的返回值与参数一致，而<code>fabs()</code> 的返回值均为浮点型</p>\n</li>\n<li><p>Python支持连续的不等式，例如<code>a &gt; b &gt; c</code> 等价于 <code>a &gt; b &amp;&amp; b &gt; c</code></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.28</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<ul>\n<li><p><strong>Python语句不需要分号分割，但是Python各语句严格按照缩进对其方式运行</strong></p>\n</li>\n<li><p>与C++一样，可以将一些非空，非零的值作为bool值的真，其余的为假</p>\n</li>\n<li><p>Python中以 <code>#</code>作为注释的开始，多行注释可以用三引号对。</p>\n</li>\n</ul>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><hr>\n<ul>\n<li><p>Python推荐使用jetbrain公司的pycharm</p>\n</li>\n<li><p>Python可以直接使用自带的IDE逐句执行，方便测试</p>\n</li>\n</ul>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><hr>\n<ul>\n<li><p><strong>Python中不需要声明变量类型，编译器会根据赋值自动判别，但是作为程序的编写者，我们需要清楚某个变量究竟是什么类型的</strong></p>\n</li>\n<li><p>Python中单独的下划线是特殊的变量，表示上一次运算的结果。</p>\n</li>\n</ul>\n<h3 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h3><ul>\n<li><p>标准输出格式： <code>print([输出1，输出2,....,输出n][,sep = 分隔符][,end = 结束符])</code></p>\n<blockquote>\n<p>默认以空格分割，换行符结尾</p>\n</blockquote>\n</li>\n<li><p>各个输出之间以逗号间隔</p>\n</li>\n<li><p><code>print()</code>函数不写参数即默认输出一个空行。在一批数据输出结束后，好的编程习惯是在末尾加上一个<code>print()</code>，使得输出美观。</p>\n</li>\n<li><p>Python的输出可以有运算在里面，例如：<code>print(5 * &#39;*&#39;)</code> 则会打印出 <code>*****</code></p>\n</li>\n<li><p>在输出字符串时，可以在字符串的引号前加一个 <code>r</code> 使得转义字符 <code>\\</code> 失效。</p>\n</li>\n</ul>\n<h3 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h3><ul>\n<li><p>相比较于java，Python的输入可以说是非常灵活而且简便了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = input()   #若调用此函数，就算输入的是数字，a的数据类型仍然为str，Python默认将命令行读入的数据作为str类型，因为str是万能的~</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>但是，对于如下的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a =eval(input())    #eval() 函数用来执行一个字符串表达式，并返回表达式的值.例如 eval(&apos;2 * 3&apos;)返回 6</span><br><span class=\"line\">#此时只能输入数字，且a是整型还是浮点型由输入数据的特征决定</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果想要同时为多个变量赋值，则只能使用<code>eval()</code>函数了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x,y = eval(input())  #输入时以逗号间隔</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于eval()函数的使用，一定要确保参数去掉引号之后的值是有意义的</p>\n</li>\n</ul>\n<h2 id=\"一些数据类型\"><a href=\"#一些数据类型\" class=\"headerlink\" title=\"一些数据类型\"></a>一些数据类型</h2><h3 id=\"综述一些注意点\"><a href=\"#综述一些注意点\" class=\"headerlink\" title=\"综述一些注意点\"></a>综述一些注意点</h3><ul>\n<li><p>序列的概念：序列是一个排序的项目 <strong>容器</strong>，按 <strong>非负整数索引</strong>。Python提供的内置序列包包括字符串，元组和列表。(序列就是可以通过索引或者切片访问的容器)</p>\n</li>\n<li><p>所有的序列都是可以迭代的，即可以作为循环的迭代器。</p>\n</li>\n<li><p>内置函数<code>len()</code>可以将任意一个容器作为参数，并返回该容器中元素的数量</p>\n</li>\n<li><p>内置函数<code>min()</code>和<code>max()</code>以一个可以比较的非空容器作为参数，返回其最小最大值。(如果给的参数不止一个，则返回最大或最小的 <strong>参数</strong>)</p>\n</li>\n<li><p>对于字典使用<code>min()</code>和<code>max()</code>则会返回字典最大或最小的 <strong>键</strong>。</p>\n</li>\n<li><p>关键字 <code>in</code> 可以检查某个元素是否在一个容器中。例如<code>k in D</code>(D是一个字典)则检查k是不是D当中的一个关键字。</p>\n</li>\n<li><p><code>reversed(seq)</code>函数： seq代表一个可迭代对象，比如列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; a = [1,2,3,4,5]</span><br><span class=\"line\">&gt;&gt;&gt; b = reversed(a)  #此时b为一个迭代器</span><br><span class=\"line\">&gt;&gt;&gt; b1 = list(b)    #将这个迭代器转化为列表</span><br><span class=\"line\">&gt;&gt;&gt; b1</span><br><span class=\"line\">&gt;&gt;&gt; [5,4,3,2,1]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>sum()</code>函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum(seq, start = m)   #sum()有两个参数，第二个为可选参数</span><br><span class=\"line\"># 返回可迭代对象中的所有项目的和再加上start的值</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"一些基础数据类型的注意点\"><a href=\"#一些基础数据类型的注意点\" class=\"headerlink\" title=\"一些基础数据类型的注意点\"></a>一些基础数据类型的注意点</h3><ul>\n<li><p>输入一个数，获取其各个位的数值的方法：<strong>注意Python的整除符号与别的编程语言不同</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设 x = 123</span><br><span class=\"line\">个位  = x % 10</span><br><span class=\"line\">十位  = x // 10 % 10   (注意，Python与其他编程语言的整除符号不同，比如C++就是 &apos;/&apos; 即表示整除，而Python为 &apos;//&apos;)</span><br><span class=\"line\">百位 = x //100 % 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>复数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = complex(2,3)</span><br><span class=\"line\">b = 1 + 2j</span><br><span class=\"line\">c = 3 - 5j</span><br><span class=\"line\">#a,b,c都是复数</span><br><span class=\"line\">#要获取复数的实部和虚部，可使用例如：a.real(a的实部), a.imag(a的虚部)，结果都是浮点型</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>45e15</code>表示45*10^15，这是科学计数法的写法</p>\n</li>\n<li><p>要判断两个浮点数是否相等，如果不确定精度的情况下，最好不要使用<code>==</code>来判断。因为可能存在看起来一样的数实际上因为精度不同而被判定为不等。解决的方法是<code>abs(x - y) &lt; 1.0e-15</code>，即是用两数之差的绝对值小于一个很小的数，即可判断两数近似相等。</p>\n</li>\n<li><p>关于Python中的bool类型，与C++类似，非零数或非空容器为真，0，None和空容器为假</p>\n</li>\n</ul>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><blockquote>\n<p>Python中list里的元素允许是不同的数据类型，这一点完全打破了C和C++体系的传统，所以平常编写程序不推荐这样做。list中也允许某个元素是list或者元组什么的。</p>\n</blockquote>\n<ul>\n<li><p>例： <code>classmates = [&quot;Mike&quot;,&quot;Davaid&quot;]</code></p>\n</li>\n<li><p><code>len()</code>函数可以获得list中的元素个数</p>\n</li>\n<li><p>与其他编程语言不同的是，Python的list下标允许负数的index，例如： <code>classmates[-1]</code>就表示这个list的最后一个元素，以此类推。</p>\n</li>\n<li><p><code>append()</code>方法：在list末尾末尾添加元素：<code>classmates.append(&quot;Alex&quot;)</code></p>\n</li>\n<li><p>把元素插入到指定的位置，比如索引号为1的位置：<code>classmates.insert(1, &#39;Jack&#39;)</code> 这样Jack的位置索引即为1，原来索引为1的元素及后面的元素依次后移。</p>\n</li>\n<li><p>删除list末尾的元素，使用<code>.pop()</code>方法，要删除指定位置的元素，使用<code>.pop(i)</code>的方法，i为元素的索引。</p>\n</li>\n</ul>\n<h3 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h3><ul>\n<li><p>元组与；list非常类似，但是tuple一经初始化其内容便不允许修改，不允许插入和删除等操作。</p>\n</li>\n<li><p>元组一般用来保存那些不允许修改的数据以保障安全。</p>\n</li>\n<li><p>但是如果tuple中某个元素是list时，这个list中的元素还是可以修改的。</p>\n</li>\n</ul>\n<h3 id=\"disk\"><a href=\"#disk\" class=\"headerlink\" title=\"disk\"></a>disk</h3><blockquote>\n<p>disk（字典）是一种键-值对类型的数据结构，在其他语言中会被称为map。dict的key必须为不可变的量</p>\n</blockquote>\n<blockquote>\n<p>注意，Python中的dick类型是以hash方式存储的，读取速度非常快。</p>\n</blockquote>\n<ul>\n<li><p>将数据添加进dick的方式，除了初始化时设定之外，还可以直接给一个键赋值的方式添加，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;&apos;A&apos;: 95, &apos;B&apos;: 75, &apos;C&apos;: 85&#125; #初始化添加元素</span><br><span class=\"line\">d[&apos;E&apos;] = 100   #直接赋值添加元素</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断一个key是否存在的方法：</p>\n</li>\n</ul>\n<ol>\n<li><code>&quot;Thomas&quot; in d</code>        #若不存在会返回false</li>\n<li><code>d.get(&quot;Thomas&quot;)</code>  #若不存在返回null</li>\n<li><code>d.get(&quot;Thomas&quot;,-1)</code>  #自己指定返回的值</li>\n</ol>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><blockquote>\n<p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>\n</blockquote>\n<ul>\n<li><p>通过<code>.add(key)</code>的方法添加元素。</p>\n</li>\n<li><p>通过<code>.remove(key)</code>的方法删除元素。</p>\n</li>\n<li><p>符号 <code>&amp;</code> 和 <code>|</code> 分别表示集合的交和并</p>\n</li>\n<li><p>list的简单的去重：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; a = [1,2,2,3,4,5,5,6,1]</span><br><span class=\"line\">&gt;&gt;&gt; b= set(a)</span><br><span class=\"line\">&gt;&gt;&gt; b</span><br><span class=\"line\">&gt;&gt;&gt;&#123;1,2,3,4,5,6&#125;</span><br><span class=\"line\">&gt;&gt;&gt;a =list(b)</span><br><span class=\"line\">&gt;&gt;&gt;a</span><br><span class=\"line\">&gt;&gt;&gt;[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h2><ul>\n<li><p>Python的if判断语句的判断条件部分不需要用括号括起来，这与其他的大多数语言均不同</p>\n</li>\n<li><p>格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if &lt;条件判断1&gt;:</span><br><span class=\"line\">    &lt;执行1&gt;</span><br><span class=\"line\">elif &lt;条件判断2&gt;:</span><br><span class=\"line\">    &lt;执行2&gt;</span><br><span class=\"line\">elif &lt;条件判断3&gt;:</span><br><span class=\"line\">    &lt;执行3&gt;</span><br><span class=\"line\">else:</span><br><span class=\"line\">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age = 20</span><br><span class=\"line\">if age &gt;= 6 and age &lt;= 30:  #多条件判断用 and 链接</span><br><span class=\"line\">    print(&apos;teenager&apos;)</span><br><span class=\"line\">elif not (age &gt;= 18):     #not相当于 非，后面的内容用括号括起来</span><br><span class=\"line\">    print(&apos;adult&apos;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&apos;kid&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>与input结合（涉及数据类型转换）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = input(&apos;birth: &apos;)</span><br><span class=\"line\">birth = int(s) \t\t#如果没有这句转换会报错，因为input进来的是str，不能直接和int比较，因此要先转换为int再比较。</span><br><span class=\"line\">#但是如果此处的输入不是一个数值类型，int函数无法强制转化便会报错。</span><br><span class=\"line\">if birth &lt; 2000:</span><br><span class=\"line\">    print(&apos;00前&apos;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&apos;00后&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>利用运算符优先级： z = x if x &gt; y else y</p>\n</li>\n</ul>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><ul>\n<li><p>例（求和）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for x in [1,2,3,4,5,6]:</span><br><span class=\"line\">\tsum = sum + x</span><br><span class=\"line\">print(sum)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>range()</code>函数： 生成从0 - <strong>输入数值-1</strong> 的一个迭代器，可用作循环条件。例<code>list(range(5))</code>的结果为 <code>[0,1,2,3,4]</code></p>\n</li>\n</ul>\n<ul>\n<li><p>例求 1- 100 的和：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum = 0</span><br><span class=\"line\">for x in range(101):</span><br><span class=\"line\">    sum = sum + x</span><br><span class=\"line\">print(sum)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>while循环示例：(素数的判断)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import math</span><br><span class=\"line\">m = int(input(&quot;Please enter a num: &quot;))  #待判断的数 m</span><br><span class=\"line\">i,j = 2, int(math.sqrt(m))       #只需要计算 2 到 根号m 范围内是否有m的因数即可，后面的计算均为重复计算</span><br><span class=\"line\">flag = 1                        #素数标志</span><br><span class=\"line\">while i &lt; j and flag == 1:</span><br><span class=\"line\">  if m % 1 == 0</span><br><span class=\"line\">    flag = 0                    #不是素数的标志</span><br><span class=\"line\">  i += 1</span><br><span class=\"line\">if flag and m &gt; 1:              #素数必须大于1</span><br><span class=\"line\">  print(m, &quot;是素数&quot;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">  print(m, &quot;不是素数&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>while和for语句使用拖尾的else子句</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for ... :</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  ...</span><br><span class=\"line\">else ...   #注意这个else是与for对齐的</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这种写法的else子句块会在循环 <strong>正常终止时执行</strong>。意思就是，如果循环中的break语句生效而导致的循环终止，是不会触发这个else子句的执行的。因此这种写法可以 <strong>优雅地判断一个循环是正常结束还是break掉了</strong>。</p>\n<ul>\n<li><p>在循环中使用print()输出时，注意Print之后是否正确地结束循环或者进入下一个输出，否则可能出现重复输出大量重复数据的可能。</p>\n</li>\n<li><p>求两个数的最大公约数(辗转相除法):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a,b = eval(input(&quot;请输入两个整数: &quot;))</span><br><span class=\"line\">if a &gt; b : a,b = b,a   #Python中可以简便地交换两个变量的值</span><br><span class=\"line\">r = a % b</span><br><span class=\"line\">while r != 0</span><br><span class=\"line\">  a,b = b,r</span><br><span class=\"line\">  r = a % b</span><br><span class=\"line\">print(&quot;最大公约数是：&quot;,b)</span><br><span class=\"line\">print()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输出[100,1000]以内的所有素数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import math</span><br><span class=\"line\">n = 0</span><br><span class=\"line\">for m in range(101,1000,2)    #直接去掉100和1000，这两个肯定不是素数</span><br><span class=\"line\">  i,j = 2, int(math.sqrt(m))</span><br><span class=\"line\">  while i &lt;= j:</span><br><span class=\"line\">    if not(m % j):      #如果 m % j == 0 就是找到因数了，直接退出这一次循环，进入下一个循环</span><br><span class=\"line\">      break</span><br><span class=\"line\">    else:</span><br><span class=\"line\">      i = i + 1</span><br><span class=\"line\">  else:</span><br><span class=\"line\">    print(m, end = &quot; &quot;)</span><br><span class=\"line\">    n += 1</span><br><span class=\"line\">    if n % 10 == 0: print(&quot;\\n&quot;)    #每输出10个数就换行</span><br><span class=\"line\">print()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><hr>\n<h3 id=\"函数定义的格式\"><a href=\"#函数定义的格式\" class=\"headerlink\" title=\"函数定义的格式\"></a>函数定义的格式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def 函数名([参数1,参数2,参数3...]):   #参数没有参数类型，如果要设置参数的默认值则要满足从右向左的原则</span><br><span class=\"line\">\t[函数体]</span><br><span class=\"line\">\t[return [返回值]] \t\t#没有写return或者直接写return都是返回None</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Python中可以让函数返回一个有多个元素的tuple来实现返回多个值的要求。</li>\n</ul>\n<h2 id=\"一些注意点\"><a href=\"#一些注意点\" class=\"headerlink\" title=\"一些注意点\"></a>一些注意点</h2><hr>\n<ul>\n<li><p><code>abs()</code> 函数的返回值与参数一致，而<code>fabs()</code> 的返回值均为浮点型</p>\n</li>\n<li><p>Python支持连续的不等式，例如<code>a &gt; b &gt; c</code> 等价于 <code>a &gt; b &amp;&amp; b &gt; c</code></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.28</p>\n</blockquote>\n"},{"layout":"post","title":"Java学习笔记——基础","date":"2018-04-06T08:47:00.000Z","_content":"\n> 不适合人类阅读的学习笔记  \n\n## Java编译环境\n\n---\n\n编译环境首选JetBrian的[Intellij IDEA](https://www.jetbrains.com/idea/)，虽然几乎所有的教材都清一色的使用eclipse，但是jetBrian的社区版Intellij IDEA已经满足了我们的需求，其无与伦比的代码补全功能，清爽的界面会让人眼前一亮。专业版只有公司里才可能会用到其中的一些功能，所以我们也不用担心。\n\n- Ultimate版本免费获取详见——[Intellij IDEA Ultimate版本使用](https://fleschier.github.io/2018/05/jetbrains/)\n\n- 使用intellij IDEA 之前需要配置一系列设置。\n  1. 在打开项目之前的那个主界面，在设置里，systemsettings里把reopen previous project勾掉\n  2. 在project structure里把lib里的东西添加一下(添加需要用到的编程语言的library)，以及设置默认的sdk/jdk。(在打开的项目里设置的仅仅对本项目有效)\n\n  - ctrl + alt + s 快速打开设置界面。\n\n## 基本语法\n---\n\n> java与C++一样，需要用分号来分割句子\n\n### 第一个JAVA程序：Helloworld\n\n- 示例\n```\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\"); // 打印 Hello World\n    }\n}\n```\n\n### 编写Java程序时注意点：\n\n- 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。\n\n- 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。\n\n- 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。\n源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。\n\n- 主方法入口：所有的Java 程序由`public static void main(String[] args)`方法开始执行。\n\n- java的通配符与C++一样，都是`*`\n\n- **Java与C++不同的地方是：Java中的整数，浮点数不能与布尔值相互转换，当然也不能用0或非0的的整数代替true或者false。**\n\n### Java数据默认值\n\n- 八大基本数据类型的默认值：\n\n| 数据类型   | 默认值          |\n| --------  |---------       |\n| boolean   |     false       |\n| char      | '/uoooo'(null)  |\n| byte      |         (byte)0 |\n| short     |       (short)0  |\n| int       |           0     |\n| long      |         0L      |\n| float     |          0.0f   |\n| double    |       0.0d      |\n\n### Java修饰符\n\n- 像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：\n\n- 访问控制修饰符 : default, public , protected, private\n\n- 非访问控制修饰符 : final, abstract, strictfp\n\n### Java枚举\n\n- 枚举限制变量只能是预先设定好的值,使用枚举可以减少代码中的bug\n```\nclass ENUM_class{\n\tenum Test{Small, Medium, Large}\n   Test size;\n}\npublic class ENUM_class_Test{\n\tpublic static void main(String[] args){\n\t\tENUM_class tst = new ENUM_class();\n\t\ttst.size = ENUM_class.Test.Small;\n\t}\n}\n```\n### Java的三目运算符\n\n- 格式：逻辑表达式 ? 值1 : 值2\n\n- 执行过程：若逻辑值表达式为true，就取值1，否则取值2\n\n- 例：\n```\nint x =1,y =2;\nx<y ? System.out.println(\"x<y\"):System.out.println(\"x>y\");\n```\n- 注意，此三目运算符不是一个完整的式子，一般是用作赋值。\n\n### Java注释\n\n- Java注释与C++一致\n\n\n## Java的输入\n>Java的输入比起C++和Python要麻烦很多\n\n---\n\n### 方法一：\n```\nimport java.io.*   //引入java.io包的类\n...\n...\nInputStreamReader in = new InputStreamReader(System.in);\nBufferedReader br = new BufferedReader(in);\nSystem.out.print(\"Please enter a num:\");\nString s = br.readLine(); //从键盘读取一行字符到s中\nfloat num;\nnum = Float.parseFloat(s); //将字符型转换成float型\nSystem.out.println();\n...\n```\n### 方法二：\n#### 通过Scannner类\n\n- 例子：\n```\nimport java.util.*\n...\nfloat score;\nScanner sn = new Scanner(System.in);\nSystem.out.println(\"Please enter a num:\");\nscore = sn.nextFloat();\nSystem.out.println();\n```\n\n- *scan在读取多行数据时会遇到的问题：*\n```\nScanner scan = new Scanner(System.in)\nint num  = scan.nextInt();  //这句会正确执行\nDouble d = scan.nextDouble(); //这句也会正确执行，即使输入在不同的行上\nString s = scan.nextline();  //这句这样写便会读到一个空串×××××××\n```\n\n- 原因分析：首先，Scanner是一个扫描器，它扫描数据都是去内存中一块缓冲区中进行扫描并读入数据的，而我们在控制台中输入的数据也都是被先存入缓冲区中等待扫描器的扫描读取。这个扫描器在扫描过程中判断停止的依据就是“空白符”，空格啊，回车啊什么的都算做是空白符。\n- nextInt()方法在扫描到空白符的时候会将前面的数据读取走，但会丢下空白符“\\r”在缓冲区中，但是，nextLine()方法在扫描的时候会将扫描到的空白符一同清理掉。\n- 了解了这两个方法特性和区别，就知道了上边的代码究竟是怎么回事，以及知道了解决的方法。像是上边的代码nextInt()方法之后在缓冲区中留下了“\\r”，然后nextLine()方法再去缓冲区找数据的时候首先看到了“\\r”，然后就把这个“\\r”扫描接收进来，并在缓冲区内清除掉。其实，nextLine()方法是执行过的，并没有不执行。\n\n- 解决方案：\n 在调用nextline()之前先调用一次nextline()将那个换行符读取掉\n\n 在读取Int的时候就调用nextline()方法，再用parseInt()转化为Int\n\n### 方法三\n\n- 这里需要import java.io.IOException; //否则会报错\n\n#### 读取下一个字符：\n\n```\nimport java.io.IOException\nclass test{\n    public static void main(String[] args) throws IOException{\n      char c = (char) System.in.read();\n  }\n}\n```\n**注意这里需要类型转换，默认为int类型，即读到的是字符的ASCII码。**\n\n#### 将一串字符读入byte数组\n\n```\nimport java.io.IOException;\nclass test {\n     public static void main(String[] args) throws IOException{\n         byte[] input = new byte[5];  //创建一个byte数组来读取一串输入\n         System.in.read(input);  //将输入存入byte数组中\n         System.out.println(input[1]); //这里输出的仍然是int类型，即ASCII码\n     }\n }\n```\n\n### 图形界面输入方式\n\n```\nimport javax.swing.* //导入javax,swing包中的类\n...\nString str;\nfloat score;\nstr = JOptionPane.showInputDialog(\"please enter a num:\");\nscore = Float.parseFloat(str);\n...\n```\n\n## 输出\n---\n- 标准输出：`System.out.println();`\n\n- 格式化输出：`System.out.printf();` //格式化输出允许对输出进行规改\n```\n//\"%\"表示进行格式化输出，\"%\"之后的内容为格式的定义。\nSystem.out.printf(\"%f\",d);//\"f\"表示格式化输出浮点数。\nSystem.out.printf(\"%9.2f\",d);//\"9.2\"中的9表示输出的长度，2表示小数点后的位数。\nSystem.out.printf(\"%+9.2f\",d);//\"+\"表示输出的数带正负号。\nSystem.out.printf(\"%-9.4f\",d);//\"-\"表示输出的数左对齐（默认为右对齐）。\nSystem.out.printf(\"%+-9.3f\",d);//\"+-\"表示输出的数带正负号且左对齐。\nSystem.out.printf(\"%d\",i);//\"d\"表示输出十进制整数。\nSystem.out.printf(\"%o\",i);//\"o\"表示输出八进制整数。\nSystem.out.printf(\"%x\",i);//\"d\"表示输出十六进制整数。\nSystem.out.printf(\"%#x\",i);//\"d\"表示输出带有十六进制标志的整数。\nSystem.out.printf(\"%s\",s);//\"d\"表示输出字符串。\nSystem.out.printf(\"输出一个浮点数：%f，一个整数：%d，一个字符串：%s\",d,i,s);\n//可以输出多个变量，注意顺序。\nSystem.out.printf(\"字符串：%2$s，%1$d的十六进制数：%1$#x\",i,s);\n//\"X$\"表示第几个变量。\n```\n\n### 图形界面输出\n\n```\nJOptionPane.showMessageDialog(....)  //具体参数见类库\n```\n\n## 一些注意点\n---\n### 数组\n\n- 数组的声明格式： 数据类型[] 数组名 或者 数据类型 数组名[]\n\n- Java的数组声明只是指明了一个对象引用，并没有为数组元素分配内存空间。**因此声明不能指定数组元素个数**。例如：`int a[10];`是错误的。**如果要声明并创建数组应该采用如下格式 ： 数据类型 数组名[] = new 数据类型[数组长度]**。\n\n- 数组的初始化与C++相同。例：`int a[] = {1,6,8};`  这句相当于`int a = new int[3]; a[0]=1,a[1]=6,a[2]=8;`\n\n- 只进行了声明的数组，它的元素是不能被访问的，只有经过初始化后，才能访问数组的元素。\n\n- 数组的长度的获取：`a.length` 就表示数组a的长度（即a的元素个数）**注意这里的.length是数组的属性（相当于类的尘成员变量）而不是方法，所以a.length()的写法是错误的，他把length当做一个类的方法来调用了**\n\n### 随机数\n\n#### Math.random()\n- `int num =(int)(Math.random() * 11);`  生成一个范围在[0,1)的随机数。\n\n#### java.util.Random\n\n- 例：\n```\nimport Java.util.Random;\nRandom rand = new Random([数值]);\nint randomNum = rand.nextInt() //Random支持的随机值类型包括：boolean, byte, int, long, float, double\nint randomNUM2 = rand.nextInt(100); //表示获取[0,100)范围的随机数\n...\n```\n\n### String类\n\n- String是常量，对一个String的任何修改都会使java创建一个新的String，而原来的会被当做垃圾回收掉\n- 例如：\n```\nString a = \"avc\";\na = \"bfd\";    //则会创建一个新的string，然后将a链向这个string，原先的string会被抛弃掉\n```\n\n\n<br>\n\n> 最后更新于2018.4.9\n","source":"_posts/2018-04-06-Java-learning.md","raw":"---\nlayout:     post\ntitle:      \"Java学习笔记——基础\"\ndate:       2018-04-6 16:47:00\ncategories: Computer Programes\ntags: ๑Java\n---\n\n> 不适合人类阅读的学习笔记  \n\n## Java编译环境\n\n---\n\n编译环境首选JetBrian的[Intellij IDEA](https://www.jetbrains.com/idea/)，虽然几乎所有的教材都清一色的使用eclipse，但是jetBrian的社区版Intellij IDEA已经满足了我们的需求，其无与伦比的代码补全功能，清爽的界面会让人眼前一亮。专业版只有公司里才可能会用到其中的一些功能，所以我们也不用担心。\n\n- Ultimate版本免费获取详见——[Intellij IDEA Ultimate版本使用](https://fleschier.github.io/2018/05/jetbrains/)\n\n- 使用intellij IDEA 之前需要配置一系列设置。\n  1. 在打开项目之前的那个主界面，在设置里，systemsettings里把reopen previous project勾掉\n  2. 在project structure里把lib里的东西添加一下(添加需要用到的编程语言的library)，以及设置默认的sdk/jdk。(在打开的项目里设置的仅仅对本项目有效)\n\n  - ctrl + alt + s 快速打开设置界面。\n\n## 基本语法\n---\n\n> java与C++一样，需要用分号来分割句子\n\n### 第一个JAVA程序：Helloworld\n\n- 示例\n```\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\"); // 打印 Hello World\n    }\n}\n```\n\n### 编写Java程序时注意点：\n\n- 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。\n\n- 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。\n\n- 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。\n源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。\n\n- 主方法入口：所有的Java 程序由`public static void main(String[] args)`方法开始执行。\n\n- java的通配符与C++一样，都是`*`\n\n- **Java与C++不同的地方是：Java中的整数，浮点数不能与布尔值相互转换，当然也不能用0或非0的的整数代替true或者false。**\n\n### Java数据默认值\n\n- 八大基本数据类型的默认值：\n\n| 数据类型   | 默认值          |\n| --------  |---------       |\n| boolean   |     false       |\n| char      | '/uoooo'(null)  |\n| byte      |         (byte)0 |\n| short     |       (short)0  |\n| int       |           0     |\n| long      |         0L      |\n| float     |          0.0f   |\n| double    |       0.0d      |\n\n### Java修饰符\n\n- 像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：\n\n- 访问控制修饰符 : default, public , protected, private\n\n- 非访问控制修饰符 : final, abstract, strictfp\n\n### Java枚举\n\n- 枚举限制变量只能是预先设定好的值,使用枚举可以减少代码中的bug\n```\nclass ENUM_class{\n\tenum Test{Small, Medium, Large}\n   Test size;\n}\npublic class ENUM_class_Test{\n\tpublic static void main(String[] args){\n\t\tENUM_class tst = new ENUM_class();\n\t\ttst.size = ENUM_class.Test.Small;\n\t}\n}\n```\n### Java的三目运算符\n\n- 格式：逻辑表达式 ? 值1 : 值2\n\n- 执行过程：若逻辑值表达式为true，就取值1，否则取值2\n\n- 例：\n```\nint x =1,y =2;\nx<y ? System.out.println(\"x<y\"):System.out.println(\"x>y\");\n```\n- 注意，此三目运算符不是一个完整的式子，一般是用作赋值。\n\n### Java注释\n\n- Java注释与C++一致\n\n\n## Java的输入\n>Java的输入比起C++和Python要麻烦很多\n\n---\n\n### 方法一：\n```\nimport java.io.*   //引入java.io包的类\n...\n...\nInputStreamReader in = new InputStreamReader(System.in);\nBufferedReader br = new BufferedReader(in);\nSystem.out.print(\"Please enter a num:\");\nString s = br.readLine(); //从键盘读取一行字符到s中\nfloat num;\nnum = Float.parseFloat(s); //将字符型转换成float型\nSystem.out.println();\n...\n```\n### 方法二：\n#### 通过Scannner类\n\n- 例子：\n```\nimport java.util.*\n...\nfloat score;\nScanner sn = new Scanner(System.in);\nSystem.out.println(\"Please enter a num:\");\nscore = sn.nextFloat();\nSystem.out.println();\n```\n\n- *scan在读取多行数据时会遇到的问题：*\n```\nScanner scan = new Scanner(System.in)\nint num  = scan.nextInt();  //这句会正确执行\nDouble d = scan.nextDouble(); //这句也会正确执行，即使输入在不同的行上\nString s = scan.nextline();  //这句这样写便会读到一个空串×××××××\n```\n\n- 原因分析：首先，Scanner是一个扫描器，它扫描数据都是去内存中一块缓冲区中进行扫描并读入数据的，而我们在控制台中输入的数据也都是被先存入缓冲区中等待扫描器的扫描读取。这个扫描器在扫描过程中判断停止的依据就是“空白符”，空格啊，回车啊什么的都算做是空白符。\n- nextInt()方法在扫描到空白符的时候会将前面的数据读取走，但会丢下空白符“\\r”在缓冲区中，但是，nextLine()方法在扫描的时候会将扫描到的空白符一同清理掉。\n- 了解了这两个方法特性和区别，就知道了上边的代码究竟是怎么回事，以及知道了解决的方法。像是上边的代码nextInt()方法之后在缓冲区中留下了“\\r”，然后nextLine()方法再去缓冲区找数据的时候首先看到了“\\r”，然后就把这个“\\r”扫描接收进来，并在缓冲区内清除掉。其实，nextLine()方法是执行过的，并没有不执行。\n\n- 解决方案：\n 在调用nextline()之前先调用一次nextline()将那个换行符读取掉\n\n 在读取Int的时候就调用nextline()方法，再用parseInt()转化为Int\n\n### 方法三\n\n- 这里需要import java.io.IOException; //否则会报错\n\n#### 读取下一个字符：\n\n```\nimport java.io.IOException\nclass test{\n    public static void main(String[] args) throws IOException{\n      char c = (char) System.in.read();\n  }\n}\n```\n**注意这里需要类型转换，默认为int类型，即读到的是字符的ASCII码。**\n\n#### 将一串字符读入byte数组\n\n```\nimport java.io.IOException;\nclass test {\n     public static void main(String[] args) throws IOException{\n         byte[] input = new byte[5];  //创建一个byte数组来读取一串输入\n         System.in.read(input);  //将输入存入byte数组中\n         System.out.println(input[1]); //这里输出的仍然是int类型，即ASCII码\n     }\n }\n```\n\n### 图形界面输入方式\n\n```\nimport javax.swing.* //导入javax,swing包中的类\n...\nString str;\nfloat score;\nstr = JOptionPane.showInputDialog(\"please enter a num:\");\nscore = Float.parseFloat(str);\n...\n```\n\n## 输出\n---\n- 标准输出：`System.out.println();`\n\n- 格式化输出：`System.out.printf();` //格式化输出允许对输出进行规改\n```\n//\"%\"表示进行格式化输出，\"%\"之后的内容为格式的定义。\nSystem.out.printf(\"%f\",d);//\"f\"表示格式化输出浮点数。\nSystem.out.printf(\"%9.2f\",d);//\"9.2\"中的9表示输出的长度，2表示小数点后的位数。\nSystem.out.printf(\"%+9.2f\",d);//\"+\"表示输出的数带正负号。\nSystem.out.printf(\"%-9.4f\",d);//\"-\"表示输出的数左对齐（默认为右对齐）。\nSystem.out.printf(\"%+-9.3f\",d);//\"+-\"表示输出的数带正负号且左对齐。\nSystem.out.printf(\"%d\",i);//\"d\"表示输出十进制整数。\nSystem.out.printf(\"%o\",i);//\"o\"表示输出八进制整数。\nSystem.out.printf(\"%x\",i);//\"d\"表示输出十六进制整数。\nSystem.out.printf(\"%#x\",i);//\"d\"表示输出带有十六进制标志的整数。\nSystem.out.printf(\"%s\",s);//\"d\"表示输出字符串。\nSystem.out.printf(\"输出一个浮点数：%f，一个整数：%d，一个字符串：%s\",d,i,s);\n//可以输出多个变量，注意顺序。\nSystem.out.printf(\"字符串：%2$s，%1$d的十六进制数：%1$#x\",i,s);\n//\"X$\"表示第几个变量。\n```\n\n### 图形界面输出\n\n```\nJOptionPane.showMessageDialog(....)  //具体参数见类库\n```\n\n## 一些注意点\n---\n### 数组\n\n- 数组的声明格式： 数据类型[] 数组名 或者 数据类型 数组名[]\n\n- Java的数组声明只是指明了一个对象引用，并没有为数组元素分配内存空间。**因此声明不能指定数组元素个数**。例如：`int a[10];`是错误的。**如果要声明并创建数组应该采用如下格式 ： 数据类型 数组名[] = new 数据类型[数组长度]**。\n\n- 数组的初始化与C++相同。例：`int a[] = {1,6,8};`  这句相当于`int a = new int[3]; a[0]=1,a[1]=6,a[2]=8;`\n\n- 只进行了声明的数组，它的元素是不能被访问的，只有经过初始化后，才能访问数组的元素。\n\n- 数组的长度的获取：`a.length` 就表示数组a的长度（即a的元素个数）**注意这里的.length是数组的属性（相当于类的尘成员变量）而不是方法，所以a.length()的写法是错误的，他把length当做一个类的方法来调用了**\n\n### 随机数\n\n#### Math.random()\n- `int num =(int)(Math.random() * 11);`  生成一个范围在[0,1)的随机数。\n\n#### java.util.Random\n\n- 例：\n```\nimport Java.util.Random;\nRandom rand = new Random([数值]);\nint randomNum = rand.nextInt() //Random支持的随机值类型包括：boolean, byte, int, long, float, double\nint randomNUM2 = rand.nextInt(100); //表示获取[0,100)范围的随机数\n...\n```\n\n### String类\n\n- String是常量，对一个String的任何修改都会使java创建一个新的String，而原来的会被当做垃圾回收掉\n- 例如：\n```\nString a = \"avc\";\na = \"bfd\";    //则会创建一个新的string，然后将a链向这个string，原先的string会被抛弃掉\n```\n\n\n<br>\n\n> 最后更新于2018.4.9\n","slug":"2018-04-06-Java-learning","published":1,"updated":"2018-09-03T13:25:53.625Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j47000e1m0opao1y8ap","content":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"Java编译环境\"><a href=\"#Java编译环境\" class=\"headerlink\" title=\"Java编译环境\"></a>Java编译环境</h2><hr>\n<p>编译环境首选JetBrian的<a href=\"https://www.jetbrains.com/idea/\" target=\"_blank\" rel=\"noopener\">Intellij IDEA</a>，虽然几乎所有的教材都清一色的使用eclipse，但是jetBrian的社区版Intellij IDEA已经满足了我们的需求，其无与伦比的代码补全功能，清爽的界面会让人眼前一亮。专业版只有公司里才可能会用到其中的一些功能，所以我们也不用担心。</p>\n<ul>\n<li><p>Ultimate版本免费获取详见——<a href=\"https://fleschier.github.io/2018/05/jetbrains/\" target=\"_blank\" rel=\"noopener\">Intellij IDEA Ultimate版本使用</a></p>\n</li>\n<li><p>使用intellij IDEA 之前需要配置一系列设置。</p>\n<ol>\n<li>在打开项目之前的那个主界面，在设置里，systemsettings里把reopen previous project勾掉</li>\n<li>在project structure里把lib里的东西添加一下(添加需要用到的编程语言的library)，以及设置默认的sdk/jdk。(在打开的项目里设置的仅仅对本项目有效)</li>\n</ol>\n<ul>\n<li>ctrl + alt + s 快速打开设置界面。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><hr>\n<blockquote>\n<p>java与C++一样，需要用分号来分割句子</p>\n</blockquote>\n<h3 id=\"第一个JAVA程序：Helloworld\"><a href=\"#第一个JAVA程序：Helloworld\" class=\"headerlink\" title=\"第一个JAVA程序：Helloworld\"></a>第一个JAVA程序：Helloworld</h3><ul>\n<li>示例<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HelloWorld &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(&quot;Hello World&quot;); // 打印 Hello World</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"编写Java程序时注意点：\"><a href=\"#编写Java程序时注意点：\" class=\"headerlink\" title=\"编写Java程序时注意点：\"></a>编写Java程序时注意点：</h3><ul>\n<li><p>大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。</p>\n</li>\n<li><p>类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。</p>\n</li>\n<li><p>方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。<br>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。</p>\n</li>\n<li><p>主方法入口：所有的Java 程序由<code>public static void main(String[] args)</code>方法开始执行。</p>\n</li>\n<li><p>java的通配符与C++一样，都是<code>*</code></p>\n</li>\n<li><p><strong>Java与C++不同的地方是：Java中的整数，浮点数不能与布尔值相互转换，当然也不能用0或非0的的整数代替true或者false。</strong></p>\n</li>\n</ul>\n<h3 id=\"Java数据默认值\"><a href=\"#Java数据默认值\" class=\"headerlink\" title=\"Java数据默认值\"></a>Java数据默认值</h3><ul>\n<li>八大基本数据类型的默认值：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>false</td>\n</tr>\n<tr>\n<td>char</td>\n<td>‘/uoooo’(null)</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>(byte)0</td>\n</tr>\n<tr>\n<td>short</td>\n<td>(short)0</td>\n</tr>\n<tr>\n<td>int</td>\n<td>0</td>\n</tr>\n<tr>\n<td>long</td>\n<td>0L</td>\n</tr>\n<tr>\n<td>float</td>\n<td>0.0f</td>\n</tr>\n<tr>\n<td>double</td>\n<td>0.0d</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Java修饰符\"><a href=\"#Java修饰符\" class=\"headerlink\" title=\"Java修饰符\"></a>Java修饰符</h3><ul>\n<li><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>\n</li>\n<li><p>访问控制修饰符 : default, public , protected, private</p>\n</li>\n<li><p>非访问控制修饰符 : final, abstract, strictfp</p>\n</li>\n</ul>\n<h3 id=\"Java枚举\"><a href=\"#Java枚举\" class=\"headerlink\" title=\"Java枚举\"></a>Java枚举</h3><ul>\n<li>枚举限制变量只能是预先设定好的值,使用枚举可以减少代码中的bug<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ENUM_class&#123;</span><br><span class=\"line\">\tenum Test&#123;Small, Medium, Large&#125;</span><br><span class=\"line\">   Test size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class ENUM_class_Test&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tENUM_class tst = new ENUM_class();</span><br><span class=\"line\">\t\ttst.size = ENUM_class.Test.Small;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Java的三目运算符\"><a href=\"#Java的三目运算符\" class=\"headerlink\" title=\"Java的三目运算符\"></a>Java的三目运算符</h3><ul>\n<li><p>格式：逻辑表达式 ? 值1 : 值2</p>\n</li>\n<li><p>执行过程：若逻辑值表达式为true，就取值1，否则取值2</p>\n</li>\n<li><p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int x =1,y =2;</span><br><span class=\"line\">x&lt;y ? System.out.println(&quot;x&lt;y&quot;):System.out.println(&quot;x&gt;y&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意，此三目运算符不是一个完整的式子，一般是用作赋值。</p>\n</li>\n</ul>\n<h3 id=\"Java注释\"><a href=\"#Java注释\" class=\"headerlink\" title=\"Java注释\"></a>Java注释</h3><ul>\n<li>Java注释与C++一致</li>\n</ul>\n<h2 id=\"Java的输入\"><a href=\"#Java的输入\" class=\"headerlink\" title=\"Java的输入\"></a>Java的输入</h2><blockquote>\n<p>Java的输入比起C++和Python要麻烦很多</p>\n</blockquote>\n<hr>\n<h3 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.*   //引入java.io包的类</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">InputStreamReader in = new InputStreamReader(System.in);</span><br><span class=\"line\">BufferedReader br = new BufferedReader(in);</span><br><span class=\"line\">System.out.print(&quot;Please enter a num:&quot;);</span><br><span class=\"line\">String s = br.readLine(); //从键盘读取一行字符到s中</span><br><span class=\"line\">float num;</span><br><span class=\"line\">num = Float.parseFloat(s); //将字符型转换成float型</span><br><span class=\"line\">System.out.println();</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h3><h4 id=\"通过Scannner类\"><a href=\"#通过Scannner类\" class=\"headerlink\" title=\"通过Scannner类\"></a>通过Scannner类</h4><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.*</span><br><span class=\"line\">...</span><br><span class=\"line\">float score;</span><br><span class=\"line\">Scanner sn = new Scanner(System.in);</span><br><span class=\"line\">System.out.println(&quot;Please enter a num:&quot;);</span><br><span class=\"line\">score = sn.nextFloat();</span><br><span class=\"line\">System.out.println();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><em>scan在读取多行数据时会遇到的问题：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner scan = new Scanner(System.in)</span><br><span class=\"line\">int num  = scan.nextInt();  //这句会正确执行</span><br><span class=\"line\">Double d = scan.nextDouble(); //这句也会正确执行，即使输入在不同的行上</span><br><span class=\"line\">String s = scan.nextline();  //这句这样写便会读到一个空串×××××××</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>原因分析：首先，Scanner是一个扫描器，它扫描数据都是去内存中一块缓冲区中进行扫描并读入数据的，而我们在控制台中输入的数据也都是被先存入缓冲区中等待扫描器的扫描读取。这个扫描器在扫描过程中判断停止的依据就是“空白符”，空格啊，回车啊什么的都算做是空白符。</p>\n</li>\n<li>nextInt()方法在扫描到空白符的时候会将前面的数据读取走，但会丢下空白符“\\r”在缓冲区中，但是，nextLine()方法在扫描的时候会将扫描到的空白符一同清理掉。</li>\n<li><p>了解了这两个方法特性和区别，就知道了上边的代码究竟是怎么回事，以及知道了解决的方法。像是上边的代码nextInt()方法之后在缓冲区中留下了“\\r”，然后nextLine()方法再去缓冲区找数据的时候首先看到了“\\r”，然后就把这个“\\r”扫描接收进来，并在缓冲区内清除掉。其实，nextLine()方法是执行过的，并没有不执行。</p>\n</li>\n<li><p>解决方案：<br>在调用nextline()之前先调用一次nextline()将那个换行符读取掉</p>\n<p>在读取Int的时候就调用nextline()方法，再用parseInt()转化为Int</p>\n</li>\n</ul>\n<h3 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h3><ul>\n<li>这里需要import java.io.IOException; //否则会报错</li>\n</ul>\n<h4 id=\"读取下一个字符：\"><a href=\"#读取下一个字符：\" class=\"headerlink\" title=\"读取下一个字符：\"></a>读取下一个字符：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.IOException</span><br><span class=\"line\">class test&#123;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException&#123;</span><br><span class=\"line\">      char c = (char) System.in.read();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意这里需要类型转换，默认为int类型，即读到的是字符的ASCII码。</strong></p>\n<h4 id=\"将一串字符读入byte数组\"><a href=\"#将一串字符读入byte数组\" class=\"headerlink\" title=\"将一串字符读入byte数组\"></a>将一串字符读入byte数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">class test &#123;</span><br><span class=\"line\">     public static void main(String[] args) throws IOException&#123;</span><br><span class=\"line\">         byte[] input = new byte[5];  //创建一个byte数组来读取一串输入</span><br><span class=\"line\">         System.in.read(input);  //将输入存入byte数组中</span><br><span class=\"line\">         System.out.println(input[1]); //这里输出的仍然是int类型，即ASCII码</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"图形界面输入方式\"><a href=\"#图形界面输入方式\" class=\"headerlink\" title=\"图形界面输入方式\"></a>图形界面输入方式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import javax.swing.* //导入javax,swing包中的类</span><br><span class=\"line\">...</span><br><span class=\"line\">String str;</span><br><span class=\"line\">float score;</span><br><span class=\"line\">str = JOptionPane.showInputDialog(&quot;please enter a num:&quot;);</span><br><span class=\"line\">score = Float.parseFloat(str);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><hr>\n<ul>\n<li><p>标准输出：<code>System.out.println();</code></p>\n</li>\n<li><p>格式化输出：<code>System.out.printf();</code> //格式化输出允许对输出进行规改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//&quot;%&quot;表示进行格式化输出，&quot;%&quot;之后的内容为格式的定义。</span><br><span class=\"line\">System.out.printf(&quot;%f&quot;,d);//&quot;f&quot;表示格式化输出浮点数。</span><br><span class=\"line\">System.out.printf(&quot;%9.2f&quot;,d);//&quot;9.2&quot;中的9表示输出的长度，2表示小数点后的位数。</span><br><span class=\"line\">System.out.printf(&quot;%+9.2f&quot;,d);//&quot;+&quot;表示输出的数带正负号。</span><br><span class=\"line\">System.out.printf(&quot;%-9.4f&quot;,d);//&quot;-&quot;表示输出的数左对齐（默认为右对齐）。</span><br><span class=\"line\">System.out.printf(&quot;%+-9.3f&quot;,d);//&quot;+-&quot;表示输出的数带正负号且左对齐。</span><br><span class=\"line\">System.out.printf(&quot;%d&quot;,i);//&quot;d&quot;表示输出十进制整数。</span><br><span class=\"line\">System.out.printf(&quot;%o&quot;,i);//&quot;o&quot;表示输出八进制整数。</span><br><span class=\"line\">System.out.printf(&quot;%x&quot;,i);//&quot;d&quot;表示输出十六进制整数。</span><br><span class=\"line\">System.out.printf(&quot;%#x&quot;,i);//&quot;d&quot;表示输出带有十六进制标志的整数。</span><br><span class=\"line\">System.out.printf(&quot;%s&quot;,s);//&quot;d&quot;表示输出字符串。</span><br><span class=\"line\">System.out.printf(&quot;输出一个浮点数：%f，一个整数：%d，一个字符串：%s&quot;,d,i,s);</span><br><span class=\"line\">//可以输出多个变量，注意顺序。</span><br><span class=\"line\">System.out.printf(&quot;字符串：%2$s，%1$d的十六进制数：%1$#x&quot;,i,s);</span><br><span class=\"line\">//&quot;X$&quot;表示第几个变量。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"图形界面输出\"><a href=\"#图形界面输出\" class=\"headerlink\" title=\"图形界面输出\"></a>图形界面输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JOptionPane.showMessageDialog(....)  //具体参数见类库</span><br></pre></td></tr></table></figure>\n<h2 id=\"一些注意点\"><a href=\"#一些注意点\" class=\"headerlink\" title=\"一些注意点\"></a>一些注意点</h2><hr>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ul>\n<li><p>数组的声明格式： 数据类型[] 数组名 或者 数据类型 数组名[]</p>\n</li>\n<li><p>Java的数组声明只是指明了一个对象引用，并没有为数组元素分配内存空间。<strong>因此声明不能指定数组元素个数</strong>。例如：<code>int a[10];</code>是错误的。<strong>如果要声明并创建数组应该采用如下格式 ： 数据类型 数组名[] = new 数据类型[数组长度]</strong>。</p>\n</li>\n<li><p>数组的初始化与C++相同。例：<code>int a[] = {1,6,8};</code>  这句相当于<code>int a = new int[3]; a[0]=1,a[1]=6,a[2]=8;</code></p>\n</li>\n<li><p>只进行了声明的数组，它的元素是不能被访问的，只有经过初始化后，才能访问数组的元素。</p>\n</li>\n<li><p>数组的长度的获取：<code>a.length</code> 就表示数组a的长度（即a的元素个数）<strong>注意这里的.length是数组的属性（相当于类的尘成员变量）而不是方法，所以a.length()的写法是错误的，他把length当做一个类的方法来调用了</strong></p>\n</li>\n</ul>\n<h3 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h3><h4 id=\"Math-random\"><a href=\"#Math-random\" class=\"headerlink\" title=\"Math.random()\"></a>Math.random()</h4><ul>\n<li><code>int num =(int)(Math.random() * 11);</code>  生成一个范围在[0,1)的随机数。</li>\n</ul>\n<h4 id=\"java-util-Random\"><a href=\"#java-util-Random\" class=\"headerlink\" title=\"java.util.Random\"></a>java.util.Random</h4><ul>\n<li>例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Java.util.Random;</span><br><span class=\"line\">Random rand = new Random([数值]);</span><br><span class=\"line\">int randomNum = rand.nextInt() //Random支持的随机值类型包括：boolean, byte, int, long, float, double</span><br><span class=\"line\">int randomNUM2 = rand.nextInt(100); //表示获取[0,100)范围的随机数</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"String类\"><a href=\"#String类\" class=\"headerlink\" title=\"String类\"></a>String类</h3><ul>\n<li>String是常量，对一个String的任何修改都会使java创建一个新的String，而原来的会被当做垃圾回收掉</li>\n<li>例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = &quot;avc&quot;;</span><br><span class=\"line\">a = &quot;bfd&quot;;    //则会创建一个新的string，然后将a链向这个string，原先的string会被抛弃掉</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.9</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"Java编译环境\"><a href=\"#Java编译环境\" class=\"headerlink\" title=\"Java编译环境\"></a>Java编译环境</h2><hr>\n<p>编译环境首选JetBrian的<a href=\"https://www.jetbrains.com/idea/\" target=\"_blank\" rel=\"noopener\">Intellij IDEA</a>，虽然几乎所有的教材都清一色的使用eclipse，但是jetBrian的社区版Intellij IDEA已经满足了我们的需求，其无与伦比的代码补全功能，清爽的界面会让人眼前一亮。专业版只有公司里才可能会用到其中的一些功能，所以我们也不用担心。</p>\n<ul>\n<li><p>Ultimate版本免费获取详见——<a href=\"https://fleschier.github.io/2018/05/jetbrains/\" target=\"_blank\" rel=\"noopener\">Intellij IDEA Ultimate版本使用</a></p>\n</li>\n<li><p>使用intellij IDEA 之前需要配置一系列设置。</p>\n<ol>\n<li>在打开项目之前的那个主界面，在设置里，systemsettings里把reopen previous project勾掉</li>\n<li>在project structure里把lib里的东西添加一下(添加需要用到的编程语言的library)，以及设置默认的sdk/jdk。(在打开的项目里设置的仅仅对本项目有效)</li>\n</ol>\n<ul>\n<li>ctrl + alt + s 快速打开设置界面。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><hr>\n<blockquote>\n<p>java与C++一样，需要用分号来分割句子</p>\n</blockquote>\n<h3 id=\"第一个JAVA程序：Helloworld\"><a href=\"#第一个JAVA程序：Helloworld\" class=\"headerlink\" title=\"第一个JAVA程序：Helloworld\"></a>第一个JAVA程序：Helloworld</h3><ul>\n<li>示例<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HelloWorld &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(&quot;Hello World&quot;); // 打印 Hello World</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"编写Java程序时注意点：\"><a href=\"#编写Java程序时注意点：\" class=\"headerlink\" title=\"编写Java程序时注意点：\"></a>编写Java程序时注意点：</h3><ul>\n<li><p>大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。</p>\n</li>\n<li><p>类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。</p>\n</li>\n<li><p>方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。<br>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。</p>\n</li>\n<li><p>主方法入口：所有的Java 程序由<code>public static void main(String[] args)</code>方法开始执行。</p>\n</li>\n<li><p>java的通配符与C++一样，都是<code>*</code></p>\n</li>\n<li><p><strong>Java与C++不同的地方是：Java中的整数，浮点数不能与布尔值相互转换，当然也不能用0或非0的的整数代替true或者false。</strong></p>\n</li>\n</ul>\n<h3 id=\"Java数据默认值\"><a href=\"#Java数据默认值\" class=\"headerlink\" title=\"Java数据默认值\"></a>Java数据默认值</h3><ul>\n<li>八大基本数据类型的默认值：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>false</td>\n</tr>\n<tr>\n<td>char</td>\n<td>‘/uoooo’(null)</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>(byte)0</td>\n</tr>\n<tr>\n<td>short</td>\n<td>(short)0</td>\n</tr>\n<tr>\n<td>int</td>\n<td>0</td>\n</tr>\n<tr>\n<td>long</td>\n<td>0L</td>\n</tr>\n<tr>\n<td>float</td>\n<td>0.0f</td>\n</tr>\n<tr>\n<td>double</td>\n<td>0.0d</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Java修饰符\"><a href=\"#Java修饰符\" class=\"headerlink\" title=\"Java修饰符\"></a>Java修饰符</h3><ul>\n<li><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>\n</li>\n<li><p>访问控制修饰符 : default, public , protected, private</p>\n</li>\n<li><p>非访问控制修饰符 : final, abstract, strictfp</p>\n</li>\n</ul>\n<h3 id=\"Java枚举\"><a href=\"#Java枚举\" class=\"headerlink\" title=\"Java枚举\"></a>Java枚举</h3><ul>\n<li>枚举限制变量只能是预先设定好的值,使用枚举可以减少代码中的bug<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ENUM_class&#123;</span><br><span class=\"line\">\tenum Test&#123;Small, Medium, Large&#125;</span><br><span class=\"line\">   Test size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class ENUM_class_Test&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tENUM_class tst = new ENUM_class();</span><br><span class=\"line\">\t\ttst.size = ENUM_class.Test.Small;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Java的三目运算符\"><a href=\"#Java的三目运算符\" class=\"headerlink\" title=\"Java的三目运算符\"></a>Java的三目运算符</h3><ul>\n<li><p>格式：逻辑表达式 ? 值1 : 值2</p>\n</li>\n<li><p>执行过程：若逻辑值表达式为true，就取值1，否则取值2</p>\n</li>\n<li><p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int x =1,y =2;</span><br><span class=\"line\">x&lt;y ? System.out.println(&quot;x&lt;y&quot;):System.out.println(&quot;x&gt;y&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意，此三目运算符不是一个完整的式子，一般是用作赋值。</p>\n</li>\n</ul>\n<h3 id=\"Java注释\"><a href=\"#Java注释\" class=\"headerlink\" title=\"Java注释\"></a>Java注释</h3><ul>\n<li>Java注释与C++一致</li>\n</ul>\n<h2 id=\"Java的输入\"><a href=\"#Java的输入\" class=\"headerlink\" title=\"Java的输入\"></a>Java的输入</h2><blockquote>\n<p>Java的输入比起C++和Python要麻烦很多</p>\n</blockquote>\n<hr>\n<h3 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.*   //引入java.io包的类</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">InputStreamReader in = new InputStreamReader(System.in);</span><br><span class=\"line\">BufferedReader br = new BufferedReader(in);</span><br><span class=\"line\">System.out.print(&quot;Please enter a num:&quot;);</span><br><span class=\"line\">String s = br.readLine(); //从键盘读取一行字符到s中</span><br><span class=\"line\">float num;</span><br><span class=\"line\">num = Float.parseFloat(s); //将字符型转换成float型</span><br><span class=\"line\">System.out.println();</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h3><h4 id=\"通过Scannner类\"><a href=\"#通过Scannner类\" class=\"headerlink\" title=\"通过Scannner类\"></a>通过Scannner类</h4><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.*</span><br><span class=\"line\">...</span><br><span class=\"line\">float score;</span><br><span class=\"line\">Scanner sn = new Scanner(System.in);</span><br><span class=\"line\">System.out.println(&quot;Please enter a num:&quot;);</span><br><span class=\"line\">score = sn.nextFloat();</span><br><span class=\"line\">System.out.println();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><em>scan在读取多行数据时会遇到的问题：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner scan = new Scanner(System.in)</span><br><span class=\"line\">int num  = scan.nextInt();  //这句会正确执行</span><br><span class=\"line\">Double d = scan.nextDouble(); //这句也会正确执行，即使输入在不同的行上</span><br><span class=\"line\">String s = scan.nextline();  //这句这样写便会读到一个空串×××××××</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>原因分析：首先，Scanner是一个扫描器，它扫描数据都是去内存中一块缓冲区中进行扫描并读入数据的，而我们在控制台中输入的数据也都是被先存入缓冲区中等待扫描器的扫描读取。这个扫描器在扫描过程中判断停止的依据就是“空白符”，空格啊，回车啊什么的都算做是空白符。</p>\n</li>\n<li>nextInt()方法在扫描到空白符的时候会将前面的数据读取走，但会丢下空白符“\\r”在缓冲区中，但是，nextLine()方法在扫描的时候会将扫描到的空白符一同清理掉。</li>\n<li><p>了解了这两个方法特性和区别，就知道了上边的代码究竟是怎么回事，以及知道了解决的方法。像是上边的代码nextInt()方法之后在缓冲区中留下了“\\r”，然后nextLine()方法再去缓冲区找数据的时候首先看到了“\\r”，然后就把这个“\\r”扫描接收进来，并在缓冲区内清除掉。其实，nextLine()方法是执行过的，并没有不执行。</p>\n</li>\n<li><p>解决方案：<br>在调用nextline()之前先调用一次nextline()将那个换行符读取掉</p>\n<p>在读取Int的时候就调用nextline()方法，再用parseInt()转化为Int</p>\n</li>\n</ul>\n<h3 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h3><ul>\n<li>这里需要import java.io.IOException; //否则会报错</li>\n</ul>\n<h4 id=\"读取下一个字符：\"><a href=\"#读取下一个字符：\" class=\"headerlink\" title=\"读取下一个字符：\"></a>读取下一个字符：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.IOException</span><br><span class=\"line\">class test&#123;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException&#123;</span><br><span class=\"line\">      char c = (char) System.in.read();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意这里需要类型转换，默认为int类型，即读到的是字符的ASCII码。</strong></p>\n<h4 id=\"将一串字符读入byte数组\"><a href=\"#将一串字符读入byte数组\" class=\"headerlink\" title=\"将一串字符读入byte数组\"></a>将一串字符读入byte数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">class test &#123;</span><br><span class=\"line\">     public static void main(String[] args) throws IOException&#123;</span><br><span class=\"line\">         byte[] input = new byte[5];  //创建一个byte数组来读取一串输入</span><br><span class=\"line\">         System.in.read(input);  //将输入存入byte数组中</span><br><span class=\"line\">         System.out.println(input[1]); //这里输出的仍然是int类型，即ASCII码</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"图形界面输入方式\"><a href=\"#图形界面输入方式\" class=\"headerlink\" title=\"图形界面输入方式\"></a>图形界面输入方式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import javax.swing.* //导入javax,swing包中的类</span><br><span class=\"line\">...</span><br><span class=\"line\">String str;</span><br><span class=\"line\">float score;</span><br><span class=\"line\">str = JOptionPane.showInputDialog(&quot;please enter a num:&quot;);</span><br><span class=\"line\">score = Float.parseFloat(str);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><hr>\n<ul>\n<li><p>标准输出：<code>System.out.println();</code></p>\n</li>\n<li><p>格式化输出：<code>System.out.printf();</code> //格式化输出允许对输出进行规改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//&quot;%&quot;表示进行格式化输出，&quot;%&quot;之后的内容为格式的定义。</span><br><span class=\"line\">System.out.printf(&quot;%f&quot;,d);//&quot;f&quot;表示格式化输出浮点数。</span><br><span class=\"line\">System.out.printf(&quot;%9.2f&quot;,d);//&quot;9.2&quot;中的9表示输出的长度，2表示小数点后的位数。</span><br><span class=\"line\">System.out.printf(&quot;%+9.2f&quot;,d);//&quot;+&quot;表示输出的数带正负号。</span><br><span class=\"line\">System.out.printf(&quot;%-9.4f&quot;,d);//&quot;-&quot;表示输出的数左对齐（默认为右对齐）。</span><br><span class=\"line\">System.out.printf(&quot;%+-9.3f&quot;,d);//&quot;+-&quot;表示输出的数带正负号且左对齐。</span><br><span class=\"line\">System.out.printf(&quot;%d&quot;,i);//&quot;d&quot;表示输出十进制整数。</span><br><span class=\"line\">System.out.printf(&quot;%o&quot;,i);//&quot;o&quot;表示输出八进制整数。</span><br><span class=\"line\">System.out.printf(&quot;%x&quot;,i);//&quot;d&quot;表示输出十六进制整数。</span><br><span class=\"line\">System.out.printf(&quot;%#x&quot;,i);//&quot;d&quot;表示输出带有十六进制标志的整数。</span><br><span class=\"line\">System.out.printf(&quot;%s&quot;,s);//&quot;d&quot;表示输出字符串。</span><br><span class=\"line\">System.out.printf(&quot;输出一个浮点数：%f，一个整数：%d，一个字符串：%s&quot;,d,i,s);</span><br><span class=\"line\">//可以输出多个变量，注意顺序。</span><br><span class=\"line\">System.out.printf(&quot;字符串：%2$s，%1$d的十六进制数：%1$#x&quot;,i,s);</span><br><span class=\"line\">//&quot;X$&quot;表示第几个变量。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"图形界面输出\"><a href=\"#图形界面输出\" class=\"headerlink\" title=\"图形界面输出\"></a>图形界面输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JOptionPane.showMessageDialog(....)  //具体参数见类库</span><br></pre></td></tr></table></figure>\n<h2 id=\"一些注意点\"><a href=\"#一些注意点\" class=\"headerlink\" title=\"一些注意点\"></a>一些注意点</h2><hr>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ul>\n<li><p>数组的声明格式： 数据类型[] 数组名 或者 数据类型 数组名[]</p>\n</li>\n<li><p>Java的数组声明只是指明了一个对象引用，并没有为数组元素分配内存空间。<strong>因此声明不能指定数组元素个数</strong>。例如：<code>int a[10];</code>是错误的。<strong>如果要声明并创建数组应该采用如下格式 ： 数据类型 数组名[] = new 数据类型[数组长度]</strong>。</p>\n</li>\n<li><p>数组的初始化与C++相同。例：<code>int a[] = {1,6,8};</code>  这句相当于<code>int a = new int[3]; a[0]=1,a[1]=6,a[2]=8;</code></p>\n</li>\n<li><p>只进行了声明的数组，它的元素是不能被访问的，只有经过初始化后，才能访问数组的元素。</p>\n</li>\n<li><p>数组的长度的获取：<code>a.length</code> 就表示数组a的长度（即a的元素个数）<strong>注意这里的.length是数组的属性（相当于类的尘成员变量）而不是方法，所以a.length()的写法是错误的，他把length当做一个类的方法来调用了</strong></p>\n</li>\n</ul>\n<h3 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h3><h4 id=\"Math-random\"><a href=\"#Math-random\" class=\"headerlink\" title=\"Math.random()\"></a>Math.random()</h4><ul>\n<li><code>int num =(int)(Math.random() * 11);</code>  生成一个范围在[0,1)的随机数。</li>\n</ul>\n<h4 id=\"java-util-Random\"><a href=\"#java-util-Random\" class=\"headerlink\" title=\"java.util.Random\"></a>java.util.Random</h4><ul>\n<li>例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Java.util.Random;</span><br><span class=\"line\">Random rand = new Random([数值]);</span><br><span class=\"line\">int randomNum = rand.nextInt() //Random支持的随机值类型包括：boolean, byte, int, long, float, double</span><br><span class=\"line\">int randomNUM2 = rand.nextInt(100); //表示获取[0,100)范围的随机数</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"String类\"><a href=\"#String类\" class=\"headerlink\" title=\"String类\"></a>String类</h3><ul>\n<li>String是常量，对一个String的任何修改都会使java创建一个新的String，而原来的会被当做垃圾回收掉</li>\n<li>例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = &quot;avc&quot;;</span><br><span class=\"line\">a = &quot;bfd&quot;;    //则会创建一个新的string，然后将a链向这个string，原先的string会被抛弃掉</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.9</p>\n</blockquote>\n"},{"layout":"post","title":"Scala学习笔记——进阶","date":"2018-04-06T08:47:00.000Z","_content":"\n> 不适合人类阅读的学习笔记  \n\n## case class与模式匹配\n---\n- case class一般被翻译为样例类，它是一种特殊的类，能够被优化以用于模式匹配。\n\n-\n\n## scala性能测试\n---\n- 测试程序的运行时间的函数：`System.currentTimeMillis()`\n\n- 用法：\n```\n[...]\n  val time = System.currentTimeMillis()\n  [要测试运行时间的代码段]\n  println(\" 耗时: \" + (System.currentTimeMillis() - time))  //以时间差来看运行时间\n[...]\n```\n\n## 函数式循环\n---\n\n- 函数式编程的循环都是用迭代来实现的\n\n- 例1：对于一个Int数组a,对里面每个元素执行 +1的操作\n```\na.map{x =>\n  val y = x + 1  //因为Int是不可变类型，所以必须要新建一个值来存储改变后的值\n  y  //返回值是y\n}\n```\n\n- 例2：对于一个Int数组，每找出一个大于5的数count就加1\n```\nvar count:Int = 0\na.foreach{x =>      //与map遍历方式不同，foreach不会对里面的内容修改，所以匿名函数也不需要返回值\n  if(x >  5)\n    count += 1\n}\n```\n\n## 一些数据结构的使用\n---\n\n### ListBuffer:\n\n- 首先需要引入包 `import scala.collection.mutable.ListBuffer`\n\n- 在使用之前，先声明一个ListBuffer变量，通过以下代码：\n`val buf = new ListBuffer[Int]()    //类型自定义，这里采用的是Int`\n\n- 在末尾进行追加，使用append()方法：\n`buf.append(x)`\n\n- 将ListBuffer转化为List:\n`val lst = buf.toList`\n\n\n<br>\n\n> 最后更新于2018.5.27\n","source":"_posts/2018-04-06-Scala-superior.md","raw":"---\nlayout:     post\ntitle:      \"Scala学习笔记——进阶\"\ndate:       2018-04-6 16:47:00\ncategories: Computer Programes\ntags: ๑Scala\n---\n\n> 不适合人类阅读的学习笔记  \n\n## case class与模式匹配\n---\n- case class一般被翻译为样例类，它是一种特殊的类，能够被优化以用于模式匹配。\n\n-\n\n## scala性能测试\n---\n- 测试程序的运行时间的函数：`System.currentTimeMillis()`\n\n- 用法：\n```\n[...]\n  val time = System.currentTimeMillis()\n  [要测试运行时间的代码段]\n  println(\" 耗时: \" + (System.currentTimeMillis() - time))  //以时间差来看运行时间\n[...]\n```\n\n## 函数式循环\n---\n\n- 函数式编程的循环都是用迭代来实现的\n\n- 例1：对于一个Int数组a,对里面每个元素执行 +1的操作\n```\na.map{x =>\n  val y = x + 1  //因为Int是不可变类型，所以必须要新建一个值来存储改变后的值\n  y  //返回值是y\n}\n```\n\n- 例2：对于一个Int数组，每找出一个大于5的数count就加1\n```\nvar count:Int = 0\na.foreach{x =>      //与map遍历方式不同，foreach不会对里面的内容修改，所以匿名函数也不需要返回值\n  if(x >  5)\n    count += 1\n}\n```\n\n## 一些数据结构的使用\n---\n\n### ListBuffer:\n\n- 首先需要引入包 `import scala.collection.mutable.ListBuffer`\n\n- 在使用之前，先声明一个ListBuffer变量，通过以下代码：\n`val buf = new ListBuffer[Int]()    //类型自定义，这里采用的是Int`\n\n- 在末尾进行追加，使用append()方法：\n`buf.append(x)`\n\n- 将ListBuffer转化为List:\n`val lst = buf.toList`\n\n\n<br>\n\n> 最后更新于2018.5.27\n","slug":"2018-04-06-Scala-superior","published":1,"updated":"2018-09-03T13:23:32.788Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j49000f1m0oz0e4vjji","content":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"case-class与模式匹配\"><a href=\"#case-class与模式匹配\" class=\"headerlink\" title=\"case class与模式匹配\"></a>case class与模式匹配</h2><hr>\n<ul>\n<li>case class一般被翻译为样例类，它是一种特殊的类，能够被优化以用于模式匹配。</li>\n</ul>\n<p>-</p>\n<h2 id=\"scala性能测试\"><a href=\"#scala性能测试\" class=\"headerlink\" title=\"scala性能测试\"></a>scala性能测试</h2><hr>\n<ul>\n<li><p>测试程序的运行时间的函数：<code>System.currentTimeMillis()</code></p>\n</li>\n<li><p>用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...]</span><br><span class=\"line\">  val time = System.currentTimeMillis()</span><br><span class=\"line\">  [要测试运行时间的代码段]</span><br><span class=\"line\">  println(&quot; 耗时: &quot; + (System.currentTimeMillis() - time))  //以时间差来看运行时间</span><br><span class=\"line\">[...]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"函数式循环\"><a href=\"#函数式循环\" class=\"headerlink\" title=\"函数式循环\"></a>函数式循环</h2><hr>\n<ul>\n<li><p>函数式编程的循环都是用迭代来实现的</p>\n</li>\n<li><p>例1：对于一个Int数组a,对里面每个元素执行 +1的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.map&#123;x =&gt;</span><br><span class=\"line\">  val y = x + 1  //因为Int是不可变类型，所以必须要新建一个值来存储改变后的值</span><br><span class=\"line\">  y  //返回值是y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例2：对于一个Int数组，每找出一个大于5的数count就加1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var count:Int = 0</span><br><span class=\"line\">a.foreach&#123;x =&gt;      //与map遍历方式不同，foreach不会对里面的内容修改，所以匿名函数也不需要返回值</span><br><span class=\"line\">  if(x &gt;  5)</span><br><span class=\"line\">    count += 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"一些数据结构的使用\"><a href=\"#一些数据结构的使用\" class=\"headerlink\" title=\"一些数据结构的使用\"></a>一些数据结构的使用</h2><hr>\n<h3 id=\"ListBuffer\"><a href=\"#ListBuffer\" class=\"headerlink\" title=\"ListBuffer:\"></a>ListBuffer:</h3><ul>\n<li><p>首先需要引入包 <code>import scala.collection.mutable.ListBuffer</code></p>\n</li>\n<li><p>在使用之前，先声明一个ListBuffer变量，通过以下代码：<br><code>val buf = new ListBuffer[Int]()    //类型自定义，这里采用的是Int</code></p>\n</li>\n<li><p>在末尾进行追加，使用append()方法：<br><code>buf.append(x)</code></p>\n</li>\n<li><p>将ListBuffer转化为List:<br><code>val lst = buf.toList</code></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.27</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"case-class与模式匹配\"><a href=\"#case-class与模式匹配\" class=\"headerlink\" title=\"case class与模式匹配\"></a>case class与模式匹配</h2><hr>\n<ul>\n<li>case class一般被翻译为样例类，它是一种特殊的类，能够被优化以用于模式匹配。</li>\n</ul>\n<p>-</p>\n<h2 id=\"scala性能测试\"><a href=\"#scala性能测试\" class=\"headerlink\" title=\"scala性能测试\"></a>scala性能测试</h2><hr>\n<ul>\n<li><p>测试程序的运行时间的函数：<code>System.currentTimeMillis()</code></p>\n</li>\n<li><p>用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...]</span><br><span class=\"line\">  val time = System.currentTimeMillis()</span><br><span class=\"line\">  [要测试运行时间的代码段]</span><br><span class=\"line\">  println(&quot; 耗时: &quot; + (System.currentTimeMillis() - time))  //以时间差来看运行时间</span><br><span class=\"line\">[...]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"函数式循环\"><a href=\"#函数式循环\" class=\"headerlink\" title=\"函数式循环\"></a>函数式循环</h2><hr>\n<ul>\n<li><p>函数式编程的循环都是用迭代来实现的</p>\n</li>\n<li><p>例1：对于一个Int数组a,对里面每个元素执行 +1的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.map&#123;x =&gt;</span><br><span class=\"line\">  val y = x + 1  //因为Int是不可变类型，所以必须要新建一个值来存储改变后的值</span><br><span class=\"line\">  y  //返回值是y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例2：对于一个Int数组，每找出一个大于5的数count就加1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var count:Int = 0</span><br><span class=\"line\">a.foreach&#123;x =&gt;      //与map遍历方式不同，foreach不会对里面的内容修改，所以匿名函数也不需要返回值</span><br><span class=\"line\">  if(x &gt;  5)</span><br><span class=\"line\">    count += 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"一些数据结构的使用\"><a href=\"#一些数据结构的使用\" class=\"headerlink\" title=\"一些数据结构的使用\"></a>一些数据结构的使用</h2><hr>\n<h3 id=\"ListBuffer\"><a href=\"#ListBuffer\" class=\"headerlink\" title=\"ListBuffer:\"></a>ListBuffer:</h3><ul>\n<li><p>首先需要引入包 <code>import scala.collection.mutable.ListBuffer</code></p>\n</li>\n<li><p>在使用之前，先声明一个ListBuffer变量，通过以下代码：<br><code>val buf = new ListBuffer[Int]()    //类型自定义，这里采用的是Int</code></p>\n</li>\n<li><p>在末尾进行追加，使用append()方法：<br><code>buf.append(x)</code></p>\n</li>\n<li><p>将ListBuffer转化为List:<br><code>val lst = buf.toList</code></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.27</p>\n</blockquote>\n"},{"layout":"post","title":"Scala学习笔记——基础","date":"2018-04-06T08:47:00.000Z","_content":"\n> 不适合人类阅读的学习笔记  \n\n## 编译环境\n---\n- scala在终端中就可以调用解释器，与python类似，可以逐语句执行。使用命令`scala`即可进入终端解释器，使用命令`:q`或者`:quit`退出解释器。\n\n- 编译首选jetbrain的intellij IDEA，下载一个Scala plugin，然后选择创建maven工程，main函数应当写在object文件中，object通过创建Scala class文件选项创建。\n\n- 如果要写分布式处理程序的话，需要自己重写配置文件\n\n- Scala注释与C++类似\n\n### 让intellij默认不打开上个项目的方法\n\n- settings`>`Apperance&Behavior`>`System Settings 将`Reopen last project on startup` 勾去掉即可.\n\n## 在intellij IDEA下创建scala项目的步骤\n---\n\n- 首先，要确保已经安装了scala的插件(这个有很大概率会安装失败，如果失败次数太多可以选择离线安装，或者跳过scala sdk的选择，在进入一个scala项目之后选择补全)\n\n-  然后，在欢迎页面的右下角点击Configure，然后在Project Defaults的下拉菜单中选择Project Structure，在打开的页面左侧选择Global Libraries，然后在中间一栏中有一个绿色的加号标志 +，点击后在下拉菜单中选择 Scala SDK\n\n- 然后在打开的对话框中选择系统本身所安装的Scala（即System对应的版本），点击OK确定，这时候会在中间一栏位置处出现Scala的SDK，在其上右键点击后选择Copy to Project Libraries…，这个操作是为了将Scala SDK添加到项目的默认Library中去。\n\n\n- 在欢迎界面点击Create New Project，在打开的页面左侧边栏中，选择Maven，然后在右侧的Project SDK一项中，查看是否是正确的JDK配置项正常来说这一栏会自动填充的，因为我们之前在1.3中已经配置过了全局的Project JDK了，如果这里没有正常显示JDK的话，可以点击右侧的New…按钮，然后指定JDK安装路径的根目录即可）。**注意不要选择create from archetype**\n\n![](/images/Scala/create_1.png)\n\n- 然后点击Next，来到Maven项目最重要三个参数的设置页面，这三个参数分别为：GroupId, ArtifactId和Version.\n\n![](/images/Scala/create_2.png)\n\n### 创建Hello world\n![](/images/Scala/first_program.png)\n\n- 为了让体验Scala更清爽一些，将一些暂时无关的文件和文件夹都删除掉，主要有 main/java, main/resources 和 test 这三个文件夹\n\n- 将Scala的框架添加到这个项目中，方法是在左侧栏中的 **项目名称** 上右键菜单中点击 Add Framework Support…，然后在打开的对话框左侧边栏中，勾选Scala前面的复选框，然后点击确定即可（前提是上文中所述步骤都已正确走通，否则你很有可能看不到Scala这个选项的）；\n\n- 在main文件夹中建立一个名为 scala 的文件夹，并右键点击 scala 文件夹，选择 Make Directory as，然后选择Sources Root ，**这里主要意思是将 scala 文件夹标记为一个源文件的根目录，然后在其内的所有代码中的 package ，其路径就从这个根目录下开始算起**。\n\n- 在已经标记好为源文件根目录的 scala 文件夹 上，右键选择 New，然后选择 Scala Class，随后设置好程序的名称，并且记得将其设置为一个 Object(类似于Java中含有静态成员的静态类)，正常的话，将会打开这个 Object 代码界面，并且可以看到IntelliJ IDEA自动添加了一些最基本的信息；\n\n### 示例程序\n```\nobject HelloWorld {\n   def main(args: Array[String]) {\n      println(\"Hello, world!\") // 输出 Hello World\n   }\n}\n```\n\n### 执行scala程序\n\n- 脚本执行：我们可以将 Scala 表达式写在一个文件里，比如 Hello.scala。在命令行中直接输入 scala Hello.scala\n\n- 作为应用程序执行：作为应用程序执行时，我们需要在一个单例对象中定义入口函数 main，经过编译后就可以执行该应用程序了。\n\n## 基础\n---\n\n> scala的语句分号规则与C++相类似(一般都不用加，加了一般也不会错)\n\n> scala中的通配符为`_`，而C++中为`*``\n\n> scala与spark很契合，所以写spark程序推荐使用scala语言\n\n### 变量\n\n- Scala中变量分为可变变量和不可变变量。可变变量用关键字`var`修饰，不可变变量用`val`修饰。\n> 注意scala中变量定义时必须赋初始值\n\n- scala大多数数据结构中的变量默认为val类型\n\n- 特例：若用占位符`_`作为值进行初始化，则String类会被初始化为null,Float,Int,Double等被初始化为0,Char类型会被初始化为\"?\".\n\n- 如果用lazy关键字修饰变量，则他只有在真正被使用时才会被赋值。\n> 注意lazy关键字只能修饰val类型变量，不能修饰var类型\n\n## 输入输出\n### 输出：`print(\"...\")` 或者 `println(\"...\")`\n\n### 输入：\n> 注意，控制台的输入均为string类型，需要在后面加上.toInt  .toFloat等转换操作\n\n- 控制台输入：\n```\n val scan = scala.io.StdIn  //设置scan\n val n = scan.readLine.trim.toInt  //输入一个int\n val arr = scan.readLine.split(\" \").map(_.trim.toInt)  //输入一串数字，之间以空格间隔\n // .trim方法是去掉输入字符串两旁的空格\n```\n\n- scala还有一系列专门的用来读下 **一个** 输入并且可以自动转换的方法，例如：\n```\nval scan = scala.io.StdIn\nval myint = scan.readInt()\nval myfloat = scan.readFloat()\nval myboolean = scan.readBoolean()\n...\n//这些方法均可以读取下一个输入并且自动转换类型\n```\n\n### 排序\n- 例如：\n```\nval a = new Array[Int](3)\na(0)  =1\na(1) = 2\na(2) = 0\na.foreach(print)  //结果: 120\nval sorted_a = a.sortWith((x,y) => x > y)  //从大到小排序（sortWith的参数为一个lambda函数，返回一个布尔值用于比较）\na.foreach(print) //结果： 210\n```\n\n### 一些注意点\n\n- scala中没有 `++` 操作，可以用 `+= 1` 代替 `++`（x += y ，y可以是一个数字，也可以是一个数字变量，但不能是数组或是其他一些类似结构的某个元素）\n\n- Scala所有数据类型首字母都要大写，因为Scala中所有值类型都是对象，**其中布尔类型应写为“Boolean”**\n\n- Scala中有 `<=` 和 `>=` 以及逻辑与 `&&` 和逻辑或 `||` 运算符，与C++相同。\n\n- Scala中String类型就是Java中的String.lang.String类型，因此可以调用Java中String的所有方法（例：`str.reverse`表示字符逆序）\n\n- **Scala中有一类特殊的运算符 \"::\"(list构造)，\":::\"(list拼接)，他们是右操作。例如：a::b::Nill执行顺序为(a::(b::Nill))**\n\n### 一些数据类型\n\n#### 整型和浮点型\n - 整型字面量用于 Int 类型，如果表示 Long，可以在数字后面添加 L 或者小写 l 作为后缀。\n\n- 如果浮点数后面有f或者F后缀时，表示这是一个Float类型，否则就是一个Double类型的。\n\n#### 符号字面量\n\n- 也就是符号类型\n\n- 符号字面量被写成： '<标识符> ，这里 <标识符> 可以是任何字母或数字的标识（注意：不能以数字开头）。这种字面量被映射成预定义类scala.Symbol的实例。\n\n#### string类\n- 一个Array[String]类型的数据使用 .toString方法后得到的是一个java.lang.string类型的数据，这个数据直接print是这个Array的地址（一堆符号）\n\n- string类的substring方法，有两个参数，第一个参数为起始位置，第二个参数为结束位置，可以不写，默认为末尾\n\n- 通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。\n- Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：\n```\ngetClass().getName() + '@' + Integer.toHexString(hashCode())\n```\n\n- 将java.lang.string以可读的形式打印出来的方法：\n\n\n\n#### 元组类型（类似于Python中的元组）\n\n- 如果想要访问元组的内容，可以通过 `变量名._N`的方式进行。其中N表示元组中元素的索引号。 例：`tuple._1` 表示tuple中的第一个元素。\n\n- **注意：元组的访问元素的索引是从1开始，而且是不可改变的。**\n\n- 元组用 `==` 进行比较时，是进行内容的比较，这与String类型一致。\n\n#### 数组\n\n> 数组的索引是从0开始的\n\n- 声明格式：\n```\nval a: Array[String] = new Array[String](3)\n或者： val a = new Array[String](3)\n```\n- 赋值： `a(0) = \"abc\"`  //注意即使是声明为val变量，数组a的元素的值也是可以改变的。 **同时，使用索引时数组名后面跟的是圆括号而不是方括号，这点与C++不同，切记**\n\n- 可以使用foreach()方法实现遍历。\n![](/images/Scala/Scala-test.jpg)\n\n#### List\n\n- 创建List:\n```\nval a = List.apply(\"1\",\"2\",\"3\")\nval a: List[String] = List(\"1\",\"2\",\"3\")\n```\n\n## 流程控制结构\n---\n### 判断语句\n\n- if语句格式：\n```\nif(条件判断){\n\t[...] //条件判断为真时执行\n}\nelse{\n\t[...] //条件判断为假时执行\n}  //也可以写成 if(){...} else if(){...} 同C++\n```\n\n- 与Java，C++不同的是，Scala中if语句可以作为表达式使用。例：\n```\nscala> val x = if(\"hello\" == \"hell\") 1 else 0\nx: Int = 0\n```\n从这个例子可以看出，if是个表达式，其返回值可以给变量赋值。**Scala会将if语句的最后一条执行语句作为返回值**\n\n### 循环语句\n\n- while循环,do..while循环同C++\n\n- for循环格式：\n```\nfor(i <- 表达式){\n\t[...]\n}\n```\n\n- 示例：\n```\nfor(i <- 1 to 3){\n\tprintln(\"i = \" + i);\n}\n```\n- 结果： i = 1  i = 2  **i = 3** **(1 to 3 的集合是包含3的)**\n\n- 其中 '<-'被称为生成器（generator），for循环实际上是通过集合的遍历来达到循环的目的的。\n\n- 如果希望集合是右开的，可以使用`1 until 5`来实现，范围是[1,5)\n\n- 还可以设置for 循环的步长。例：\n```\nfor(i <- 1 until (10，2))\n\tprintln(\"i = \" + i);\n结果： i =1 i = 3 .... i = 9\n```\n\n- **不过，由于Scala是函数式编程，应当尽量使用迭代来代替循环**\n\n- 例如：使用 `标识符.foreach()`方法来实现对元素的遍历\n\n\n<br>\n\n> 最后更新于2018.5.27\n","source":"_posts/2018-04-06-Scala-learning.md","raw":"---\nlayout:     post\ntitle:      \"Scala学习笔记——基础\"\ndate:       2018-04-6 16:47:00\ncategories: Computer Programes\ntags: ๑Scala\n---\n\n> 不适合人类阅读的学习笔记  \n\n## 编译环境\n---\n- scala在终端中就可以调用解释器，与python类似，可以逐语句执行。使用命令`scala`即可进入终端解释器，使用命令`:q`或者`:quit`退出解释器。\n\n- 编译首选jetbrain的intellij IDEA，下载一个Scala plugin，然后选择创建maven工程，main函数应当写在object文件中，object通过创建Scala class文件选项创建。\n\n- 如果要写分布式处理程序的话，需要自己重写配置文件\n\n- Scala注释与C++类似\n\n### 让intellij默认不打开上个项目的方法\n\n- settings`>`Apperance&Behavior`>`System Settings 将`Reopen last project on startup` 勾去掉即可.\n\n## 在intellij IDEA下创建scala项目的步骤\n---\n\n- 首先，要确保已经安装了scala的插件(这个有很大概率会安装失败，如果失败次数太多可以选择离线安装，或者跳过scala sdk的选择，在进入一个scala项目之后选择补全)\n\n-  然后，在欢迎页面的右下角点击Configure，然后在Project Defaults的下拉菜单中选择Project Structure，在打开的页面左侧选择Global Libraries，然后在中间一栏中有一个绿色的加号标志 +，点击后在下拉菜单中选择 Scala SDK\n\n- 然后在打开的对话框中选择系统本身所安装的Scala（即System对应的版本），点击OK确定，这时候会在中间一栏位置处出现Scala的SDK，在其上右键点击后选择Copy to Project Libraries…，这个操作是为了将Scala SDK添加到项目的默认Library中去。\n\n\n- 在欢迎界面点击Create New Project，在打开的页面左侧边栏中，选择Maven，然后在右侧的Project SDK一项中，查看是否是正确的JDK配置项正常来说这一栏会自动填充的，因为我们之前在1.3中已经配置过了全局的Project JDK了，如果这里没有正常显示JDK的话，可以点击右侧的New…按钮，然后指定JDK安装路径的根目录即可）。**注意不要选择create from archetype**\n\n![](/images/Scala/create_1.png)\n\n- 然后点击Next，来到Maven项目最重要三个参数的设置页面，这三个参数分别为：GroupId, ArtifactId和Version.\n\n![](/images/Scala/create_2.png)\n\n### 创建Hello world\n![](/images/Scala/first_program.png)\n\n- 为了让体验Scala更清爽一些，将一些暂时无关的文件和文件夹都删除掉，主要有 main/java, main/resources 和 test 这三个文件夹\n\n- 将Scala的框架添加到这个项目中，方法是在左侧栏中的 **项目名称** 上右键菜单中点击 Add Framework Support…，然后在打开的对话框左侧边栏中，勾选Scala前面的复选框，然后点击确定即可（前提是上文中所述步骤都已正确走通，否则你很有可能看不到Scala这个选项的）；\n\n- 在main文件夹中建立一个名为 scala 的文件夹，并右键点击 scala 文件夹，选择 Make Directory as，然后选择Sources Root ，**这里主要意思是将 scala 文件夹标记为一个源文件的根目录，然后在其内的所有代码中的 package ，其路径就从这个根目录下开始算起**。\n\n- 在已经标记好为源文件根目录的 scala 文件夹 上，右键选择 New，然后选择 Scala Class，随后设置好程序的名称，并且记得将其设置为一个 Object(类似于Java中含有静态成员的静态类)，正常的话，将会打开这个 Object 代码界面，并且可以看到IntelliJ IDEA自动添加了一些最基本的信息；\n\n### 示例程序\n```\nobject HelloWorld {\n   def main(args: Array[String]) {\n      println(\"Hello, world!\") // 输出 Hello World\n   }\n}\n```\n\n### 执行scala程序\n\n- 脚本执行：我们可以将 Scala 表达式写在一个文件里，比如 Hello.scala。在命令行中直接输入 scala Hello.scala\n\n- 作为应用程序执行：作为应用程序执行时，我们需要在一个单例对象中定义入口函数 main，经过编译后就可以执行该应用程序了。\n\n## 基础\n---\n\n> scala的语句分号规则与C++相类似(一般都不用加，加了一般也不会错)\n\n> scala中的通配符为`_`，而C++中为`*``\n\n> scala与spark很契合，所以写spark程序推荐使用scala语言\n\n### 变量\n\n- Scala中变量分为可变变量和不可变变量。可变变量用关键字`var`修饰，不可变变量用`val`修饰。\n> 注意scala中变量定义时必须赋初始值\n\n- scala大多数数据结构中的变量默认为val类型\n\n- 特例：若用占位符`_`作为值进行初始化，则String类会被初始化为null,Float,Int,Double等被初始化为0,Char类型会被初始化为\"?\".\n\n- 如果用lazy关键字修饰变量，则他只有在真正被使用时才会被赋值。\n> 注意lazy关键字只能修饰val类型变量，不能修饰var类型\n\n## 输入输出\n### 输出：`print(\"...\")` 或者 `println(\"...\")`\n\n### 输入：\n> 注意，控制台的输入均为string类型，需要在后面加上.toInt  .toFloat等转换操作\n\n- 控制台输入：\n```\n val scan = scala.io.StdIn  //设置scan\n val n = scan.readLine.trim.toInt  //输入一个int\n val arr = scan.readLine.split(\" \").map(_.trim.toInt)  //输入一串数字，之间以空格间隔\n // .trim方法是去掉输入字符串两旁的空格\n```\n\n- scala还有一系列专门的用来读下 **一个** 输入并且可以自动转换的方法，例如：\n```\nval scan = scala.io.StdIn\nval myint = scan.readInt()\nval myfloat = scan.readFloat()\nval myboolean = scan.readBoolean()\n...\n//这些方法均可以读取下一个输入并且自动转换类型\n```\n\n### 排序\n- 例如：\n```\nval a = new Array[Int](3)\na(0)  =1\na(1) = 2\na(2) = 0\na.foreach(print)  //结果: 120\nval sorted_a = a.sortWith((x,y) => x > y)  //从大到小排序（sortWith的参数为一个lambda函数，返回一个布尔值用于比较）\na.foreach(print) //结果： 210\n```\n\n### 一些注意点\n\n- scala中没有 `++` 操作，可以用 `+= 1` 代替 `++`（x += y ，y可以是一个数字，也可以是一个数字变量，但不能是数组或是其他一些类似结构的某个元素）\n\n- Scala所有数据类型首字母都要大写，因为Scala中所有值类型都是对象，**其中布尔类型应写为“Boolean”**\n\n- Scala中有 `<=` 和 `>=` 以及逻辑与 `&&` 和逻辑或 `||` 运算符，与C++相同。\n\n- Scala中String类型就是Java中的String.lang.String类型，因此可以调用Java中String的所有方法（例：`str.reverse`表示字符逆序）\n\n- **Scala中有一类特殊的运算符 \"::\"(list构造)，\":::\"(list拼接)，他们是右操作。例如：a::b::Nill执行顺序为(a::(b::Nill))**\n\n### 一些数据类型\n\n#### 整型和浮点型\n - 整型字面量用于 Int 类型，如果表示 Long，可以在数字后面添加 L 或者小写 l 作为后缀。\n\n- 如果浮点数后面有f或者F后缀时，表示这是一个Float类型，否则就是一个Double类型的。\n\n#### 符号字面量\n\n- 也就是符号类型\n\n- 符号字面量被写成： '<标识符> ，这里 <标识符> 可以是任何字母或数字的标识（注意：不能以数字开头）。这种字面量被映射成预定义类scala.Symbol的实例。\n\n#### string类\n- 一个Array[String]类型的数据使用 .toString方法后得到的是一个java.lang.string类型的数据，这个数据直接print是这个Array的地址（一堆符号）\n\n- string类的substring方法，有两个参数，第一个参数为起始位置，第二个参数为结束位置，可以不写，默认为末尾\n\n- 通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。\n- Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：\n```\ngetClass().getName() + '@' + Integer.toHexString(hashCode())\n```\n\n- 将java.lang.string以可读的形式打印出来的方法：\n\n\n\n#### 元组类型（类似于Python中的元组）\n\n- 如果想要访问元组的内容，可以通过 `变量名._N`的方式进行。其中N表示元组中元素的索引号。 例：`tuple._1` 表示tuple中的第一个元素。\n\n- **注意：元组的访问元素的索引是从1开始，而且是不可改变的。**\n\n- 元组用 `==` 进行比较时，是进行内容的比较，这与String类型一致。\n\n#### 数组\n\n> 数组的索引是从0开始的\n\n- 声明格式：\n```\nval a: Array[String] = new Array[String](3)\n或者： val a = new Array[String](3)\n```\n- 赋值： `a(0) = \"abc\"`  //注意即使是声明为val变量，数组a的元素的值也是可以改变的。 **同时，使用索引时数组名后面跟的是圆括号而不是方括号，这点与C++不同，切记**\n\n- 可以使用foreach()方法实现遍历。\n![](/images/Scala/Scala-test.jpg)\n\n#### List\n\n- 创建List:\n```\nval a = List.apply(\"1\",\"2\",\"3\")\nval a: List[String] = List(\"1\",\"2\",\"3\")\n```\n\n## 流程控制结构\n---\n### 判断语句\n\n- if语句格式：\n```\nif(条件判断){\n\t[...] //条件判断为真时执行\n}\nelse{\n\t[...] //条件判断为假时执行\n}  //也可以写成 if(){...} else if(){...} 同C++\n```\n\n- 与Java，C++不同的是，Scala中if语句可以作为表达式使用。例：\n```\nscala> val x = if(\"hello\" == \"hell\") 1 else 0\nx: Int = 0\n```\n从这个例子可以看出，if是个表达式，其返回值可以给变量赋值。**Scala会将if语句的最后一条执行语句作为返回值**\n\n### 循环语句\n\n- while循环,do..while循环同C++\n\n- for循环格式：\n```\nfor(i <- 表达式){\n\t[...]\n}\n```\n\n- 示例：\n```\nfor(i <- 1 to 3){\n\tprintln(\"i = \" + i);\n}\n```\n- 结果： i = 1  i = 2  **i = 3** **(1 to 3 的集合是包含3的)**\n\n- 其中 '<-'被称为生成器（generator），for循环实际上是通过集合的遍历来达到循环的目的的。\n\n- 如果希望集合是右开的，可以使用`1 until 5`来实现，范围是[1,5)\n\n- 还可以设置for 循环的步长。例：\n```\nfor(i <- 1 until (10，2))\n\tprintln(\"i = \" + i);\n结果： i =1 i = 3 .... i = 9\n```\n\n- **不过，由于Scala是函数式编程，应当尽量使用迭代来代替循环**\n\n- 例如：使用 `标识符.foreach()`方法来实现对元素的遍历\n\n\n<br>\n\n> 最后更新于2018.5.27\n","slug":"2018-04-06-Scala-learning","published":1,"updated":"2018-09-03T13:24:23.616Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4b000j1m0osyn6stvu","content":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"编译环境\"><a href=\"#编译环境\" class=\"headerlink\" title=\"编译环境\"></a>编译环境</h2><hr>\n<ul>\n<li><p>scala在终端中就可以调用解释器，与python类似，可以逐语句执行。使用命令<code>scala</code>即可进入终端解释器，使用命令<code>:q</code>或者<code>:quit</code>退出解释器。</p>\n</li>\n<li><p>编译首选jetbrain的intellij IDEA，下载一个Scala plugin，然后选择创建maven工程，main函数应当写在object文件中，object通过创建Scala class文件选项创建。</p>\n</li>\n<li><p>如果要写分布式处理程序的话，需要自己重写配置文件</p>\n</li>\n<li><p>Scala注释与C++类似</p>\n</li>\n</ul>\n<h3 id=\"让intellij默认不打开上个项目的方法\"><a href=\"#让intellij默认不打开上个项目的方法\" class=\"headerlink\" title=\"让intellij默认不打开上个项目的方法\"></a>让intellij默认不打开上个项目的方法</h3><ul>\n<li>settings<code>&gt;</code>Apperance&amp;Behavior<code>&gt;</code>System Settings 将<code>Reopen last project on startup</code> 勾去掉即可.</li>\n</ul>\n<h2 id=\"在intellij-IDEA下创建scala项目的步骤\"><a href=\"#在intellij-IDEA下创建scala项目的步骤\" class=\"headerlink\" title=\"在intellij IDEA下创建scala项目的步骤\"></a>在intellij IDEA下创建scala项目的步骤</h2><hr>\n<ul>\n<li><p>首先，要确保已经安装了scala的插件(这个有很大概率会安装失败，如果失败次数太多可以选择离线安装，或者跳过scala sdk的选择，在进入一个scala项目之后选择补全)</p>\n</li>\n<li><p>然后，在欢迎页面的右下角点击Configure，然后在Project Defaults的下拉菜单中选择Project Structure，在打开的页面左侧选择Global Libraries，然后在中间一栏中有一个绿色的加号标志 +，点击后在下拉菜单中选择 Scala SDK</p>\n</li>\n<li><p>然后在打开的对话框中选择系统本身所安装的Scala（即System对应的版本），点击OK确定，这时候会在中间一栏位置处出现Scala的SDK，在其上右键点击后选择Copy to Project Libraries…，这个操作是为了将Scala SDK添加到项目的默认Library中去。</p>\n</li>\n</ul>\n<ul>\n<li>在欢迎界面点击Create New Project，在打开的页面左侧边栏中，选择Maven，然后在右侧的Project SDK一项中，查看是否是正确的JDK配置项正常来说这一栏会自动填充的，因为我们之前在1.3中已经配置过了全局的Project JDK了，如果这里没有正常显示JDK的话，可以点击右侧的New…按钮，然后指定JDK安装路径的根目录即可）。<strong>注意不要选择create from archetype</strong></li>\n</ul>\n<p><img src=\"/images/Scala/create_1.png\" alt=\"\"></p>\n<ul>\n<li>然后点击Next，来到Maven项目最重要三个参数的设置页面，这三个参数分别为：GroupId, ArtifactId和Version.</li>\n</ul>\n<p><img src=\"/images/Scala/create_2.png\" alt=\"\"></p>\n<h3 id=\"创建Hello-world\"><a href=\"#创建Hello-world\" class=\"headerlink\" title=\"创建Hello world\"></a>创建Hello world</h3><p><img src=\"/images/Scala/first_program.png\" alt=\"\"></p>\n<ul>\n<li><p>为了让体验Scala更清爽一些，将一些暂时无关的文件和文件夹都删除掉，主要有 main/java, main/resources 和 test 这三个文件夹</p>\n</li>\n<li><p>将Scala的框架添加到这个项目中，方法是在左侧栏中的 <strong>项目名称</strong> 上右键菜单中点击 Add Framework Support…，然后在打开的对话框左侧边栏中，勾选Scala前面的复选框，然后点击确定即可（前提是上文中所述步骤都已正确走通，否则你很有可能看不到Scala这个选项的）；</p>\n</li>\n<li><p>在main文件夹中建立一个名为 scala 的文件夹，并右键点击 scala 文件夹，选择 Make Directory as，然后选择Sources Root ，<strong>这里主要意思是将 scala 文件夹标记为一个源文件的根目录，然后在其内的所有代码中的 package ，其路径就从这个根目录下开始算起</strong>。</p>\n</li>\n<li><p>在已经标记好为源文件根目录的 scala 文件夹 上，右键选择 New，然后选择 Scala Class，随后设置好程序的名称，并且记得将其设置为一个 Object(类似于Java中含有静态成员的静态类)，正常的话，将会打开这个 Object 代码界面，并且可以看到IntelliJ IDEA自动添加了一些最基本的信息；</p>\n</li>\n</ul>\n<h3 id=\"示例程序\"><a href=\"#示例程序\" class=\"headerlink\" title=\"示例程序\"></a>示例程序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object HelloWorld &#123;</span><br><span class=\"line\">   def main(args: Array[String]) &#123;</span><br><span class=\"line\">      println(&quot;Hello, world!&quot;) // 输出 Hello World</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行scala程序\"><a href=\"#执行scala程序\" class=\"headerlink\" title=\"执行scala程序\"></a>执行scala程序</h3><ul>\n<li><p>脚本执行：我们可以将 Scala 表达式写在一个文件里，比如 Hello.scala。在命令行中直接输入 scala Hello.scala</p>\n</li>\n<li><p>作为应用程序执行：作为应用程序执行时，我们需要在一个单例对象中定义入口函数 main，经过编译后就可以执行该应用程序了。</p>\n</li>\n</ul>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><hr>\n<blockquote>\n<p>scala的语句分号规则与C++相类似(一般都不用加，加了一般也不会错)</p>\n</blockquote>\n<blockquote>\n<p>scala中的通配符为<code>_</code>，而C++中为<code>*`</code></p>\n</blockquote>\n<blockquote>\n<p>scala与spark很契合，所以写spark程序推荐使用scala语言</p>\n</blockquote>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ul>\n<li><p>Scala中变量分为可变变量和不可变变量。可变变量用关键字<code>var</code>修饰，不可变变量用<code>val</code>修饰。</p>\n<blockquote>\n<p>注意scala中变量定义时必须赋初始值</p>\n</blockquote>\n</li>\n<li><p>scala大多数数据结构中的变量默认为val类型</p>\n</li>\n<li><p>特例：若用占位符<code>_</code>作为值进行初始化，则String类会被初始化为null,Float,Int,Double等被初始化为0,Char类型会被初始化为”?”.</p>\n</li>\n<li><p>如果用lazy关键字修饰变量，则他只有在真正被使用时才会被赋值。</p>\n<blockquote>\n<p>注意lazy关键字只能修饰val类型变量，不能修饰var类型</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h2><h3 id=\"输出：print-quot-quot-或者-println-quot-quot\"><a href=\"#输出：print-quot-quot-或者-println-quot-quot\" class=\"headerlink\" title=\"输出：print(&quot;...&quot;) 或者 println(&quot;...&quot;)\"></a>输出：<code>print(&quot;...&quot;)</code> 或者 <code>println(&quot;...&quot;)</code></h3><h3 id=\"输入：\"><a href=\"#输入：\" class=\"headerlink\" title=\"输入：\"></a>输入：</h3><blockquote>\n<p>注意，控制台的输入均为string类型，需要在后面加上.toInt  .toFloat等转换操作</p>\n</blockquote>\n<ul>\n<li><p>控制台输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val scan = scala.io.StdIn  //设置scan</span><br><span class=\"line\">val n = scan.readLine.trim.toInt  //输入一个int</span><br><span class=\"line\">val arr = scan.readLine.split(&quot; &quot;).map(_.trim.toInt)  //输入一串数字，之间以空格间隔</span><br><span class=\"line\">// .trim方法是去掉输入字符串两旁的空格</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scala还有一系列专门的用来读下 <strong>一个</strong> 输入并且可以自动转换的方法，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val scan = scala.io.StdIn</span><br><span class=\"line\">val myint = scan.readInt()</span><br><span class=\"line\">val myfloat = scan.readFloat()</span><br><span class=\"line\">val myboolean = scan.readBoolean()</span><br><span class=\"line\">...</span><br><span class=\"line\">//这些方法均可以读取下一个输入并且自动转换类型</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><ul>\n<li>例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val a = new Array[Int](3)</span><br><span class=\"line\">a(0)  =1</span><br><span class=\"line\">a(1) = 2</span><br><span class=\"line\">a(2) = 0</span><br><span class=\"line\">a.foreach(print)  //结果: 120</span><br><span class=\"line\">val sorted_a = a.sortWith((x,y) =&gt; x &gt; y)  //从大到小排序（sortWith的参数为一个lambda函数，返回一个布尔值用于比较）</span><br><span class=\"line\">a.foreach(print) //结果： 210</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"一些注意点\"><a href=\"#一些注意点\" class=\"headerlink\" title=\"一些注意点\"></a>一些注意点</h3><ul>\n<li><p>scala中没有 <code>++</code> 操作，可以用 <code>+= 1</code> 代替 <code>++</code>（x += y ，y可以是一个数字，也可以是一个数字变量，但不能是数组或是其他一些类似结构的某个元素）</p>\n</li>\n<li><p>Scala所有数据类型首字母都要大写，因为Scala中所有值类型都是对象，<strong>其中布尔类型应写为“Boolean”</strong></p>\n</li>\n<li><p>Scala中有 <code>&lt;=</code> 和 <code>&gt;=</code> 以及逻辑与 <code>&amp;&amp;</code> 和逻辑或 <code>||</code> 运算符，与C++相同。</p>\n</li>\n<li><p>Scala中String类型就是Java中的String.lang.String类型，因此可以调用Java中String的所有方法（例：<code>str.reverse</code>表示字符逆序）</p>\n</li>\n<li><p><strong>Scala中有一类特殊的运算符 “::”(list构造)，”:::”(list拼接)，他们是右操作。例如：a::b::Nill执行顺序为(a::(b::Nill))</strong></p>\n</li>\n</ul>\n<h3 id=\"一些数据类型\"><a href=\"#一些数据类型\" class=\"headerlink\" title=\"一些数据类型\"></a>一些数据类型</h3><h4 id=\"整型和浮点型\"><a href=\"#整型和浮点型\" class=\"headerlink\" title=\"整型和浮点型\"></a>整型和浮点型</h4><ul>\n<li>整型字面量用于 Int 类型，如果表示 Long，可以在数字后面添加 L 或者小写 l 作为后缀。</li>\n</ul>\n<ul>\n<li>如果浮点数后面有f或者F后缀时，表示这是一个Float类型，否则就是一个Double类型的。</li>\n</ul>\n<h4 id=\"符号字面量\"><a href=\"#符号字面量\" class=\"headerlink\" title=\"符号字面量\"></a>符号字面量</h4><ul>\n<li><p>也就是符号类型</p>\n</li>\n<li><p>符号字面量被写成： ‘&lt;标识符&gt; ，这里 &lt;标识符&gt; 可以是任何字母或数字的标识（注意：不能以数字开头）。这种字面量被映射成预定义类scala.Symbol的实例。</p>\n</li>\n</ul>\n<h4 id=\"string类\"><a href=\"#string类\" class=\"headerlink\" title=\"string类\"></a>string类</h4><ul>\n<li><p>一个Array[String]类型的数据使用 .toString方法后得到的是一个java.lang.string类型的数据，这个数据直接print是这个Array的地址（一堆符号）</p>\n</li>\n<li><p>string类的substring方法，有两个参数，第一个参数为起始位置，第二个参数为结束位置，可以不写，默认为末尾</p>\n</li>\n<li><p>通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。</p>\n</li>\n<li><p>Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getClass().getName() + &apos;@&apos; + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将java.lang.string以可读的形式打印出来的方法：</p>\n</li>\n</ul>\n<h4 id=\"元组类型（类似于Python中的元组）\"><a href=\"#元组类型（类似于Python中的元组）\" class=\"headerlink\" title=\"元组类型（类似于Python中的元组）\"></a>元组类型（类似于Python中的元组）</h4><ul>\n<li><p>如果想要访问元组的内容，可以通过 <code>变量名._N</code>的方式进行。其中N表示元组中元素的索引号。 例：<code>tuple._1</code> 表示tuple中的第一个元素。</p>\n</li>\n<li><p><strong>注意：元组的访问元素的索引是从1开始，而且是不可改变的。</strong></p>\n</li>\n<li><p>元组用 <code>==</code> 进行比较时，是进行内容的比较，这与String类型一致。</p>\n</li>\n</ul>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><blockquote>\n<p>数组的索引是从0开始的</p>\n</blockquote>\n<ul>\n<li><p>声明格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val a: Array[String] = new Array[String](3)</span><br><span class=\"line\">或者： val a = new Array[String](3)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>赋值： <code>a(0) = &quot;abc&quot;</code>  //注意即使是声明为val变量，数组a的元素的值也是可以改变的。 <strong>同时，使用索引时数组名后面跟的是圆括号而不是方括号，这点与C++不同，切记</strong></p>\n</li>\n<li><p>可以使用foreach()方法实现遍历。<br><img src=\"/images/Scala/Scala-test.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h4 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h4><ul>\n<li>创建List:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val a = List.apply(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)</span><br><span class=\"line\">val a: List[String] = List(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"流程控制结构\"><a href=\"#流程控制结构\" class=\"headerlink\" title=\"流程控制结构\"></a>流程控制结构</h2><hr>\n<h3 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h3><ul>\n<li><p>if语句格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(条件判断)&#123;</span><br><span class=\"line\">\t[...] //条件判断为真时执行</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else&#123;</span><br><span class=\"line\">\t[...] //条件判断为假时执行</span><br><span class=\"line\">&#125;  //也可以写成 if()&#123;...&#125; else if()&#123;...&#125; 同C++</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>与Java，C++不同的是，Scala中if语句可以作为表达式使用。例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; val x = if(&quot;hello&quot; == &quot;hell&quot;) 1 else 0</span><br><span class=\"line\">x: Int = 0</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>从这个例子可以看出，if是个表达式，其返回值可以给变量赋值。<strong>Scala会将if语句的最后一条执行语句作为返回值</strong></p>\n<h3 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h3><ul>\n<li><p>while循环,do..while循环同C++</p>\n</li>\n<li><p>for循环格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(i &lt;- 表达式)&#123;</span><br><span class=\"line\">\t[...]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(i &lt;- 1 to 3)&#123;</span><br><span class=\"line\">\tprintln(&quot;i = &quot; + i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>结果： i = 1  i = 2  <strong>i = 3</strong> <strong>(1 to 3 的集合是包含3的)</strong></p>\n</li>\n<li><p>其中 ‘&lt;-‘被称为生成器（generator），for循环实际上是通过集合的遍历来达到循环的目的的。</p>\n</li>\n<li><p>如果希望集合是右开的，可以使用<code>1 until 5</code>来实现，范围是[1,5)</p>\n</li>\n<li><p>还可以设置for 循环的步长。例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(i &lt;- 1 until (10，2))</span><br><span class=\"line\">\tprintln(&quot;i = &quot; + i);</span><br><span class=\"line\">结果： i =1 i = 3 .... i = 9</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>不过，由于Scala是函数式编程，应当尽量使用迭代来代替循环</strong></p>\n</li>\n<li><p>例如：使用 <code>标识符.foreach()</code>方法来实现对元素的遍历</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.27</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"编译环境\"><a href=\"#编译环境\" class=\"headerlink\" title=\"编译环境\"></a>编译环境</h2><hr>\n<ul>\n<li><p>scala在终端中就可以调用解释器，与python类似，可以逐语句执行。使用命令<code>scala</code>即可进入终端解释器，使用命令<code>:q</code>或者<code>:quit</code>退出解释器。</p>\n</li>\n<li><p>编译首选jetbrain的intellij IDEA，下载一个Scala plugin，然后选择创建maven工程，main函数应当写在object文件中，object通过创建Scala class文件选项创建。</p>\n</li>\n<li><p>如果要写分布式处理程序的话，需要自己重写配置文件</p>\n</li>\n<li><p>Scala注释与C++类似</p>\n</li>\n</ul>\n<h3 id=\"让intellij默认不打开上个项目的方法\"><a href=\"#让intellij默认不打开上个项目的方法\" class=\"headerlink\" title=\"让intellij默认不打开上个项目的方法\"></a>让intellij默认不打开上个项目的方法</h3><ul>\n<li>settings<code>&gt;</code>Apperance&amp;Behavior<code>&gt;</code>System Settings 将<code>Reopen last project on startup</code> 勾去掉即可.</li>\n</ul>\n<h2 id=\"在intellij-IDEA下创建scala项目的步骤\"><a href=\"#在intellij-IDEA下创建scala项目的步骤\" class=\"headerlink\" title=\"在intellij IDEA下创建scala项目的步骤\"></a>在intellij IDEA下创建scala项目的步骤</h2><hr>\n<ul>\n<li><p>首先，要确保已经安装了scala的插件(这个有很大概率会安装失败，如果失败次数太多可以选择离线安装，或者跳过scala sdk的选择，在进入一个scala项目之后选择补全)</p>\n</li>\n<li><p>然后，在欢迎页面的右下角点击Configure，然后在Project Defaults的下拉菜单中选择Project Structure，在打开的页面左侧选择Global Libraries，然后在中间一栏中有一个绿色的加号标志 +，点击后在下拉菜单中选择 Scala SDK</p>\n</li>\n<li><p>然后在打开的对话框中选择系统本身所安装的Scala（即System对应的版本），点击OK确定，这时候会在中间一栏位置处出现Scala的SDK，在其上右键点击后选择Copy to Project Libraries…，这个操作是为了将Scala SDK添加到项目的默认Library中去。</p>\n</li>\n</ul>\n<ul>\n<li>在欢迎界面点击Create New Project，在打开的页面左侧边栏中，选择Maven，然后在右侧的Project SDK一项中，查看是否是正确的JDK配置项正常来说这一栏会自动填充的，因为我们之前在1.3中已经配置过了全局的Project JDK了，如果这里没有正常显示JDK的话，可以点击右侧的New…按钮，然后指定JDK安装路径的根目录即可）。<strong>注意不要选择create from archetype</strong></li>\n</ul>\n<p><img src=\"/images/Scala/create_1.png\" alt=\"\"></p>\n<ul>\n<li>然后点击Next，来到Maven项目最重要三个参数的设置页面，这三个参数分别为：GroupId, ArtifactId和Version.</li>\n</ul>\n<p><img src=\"/images/Scala/create_2.png\" alt=\"\"></p>\n<h3 id=\"创建Hello-world\"><a href=\"#创建Hello-world\" class=\"headerlink\" title=\"创建Hello world\"></a>创建Hello world</h3><p><img src=\"/images/Scala/first_program.png\" alt=\"\"></p>\n<ul>\n<li><p>为了让体验Scala更清爽一些，将一些暂时无关的文件和文件夹都删除掉，主要有 main/java, main/resources 和 test 这三个文件夹</p>\n</li>\n<li><p>将Scala的框架添加到这个项目中，方法是在左侧栏中的 <strong>项目名称</strong> 上右键菜单中点击 Add Framework Support…，然后在打开的对话框左侧边栏中，勾选Scala前面的复选框，然后点击确定即可（前提是上文中所述步骤都已正确走通，否则你很有可能看不到Scala这个选项的）；</p>\n</li>\n<li><p>在main文件夹中建立一个名为 scala 的文件夹，并右键点击 scala 文件夹，选择 Make Directory as，然后选择Sources Root ，<strong>这里主要意思是将 scala 文件夹标记为一个源文件的根目录，然后在其内的所有代码中的 package ，其路径就从这个根目录下开始算起</strong>。</p>\n</li>\n<li><p>在已经标记好为源文件根目录的 scala 文件夹 上，右键选择 New，然后选择 Scala Class，随后设置好程序的名称，并且记得将其设置为一个 Object(类似于Java中含有静态成员的静态类)，正常的话，将会打开这个 Object 代码界面，并且可以看到IntelliJ IDEA自动添加了一些最基本的信息；</p>\n</li>\n</ul>\n<h3 id=\"示例程序\"><a href=\"#示例程序\" class=\"headerlink\" title=\"示例程序\"></a>示例程序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object HelloWorld &#123;</span><br><span class=\"line\">   def main(args: Array[String]) &#123;</span><br><span class=\"line\">      println(&quot;Hello, world!&quot;) // 输出 Hello World</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"执行scala程序\"><a href=\"#执行scala程序\" class=\"headerlink\" title=\"执行scala程序\"></a>执行scala程序</h3><ul>\n<li><p>脚本执行：我们可以将 Scala 表达式写在一个文件里，比如 Hello.scala。在命令行中直接输入 scala Hello.scala</p>\n</li>\n<li><p>作为应用程序执行：作为应用程序执行时，我们需要在一个单例对象中定义入口函数 main，经过编译后就可以执行该应用程序了。</p>\n</li>\n</ul>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><hr>\n<blockquote>\n<p>scala的语句分号规则与C++相类似(一般都不用加，加了一般也不会错)</p>\n</blockquote>\n<blockquote>\n<p>scala中的通配符为<code>_</code>，而C++中为<code>*`</code></p>\n</blockquote>\n<blockquote>\n<p>scala与spark很契合，所以写spark程序推荐使用scala语言</p>\n</blockquote>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ul>\n<li><p>Scala中变量分为可变变量和不可变变量。可变变量用关键字<code>var</code>修饰，不可变变量用<code>val</code>修饰。</p>\n<blockquote>\n<p>注意scala中变量定义时必须赋初始值</p>\n</blockquote>\n</li>\n<li><p>scala大多数数据结构中的变量默认为val类型</p>\n</li>\n<li><p>特例：若用占位符<code>_</code>作为值进行初始化，则String类会被初始化为null,Float,Int,Double等被初始化为0,Char类型会被初始化为”?”.</p>\n</li>\n<li><p>如果用lazy关键字修饰变量，则他只有在真正被使用时才会被赋值。</p>\n<blockquote>\n<p>注意lazy关键字只能修饰val类型变量，不能修饰var类型</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h2><h3 id=\"输出：print-quot-quot-或者-println-quot-quot\"><a href=\"#输出：print-quot-quot-或者-println-quot-quot\" class=\"headerlink\" title=\"输出：print(&quot;...&quot;) 或者 println(&quot;...&quot;)\"></a>输出：<code>print(&quot;...&quot;)</code> 或者 <code>println(&quot;...&quot;)</code></h3><h3 id=\"输入：\"><a href=\"#输入：\" class=\"headerlink\" title=\"输入：\"></a>输入：</h3><blockquote>\n<p>注意，控制台的输入均为string类型，需要在后面加上.toInt  .toFloat等转换操作</p>\n</blockquote>\n<ul>\n<li><p>控制台输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val scan = scala.io.StdIn  //设置scan</span><br><span class=\"line\">val n = scan.readLine.trim.toInt  //输入一个int</span><br><span class=\"line\">val arr = scan.readLine.split(&quot; &quot;).map(_.trim.toInt)  //输入一串数字，之间以空格间隔</span><br><span class=\"line\">// .trim方法是去掉输入字符串两旁的空格</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scala还有一系列专门的用来读下 <strong>一个</strong> 输入并且可以自动转换的方法，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val scan = scala.io.StdIn</span><br><span class=\"line\">val myint = scan.readInt()</span><br><span class=\"line\">val myfloat = scan.readFloat()</span><br><span class=\"line\">val myboolean = scan.readBoolean()</span><br><span class=\"line\">...</span><br><span class=\"line\">//这些方法均可以读取下一个输入并且自动转换类型</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><ul>\n<li>例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val a = new Array[Int](3)</span><br><span class=\"line\">a(0)  =1</span><br><span class=\"line\">a(1) = 2</span><br><span class=\"line\">a(2) = 0</span><br><span class=\"line\">a.foreach(print)  //结果: 120</span><br><span class=\"line\">val sorted_a = a.sortWith((x,y) =&gt; x &gt; y)  //从大到小排序（sortWith的参数为一个lambda函数，返回一个布尔值用于比较）</span><br><span class=\"line\">a.foreach(print) //结果： 210</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"一些注意点\"><a href=\"#一些注意点\" class=\"headerlink\" title=\"一些注意点\"></a>一些注意点</h3><ul>\n<li><p>scala中没有 <code>++</code> 操作，可以用 <code>+= 1</code> 代替 <code>++</code>（x += y ，y可以是一个数字，也可以是一个数字变量，但不能是数组或是其他一些类似结构的某个元素）</p>\n</li>\n<li><p>Scala所有数据类型首字母都要大写，因为Scala中所有值类型都是对象，<strong>其中布尔类型应写为“Boolean”</strong></p>\n</li>\n<li><p>Scala中有 <code>&lt;=</code> 和 <code>&gt;=</code> 以及逻辑与 <code>&amp;&amp;</code> 和逻辑或 <code>||</code> 运算符，与C++相同。</p>\n</li>\n<li><p>Scala中String类型就是Java中的String.lang.String类型，因此可以调用Java中String的所有方法（例：<code>str.reverse</code>表示字符逆序）</p>\n</li>\n<li><p><strong>Scala中有一类特殊的运算符 “::”(list构造)，”:::”(list拼接)，他们是右操作。例如：a::b::Nill执行顺序为(a::(b::Nill))</strong></p>\n</li>\n</ul>\n<h3 id=\"一些数据类型\"><a href=\"#一些数据类型\" class=\"headerlink\" title=\"一些数据类型\"></a>一些数据类型</h3><h4 id=\"整型和浮点型\"><a href=\"#整型和浮点型\" class=\"headerlink\" title=\"整型和浮点型\"></a>整型和浮点型</h4><ul>\n<li>整型字面量用于 Int 类型，如果表示 Long，可以在数字后面添加 L 或者小写 l 作为后缀。</li>\n</ul>\n<ul>\n<li>如果浮点数后面有f或者F后缀时，表示这是一个Float类型，否则就是一个Double类型的。</li>\n</ul>\n<h4 id=\"符号字面量\"><a href=\"#符号字面量\" class=\"headerlink\" title=\"符号字面量\"></a>符号字面量</h4><ul>\n<li><p>也就是符号类型</p>\n</li>\n<li><p>符号字面量被写成： ‘&lt;标识符&gt; ，这里 &lt;标识符&gt; 可以是任何字母或数字的标识（注意：不能以数字开头）。这种字面量被映射成预定义类scala.Symbol的实例。</p>\n</li>\n</ul>\n<h4 id=\"string类\"><a href=\"#string类\" class=\"headerlink\" title=\"string类\"></a>string类</h4><ul>\n<li><p>一个Array[String]类型的数据使用 .toString方法后得到的是一个java.lang.string类型的数据，这个数据直接print是这个Array的地址（一堆符号）</p>\n</li>\n<li><p>string类的substring方法，有两个参数，第一个参数为起始位置，第二个参数为结束位置，可以不写，默认为末尾</p>\n</li>\n<li><p>通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。</p>\n</li>\n<li><p>Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getClass().getName() + &apos;@&apos; + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将java.lang.string以可读的形式打印出来的方法：</p>\n</li>\n</ul>\n<h4 id=\"元组类型（类似于Python中的元组）\"><a href=\"#元组类型（类似于Python中的元组）\" class=\"headerlink\" title=\"元组类型（类似于Python中的元组）\"></a>元组类型（类似于Python中的元组）</h4><ul>\n<li><p>如果想要访问元组的内容，可以通过 <code>变量名._N</code>的方式进行。其中N表示元组中元素的索引号。 例：<code>tuple._1</code> 表示tuple中的第一个元素。</p>\n</li>\n<li><p><strong>注意：元组的访问元素的索引是从1开始，而且是不可改变的。</strong></p>\n</li>\n<li><p>元组用 <code>==</code> 进行比较时，是进行内容的比较，这与String类型一致。</p>\n</li>\n</ul>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><blockquote>\n<p>数组的索引是从0开始的</p>\n</blockquote>\n<ul>\n<li><p>声明格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val a: Array[String] = new Array[String](3)</span><br><span class=\"line\">或者： val a = new Array[String](3)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>赋值： <code>a(0) = &quot;abc&quot;</code>  //注意即使是声明为val变量，数组a的元素的值也是可以改变的。 <strong>同时，使用索引时数组名后面跟的是圆括号而不是方括号，这点与C++不同，切记</strong></p>\n</li>\n<li><p>可以使用foreach()方法实现遍历。<br><img src=\"/images/Scala/Scala-test.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h4 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h4><ul>\n<li>创建List:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val a = List.apply(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)</span><br><span class=\"line\">val a: List[String] = List(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"流程控制结构\"><a href=\"#流程控制结构\" class=\"headerlink\" title=\"流程控制结构\"></a>流程控制结构</h2><hr>\n<h3 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h3><ul>\n<li><p>if语句格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(条件判断)&#123;</span><br><span class=\"line\">\t[...] //条件判断为真时执行</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else&#123;</span><br><span class=\"line\">\t[...] //条件判断为假时执行</span><br><span class=\"line\">&#125;  //也可以写成 if()&#123;...&#125; else if()&#123;...&#125; 同C++</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>与Java，C++不同的是，Scala中if语句可以作为表达式使用。例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; val x = if(&quot;hello&quot; == &quot;hell&quot;) 1 else 0</span><br><span class=\"line\">x: Int = 0</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>从这个例子可以看出，if是个表达式，其返回值可以给变量赋值。<strong>Scala会将if语句的最后一条执行语句作为返回值</strong></p>\n<h3 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h3><ul>\n<li><p>while循环,do..while循环同C++</p>\n</li>\n<li><p>for循环格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(i &lt;- 表达式)&#123;</span><br><span class=\"line\">\t[...]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(i &lt;- 1 to 3)&#123;</span><br><span class=\"line\">\tprintln(&quot;i = &quot; + i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>结果： i = 1  i = 2  <strong>i = 3</strong> <strong>(1 to 3 的集合是包含3的)</strong></p>\n</li>\n<li><p>其中 ‘&lt;-‘被称为生成器（generator），for循环实际上是通过集合的遍历来达到循环的目的的。</p>\n</li>\n<li><p>如果希望集合是右开的，可以使用<code>1 until 5</code>来实现，范围是[1,5)</p>\n</li>\n<li><p>还可以设置for 循环的步长。例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(i &lt;- 1 until (10，2))</span><br><span class=\"line\">\tprintln(&quot;i = &quot; + i);</span><br><span class=\"line\">结果： i =1 i = 3 .... i = 9</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>不过，由于Scala是函数式编程，应当尽量使用迭代来代替循环</strong></p>\n</li>\n<li><p>例如：使用 <code>标识符.foreach()</code>方法来实现对元素的遍历</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.27</p>\n</blockquote>\n"},{"layout":"post","title":"Ubuntu随笔","date":"2018-04-06T08:47:00.000Z","_content":"\n> 不适合人类阅读的备忘笔记\n\n## Ubuntu目录结构\n\n- `/`:这就是根目录，一台电脑有且只有一个根目录，所有的文件都是从这里开始的。举个例子：当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。\n\n- `/root`:系统管理员（root user）的目录。至于系统管理员的权限有多大我这里就不在废话了。因此，请小心使用root帐号。\n\n- `/boot`: 系统启动文件，所有与系统启动有关的文件都保存在这里 。\n\n- `/bin`: 这里是存放系统的程序。\n\n- `/etc`:主要存放了系统配置方面的文件。\n\n- `/dev`:这里主要存放与设备（包括外设）有关的文件（unix和linux系统均把设备当成文件）。想连线打印机吗？系统就是从这个目录开始工作的。另外还有一些包括磁盘驱动、USB驱动等都放在这个目录。\n\n- `/home`:这里主要存放你的个人数据。具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root用户除外。\n\n- `/tmp`:这是临时目录。对于某些程序来说，有些文件被用了一次两次之后，就不会再被用到，像这样的文件就放在这里。因此，千万不要把重要的数据放在这里哦。\n\n- `/usr`:在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序；/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等；/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器会自动帮你管理好/usr目录的。\n\n- `/opt`:这里主要存放一些可选的程序。如你想尝试最新的firefox测试版吗？那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就 可以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。\n\n- `usr/local`:这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts）放到/usr/local目录下面。\n\n- `/media`:这个目录是用来挂载那些usb接口的移动硬盘（包括U盘）、CD/DVD驱动器等等。\n\n## 一些推荐的软件\n---\n>  一旦出现某个软件没有安装，Linux系统大多数情况下都会提示你怎样安装这个软件，最常用的就是 sudo apt-get install XXX 命令\n\n-  fish! fish! fish!： fish大法好啊，功能强大，自动补全，Ubuntu最好用的软件之一。\n\n- vim和gedit：这个不用我多说大家都知道，Linux非常好用的编辑软件\n\n- [atom](https://atom.io/)  //集成许多功能于一体的编辑器\n\n- [SpaceVim](https://zhuanlan.zhihu.com/p/24802058)模块化Vim-IDE。[使用手册](https://spacevim.org/cn/documentation/)\n\n- gnome 桌面： 装了gnome桌面和它的一系列插件之后我才真正感受到了Ubuntu的魅力！（教程以及主题百度很多）\n\n- docky: 一款mac风格的dock,删除图标直接拉出去(sudo apt-get install docky)\n\n- tweak-tool: 与gnome桌面对应的是tweak-tool(sudo apt install unity-tweak-tool)\n\n- yakuake : 可以从上方一键滑出和滑入的终端（滑出时强制窗口在最前端）（gnome中也有类似功能的插件，两个选一个即可）\n\n- Moeditor: Ubuntu下界面简洁美观，功能强大的markdown格式文件编辑器，已经在github上开源\n\n- processon： 一个网页上的设计工具，可以很简单地完成诸如流程图的设计和生成图片文件。\n\n## 一些注意点\n---\n\n- **F11键可以进入全屏模式**\n\n- 触摸板双击之后再移动就相当于长按鼠标左键的效果了\n\n- 在Ubuntu终端窗口中，复制粘贴的快捷键需要加上 shift，即粘贴是 ctrl+shift+v。\n\n- ssh cyx@192.168.1.201 cyx  高性能服务器  WIFI:sklcc_slave\n\n- 192.168.1.201:18080\n- 192.168.1.201:18088 进程\n- 192.168.1.201:50070 hdfs\n\n\n### 关于添加Ubuntu的本地ssh-key与github相关联\n\n- 首先检测本地有没有安装ssh  `终端输入ssh`\n\n- 然后终端执行`ssh-kengen -t rsa`，连续三次默认回车就行。接着 ~/.ssh目录下就会多出来两个文件：`id_rsa`和`id_rsa.pub`\n\n- 接着只要在github上添加`id_rsa.pub`这个key就行了。在github的setting中，找到sshkey一栏，选择new key，将`id_rsa.pub`的文件内容复制到里面，随便起个title即可。\n\n\n### 关于挂载本地的卷到Ubuntu\n\n- 使用`mount /dev/卷名  /挂载点`   //将某个卷挂载到某个文件目录下，该卷就可以在这个文件目录下访问了。\n\n- Ubuntu中，所有的硬件设备都是作为文件存储的，这一点与Windows不同。\n\n### 关于桌面快捷方式的创建\n\n- 方法一：进入 /usr/share/applications/ 目录，里面会有**绝大多数**你安装的软件的 .desktop文件，只需要把你需要的软件的 .desktop文件复制到home目录下的 桌面文件夹里即可。\n\n- 方法二： 有点蠢但是很简单的一个方法。对于那些没有安装直接可以使用的软件，我们在上个方法中提到的文件夹里是找不到 .desktop文件的。怎么办呢？我们只需要进入我们那个软件的目录，找到启动文件，创建一个它的链接文件（右键还是终端随意），然后将这个链接文件复制到桌面，改下名字即可。虽然和简单，但是缺点是没有图标....身为一个外观党还是有点难以接受的...\n\n- 方法三：就是自己写一个.desktop文件，这里举例我写的Moeditor的桌面文件：\n```\n//首先终端切到桌面\nvim Moeditor.desktop\n//然后输入如下内容\n[Desktop Entry]\nVersion=1.0\nType=Application\nName=Moeditor\nGenericName=Moeditor\nComment=editor for markdown\nExec=/home/fleshier/Programe\\ Files/Moeditor-linux-x64/Moeditor %F  //文件启动器的路径\nTerminal=false\nIcon=/home/fleshier/Programe\\ Files/Images/icons/g10.png  //图标的路径\nStartupNotify=true\nActions=Window;\n//空行\n[Desktop Action Window]\nName=New Window\nExec=/home/fleshier/Programe\\ Files/Moeditor-linux-x64/Moeditor -n\nOnlyShowIn=Unity;\n```\n- 保存之后执行 `chmod a+x filename` 改变执行权限即可运行\n\n- 实际写的时候要把注释删除掉，不然会出错。\n\n### 关于shell脚本的创建\n\n- 首先可以touch一个文件再进行内容的修改。或者直接`vim filename`新建一个文件并进行内容的编辑\n\n- 所有shell脚本本质上都是文本文件，命名格式为`filename.sh`,内容必须以`#!/bin/bash`为第一行，当中没有空格。\n\n- 事实上，这个#!字符序列是一种特殊的结构叫做 shebang。 这个 shebang 被用来告诉操作系统将执行此脚本所用的解释器的名字。每个 shell 脚本都应该把这一文本行作为它的第一行。\n\n- 示例写法：\n```\n#!/bin/bash\n#This is a test script!    #本句是一个注释，'#'号之后的字符都会被忽略\necho 'Hello World!'  #本句会在终端中打印 \"Hello World!\"\n```\n\n- 然后在终端中执行： `chmod +x filename.sh` 为这个脚本文件添加可执行权限\n\n- 或者使用另外一个更改权限的写法：\n```\n[me@linuxbox ~]$ ll hello_world\n-rw-r--r-- 1  me    me      63  2009-03-07 10:10 hello_world\n[me@linuxbox ~]$ chmod 755 hello_world\n[me@linuxbox ~]$ ll hello_world\n-rwxr-xr-x 1  me    me      63  2009-03-07 10:10 hello_world\n```\n对于脚本文件，有两个常见的权限设置：权限为755的脚本，则每个人都能执行，权限为700的 脚本，只有文件所有者能够执行。注意为了能够执行脚本，脚本必须是可读的。\n\n- 最后是运行脚本，终端进入脚本所在文件夹，输入： `./filename.sh`\n\n\n## Linux中添加环境变量的方法\n\n> $PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录下进行搜寻编译链接。\n\n- 为什么要添加环境变量呢？如果你在Linux下载了一个免安装的软件，你要启动它的话，要么创建一个桌面快捷方式（方法见上文），要么就是每次进入它的目录点开。这时候如果我们把它添加进了PATH环境变量，那么我们只需要在终端中输入这个软件的名字，回车，就可以启动它了。\n\n- 方法一：修改profile文件（**注意：一定要切换到root用户，一定要切换到root用户，一定要切换到root用户(sudo su)! ! ! !** 否则最后保存文件会一直被拒绝又退不出去只能强退终端...可能还会有其他一些麻烦事...总之有的爽呢...） //对所有用户永久生效\n```  \n(root模式下执行) vim /etc/profile\n在文档最后加入一行:\nexport PATH=$PATH: 软件的启动脚本文件所在的**绝对路径**\"\n(一般都是 /.../bin目录)\n退出修改后在root模式下执行： source /etc/profile\n或者重启\n```\n\n- spark-shell的路径写法例子：\n```\nexport SPARK_HOME=/usr/lib/spark/spark-2.2.0-bin-hadoop2.7\nexport PATH=${SPARK_HOME}/bin:$PATH\n```\n\n- *使用source命令时要关闭fish，否则会报错*\n\n- 方法二：修改.bashrc文件（注意点同上）//仅对当前用户永久生效\n```\n(root模式下执行)vi /root/.bashrc\n在文档最后加入一行：\nexport PATH=$PATH: 软件的启动脚本文件所在的**绝对路径**\"\n退出修改后在root模式下执行： source /root/.bashrc\n```\n\n- 这两种方法最后的source语句就是让系统重新读取文件使之生效，没有写最后一句source的话，会在下次启动系统后生效\n\n## 分布式文件系统(HDFS)\n- **注意，分布式文件系统中没有切换到某个目录下的概念，因为其文件全是分散在各个节点上的**\n\n- 分布式文件系统的文件路径完整格式为 `hdfs://namenode|master:编号/root/...`\n- 例如：`hdfs://master:8020/dataset/evaluation/bots_10m_10.csv`\n\n- `hdfs dfs -ls  /...`显示分布式文件系统中某个目录（实际并不存在，只是逻辑上的）下的文件\n\n- `hdfs dfs -rm -r file|directory` 删除某个文件\n\n- 附[vim教程](https://github.com/wsdjeg/vim-galore-zh_cn)\n\n<br>\n\n> 最后更新于2018.4.19\n","source":"_posts/2018-04-06-Ubuntu-operation.md","raw":"---\nlayout:     post\ntitle:      \"Ubuntu随笔\"\ndate:       2018-04-6 16:47:00\ncategories: Computer System\ntags: [๑Ubuntu, ๑Linux]\n---\n\n> 不适合人类阅读的备忘笔记\n\n## Ubuntu目录结构\n\n- `/`:这就是根目录，一台电脑有且只有一个根目录，所有的文件都是从这里开始的。举个例子：当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。\n\n- `/root`:系统管理员（root user）的目录。至于系统管理员的权限有多大我这里就不在废话了。因此，请小心使用root帐号。\n\n- `/boot`: 系统启动文件，所有与系统启动有关的文件都保存在这里 。\n\n- `/bin`: 这里是存放系统的程序。\n\n- `/etc`:主要存放了系统配置方面的文件。\n\n- `/dev`:这里主要存放与设备（包括外设）有关的文件（unix和linux系统均把设备当成文件）。想连线打印机吗？系统就是从这个目录开始工作的。另外还有一些包括磁盘驱动、USB驱动等都放在这个目录。\n\n- `/home`:这里主要存放你的个人数据。具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root用户除外。\n\n- `/tmp`:这是临时目录。对于某些程序来说，有些文件被用了一次两次之后，就不会再被用到，像这样的文件就放在这里。因此，千万不要把重要的数据放在这里哦。\n\n- `/usr`:在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序；/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等；/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器会自动帮你管理好/usr目录的。\n\n- `/opt`:这里主要存放一些可选的程序。如你想尝试最新的firefox测试版吗？那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就 可以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。\n\n- `usr/local`:这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts）放到/usr/local目录下面。\n\n- `/media`:这个目录是用来挂载那些usb接口的移动硬盘（包括U盘）、CD/DVD驱动器等等。\n\n## 一些推荐的软件\n---\n>  一旦出现某个软件没有安装，Linux系统大多数情况下都会提示你怎样安装这个软件，最常用的就是 sudo apt-get install XXX 命令\n\n-  fish! fish! fish!： fish大法好啊，功能强大，自动补全，Ubuntu最好用的软件之一。\n\n- vim和gedit：这个不用我多说大家都知道，Linux非常好用的编辑软件\n\n- [atom](https://atom.io/)  //集成许多功能于一体的编辑器\n\n- [SpaceVim](https://zhuanlan.zhihu.com/p/24802058)模块化Vim-IDE。[使用手册](https://spacevim.org/cn/documentation/)\n\n- gnome 桌面： 装了gnome桌面和它的一系列插件之后我才真正感受到了Ubuntu的魅力！（教程以及主题百度很多）\n\n- docky: 一款mac风格的dock,删除图标直接拉出去(sudo apt-get install docky)\n\n- tweak-tool: 与gnome桌面对应的是tweak-tool(sudo apt install unity-tweak-tool)\n\n- yakuake : 可以从上方一键滑出和滑入的终端（滑出时强制窗口在最前端）（gnome中也有类似功能的插件，两个选一个即可）\n\n- Moeditor: Ubuntu下界面简洁美观，功能强大的markdown格式文件编辑器，已经在github上开源\n\n- processon： 一个网页上的设计工具，可以很简单地完成诸如流程图的设计和生成图片文件。\n\n## 一些注意点\n---\n\n- **F11键可以进入全屏模式**\n\n- 触摸板双击之后再移动就相当于长按鼠标左键的效果了\n\n- 在Ubuntu终端窗口中，复制粘贴的快捷键需要加上 shift，即粘贴是 ctrl+shift+v。\n\n- ssh cyx@192.168.1.201 cyx  高性能服务器  WIFI:sklcc_slave\n\n- 192.168.1.201:18080\n- 192.168.1.201:18088 进程\n- 192.168.1.201:50070 hdfs\n\n\n### 关于添加Ubuntu的本地ssh-key与github相关联\n\n- 首先检测本地有没有安装ssh  `终端输入ssh`\n\n- 然后终端执行`ssh-kengen -t rsa`，连续三次默认回车就行。接着 ~/.ssh目录下就会多出来两个文件：`id_rsa`和`id_rsa.pub`\n\n- 接着只要在github上添加`id_rsa.pub`这个key就行了。在github的setting中，找到sshkey一栏，选择new key，将`id_rsa.pub`的文件内容复制到里面，随便起个title即可。\n\n\n### 关于挂载本地的卷到Ubuntu\n\n- 使用`mount /dev/卷名  /挂载点`   //将某个卷挂载到某个文件目录下，该卷就可以在这个文件目录下访问了。\n\n- Ubuntu中，所有的硬件设备都是作为文件存储的，这一点与Windows不同。\n\n### 关于桌面快捷方式的创建\n\n- 方法一：进入 /usr/share/applications/ 目录，里面会有**绝大多数**你安装的软件的 .desktop文件，只需要把你需要的软件的 .desktop文件复制到home目录下的 桌面文件夹里即可。\n\n- 方法二： 有点蠢但是很简单的一个方法。对于那些没有安装直接可以使用的软件，我们在上个方法中提到的文件夹里是找不到 .desktop文件的。怎么办呢？我们只需要进入我们那个软件的目录，找到启动文件，创建一个它的链接文件（右键还是终端随意），然后将这个链接文件复制到桌面，改下名字即可。虽然和简单，但是缺点是没有图标....身为一个外观党还是有点难以接受的...\n\n- 方法三：就是自己写一个.desktop文件，这里举例我写的Moeditor的桌面文件：\n```\n//首先终端切到桌面\nvim Moeditor.desktop\n//然后输入如下内容\n[Desktop Entry]\nVersion=1.0\nType=Application\nName=Moeditor\nGenericName=Moeditor\nComment=editor for markdown\nExec=/home/fleshier/Programe\\ Files/Moeditor-linux-x64/Moeditor %F  //文件启动器的路径\nTerminal=false\nIcon=/home/fleshier/Programe\\ Files/Images/icons/g10.png  //图标的路径\nStartupNotify=true\nActions=Window;\n//空行\n[Desktop Action Window]\nName=New Window\nExec=/home/fleshier/Programe\\ Files/Moeditor-linux-x64/Moeditor -n\nOnlyShowIn=Unity;\n```\n- 保存之后执行 `chmod a+x filename` 改变执行权限即可运行\n\n- 实际写的时候要把注释删除掉，不然会出错。\n\n### 关于shell脚本的创建\n\n- 首先可以touch一个文件再进行内容的修改。或者直接`vim filename`新建一个文件并进行内容的编辑\n\n- 所有shell脚本本质上都是文本文件，命名格式为`filename.sh`,内容必须以`#!/bin/bash`为第一行，当中没有空格。\n\n- 事实上，这个#!字符序列是一种特殊的结构叫做 shebang。 这个 shebang 被用来告诉操作系统将执行此脚本所用的解释器的名字。每个 shell 脚本都应该把这一文本行作为它的第一行。\n\n- 示例写法：\n```\n#!/bin/bash\n#This is a test script!    #本句是一个注释，'#'号之后的字符都会被忽略\necho 'Hello World!'  #本句会在终端中打印 \"Hello World!\"\n```\n\n- 然后在终端中执行： `chmod +x filename.sh` 为这个脚本文件添加可执行权限\n\n- 或者使用另外一个更改权限的写法：\n```\n[me@linuxbox ~]$ ll hello_world\n-rw-r--r-- 1  me    me      63  2009-03-07 10:10 hello_world\n[me@linuxbox ~]$ chmod 755 hello_world\n[me@linuxbox ~]$ ll hello_world\n-rwxr-xr-x 1  me    me      63  2009-03-07 10:10 hello_world\n```\n对于脚本文件，有两个常见的权限设置：权限为755的脚本，则每个人都能执行，权限为700的 脚本，只有文件所有者能够执行。注意为了能够执行脚本，脚本必须是可读的。\n\n- 最后是运行脚本，终端进入脚本所在文件夹，输入： `./filename.sh`\n\n\n## Linux中添加环境变量的方法\n\n> $PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录下进行搜寻编译链接。\n\n- 为什么要添加环境变量呢？如果你在Linux下载了一个免安装的软件，你要启动它的话，要么创建一个桌面快捷方式（方法见上文），要么就是每次进入它的目录点开。这时候如果我们把它添加进了PATH环境变量，那么我们只需要在终端中输入这个软件的名字，回车，就可以启动它了。\n\n- 方法一：修改profile文件（**注意：一定要切换到root用户，一定要切换到root用户，一定要切换到root用户(sudo su)! ! ! !** 否则最后保存文件会一直被拒绝又退不出去只能强退终端...可能还会有其他一些麻烦事...总之有的爽呢...） //对所有用户永久生效\n```  \n(root模式下执行) vim /etc/profile\n在文档最后加入一行:\nexport PATH=$PATH: 软件的启动脚本文件所在的**绝对路径**\"\n(一般都是 /.../bin目录)\n退出修改后在root模式下执行： source /etc/profile\n或者重启\n```\n\n- spark-shell的路径写法例子：\n```\nexport SPARK_HOME=/usr/lib/spark/spark-2.2.0-bin-hadoop2.7\nexport PATH=${SPARK_HOME}/bin:$PATH\n```\n\n- *使用source命令时要关闭fish，否则会报错*\n\n- 方法二：修改.bashrc文件（注意点同上）//仅对当前用户永久生效\n```\n(root模式下执行)vi /root/.bashrc\n在文档最后加入一行：\nexport PATH=$PATH: 软件的启动脚本文件所在的**绝对路径**\"\n退出修改后在root模式下执行： source /root/.bashrc\n```\n\n- 这两种方法最后的source语句就是让系统重新读取文件使之生效，没有写最后一句source的话，会在下次启动系统后生效\n\n## 分布式文件系统(HDFS)\n- **注意，分布式文件系统中没有切换到某个目录下的概念，因为其文件全是分散在各个节点上的**\n\n- 分布式文件系统的文件路径完整格式为 `hdfs://namenode|master:编号/root/...`\n- 例如：`hdfs://master:8020/dataset/evaluation/bots_10m_10.csv`\n\n- `hdfs dfs -ls  /...`显示分布式文件系统中某个目录（实际并不存在，只是逻辑上的）下的文件\n\n- `hdfs dfs -rm -r file|directory` 删除某个文件\n\n- 附[vim教程](https://github.com/wsdjeg/vim-galore-zh_cn)\n\n<br>\n\n> 最后更新于2018.4.19\n","slug":"2018-04-06-Ubuntu-operation","published":1,"updated":"2018-09-03T13:23:13.035Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4d000m1m0obul5h5ek","content":"<blockquote>\n<p>不适合人类阅读的备忘笔记</p>\n</blockquote>\n<h2 id=\"Ubuntu目录结构\"><a href=\"#Ubuntu目录结构\" class=\"headerlink\" title=\"Ubuntu目录结构\"></a>Ubuntu目录结构</h2><ul>\n<li><p><code>/</code>:这就是根目录，一台电脑有且只有一个根目录，所有的文件都是从这里开始的。举个例子：当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</p>\n</li>\n<li><p><code>/root</code>:系统管理员（root user）的目录。至于系统管理员的权限有多大我这里就不在废话了。因此，请小心使用root帐号。</p>\n</li>\n<li><p><code>/boot</code>: 系统启动文件，所有与系统启动有关的文件都保存在这里 。</p>\n</li>\n<li><p><code>/bin</code>: 这里是存放系统的程序。</p>\n</li>\n<li><p><code>/etc</code>:主要存放了系统配置方面的文件。</p>\n</li>\n<li><p><code>/dev</code>:这里主要存放与设备（包括外设）有关的文件（unix和linux系统均把设备当成文件）。想连线打印机吗？系统就是从这个目录开始工作的。另外还有一些包括磁盘驱动、USB驱动等都放在这个目录。</p>\n</li>\n<li><p><code>/home</code>:这里主要存放你的个人数据。具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root用户除外。</p>\n</li>\n<li><p><code>/tmp</code>:这是临时目录。对于某些程序来说，有些文件被用了一次两次之后，就不会再被用到，像这样的文件就放在这里。因此，千万不要把重要的数据放在这里哦。</p>\n</li>\n<li><p><code>/usr</code>:在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序；/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等；/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器会自动帮你管理好/usr目录的。</p>\n</li>\n<li><p><code>/opt</code>:这里主要存放一些可选的程序。如你想尝试最新的firefox测试版吗？那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就 可以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。</p>\n</li>\n<li><p><code>usr/local</code>:这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts）放到/usr/local目录下面。</p>\n</li>\n<li><p><code>/media</code>:这个目录是用来挂载那些usb接口的移动硬盘（包括U盘）、CD/DVD驱动器等等。</p>\n</li>\n</ul>\n<h2 id=\"一些推荐的软件\"><a href=\"#一些推荐的软件\" class=\"headerlink\" title=\"一些推荐的软件\"></a>一些推荐的软件</h2><hr>\n<blockquote>\n<p> 一旦出现某个软件没有安装，Linux系统大多数情况下都会提示你怎样安装这个软件，最常用的就是 sudo apt-get install XXX 命令</p>\n</blockquote>\n<ul>\n<li><p>fish! fish! fish!： fish大法好啊，功能强大，自动补全，Ubuntu最好用的软件之一。</p>\n</li>\n<li><p>vim和gedit：这个不用我多说大家都知道，Linux非常好用的编辑软件</p>\n</li>\n<li><p><a href=\"https://atom.io/\" target=\"_blank\" rel=\"noopener\">atom</a>  //集成许多功能于一体的编辑器</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/24802058\" target=\"_blank\" rel=\"noopener\">SpaceVim</a>模块化Vim-IDE。<a href=\"https://spacevim.org/cn/documentation/\" target=\"_blank\" rel=\"noopener\">使用手册</a></p>\n</li>\n<li><p>gnome 桌面： 装了gnome桌面和它的一系列插件之后我才真正感受到了Ubuntu的魅力！（教程以及主题百度很多）</p>\n</li>\n<li><p>docky: 一款mac风格的dock,删除图标直接拉出去(sudo apt-get install docky)</p>\n</li>\n<li><p>tweak-tool: 与gnome桌面对应的是tweak-tool(sudo apt install unity-tweak-tool)</p>\n</li>\n<li><p>yakuake : 可以从上方一键滑出和滑入的终端（滑出时强制窗口在最前端）（gnome中也有类似功能的插件，两个选一个即可）</p>\n</li>\n<li><p>Moeditor: Ubuntu下界面简洁美观，功能强大的markdown格式文件编辑器，已经在github上开源</p>\n</li>\n<li><p>processon： 一个网页上的设计工具，可以很简单地完成诸如流程图的设计和生成图片文件。</p>\n</li>\n</ul>\n<h2 id=\"一些注意点\"><a href=\"#一些注意点\" class=\"headerlink\" title=\"一些注意点\"></a>一些注意点</h2><hr>\n<ul>\n<li><p><strong>F11键可以进入全屏模式</strong></p>\n</li>\n<li><p>触摸板双击之后再移动就相当于长按鼠标左键的效果了</p>\n</li>\n<li><p>在Ubuntu终端窗口中，复制粘贴的快捷键需要加上 shift，即粘贴是 ctrl+shift+v。</p>\n</li>\n<li><p>ssh <a href=\"mailto:cyx@192.168.1.201\" target=\"_blank\" rel=\"noopener\">cyx@192.168.1.201</a> cyx  高性能服务器  WIFI:sklcc_slave</p>\n</li>\n<li><p>192.168.1.201:18080</p>\n</li>\n<li>192.168.1.201:18088 进程</li>\n<li>192.168.1.201:50070 hdfs</li>\n</ul>\n<h3 id=\"关于添加Ubuntu的本地ssh-key与github相关联\"><a href=\"#关于添加Ubuntu的本地ssh-key与github相关联\" class=\"headerlink\" title=\"关于添加Ubuntu的本地ssh-key与github相关联\"></a>关于添加Ubuntu的本地ssh-key与github相关联</h3><ul>\n<li><p>首先检测本地有没有安装ssh  <code>终端输入ssh</code></p>\n</li>\n<li><p>然后终端执行<code>ssh-kengen -t rsa</code>，连续三次默认回车就行。接着 ~/.ssh目录下就会多出来两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code></p>\n</li>\n<li><p>接着只要在github上添加<code>id_rsa.pub</code>这个key就行了。在github的setting中，找到sshkey一栏，选择new key，将<code>id_rsa.pub</code>的文件内容复制到里面，随便起个title即可。</p>\n</li>\n</ul>\n<h3 id=\"关于挂载本地的卷到Ubuntu\"><a href=\"#关于挂载本地的卷到Ubuntu\" class=\"headerlink\" title=\"关于挂载本地的卷到Ubuntu\"></a>关于挂载本地的卷到Ubuntu</h3><ul>\n<li><p>使用<code>mount /dev/卷名  /挂载点</code>   //将某个卷挂载到某个文件目录下，该卷就可以在这个文件目录下访问了。</p>\n</li>\n<li><p>Ubuntu中，所有的硬件设备都是作为文件存储的，这一点与Windows不同。</p>\n</li>\n</ul>\n<h3 id=\"关于桌面快捷方式的创建\"><a href=\"#关于桌面快捷方式的创建\" class=\"headerlink\" title=\"关于桌面快捷方式的创建\"></a>关于桌面快捷方式的创建</h3><ul>\n<li><p>方法一：进入 /usr/share/applications/ 目录，里面会有<strong>绝大多数</strong>你安装的软件的 .desktop文件，只需要把你需要的软件的 .desktop文件复制到home目录下的 桌面文件夹里即可。</p>\n</li>\n<li><p>方法二： 有点蠢但是很简单的一个方法。对于那些没有安装直接可以使用的软件，我们在上个方法中提到的文件夹里是找不到 .desktop文件的。怎么办呢？我们只需要进入我们那个软件的目录，找到启动文件，创建一个它的链接文件（右键还是终端随意），然后将这个链接文件复制到桌面，改下名字即可。虽然和简单，但是缺点是没有图标….身为一个外观党还是有点难以接受的…</p>\n</li>\n<li><p>方法三：就是自己写一个.desktop文件，这里举例我写的Moeditor的桌面文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//首先终端切到桌面</span><br><span class=\"line\">vim Moeditor.desktop</span><br><span class=\"line\">//然后输入如下内容</span><br><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Version=1.0</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Name=Moeditor</span><br><span class=\"line\">GenericName=Moeditor</span><br><span class=\"line\">Comment=editor for markdown</span><br><span class=\"line\">Exec=/home/fleshier/Programe\\ Files/Moeditor-linux-x64/Moeditor %F  //文件启动器的路径</span><br><span class=\"line\">Terminal=false</span><br><span class=\"line\">Icon=/home/fleshier/Programe\\ Files/Images/icons/g10.png  //图标的路径</span><br><span class=\"line\">StartupNotify=true</span><br><span class=\"line\">Actions=Window;</span><br><span class=\"line\">//空行</span><br><span class=\"line\">[Desktop Action Window]</span><br><span class=\"line\">Name=New Window</span><br><span class=\"line\">Exec=/home/fleshier/Programe\\ Files/Moeditor-linux-x64/Moeditor -n</span><br><span class=\"line\">OnlyShowIn=Unity;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存之后执行 <code>chmod a+x filename</code> 改变执行权限即可运行</p>\n</li>\n<li><p>实际写的时候要把注释删除掉，不然会出错。</p>\n</li>\n</ul>\n<h3 id=\"关于shell脚本的创建\"><a href=\"#关于shell脚本的创建\" class=\"headerlink\" title=\"关于shell脚本的创建\"></a>关于shell脚本的创建</h3><ul>\n<li><p>首先可以touch一个文件再进行内容的修改。或者直接<code>vim filename</code>新建一个文件并进行内容的编辑</p>\n</li>\n<li><p>所有shell脚本本质上都是文本文件，命名格式为<code>filename.sh</code>,内容必须以<code>#!/bin/bash</code>为第一行，当中没有空格。</p>\n</li>\n<li><p>事实上，这个#!字符序列是一种特殊的结构叫做 shebang。 这个 shebang 被用来告诉操作系统将执行此脚本所用的解释器的名字。每个 shell 脚本都应该把这一文本行作为它的第一行。</p>\n</li>\n<li><p>示例写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#This is a test script!    #本句是一个注释，&apos;#&apos;号之后的字符都会被忽略</span><br><span class=\"line\">echo &apos;Hello World!&apos;  #本句会在终端中打印 &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在终端中执行： <code>chmod +x filename.sh</code> 为这个脚本文件添加可执行权限</p>\n</li>\n<li><p>或者使用另外一个更改权限的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[me@linuxbox ~]$ ll hello_world</span><br><span class=\"line\">-rw-r--r-- 1  me    me      63  2009-03-07 10:10 hello_world</span><br><span class=\"line\">[me@linuxbox ~]$ chmod 755 hello_world</span><br><span class=\"line\">[me@linuxbox ~]$ ll hello_world</span><br><span class=\"line\">-rwxr-xr-x 1  me    me      63  2009-03-07 10:10 hello_world</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对于脚本文件，有两个常见的权限设置：权限为755的脚本，则每个人都能执行，权限为700的 脚本，只有文件所有者能够执行。注意为了能够执行脚本，脚本必须是可读的。</p>\n<ul>\n<li>最后是运行脚本，终端进入脚本所在文件夹，输入： <code>./filename.sh</code></li>\n</ul>\n<h2 id=\"Linux中添加环境变量的方法\"><a href=\"#Linux中添加环境变量的方法\" class=\"headerlink\" title=\"Linux中添加环境变量的方法\"></a>Linux中添加环境变量的方法</h2><blockquote>\n<p>$PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录下进行搜寻编译链接。</p>\n</blockquote>\n<ul>\n<li><p>为什么要添加环境变量呢？如果你在Linux下载了一个免安装的软件，你要启动它的话，要么创建一个桌面快捷方式（方法见上文），要么就是每次进入它的目录点开。这时候如果我们把它添加进了PATH环境变量，那么我们只需要在终端中输入这个软件的名字，回车，就可以启动它了。</p>\n</li>\n<li><p>方法一：修改profile文件（<strong>注意：一定要切换到root用户，一定要切换到root用户，一定要切换到root用户(sudo su)! ! ! !</strong> 否则最后保存文件会一直被拒绝又退不出去只能强退终端…可能还会有其他一些麻烦事…总之有的爽呢…） //对所有用户永久生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(root模式下执行) vim /etc/profile</span><br><span class=\"line\">在文档最后加入一行:</span><br><span class=\"line\">export PATH=$PATH: 软件的启动脚本文件所在的**绝对路径**&quot;</span><br><span class=\"line\">(一般都是 /.../bin目录)</span><br><span class=\"line\">退出修改后在root模式下执行： source /etc/profile</span><br><span class=\"line\">或者重启</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>spark-shell的路径写法例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export SPARK_HOME=/usr/lib/spark/spark-2.2.0-bin-hadoop2.7</span><br><span class=\"line\">export PATH=$&#123;SPARK_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><em>使用source命令时要关闭fish，否则会报错</em></p>\n</li>\n<li><p>方法二：修改.bashrc文件（注意点同上）//仅对当前用户永久生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(root模式下执行)vi /root/.bashrc</span><br><span class=\"line\">在文档最后加入一行：</span><br><span class=\"line\">export PATH=$PATH: 软件的启动脚本文件所在的**绝对路径**&quot;</span><br><span class=\"line\">退出修改后在root模式下执行： source /root/.bashrc</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这两种方法最后的source语句就是让系统重新读取文件使之生效，没有写最后一句source的话，会在下次启动系统后生效</p>\n</li>\n</ul>\n<h2 id=\"分布式文件系统-HDFS\"><a href=\"#分布式文件系统-HDFS\" class=\"headerlink\" title=\"分布式文件系统(HDFS)\"></a>分布式文件系统(HDFS)</h2><ul>\n<li><p><strong>注意，分布式文件系统中没有切换到某个目录下的概念，因为其文件全是分散在各个节点上的</strong></p>\n</li>\n<li><p>分布式文件系统的文件路径完整格式为 <code>hdfs://namenode|master:编号/root/...</code></p>\n</li>\n<li><p>例如：<code>hdfs://master:8020/dataset/evaluation/bots_10m_10.csv</code></p>\n</li>\n<li><p><code>hdfs dfs -ls  /...</code>显示分布式文件系统中某个目录（实际并不存在，只是逻辑上的）下的文件</p>\n</li>\n<li><p><code>hdfs dfs -rm -r file|directory</code> 删除某个文件</p>\n</li>\n<li><p>附<a href=\"https://github.com/wsdjeg/vim-galore-zh_cn\" target=\"_blank\" rel=\"noopener\">vim教程</a></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.19</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的备忘笔记</p>\n</blockquote>\n<h2 id=\"Ubuntu目录结构\"><a href=\"#Ubuntu目录结构\" class=\"headerlink\" title=\"Ubuntu目录结构\"></a>Ubuntu目录结构</h2><ul>\n<li><p><code>/</code>:这就是根目录，一台电脑有且只有一个根目录，所有的文件都是从这里开始的。举个例子：当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</p>\n</li>\n<li><p><code>/root</code>:系统管理员（root user）的目录。至于系统管理员的权限有多大我这里就不在废话了。因此，请小心使用root帐号。</p>\n</li>\n<li><p><code>/boot</code>: 系统启动文件，所有与系统启动有关的文件都保存在这里 。</p>\n</li>\n<li><p><code>/bin</code>: 这里是存放系统的程序。</p>\n</li>\n<li><p><code>/etc</code>:主要存放了系统配置方面的文件。</p>\n</li>\n<li><p><code>/dev</code>:这里主要存放与设备（包括外设）有关的文件（unix和linux系统均把设备当成文件）。想连线打印机吗？系统就是从这个目录开始工作的。另外还有一些包括磁盘驱动、USB驱动等都放在这个目录。</p>\n</li>\n<li><p><code>/home</code>:这里主要存放你的个人数据。具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root用户除外。</p>\n</li>\n<li><p><code>/tmp</code>:这是临时目录。对于某些程序来说，有些文件被用了一次两次之后，就不会再被用到，像这样的文件就放在这里。因此，千万不要把重要的数据放在这里哦。</p>\n</li>\n<li><p><code>/usr</code>:在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序；/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等；/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器会自动帮你管理好/usr目录的。</p>\n</li>\n<li><p><code>/opt</code>:这里主要存放一些可选的程序。如你想尝试最新的firefox测试版吗？那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就 可以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。</p>\n</li>\n<li><p><code>usr/local</code>:这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts）放到/usr/local目录下面。</p>\n</li>\n<li><p><code>/media</code>:这个目录是用来挂载那些usb接口的移动硬盘（包括U盘）、CD/DVD驱动器等等。</p>\n</li>\n</ul>\n<h2 id=\"一些推荐的软件\"><a href=\"#一些推荐的软件\" class=\"headerlink\" title=\"一些推荐的软件\"></a>一些推荐的软件</h2><hr>\n<blockquote>\n<p> 一旦出现某个软件没有安装，Linux系统大多数情况下都会提示你怎样安装这个软件，最常用的就是 sudo apt-get install XXX 命令</p>\n</blockquote>\n<ul>\n<li><p>fish! fish! fish!： fish大法好啊，功能强大，自动补全，Ubuntu最好用的软件之一。</p>\n</li>\n<li><p>vim和gedit：这个不用我多说大家都知道，Linux非常好用的编辑软件</p>\n</li>\n<li><p><a href=\"https://atom.io/\" target=\"_blank\" rel=\"noopener\">atom</a>  //集成许多功能于一体的编辑器</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/24802058\" target=\"_blank\" rel=\"noopener\">SpaceVim</a>模块化Vim-IDE。<a href=\"https://spacevim.org/cn/documentation/\" target=\"_blank\" rel=\"noopener\">使用手册</a></p>\n</li>\n<li><p>gnome 桌面： 装了gnome桌面和它的一系列插件之后我才真正感受到了Ubuntu的魅力！（教程以及主题百度很多）</p>\n</li>\n<li><p>docky: 一款mac风格的dock,删除图标直接拉出去(sudo apt-get install docky)</p>\n</li>\n<li><p>tweak-tool: 与gnome桌面对应的是tweak-tool(sudo apt install unity-tweak-tool)</p>\n</li>\n<li><p>yakuake : 可以从上方一键滑出和滑入的终端（滑出时强制窗口在最前端）（gnome中也有类似功能的插件，两个选一个即可）</p>\n</li>\n<li><p>Moeditor: Ubuntu下界面简洁美观，功能强大的markdown格式文件编辑器，已经在github上开源</p>\n</li>\n<li><p>processon： 一个网页上的设计工具，可以很简单地完成诸如流程图的设计和生成图片文件。</p>\n</li>\n</ul>\n<h2 id=\"一些注意点\"><a href=\"#一些注意点\" class=\"headerlink\" title=\"一些注意点\"></a>一些注意点</h2><hr>\n<ul>\n<li><p><strong>F11键可以进入全屏模式</strong></p>\n</li>\n<li><p>触摸板双击之后再移动就相当于长按鼠标左键的效果了</p>\n</li>\n<li><p>在Ubuntu终端窗口中，复制粘贴的快捷键需要加上 shift，即粘贴是 ctrl+shift+v。</p>\n</li>\n<li><p>ssh <a href=\"mailto:cyx@192.168.1.201\" target=\"_blank\" rel=\"noopener\">cyx@192.168.1.201</a> cyx  高性能服务器  WIFI:sklcc_slave</p>\n</li>\n<li><p>192.168.1.201:18080</p>\n</li>\n<li>192.168.1.201:18088 进程</li>\n<li>192.168.1.201:50070 hdfs</li>\n</ul>\n<h3 id=\"关于添加Ubuntu的本地ssh-key与github相关联\"><a href=\"#关于添加Ubuntu的本地ssh-key与github相关联\" class=\"headerlink\" title=\"关于添加Ubuntu的本地ssh-key与github相关联\"></a>关于添加Ubuntu的本地ssh-key与github相关联</h3><ul>\n<li><p>首先检测本地有没有安装ssh  <code>终端输入ssh</code></p>\n</li>\n<li><p>然后终端执行<code>ssh-kengen -t rsa</code>，连续三次默认回车就行。接着 ~/.ssh目录下就会多出来两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code></p>\n</li>\n<li><p>接着只要在github上添加<code>id_rsa.pub</code>这个key就行了。在github的setting中，找到sshkey一栏，选择new key，将<code>id_rsa.pub</code>的文件内容复制到里面，随便起个title即可。</p>\n</li>\n</ul>\n<h3 id=\"关于挂载本地的卷到Ubuntu\"><a href=\"#关于挂载本地的卷到Ubuntu\" class=\"headerlink\" title=\"关于挂载本地的卷到Ubuntu\"></a>关于挂载本地的卷到Ubuntu</h3><ul>\n<li><p>使用<code>mount /dev/卷名  /挂载点</code>   //将某个卷挂载到某个文件目录下，该卷就可以在这个文件目录下访问了。</p>\n</li>\n<li><p>Ubuntu中，所有的硬件设备都是作为文件存储的，这一点与Windows不同。</p>\n</li>\n</ul>\n<h3 id=\"关于桌面快捷方式的创建\"><a href=\"#关于桌面快捷方式的创建\" class=\"headerlink\" title=\"关于桌面快捷方式的创建\"></a>关于桌面快捷方式的创建</h3><ul>\n<li><p>方法一：进入 /usr/share/applications/ 目录，里面会有<strong>绝大多数</strong>你安装的软件的 .desktop文件，只需要把你需要的软件的 .desktop文件复制到home目录下的 桌面文件夹里即可。</p>\n</li>\n<li><p>方法二： 有点蠢但是很简单的一个方法。对于那些没有安装直接可以使用的软件，我们在上个方法中提到的文件夹里是找不到 .desktop文件的。怎么办呢？我们只需要进入我们那个软件的目录，找到启动文件，创建一个它的链接文件（右键还是终端随意），然后将这个链接文件复制到桌面，改下名字即可。虽然和简单，但是缺点是没有图标….身为一个外观党还是有点难以接受的…</p>\n</li>\n<li><p>方法三：就是自己写一个.desktop文件，这里举例我写的Moeditor的桌面文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//首先终端切到桌面</span><br><span class=\"line\">vim Moeditor.desktop</span><br><span class=\"line\">//然后输入如下内容</span><br><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Version=1.0</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Name=Moeditor</span><br><span class=\"line\">GenericName=Moeditor</span><br><span class=\"line\">Comment=editor for markdown</span><br><span class=\"line\">Exec=/home/fleshier/Programe\\ Files/Moeditor-linux-x64/Moeditor %F  //文件启动器的路径</span><br><span class=\"line\">Terminal=false</span><br><span class=\"line\">Icon=/home/fleshier/Programe\\ Files/Images/icons/g10.png  //图标的路径</span><br><span class=\"line\">StartupNotify=true</span><br><span class=\"line\">Actions=Window;</span><br><span class=\"line\">//空行</span><br><span class=\"line\">[Desktop Action Window]</span><br><span class=\"line\">Name=New Window</span><br><span class=\"line\">Exec=/home/fleshier/Programe\\ Files/Moeditor-linux-x64/Moeditor -n</span><br><span class=\"line\">OnlyShowIn=Unity;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存之后执行 <code>chmod a+x filename</code> 改变执行权限即可运行</p>\n</li>\n<li><p>实际写的时候要把注释删除掉，不然会出错。</p>\n</li>\n</ul>\n<h3 id=\"关于shell脚本的创建\"><a href=\"#关于shell脚本的创建\" class=\"headerlink\" title=\"关于shell脚本的创建\"></a>关于shell脚本的创建</h3><ul>\n<li><p>首先可以touch一个文件再进行内容的修改。或者直接<code>vim filename</code>新建一个文件并进行内容的编辑</p>\n</li>\n<li><p>所有shell脚本本质上都是文本文件，命名格式为<code>filename.sh</code>,内容必须以<code>#!/bin/bash</code>为第一行，当中没有空格。</p>\n</li>\n<li><p>事实上，这个#!字符序列是一种特殊的结构叫做 shebang。 这个 shebang 被用来告诉操作系统将执行此脚本所用的解释器的名字。每个 shell 脚本都应该把这一文本行作为它的第一行。</p>\n</li>\n<li><p>示例写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#This is a test script!    #本句是一个注释，&apos;#&apos;号之后的字符都会被忽略</span><br><span class=\"line\">echo &apos;Hello World!&apos;  #本句会在终端中打印 &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在终端中执行： <code>chmod +x filename.sh</code> 为这个脚本文件添加可执行权限</p>\n</li>\n<li><p>或者使用另外一个更改权限的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[me@linuxbox ~]$ ll hello_world</span><br><span class=\"line\">-rw-r--r-- 1  me    me      63  2009-03-07 10:10 hello_world</span><br><span class=\"line\">[me@linuxbox ~]$ chmod 755 hello_world</span><br><span class=\"line\">[me@linuxbox ~]$ ll hello_world</span><br><span class=\"line\">-rwxr-xr-x 1  me    me      63  2009-03-07 10:10 hello_world</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对于脚本文件，有两个常见的权限设置：权限为755的脚本，则每个人都能执行，权限为700的 脚本，只有文件所有者能够执行。注意为了能够执行脚本，脚本必须是可读的。</p>\n<ul>\n<li>最后是运行脚本，终端进入脚本所在文件夹，输入： <code>./filename.sh</code></li>\n</ul>\n<h2 id=\"Linux中添加环境变量的方法\"><a href=\"#Linux中添加环境变量的方法\" class=\"headerlink\" title=\"Linux中添加环境变量的方法\"></a>Linux中添加环境变量的方法</h2><blockquote>\n<p>$PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录下进行搜寻编译链接。</p>\n</blockquote>\n<ul>\n<li><p>为什么要添加环境变量呢？如果你在Linux下载了一个免安装的软件，你要启动它的话，要么创建一个桌面快捷方式（方法见上文），要么就是每次进入它的目录点开。这时候如果我们把它添加进了PATH环境变量，那么我们只需要在终端中输入这个软件的名字，回车，就可以启动它了。</p>\n</li>\n<li><p>方法一：修改profile文件（<strong>注意：一定要切换到root用户，一定要切换到root用户，一定要切换到root用户(sudo su)! ! ! !</strong> 否则最后保存文件会一直被拒绝又退不出去只能强退终端…可能还会有其他一些麻烦事…总之有的爽呢…） //对所有用户永久生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(root模式下执行) vim /etc/profile</span><br><span class=\"line\">在文档最后加入一行:</span><br><span class=\"line\">export PATH=$PATH: 软件的启动脚本文件所在的**绝对路径**&quot;</span><br><span class=\"line\">(一般都是 /.../bin目录)</span><br><span class=\"line\">退出修改后在root模式下执行： source /etc/profile</span><br><span class=\"line\">或者重启</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>spark-shell的路径写法例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export SPARK_HOME=/usr/lib/spark/spark-2.2.0-bin-hadoop2.7</span><br><span class=\"line\">export PATH=$&#123;SPARK_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><em>使用source命令时要关闭fish，否则会报错</em></p>\n</li>\n<li><p>方法二：修改.bashrc文件（注意点同上）//仅对当前用户永久生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(root模式下执行)vi /root/.bashrc</span><br><span class=\"line\">在文档最后加入一行：</span><br><span class=\"line\">export PATH=$PATH: 软件的启动脚本文件所在的**绝对路径**&quot;</span><br><span class=\"line\">退出修改后在root模式下执行： source /root/.bashrc</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这两种方法最后的source语句就是让系统重新读取文件使之生效，没有写最后一句source的话，会在下次启动系统后生效</p>\n</li>\n</ul>\n<h2 id=\"分布式文件系统-HDFS\"><a href=\"#分布式文件系统-HDFS\" class=\"headerlink\" title=\"分布式文件系统(HDFS)\"></a>分布式文件系统(HDFS)</h2><ul>\n<li><p><strong>注意，分布式文件系统中没有切换到某个目录下的概念，因为其文件全是分散在各个节点上的</strong></p>\n</li>\n<li><p>分布式文件系统的文件路径完整格式为 <code>hdfs://namenode|master:编号/root/...</code></p>\n</li>\n<li><p>例如：<code>hdfs://master:8020/dataset/evaluation/bots_10m_10.csv</code></p>\n</li>\n<li><p><code>hdfs dfs -ls  /...</code>显示分布式文件系统中某个目录（实际并不存在，只是逻辑上的）下的文件</p>\n</li>\n<li><p><code>hdfs dfs -rm -r file|directory</code> 删除某个文件</p>\n</li>\n<li><p>附<a href=\"https://github.com/wsdjeg/vim-galore-zh_cn\" target=\"_blank\" rel=\"noopener\">vim教程</a></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.19</p>\n</blockquote>\n"},{"layout":"post","title":"Ubuntu终端常用命令","date":"2018-04-06T08:47:00.000Z","_content":"\n> 不适合人类阅读的备忘笔记  \n\n## 命令\n---\n\n### 常用基本命令\n\n- `ls -l` 的简略写法就是 `ll`，但是这个与`ls -a`又不同，后者用来显示隐藏文件和文件夹。\n\n- 使用 `vim`修改文件时，如果想要不保存退出，使用`:q!`命令。\n\n- ubuntu改文件名用 `mv name1 name2`即可\n\n- `cp filename filepath` //拷贝文件\n\n- `cp -r 源目录  指定目录` //拷贝一个文件夹到另一个目录\n\n- 从hdfs上取文件到本地需要链接集群，然后 `hdfs dfs -get /.../filename  storepath`\n\n- 查看路径：例如用`which python`查看python安装的路径\n\n- `sudo apt-get remove + 软件名` 用于删除apt方式安装的软件\n\n- `chmod [-可选参数][<权限范围>+/-/=<权限设置>] 文件/目录`  //改变文件权限\n\n- `chown [-R] username filename/directoryname`  //更改文件或者文件夹所属用户\n\n- `touch 文件名`命令用来创建一个空的文件\n\n- 查看系统的所有PATH环境变量： `echo $PATH`\n\n- `rm -rf` 强制 递归地删除某个文件或者文件夹的所有文件\n\n- `dpkg -i filename.deb`  //安装 .deb 文件\n\n### grep语句\n\n- Linux grep命令用于查找文件里符合条件的字符串。\n\n- 简单命令格式： `grep [option] pattern file`\n- 完整格式： `grep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]`\n\n- **例（最常用）**：`cat AR_log | grep \"====\"\n`此句就是打印日志AR_log当中所有包含了\"====\"的行\n\n- 在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：\n```\ngrep test *file\n```\n\n### apt常用命令\n\n- `apt-cache search package` 搜索包\n\n- `apt-cache show package` 获取包的相关信息，如说明、大小、版本等\n\n- `sudo apt-get install package` 安装包\n\n- `sudo apt-get install package - - reinstall` 重新安装包\n\n- `sudo apt-get -f install` 修复安装 \"-f = ——fix-missing\"\n\n- `sudo apt autoremove` **卸载某个软件并且删除与之相关的多余依赖**\n\n- `sudo apt-get update` 更新源\n\n- `sudo apt-get upgrade` **更新已安装的包**\n\n- `apt-cache depends package` 了解使用依赖\n\n- `apt-cache rdepends package` 是查看该包被哪些包依赖\n\n- `sudo apt-get build-dep package` 安装相关的编译环境\n\n- `sudo apt-get clean && sudo apt-get autoclean` 清理无用的包\n\n- `sudo apt-get check` 检查是否有损坏的依赖\n\n### scp语句\n\n- 语法： `scp [可选参数] file_source file_target `\n\n- 例：`scp /home/fleshier/My_Programes/Programes/AssociationRuleDiscovery/target/AR.jar   root@192.168.1.201:/root`\n此句就是吧一个本地的文件拷贝到远端的服务器上，用户是root，服务器地址是192.168.1.201，存放目录是 `/root`\n\n- 如果指定了用户名（如上例），则需要输入密码，如果没有指定用户名，则回车后需要输入用户名和密码。\n\n- 使用参数`-r`来实现递归拷贝\n\n例：`scp root@192.168.1.201:/root/runAR.sh /home/fleschier/cloud\\ computing/\n`从远程服务器拷贝到本地\n\n- 远程服务器的格式为 `用户名@IP地址:文件路径`\n\n- 额外说明：如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：\n```\n#scp 命令使用端口号 4588\nscp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator\n```\n\n### curl命令\n\n- curl命令是个功能强大的网络工具，支持通过http、ftp等方式下载文件、上传文件。还可以用来抓取网页、网络监控等方面的开发，解决开发过程中遇到的问题。\n\n- curl安装：`sudo apt-get install curl`\n\n- get请求：`curl http://www.baidu.com` 回车之后，HTML内容打印在屏幕上；如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。\n\n- 更多详细参数——[curl命令详解](http://www.cnblogs.com/linjiqin/p/5484910.html)\n\n\n### gem命令\n\n- 安装命令 `gem install appname`\n\n- Gem 是一个管理 Ruby 库和程序的标准包\n\n- 所有的 gem 包，会被安装到 `/[Ruby root]/lib/ruby/gems/[ver]/` 目录下，这其中包括了 `Cache、doc、gems、specifications` 4个目录，`cache` 下放置下载的原生 gem 包，`gems` 下则放置的是解压过的 gem 包。\n\n- 当安装过程中遇到问题时，可以进入这些目录，手动删除有问题的 gem 包，然后重新运行 `gem install [gemname]` 命令即可。\n\n<br>\n- 参考资料：[linux命令大全-菜鸟教程](http://www.runoob.com/linux/linux-command-manual.html)以及各大博客网站大佬们的博文。\n\n### df命令\n\n- df命令用来查看磁盘上的空间，默认以KB为单位\n\n- 一般使用`df-h`命令来以KB以上的单位显示，可读性高\n\n- [详解](http://man.linuxde.net/df)\n\n### find命令\n\n- 语法：`find path -option [ -print ] [-exec -ok command ] {} \\;`\n\n- [详解](http://www.runoob.com/linux/linux-comm-find.html)\n\n### du命令\n\n- 一般使用`du -h [--max-depth = k] /路径`来查看这个目录下的各个文件占用的空间\n\n- `--max-depth`用来调节深度，一般k取1\n\n- [详细教程](https://www.jianshu.com/p/1c22dcb17a2e)\n\n<br>\n\n> 最后更新于2018.7.20\n","source":"_posts/2018-04-06-Ubuntu-order.md","raw":"---\nlayout:     post\ntitle:      \"Ubuntu终端常用命令\"\ndate:       2018-04-6 16:47:00\ncategories: Computer System\ntags: [๑Ubuntu, ๑Linux]\n---\n\n> 不适合人类阅读的备忘笔记  \n\n## 命令\n---\n\n### 常用基本命令\n\n- `ls -l` 的简略写法就是 `ll`，但是这个与`ls -a`又不同，后者用来显示隐藏文件和文件夹。\n\n- 使用 `vim`修改文件时，如果想要不保存退出，使用`:q!`命令。\n\n- ubuntu改文件名用 `mv name1 name2`即可\n\n- `cp filename filepath` //拷贝文件\n\n- `cp -r 源目录  指定目录` //拷贝一个文件夹到另一个目录\n\n- 从hdfs上取文件到本地需要链接集群，然后 `hdfs dfs -get /.../filename  storepath`\n\n- 查看路径：例如用`which python`查看python安装的路径\n\n- `sudo apt-get remove + 软件名` 用于删除apt方式安装的软件\n\n- `chmod [-可选参数][<权限范围>+/-/=<权限设置>] 文件/目录`  //改变文件权限\n\n- `chown [-R] username filename/directoryname`  //更改文件或者文件夹所属用户\n\n- `touch 文件名`命令用来创建一个空的文件\n\n- 查看系统的所有PATH环境变量： `echo $PATH`\n\n- `rm -rf` 强制 递归地删除某个文件或者文件夹的所有文件\n\n- `dpkg -i filename.deb`  //安装 .deb 文件\n\n### grep语句\n\n- Linux grep命令用于查找文件里符合条件的字符串。\n\n- 简单命令格式： `grep [option] pattern file`\n- 完整格式： `grep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]`\n\n- **例（最常用）**：`cat AR_log | grep \"====\"\n`此句就是打印日志AR_log当中所有包含了\"====\"的行\n\n- 在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：\n```\ngrep test *file\n```\n\n### apt常用命令\n\n- `apt-cache search package` 搜索包\n\n- `apt-cache show package` 获取包的相关信息，如说明、大小、版本等\n\n- `sudo apt-get install package` 安装包\n\n- `sudo apt-get install package - - reinstall` 重新安装包\n\n- `sudo apt-get -f install` 修复安装 \"-f = ——fix-missing\"\n\n- `sudo apt autoremove` **卸载某个软件并且删除与之相关的多余依赖**\n\n- `sudo apt-get update` 更新源\n\n- `sudo apt-get upgrade` **更新已安装的包**\n\n- `apt-cache depends package` 了解使用依赖\n\n- `apt-cache rdepends package` 是查看该包被哪些包依赖\n\n- `sudo apt-get build-dep package` 安装相关的编译环境\n\n- `sudo apt-get clean && sudo apt-get autoclean` 清理无用的包\n\n- `sudo apt-get check` 检查是否有损坏的依赖\n\n### scp语句\n\n- 语法： `scp [可选参数] file_source file_target `\n\n- 例：`scp /home/fleshier/My_Programes/Programes/AssociationRuleDiscovery/target/AR.jar   root@192.168.1.201:/root`\n此句就是吧一个本地的文件拷贝到远端的服务器上，用户是root，服务器地址是192.168.1.201，存放目录是 `/root`\n\n- 如果指定了用户名（如上例），则需要输入密码，如果没有指定用户名，则回车后需要输入用户名和密码。\n\n- 使用参数`-r`来实现递归拷贝\n\n例：`scp root@192.168.1.201:/root/runAR.sh /home/fleschier/cloud\\ computing/\n`从远程服务器拷贝到本地\n\n- 远程服务器的格式为 `用户名@IP地址:文件路径`\n\n- 额外说明：如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：\n```\n#scp 命令使用端口号 4588\nscp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator\n```\n\n### curl命令\n\n- curl命令是个功能强大的网络工具，支持通过http、ftp等方式下载文件、上传文件。还可以用来抓取网页、网络监控等方面的开发，解决开发过程中遇到的问题。\n\n- curl安装：`sudo apt-get install curl`\n\n- get请求：`curl http://www.baidu.com` 回车之后，HTML内容打印在屏幕上；如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。\n\n- 更多详细参数——[curl命令详解](http://www.cnblogs.com/linjiqin/p/5484910.html)\n\n\n### gem命令\n\n- 安装命令 `gem install appname`\n\n- Gem 是一个管理 Ruby 库和程序的标准包\n\n- 所有的 gem 包，会被安装到 `/[Ruby root]/lib/ruby/gems/[ver]/` 目录下，这其中包括了 `Cache、doc、gems、specifications` 4个目录，`cache` 下放置下载的原生 gem 包，`gems` 下则放置的是解压过的 gem 包。\n\n- 当安装过程中遇到问题时，可以进入这些目录，手动删除有问题的 gem 包，然后重新运行 `gem install [gemname]` 命令即可。\n\n<br>\n- 参考资料：[linux命令大全-菜鸟教程](http://www.runoob.com/linux/linux-command-manual.html)以及各大博客网站大佬们的博文。\n\n### df命令\n\n- df命令用来查看磁盘上的空间，默认以KB为单位\n\n- 一般使用`df-h`命令来以KB以上的单位显示，可读性高\n\n- [详解](http://man.linuxde.net/df)\n\n### find命令\n\n- 语法：`find path -option [ -print ] [-exec -ok command ] {} \\;`\n\n- [详解](http://www.runoob.com/linux/linux-comm-find.html)\n\n### du命令\n\n- 一般使用`du -h [--max-depth = k] /路径`来查看这个目录下的各个文件占用的空间\n\n- `--max-depth`用来调节深度，一般k取1\n\n- [详细教程](https://www.jianshu.com/p/1c22dcb17a2e)\n\n<br>\n\n> 最后更新于2018.7.20\n","slug":"2018-04-06-Ubuntu-order","published":1,"updated":"2018-09-03T13:22:38.768Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4f000p1m0oe85wkwsn","content":"<blockquote>\n<p>不适合人类阅读的备忘笔记  </p>\n</blockquote>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><hr>\n<h3 id=\"常用基本命令\"><a href=\"#常用基本命令\" class=\"headerlink\" title=\"常用基本命令\"></a>常用基本命令</h3><ul>\n<li><p><code>ls -l</code> 的简略写法就是 <code>ll</code>，但是这个与<code>ls -a</code>又不同，后者用来显示隐藏文件和文件夹。</p>\n</li>\n<li><p>使用 <code>vim</code>修改文件时，如果想要不保存退出，使用<code>:q!</code>命令。</p>\n</li>\n<li><p>ubuntu改文件名用 <code>mv name1 name2</code>即可</p>\n</li>\n<li><p><code>cp filename filepath</code> //拷贝文件</p>\n</li>\n<li><p><code>cp -r 源目录  指定目录</code> //拷贝一个文件夹到另一个目录</p>\n</li>\n<li><p>从hdfs上取文件到本地需要链接集群，然后 <code>hdfs dfs -get /.../filename  storepath</code></p>\n</li>\n<li><p>查看路径：例如用<code>which python</code>查看python安装的路径</p>\n</li>\n<li><p><code>sudo apt-get remove + 软件名</code> 用于删除apt方式安装的软件</p>\n</li>\n<li><p><code>chmod [-可选参数][&lt;权限范围&gt;+/-/=&lt;权限设置&gt;] 文件/目录</code>  //改变文件权限</p>\n</li>\n<li><p><code>chown [-R] username filename/directoryname</code>  //更改文件或者文件夹所属用户</p>\n</li>\n<li><p><code>touch 文件名</code>命令用来创建一个空的文件</p>\n</li>\n<li><p>查看系统的所有PATH环境变量： <code>echo $PATH</code></p>\n</li>\n<li><p><code>rm -rf</code> 强制 递归地删除某个文件或者文件夹的所有文件</p>\n</li>\n<li><p><code>dpkg -i filename.deb</code>  //安装 .deb 文件</p>\n</li>\n</ul>\n<h3 id=\"grep语句\"><a href=\"#grep语句\" class=\"headerlink\" title=\"grep语句\"></a>grep语句</h3><ul>\n<li><p>Linux grep命令用于查找文件里符合条件的字符串。</p>\n</li>\n<li><p>简单命令格式： <code>grep [option] pattern file</code></p>\n</li>\n<li><p>完整格式： <code>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</code></p>\n</li>\n<li><p><strong>例（最常用）</strong>：<code>cat AR_log | grep &quot;====&quot;</code>此句就是打印日志AR_log当中所有包含了”====”的行</p>\n</li>\n<li><p>在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep test *file</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"apt常用命令\"><a href=\"#apt常用命令\" class=\"headerlink\" title=\"apt常用命令\"></a>apt常用命令</h3><ul>\n<li><p><code>apt-cache search package</code> 搜索包</p>\n</li>\n<li><p><code>apt-cache show package</code> 获取包的相关信息，如说明、大小、版本等</p>\n</li>\n<li><p><code>sudo apt-get install package</code> 安装包</p>\n</li>\n<li><p><code>sudo apt-get install package - - reinstall</code> 重新安装包</p>\n</li>\n<li><p><code>sudo apt-get -f install</code> 修复安装 “-f = ——fix-missing”</p>\n</li>\n<li><p><code>sudo apt autoremove</code> <strong>卸载某个软件并且删除与之相关的多余依赖</strong></p>\n</li>\n<li><p><code>sudo apt-get update</code> 更新源</p>\n</li>\n<li><p><code>sudo apt-get upgrade</code> <strong>更新已安装的包</strong></p>\n</li>\n<li><p><code>apt-cache depends package</code> 了解使用依赖</p>\n</li>\n<li><p><code>apt-cache rdepends package</code> 是查看该包被哪些包依赖</p>\n</li>\n<li><p><code>sudo apt-get build-dep package</code> 安装相关的编译环境</p>\n</li>\n<li><p><code>sudo apt-get clean &amp;&amp; sudo apt-get autoclean</code> 清理无用的包</p>\n</li>\n<li><p><code>sudo apt-get check</code> 检查是否有损坏的依赖</p>\n</li>\n</ul>\n<h3 id=\"scp语句\"><a href=\"#scp语句\" class=\"headerlink\" title=\"scp语句\"></a>scp语句</h3><ul>\n<li><p>语法： <code>scp [可选参数] file_source file_target</code></p>\n</li>\n<li><p>例：<code>scp /home/fleshier/My_Programes/Programes/AssociationRuleDiscovery/target/AR.jar   root@192.168.1.201:/root</code><br>此句就是吧一个本地的文件拷贝到远端的服务器上，用户是root，服务器地址是192.168.1.201，存放目录是 <code>/root</code></p>\n</li>\n<li><p>如果指定了用户名（如上例），则需要输入密码，如果没有指定用户名，则回车后需要输入用户名和密码。</p>\n</li>\n<li><p>使用参数<code>-r</code>来实现递归拷贝</p>\n</li>\n</ul>\n<p>例：<code>scp root@192.168.1.201:/root/runAR.sh /home/fleschier/cloud\\ computing/</code>从远程服务器拷贝到本地</p>\n<ul>\n<li><p>远程服务器的格式为 <code>用户名@IP地址:文件路径</code></p>\n</li>\n<li><p>额外说明：如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#scp 命令使用端口号 4588</span><br><span class=\"line\">scp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"curl命令\"><a href=\"#curl命令\" class=\"headerlink\" title=\"curl命令\"></a>curl命令</h3><ul>\n<li><p>curl命令是个功能强大的网络工具，支持通过http、ftp等方式下载文件、上传文件。还可以用来抓取网页、网络监控等方面的开发，解决开发过程中遇到的问题。</p>\n</li>\n<li><p>curl安装：<code>sudo apt-get install curl</code></p>\n</li>\n<li><p>get请求：<code>curl http://www.baidu.com</code> 回车之后，HTML内容打印在屏幕上；如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。</p>\n</li>\n<li><p>更多详细参数——<a href=\"http://www.cnblogs.com/linjiqin/p/5484910.html\" target=\"_blank\" rel=\"noopener\">curl命令详解</a></p>\n</li>\n</ul>\n<h3 id=\"gem命令\"><a href=\"#gem命令\" class=\"headerlink\" title=\"gem命令\"></a>gem命令</h3><ul>\n<li><p>安装命令 <code>gem install appname</code></p>\n</li>\n<li><p>Gem 是一个管理 Ruby 库和程序的标准包</p>\n</li>\n<li><p>所有的 gem 包，会被安装到 <code>/[Ruby root]/lib/ruby/gems/[ver]/</code> 目录下，这其中包括了 <code>Cache、doc、gems、specifications</code> 4个目录，<code>cache</code> 下放置下载的原生 gem 包，<code>gems</code> 下则放置的是解压过的 gem 包。</p>\n</li>\n<li><p>当安装过程中遇到问题时，可以进入这些目录，手动删除有问题的 gem 包，然后重新运行 <code>gem install [gemname]</code> 命令即可。</p>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li>参考资料：<a href=\"http://www.runoob.com/linux/linux-command-manual.html\" target=\"_blank\" rel=\"noopener\">linux命令大全-菜鸟教程</a>以及各大博客网站大佬们的博文。</li>\n</ul>\n<h3 id=\"df命令\"><a href=\"#df命令\" class=\"headerlink\" title=\"df命令\"></a>df命令</h3><ul>\n<li><p>df命令用来查看磁盘上的空间，默认以KB为单位</p>\n</li>\n<li><p>一般使用<code>df-h</code>命令来以KB以上的单位显示，可读性高</p>\n</li>\n<li><p><a href=\"http://man.linuxde.net/df\" target=\"_blank\" rel=\"noopener\">详解</a></p>\n</li>\n</ul>\n<h3 id=\"find命令\"><a href=\"#find命令\" class=\"headerlink\" title=\"find命令\"></a>find命令</h3><ul>\n<li><p>语法：<code>find path -option [ -print ] [-exec -ok command ] {} \\;</code></p>\n</li>\n<li><p><a href=\"http://www.runoob.com/linux/linux-comm-find.html\" target=\"_blank\" rel=\"noopener\">详解</a></p>\n</li>\n</ul>\n<h3 id=\"du命令\"><a href=\"#du命令\" class=\"headerlink\" title=\"du命令\"></a>du命令</h3><ul>\n<li><p>一般使用<code>du -h [--max-depth = k] /路径</code>来查看这个目录下的各个文件占用的空间</p>\n</li>\n<li><p><code>--max-depth</code>用来调节深度，一般k取1</p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/1c22dcb17a2e\" target=\"_blank\" rel=\"noopener\">详细教程</a></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.20</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的备忘笔记  </p>\n</blockquote>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><hr>\n<h3 id=\"常用基本命令\"><a href=\"#常用基本命令\" class=\"headerlink\" title=\"常用基本命令\"></a>常用基本命令</h3><ul>\n<li><p><code>ls -l</code> 的简略写法就是 <code>ll</code>，但是这个与<code>ls -a</code>又不同，后者用来显示隐藏文件和文件夹。</p>\n</li>\n<li><p>使用 <code>vim</code>修改文件时，如果想要不保存退出，使用<code>:q!</code>命令。</p>\n</li>\n<li><p>ubuntu改文件名用 <code>mv name1 name2</code>即可</p>\n</li>\n<li><p><code>cp filename filepath</code> //拷贝文件</p>\n</li>\n<li><p><code>cp -r 源目录  指定目录</code> //拷贝一个文件夹到另一个目录</p>\n</li>\n<li><p>从hdfs上取文件到本地需要链接集群，然后 <code>hdfs dfs -get /.../filename  storepath</code></p>\n</li>\n<li><p>查看路径：例如用<code>which python</code>查看python安装的路径</p>\n</li>\n<li><p><code>sudo apt-get remove + 软件名</code> 用于删除apt方式安装的软件</p>\n</li>\n<li><p><code>chmod [-可选参数][&lt;权限范围&gt;+/-/=&lt;权限设置&gt;] 文件/目录</code>  //改变文件权限</p>\n</li>\n<li><p><code>chown [-R] username filename/directoryname</code>  //更改文件或者文件夹所属用户</p>\n</li>\n<li><p><code>touch 文件名</code>命令用来创建一个空的文件</p>\n</li>\n<li><p>查看系统的所有PATH环境变量： <code>echo $PATH</code></p>\n</li>\n<li><p><code>rm -rf</code> 强制 递归地删除某个文件或者文件夹的所有文件</p>\n</li>\n<li><p><code>dpkg -i filename.deb</code>  //安装 .deb 文件</p>\n</li>\n</ul>\n<h3 id=\"grep语句\"><a href=\"#grep语句\" class=\"headerlink\" title=\"grep语句\"></a>grep语句</h3><ul>\n<li><p>Linux grep命令用于查找文件里符合条件的字符串。</p>\n</li>\n<li><p>简单命令格式： <code>grep [option] pattern file</code></p>\n</li>\n<li><p>完整格式： <code>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</code></p>\n</li>\n<li><p><strong>例（最常用）</strong>：<code>cat AR_log | grep &quot;====&quot;</code>此句就是打印日志AR_log当中所有包含了”====”的行</p>\n</li>\n<li><p>在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep test *file</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"apt常用命令\"><a href=\"#apt常用命令\" class=\"headerlink\" title=\"apt常用命令\"></a>apt常用命令</h3><ul>\n<li><p><code>apt-cache search package</code> 搜索包</p>\n</li>\n<li><p><code>apt-cache show package</code> 获取包的相关信息，如说明、大小、版本等</p>\n</li>\n<li><p><code>sudo apt-get install package</code> 安装包</p>\n</li>\n<li><p><code>sudo apt-get install package - - reinstall</code> 重新安装包</p>\n</li>\n<li><p><code>sudo apt-get -f install</code> 修复安装 “-f = ——fix-missing”</p>\n</li>\n<li><p><code>sudo apt autoremove</code> <strong>卸载某个软件并且删除与之相关的多余依赖</strong></p>\n</li>\n<li><p><code>sudo apt-get update</code> 更新源</p>\n</li>\n<li><p><code>sudo apt-get upgrade</code> <strong>更新已安装的包</strong></p>\n</li>\n<li><p><code>apt-cache depends package</code> 了解使用依赖</p>\n</li>\n<li><p><code>apt-cache rdepends package</code> 是查看该包被哪些包依赖</p>\n</li>\n<li><p><code>sudo apt-get build-dep package</code> 安装相关的编译环境</p>\n</li>\n<li><p><code>sudo apt-get clean &amp;&amp; sudo apt-get autoclean</code> 清理无用的包</p>\n</li>\n<li><p><code>sudo apt-get check</code> 检查是否有损坏的依赖</p>\n</li>\n</ul>\n<h3 id=\"scp语句\"><a href=\"#scp语句\" class=\"headerlink\" title=\"scp语句\"></a>scp语句</h3><ul>\n<li><p>语法： <code>scp [可选参数] file_source file_target</code></p>\n</li>\n<li><p>例：<code>scp /home/fleshier/My_Programes/Programes/AssociationRuleDiscovery/target/AR.jar   root@192.168.1.201:/root</code><br>此句就是吧一个本地的文件拷贝到远端的服务器上，用户是root，服务器地址是192.168.1.201，存放目录是 <code>/root</code></p>\n</li>\n<li><p>如果指定了用户名（如上例），则需要输入密码，如果没有指定用户名，则回车后需要输入用户名和密码。</p>\n</li>\n<li><p>使用参数<code>-r</code>来实现递归拷贝</p>\n</li>\n</ul>\n<p>例：<code>scp root@192.168.1.201:/root/runAR.sh /home/fleschier/cloud\\ computing/</code>从远程服务器拷贝到本地</p>\n<ul>\n<li><p>远程服务器的格式为 <code>用户名@IP地址:文件路径</code></p>\n</li>\n<li><p>额外说明：如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#scp 命令使用端口号 4588</span><br><span class=\"line\">scp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"curl命令\"><a href=\"#curl命令\" class=\"headerlink\" title=\"curl命令\"></a>curl命令</h3><ul>\n<li><p>curl命令是个功能强大的网络工具，支持通过http、ftp等方式下载文件、上传文件。还可以用来抓取网页、网络监控等方面的开发，解决开发过程中遇到的问题。</p>\n</li>\n<li><p>curl安装：<code>sudo apt-get install curl</code></p>\n</li>\n<li><p>get请求：<code>curl http://www.baidu.com</code> 回车之后，HTML内容打印在屏幕上；如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。</p>\n</li>\n<li><p>更多详细参数——<a href=\"http://www.cnblogs.com/linjiqin/p/5484910.html\" target=\"_blank\" rel=\"noopener\">curl命令详解</a></p>\n</li>\n</ul>\n<h3 id=\"gem命令\"><a href=\"#gem命令\" class=\"headerlink\" title=\"gem命令\"></a>gem命令</h3><ul>\n<li><p>安装命令 <code>gem install appname</code></p>\n</li>\n<li><p>Gem 是一个管理 Ruby 库和程序的标准包</p>\n</li>\n<li><p>所有的 gem 包，会被安装到 <code>/[Ruby root]/lib/ruby/gems/[ver]/</code> 目录下，这其中包括了 <code>Cache、doc、gems、specifications</code> 4个目录，<code>cache</code> 下放置下载的原生 gem 包，<code>gems</code> 下则放置的是解压过的 gem 包。</p>\n</li>\n<li><p>当安装过程中遇到问题时，可以进入这些目录，手动删除有问题的 gem 包，然后重新运行 <code>gem install [gemname]</code> 命令即可。</p>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li>参考资料：<a href=\"http://www.runoob.com/linux/linux-command-manual.html\" target=\"_blank\" rel=\"noopener\">linux命令大全-菜鸟教程</a>以及各大博客网站大佬们的博文。</li>\n</ul>\n<h3 id=\"df命令\"><a href=\"#df命令\" class=\"headerlink\" title=\"df命令\"></a>df命令</h3><ul>\n<li><p>df命令用来查看磁盘上的空间，默认以KB为单位</p>\n</li>\n<li><p>一般使用<code>df-h</code>命令来以KB以上的单位显示，可读性高</p>\n</li>\n<li><p><a href=\"http://man.linuxde.net/df\" target=\"_blank\" rel=\"noopener\">详解</a></p>\n</li>\n</ul>\n<h3 id=\"find命令\"><a href=\"#find命令\" class=\"headerlink\" title=\"find命令\"></a>find命令</h3><ul>\n<li><p>语法：<code>find path -option [ -print ] [-exec -ok command ] {} \\;</code></p>\n</li>\n<li><p><a href=\"http://www.runoob.com/linux/linux-comm-find.html\" target=\"_blank\" rel=\"noopener\">详解</a></p>\n</li>\n</ul>\n<h3 id=\"du命令\"><a href=\"#du命令\" class=\"headerlink\" title=\"du命令\"></a>du命令</h3><ul>\n<li><p>一般使用<code>du -h [--max-depth = k] /路径</code>来查看这个目录下的各个文件占用的空间</p>\n</li>\n<li><p><code>--max-depth</code>用来调节深度，一般k取1</p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/1c22dcb17a2e\" target=\"_blank\" rel=\"noopener\">详细教程</a></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.20</p>\n</blockquote>\n"},{"layout":"post","title":"UEFI双系统的那些坑","date":"2018-04-06T01:40:00.000Z","_content":"> 不适合人类阅读的自我备忘笔记  \n\n## 关于ubuntu 和 windows 双系统\n---\n\n- 在长时间使用Windows时候，难免会想要尝试新系统，而专业又是如此，于是我选择了linux中图形界面最为友好的ubuntu系统作为自己双系统的入门系统。\n\n- 虽然网上的双系统教程多说的很是简单，但是大多数已经是几年前的文章了，其中所讲的一些计算机的硬件系统已经落伍了，就比如说，网上绝大多数的双系统引导模式是建立在bios支持legacy（传统模式）模式下的，然而我自己的bios只能在UEFI模式下引导系统启动.....作为一名计算机系的学生当然不服气啊，当然各种百度什么的，期间踩过的坑实在难为外人道也。\n\n- 如果你的电脑支持legacy模式的话，自行百度一些教程就行了。装好ubuntu系统之后，进入bios将启动顺序整下，将Ubuntu启动器放在Windows boot manager前面就可以了。因为Ubuntu启动器可以调用Windows boot manager 而Windows不能启动Ubuntu。\n\n- 但是，UEFI作为最新的计算机启动模式，肯定要比原来的更加快速，或者如果你也像我一样，电脑不支持legacy启动，那么下面将要介绍一个非常好用的第三方启动引导程序。\n\n## 第三方启动引导程序——refind\n---\n\n- refind是一款功能非常强大的开机启动引导程序，它能够自定义开机界面。你可以吧系统图标，背景什么的换成你自己喜欢的风格。这里附上一张我采用的主题开机界面![](/images/linux-and-windows/opening-bg.jpg)如果你也喜欢这一风格，[这里是链接地址](https://github.com/EvanPurkhiser/rEFInd-minimal)。\n\n- refind是一款免费的软件([官方下载地址](http://www.rodsbooks.com/refind/getting.html))，如果你高兴也可以给作者赞助。\n\n- 如果使用UEFI引导方式启动系统的话，**在安装Ubuntu时要预留一个efi分区用来存放开机引导文件**，预留大概200MB-500MB即可。\n\n### Ubuntu下安装\n\n- 推荐在ubuntu下安装refind，简单到让人不敢相信。你只需要把软件下载下来，在终端运行里面的.shell文件，就会自动安装，无需任何额外的操作，重启系统，进入bios在启动顺序里将rEFInd调为第一个即可。\n\n### Windows下安装\n\n- 如果你非要不信邪，在Windows下尝试安装的话，我也不反对。首先你需要一个能够进入系统隐藏分区的软件——[DiskGenius](http://www.diskgenius.cn/)。推荐去官网下载正版而不要用盗版（然后去百度激活码...咳咳），毕竟牵涉到系统文件万一崩了别怪我没提醒。\n\n- 第一步，找到你系统的esp分区![](/img/linux-and-windows/ubuntu-boot.jpg)\n\n- 第二步，将下载的refind文件夹及其里面所有的东西全部复制进去。*（注意：虽然DiskGenius支持同时复制多个文件，但是文件夹没法复制，只能自己先手动创建）* **同时必须要自己创建一个refind.conf文件，可以什么都不写但是不能没有。** 然后原来的refind.conf-sample文件就可以删除了。![](/img/linux-and-windows/refind-info.jpg)\n\n- 第三步，将一些不需要的文件删除，如果你在网上下载了一些主题的话，也一并把文件复制进去。\n\n- 第四步，下载[bootice](https://bootice.en.softonic.com/?ex=REG-60.2)，打开DIskGenius给你放refind文件的那个分区取个卷标（随便什么都可以，下面有用）。打开bootice——UEFI——修改启动序列![](/img/linux-and-windows/bootice01.jpg)*(也可以顺手吧下面那个下次启动直接进入bios勾上，省的下次进bios要手动)*。点击添加，找到你之前分配盘符的那个盘（也就是esp分区），找到里面的refind文件夹，选择对应你系统的.efi文件，点击确定。![](/img/linux-and-windows/bootice02.jpg)重启系统，进入bios，将rEFInd启动项调整为第一个即可。*（没有对比就没有伤害，Windows下简直烦死，还不一定成功...）*\n\n- 最后希望各位都能成功在UEFI模式下完成双系统的安装和引导。\n\n\n<br>\n\n> 最后更新于2018.4.7\n","source":"_posts/2018-04-06-ubuntu-and-windows.md","raw":"---\nlayout:     post\ntitle:      \"UEFI双系统的那些坑\"\ndate:       2018-04-06 09:40:00\ncategories: Computer System\ntags: [๑DualSystem, ๑Ubuntu, ๑Linux]\n---\n> 不适合人类阅读的自我备忘笔记  \n\n## 关于ubuntu 和 windows 双系统\n---\n\n- 在长时间使用Windows时候，难免会想要尝试新系统，而专业又是如此，于是我选择了linux中图形界面最为友好的ubuntu系统作为自己双系统的入门系统。\n\n- 虽然网上的双系统教程多说的很是简单，但是大多数已经是几年前的文章了，其中所讲的一些计算机的硬件系统已经落伍了，就比如说，网上绝大多数的双系统引导模式是建立在bios支持legacy（传统模式）模式下的，然而我自己的bios只能在UEFI模式下引导系统启动.....作为一名计算机系的学生当然不服气啊，当然各种百度什么的，期间踩过的坑实在难为外人道也。\n\n- 如果你的电脑支持legacy模式的话，自行百度一些教程就行了。装好ubuntu系统之后，进入bios将启动顺序整下，将Ubuntu启动器放在Windows boot manager前面就可以了。因为Ubuntu启动器可以调用Windows boot manager 而Windows不能启动Ubuntu。\n\n- 但是，UEFI作为最新的计算机启动模式，肯定要比原来的更加快速，或者如果你也像我一样，电脑不支持legacy启动，那么下面将要介绍一个非常好用的第三方启动引导程序。\n\n## 第三方启动引导程序——refind\n---\n\n- refind是一款功能非常强大的开机启动引导程序，它能够自定义开机界面。你可以吧系统图标，背景什么的换成你自己喜欢的风格。这里附上一张我采用的主题开机界面![](/images/linux-and-windows/opening-bg.jpg)如果你也喜欢这一风格，[这里是链接地址](https://github.com/EvanPurkhiser/rEFInd-minimal)。\n\n- refind是一款免费的软件([官方下载地址](http://www.rodsbooks.com/refind/getting.html))，如果你高兴也可以给作者赞助。\n\n- 如果使用UEFI引导方式启动系统的话，**在安装Ubuntu时要预留一个efi分区用来存放开机引导文件**，预留大概200MB-500MB即可。\n\n### Ubuntu下安装\n\n- 推荐在ubuntu下安装refind，简单到让人不敢相信。你只需要把软件下载下来，在终端运行里面的.shell文件，就会自动安装，无需任何额外的操作，重启系统，进入bios在启动顺序里将rEFInd调为第一个即可。\n\n### Windows下安装\n\n- 如果你非要不信邪，在Windows下尝试安装的话，我也不反对。首先你需要一个能够进入系统隐藏分区的软件——[DiskGenius](http://www.diskgenius.cn/)。推荐去官网下载正版而不要用盗版（然后去百度激活码...咳咳），毕竟牵涉到系统文件万一崩了别怪我没提醒。\n\n- 第一步，找到你系统的esp分区![](/img/linux-and-windows/ubuntu-boot.jpg)\n\n- 第二步，将下载的refind文件夹及其里面所有的东西全部复制进去。*（注意：虽然DiskGenius支持同时复制多个文件，但是文件夹没法复制，只能自己先手动创建）* **同时必须要自己创建一个refind.conf文件，可以什么都不写但是不能没有。** 然后原来的refind.conf-sample文件就可以删除了。![](/img/linux-and-windows/refind-info.jpg)\n\n- 第三步，将一些不需要的文件删除，如果你在网上下载了一些主题的话，也一并把文件复制进去。\n\n- 第四步，下载[bootice](https://bootice.en.softonic.com/?ex=REG-60.2)，打开DIskGenius给你放refind文件的那个分区取个卷标（随便什么都可以，下面有用）。打开bootice——UEFI——修改启动序列![](/img/linux-and-windows/bootice01.jpg)*(也可以顺手吧下面那个下次启动直接进入bios勾上，省的下次进bios要手动)*。点击添加，找到你之前分配盘符的那个盘（也就是esp分区），找到里面的refind文件夹，选择对应你系统的.efi文件，点击确定。![](/img/linux-and-windows/bootice02.jpg)重启系统，进入bios，将rEFInd启动项调整为第一个即可。*（没有对比就没有伤害，Windows下简直烦死，还不一定成功...）*\n\n- 最后希望各位都能成功在UEFI模式下完成双系统的安装和引导。\n\n\n<br>\n\n> 最后更新于2018.4.7\n","slug":"2018-04-06-ubuntu-and-windows","published":1,"updated":"2018-09-03T13:23:23.907Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4g000t1m0o6y2vwebi","content":"<blockquote>\n<p>不适合人类阅读的自我备忘笔记  </p>\n</blockquote>\n<h2 id=\"关于ubuntu-和-windows-双系统\"><a href=\"#关于ubuntu-和-windows-双系统\" class=\"headerlink\" title=\"关于ubuntu 和 windows 双系统\"></a>关于ubuntu 和 windows 双系统</h2><hr>\n<ul>\n<li><p>在长时间使用Windows时候，难免会想要尝试新系统，而专业又是如此，于是我选择了linux中图形界面最为友好的ubuntu系统作为自己双系统的入门系统。</p>\n</li>\n<li><p>虽然网上的双系统教程多说的很是简单，但是大多数已经是几年前的文章了，其中所讲的一些计算机的硬件系统已经落伍了，就比如说，网上绝大多数的双系统引导模式是建立在bios支持legacy（传统模式）模式下的，然而我自己的bios只能在UEFI模式下引导系统启动…..作为一名计算机系的学生当然不服气啊，当然各种百度什么的，期间踩过的坑实在难为外人道也。</p>\n</li>\n<li><p>如果你的电脑支持legacy模式的话，自行百度一些教程就行了。装好ubuntu系统之后，进入bios将启动顺序整下，将Ubuntu启动器放在Windows boot manager前面就可以了。因为Ubuntu启动器可以调用Windows boot manager 而Windows不能启动Ubuntu。</p>\n</li>\n<li><p>但是，UEFI作为最新的计算机启动模式，肯定要比原来的更加快速，或者如果你也像我一样，电脑不支持legacy启动，那么下面将要介绍一个非常好用的第三方启动引导程序。</p>\n</li>\n</ul>\n<h2 id=\"第三方启动引导程序——refind\"><a href=\"#第三方启动引导程序——refind\" class=\"headerlink\" title=\"第三方启动引导程序——refind\"></a>第三方启动引导程序——refind</h2><hr>\n<ul>\n<li><p>refind是一款功能非常强大的开机启动引导程序，它能够自定义开机界面。你可以吧系统图标，背景什么的换成你自己喜欢的风格。这里附上一张我采用的主题开机界面<img src=\"/images/linux-and-windows/opening-bg.jpg\" alt=\"\">如果你也喜欢这一风格，<a href=\"https://github.com/EvanPurkhiser/rEFInd-minimal\" target=\"_blank\" rel=\"noopener\">这里是链接地址</a>。</p>\n</li>\n<li><p>refind是一款免费的软件(<a href=\"http://www.rodsbooks.com/refind/getting.html\" target=\"_blank\" rel=\"noopener\">官方下载地址</a>)，如果你高兴也可以给作者赞助。</p>\n</li>\n<li><p>如果使用UEFI引导方式启动系统的话，<strong>在安装Ubuntu时要预留一个efi分区用来存放开机引导文件</strong>，预留大概200MB-500MB即可。</p>\n</li>\n</ul>\n<h3 id=\"Ubuntu下安装\"><a href=\"#Ubuntu下安装\" class=\"headerlink\" title=\"Ubuntu下安装\"></a>Ubuntu下安装</h3><ul>\n<li>推荐在ubuntu下安装refind，简单到让人不敢相信。你只需要把软件下载下来，在终端运行里面的.shell文件，就会自动安装，无需任何额外的操作，重启系统，进入bios在启动顺序里将rEFInd调为第一个即可。</li>\n</ul>\n<h3 id=\"Windows下安装\"><a href=\"#Windows下安装\" class=\"headerlink\" title=\"Windows下安装\"></a>Windows下安装</h3><ul>\n<li><p>如果你非要不信邪，在Windows下尝试安装的话，我也不反对。首先你需要一个能够进入系统隐藏分区的软件——<a href=\"http://www.diskgenius.cn/\" target=\"_blank\" rel=\"noopener\">DiskGenius</a>。推荐去官网下载正版而不要用盗版（然后去百度激活码…咳咳），毕竟牵涉到系统文件万一崩了别怪我没提醒。</p>\n</li>\n<li><p>第一步，找到你系统的esp分区<img src=\"/img/linux-and-windows/ubuntu-boot.jpg\" alt=\"\"></p>\n</li>\n<li><p>第二步，将下载的refind文件夹及其里面所有的东西全部复制进去。<em>（注意：虽然DiskGenius支持同时复制多个文件，但是文件夹没法复制，只能自己先手动创建）</em> <strong>同时必须要自己创建一个refind.conf文件，可以什么都不写但是不能没有。</strong> 然后原来的refind.conf-sample文件就可以删除了。<img src=\"/img/linux-and-windows/refind-info.jpg\" alt=\"\"></p>\n</li>\n<li><p>第三步，将一些不需要的文件删除，如果你在网上下载了一些主题的话，也一并把文件复制进去。</p>\n</li>\n<li><p>第四步，下载<a href=\"https://bootice.en.softonic.com/?ex=REG-60.2\" target=\"_blank\" rel=\"noopener\">bootice</a>，打开DIskGenius给你放refind文件的那个分区取个卷标（随便什么都可以，下面有用）。打开bootice——UEFI——修改启动序列<img src=\"/img/linux-and-windows/bootice01.jpg\" alt=\"\"><em>(也可以顺手吧下面那个下次启动直接进入bios勾上，省的下次进bios要手动)</em>。点击添加，找到你之前分配盘符的那个盘（也就是esp分区），找到里面的refind文件夹，选择对应你系统的.efi文件，点击确定。<img src=\"/img/linux-and-windows/bootice02.jpg\" alt=\"\">重启系统，进入bios，将rEFInd启动项调整为第一个即可。<em>（没有对比就没有伤害，Windows下简直烦死，还不一定成功…）</em></p>\n</li>\n<li><p>最后希望各位都能成功在UEFI模式下完成双系统的安装和引导。</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.7</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的自我备忘笔记  </p>\n</blockquote>\n<h2 id=\"关于ubuntu-和-windows-双系统\"><a href=\"#关于ubuntu-和-windows-双系统\" class=\"headerlink\" title=\"关于ubuntu 和 windows 双系统\"></a>关于ubuntu 和 windows 双系统</h2><hr>\n<ul>\n<li><p>在长时间使用Windows时候，难免会想要尝试新系统，而专业又是如此，于是我选择了linux中图形界面最为友好的ubuntu系统作为自己双系统的入门系统。</p>\n</li>\n<li><p>虽然网上的双系统教程多说的很是简单，但是大多数已经是几年前的文章了，其中所讲的一些计算机的硬件系统已经落伍了，就比如说，网上绝大多数的双系统引导模式是建立在bios支持legacy（传统模式）模式下的，然而我自己的bios只能在UEFI模式下引导系统启动…..作为一名计算机系的学生当然不服气啊，当然各种百度什么的，期间踩过的坑实在难为外人道也。</p>\n</li>\n<li><p>如果你的电脑支持legacy模式的话，自行百度一些教程就行了。装好ubuntu系统之后，进入bios将启动顺序整下，将Ubuntu启动器放在Windows boot manager前面就可以了。因为Ubuntu启动器可以调用Windows boot manager 而Windows不能启动Ubuntu。</p>\n</li>\n<li><p>但是，UEFI作为最新的计算机启动模式，肯定要比原来的更加快速，或者如果你也像我一样，电脑不支持legacy启动，那么下面将要介绍一个非常好用的第三方启动引导程序。</p>\n</li>\n</ul>\n<h2 id=\"第三方启动引导程序——refind\"><a href=\"#第三方启动引导程序——refind\" class=\"headerlink\" title=\"第三方启动引导程序——refind\"></a>第三方启动引导程序——refind</h2><hr>\n<ul>\n<li><p>refind是一款功能非常强大的开机启动引导程序，它能够自定义开机界面。你可以吧系统图标，背景什么的换成你自己喜欢的风格。这里附上一张我采用的主题开机界面<img src=\"/images/linux-and-windows/opening-bg.jpg\" alt=\"\">如果你也喜欢这一风格，<a href=\"https://github.com/EvanPurkhiser/rEFInd-minimal\" target=\"_blank\" rel=\"noopener\">这里是链接地址</a>。</p>\n</li>\n<li><p>refind是一款免费的软件(<a href=\"http://www.rodsbooks.com/refind/getting.html\" target=\"_blank\" rel=\"noopener\">官方下载地址</a>)，如果你高兴也可以给作者赞助。</p>\n</li>\n<li><p>如果使用UEFI引导方式启动系统的话，<strong>在安装Ubuntu时要预留一个efi分区用来存放开机引导文件</strong>，预留大概200MB-500MB即可。</p>\n</li>\n</ul>\n<h3 id=\"Ubuntu下安装\"><a href=\"#Ubuntu下安装\" class=\"headerlink\" title=\"Ubuntu下安装\"></a>Ubuntu下安装</h3><ul>\n<li>推荐在ubuntu下安装refind，简单到让人不敢相信。你只需要把软件下载下来，在终端运行里面的.shell文件，就会自动安装，无需任何额外的操作，重启系统，进入bios在启动顺序里将rEFInd调为第一个即可。</li>\n</ul>\n<h3 id=\"Windows下安装\"><a href=\"#Windows下安装\" class=\"headerlink\" title=\"Windows下安装\"></a>Windows下安装</h3><ul>\n<li><p>如果你非要不信邪，在Windows下尝试安装的话，我也不反对。首先你需要一个能够进入系统隐藏分区的软件——<a href=\"http://www.diskgenius.cn/\" target=\"_blank\" rel=\"noopener\">DiskGenius</a>。推荐去官网下载正版而不要用盗版（然后去百度激活码…咳咳），毕竟牵涉到系统文件万一崩了别怪我没提醒。</p>\n</li>\n<li><p>第一步，找到你系统的esp分区<img src=\"/img/linux-and-windows/ubuntu-boot.jpg\" alt=\"\"></p>\n</li>\n<li><p>第二步，将下载的refind文件夹及其里面所有的东西全部复制进去。<em>（注意：虽然DiskGenius支持同时复制多个文件，但是文件夹没法复制，只能自己先手动创建）</em> <strong>同时必须要自己创建一个refind.conf文件，可以什么都不写但是不能没有。</strong> 然后原来的refind.conf-sample文件就可以删除了。<img src=\"/img/linux-and-windows/refind-info.jpg\" alt=\"\"></p>\n</li>\n<li><p>第三步，将一些不需要的文件删除，如果你在网上下载了一些主题的话，也一并把文件复制进去。</p>\n</li>\n<li><p>第四步，下载<a href=\"https://bootice.en.softonic.com/?ex=REG-60.2\" target=\"_blank\" rel=\"noopener\">bootice</a>，打开DIskGenius给你放refind文件的那个分区取个卷标（随便什么都可以，下面有用）。打开bootice——UEFI——修改启动序列<img src=\"/img/linux-and-windows/bootice01.jpg\" alt=\"\"><em>(也可以顺手吧下面那个下次启动直接进入bios勾上，省的下次进bios要手动)</em>。点击添加，找到你之前分配盘符的那个盘（也就是esp分区），找到里面的refind文件夹，选择对应你系统的.efi文件，点击确定。<img src=\"/img/linux-and-windows/bootice02.jpg\" alt=\"\">重启系统，进入bios，将rEFInd启动项调整为第一个即可。<em>（没有对比就没有伤害，Windows下简直烦死，还不一定成功…）</em></p>\n</li>\n<li><p>最后希望各位都能成功在UEFI模式下完成双系统的安装和引导。</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.7</p>\n</blockquote>\n"},{"layout":"post","title":"数据库SQL语句","date":"2018-04-07T12:55:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n- **数据库的命令语句均不区分大小写**\n\n## 创建语句\n---\n\n### 基本创建\n\n- 创建数据库 ：`create database XXX`\n\n- 带详细参数的数据库创建：\n```\ncreate database School on(\n\tname = 'School_data',\n\tfilename = 'c:\\data\\School_data.mdf',\n\tsize = 5mb,\n\tfilegrowth = 1mb --每次增长的大小\n)\n```\n\n- 创建表： `create table XXX`\n\n- 带属性的创建：\n```\ncreate table student(\n\tSno char(6) primary key,\n\tSname varchar(8),\n\tSsex char(2),\n\tSage smallint,\n\tSdept varchar(15)\n)\n```\n\n- 更加复杂的创建：\n```\ncreate table student(\n\tSno char(6) primary key,  --主键\n\tSname varchar(8) not null constraint ck_1 unique, --创建时加入约束条件\n\tSsex char(2) not null constraint ck_2 check(Ssex in('男','女')),\n\tSage smallint constraint ck_3 check(sage>16),\n\tSdept varchar(15) default 'JSJ'  --默认值\n)\ncreate table course(\n\tCno char(6) primary key,\n\tCname varchar(20),\n\tCpno char(4),\n\tCcredit tinyint\n)\ncreate table SC(\n\tSno char(6) not null, --要在表外添加主键的约束，则这个属性不能为空\n\tCno char(6) not null,\n\tGrade decimal(12,1) constraint ck_6 check(Grade <= 100 and Grade >=0)\n\tconstraint fk_1 foreign key (Sno) references student(sno)\n)\nalter table SC add constraint PK_SC primary key(Sno,Cno)\n```\ncheck语句是一种约束条件写法，与constraint功能类似\n\n- 在创建时设置foreign key：\n```\ncreate table sc(\n\tSno char(6),\n\tCno char(4),\n\tGrade decimal(12,2),\n\tprimary key(Sno,Cno),\n\tforeign key(Sno) references student(Sno),\n\tforeign key(Cno) references course(Cno)\n)\n```\n\n### 创建索引\n\n```\ncreate index Ix_student_sname on student(Sname)\ncreate index Ix_student_sdept on student(Sdept)\ncreate index Ix_sc_cno on SC(Cno)\ncreate index Ix_course_cname on Course(Cname)\nsp_help student  --查看索引等信息\ndrop index student.ix_student_sname    --删除索引\n```\n\n### 插入数据：\n>数据顺序和类型要与创建时的定义一致\n\n```\ninsert into student values('5001','赵强','男','20','SX')\ninsert into student values('5002','李丽华','女','21','JSJ')\ninsert into student values('5001','李静','女','20','SX')\n```\n### 将数据从一个表插入另一个表\n\n```\n--批量插入数据(从student 到 sc_name)\ninsert into sc_name (Sno,Sname,Ssex)\nselect Sno,Sname,Ssex from student where Sdept = 'SX'\n```\n\n\n## 在表外的更改操作\n---\n\n### 在表外更改表结构\n\n```\ncreate table student(\n\tSno char(6),\n\tSname varchar(8),\n\tSsex char(2),\n\tSage smallint,\n\tSdept varchar(15)\n)\nalter table student add address varchar(60) --添加列\nalter table student add inDate datetime --添加列，数据类型为datetime\nalter table student alter column adress varchar(50)\nalter table student drop column inDate\n```\n\n### 用户自定义完整性约束\n\n```\nalter table student add constraint cs_1 check(Ssex in ('男','女'))\nalter table student add constraint cs_2 check(Sage >16)\nalter table Course add constraint cs_3 check(Ccredit in (0,1,2,3,4,5))\nalter table Course add constraint cs_4 check(Cno != Cpno)\n```\n\n- 删除约束： `alter table student drop constraint cs_1`\n\n### 更新表数据\n\n- 使用update和查找条件： `update student set Sno = 4018 where Sno = 4003`\n\n## 获取详细信息\n---\n\n- `sp_help 表名`\n\n- `sp_helpdb 数据库名`\n\n## 查询语句\n---\n### 基本查询操作\n\n- `select [列名（逗号间隔）或者*] from 表名`\n\n### 进阶(单表)\n\n```\nselect Sno,Sname,Sage from student\nwhere Sage >= 19 and Sage <= 21 and Ssex = '女' order by Sage desc\n-- desc表示降序，asc表示升序\n```\n\n```\nselect Sno,Ssex from student where Sname like '_明%'  \n--'_'表示一个字符，%表示任意多个字符,这里筛选出名字第二个字为‘明’的人\n```\n\n```\nselect Sno,Cno from SC where Grade is null\n-- 如果用'= null'则查询结果为空\n```\n\n```\nselect Sno,Cno,cast((Grade/10) as int)from SC\n-- cast(a as int)转换数据类型\n```\n\n```\nselect distinct Sdept from student\n-- distinct写在最前面\n```\n\n### 进阶（统计）\n\n```\nselect count(*) as number from student\nwhere Sname like '%明%'\n-- 统计名字有‘明’的人数\n```\n\n```\nselect Cno,sum(Grade) as total_grade,avg(Grade) as avg_grade,max(Grade) as max_grade,min(Grade) as min_grade from SC  \ngroup by Cno\norder by avg_grade desc\n-- sum()求和\n```\n\n```\nselect Cno from SC\nwhere Grade >= 85\ngroup by Cno\nhaving count(Sno)>10\n-- where 筛选必须在group 之前，group之后可以用having筛选，两者可以并用\n```\n\n```\nselect Sno from SC\nwhere Grade <60  \ngroup by Sno\nhaving count(Cno) > 2\n```\n### 进阶（连接）\n\n```\nselect distinct Cno from student,SC\nwhere student.Sno = SC.Sno and Sdept = 'JSJ'\n-- 连接要写出连接条件\n```\n\n```\n-- 三种写法\nselect Sname from student,SC\nwhere student.Sno = SC.Sno and Cno = 1002\nXXXXXX\nselect Sname from student\njoin SC on student.Sno = Sc.Sno\nwhere Cno = 1002             -- JOIN..ON..语句\nXXXXXX\nselect Sname from student\nwhere Sno in(                --嵌套执行\n\tselect Sno from SC where Cno = 1002\n)\n```\n\n```\nselect student.Sno, Grade from student,course,SC\nwhere student.Sno = SC.Sno and course.Cno = SC.Cno and Cname = '数据库原理' and Grade <60\n--用表名.列名来获取具有相同列名的几个表中某个表的某一列\n```\n\n```\n-- 两种写法\nselect student.Sname from student,SC\nwhere student.Sno = SC.Sno and Grade >= 80 and Cno = 1004\nXXXXXX\nselect Sname from student\nwhere Sno in(                --嵌套写法\n\tselect Sno from SC where Grade > 80 and Cno in(\n\t\tselect Cno from course where Cname = '数据库原理'\n\t)\n)\n```\n###\n\n### 进阶（嵌套）\n\n```\n-- 找出平均成绩最大的一个（两种写法）\nselect  top 1 Sno,avg(Grade) as avg_grade from SC\ngroup by Sno\norder by avg(Grade) desc\nXXXXXX\nselect Sno,avg(Grade) as avg_grade from SC\ngroup by Sno\nhaving avg(Grade) >= all(select avg(Grade) from SC group by Sno)\n```\n\n## 删除\n---\n\n- 删除表： `drop table XXX`\n\n- 删除表中的内容： `delete from XXX`\n\n- 删除数据库： `drop database XXX`\n\n- 删除依赖： `drop constraint XXX`\n\n## 补充\n---\n\n### 循环生成数据\n```\n--生成大量数据\ncreate procedure usp_makedata as\ndeclare @nCnt int, @sNo char(6), @sname varchar(8)\nset @nCnt = 12000 --counter\nwhile @nCnt <999999\nbegin\n\tset @nCnt = @nCnt +1\n\tset @sNo = convert(varchar(6),@nCnt)\n\tset @sName = '张' +@sno\n\tinsert into student (sno,sname,ssex,sage) values (@sno,@sname,'男',20)\nend\nreturn\nexec usp_makedata\t--执行生成过程\n```\n### 测试生成的数据\n```\n--生成测试\ncreate procedure usp_test as\ndeclare @nCount int ,@data int\nset @nCount=0\nwhile @nCount <100\nbegin\n\tselect @data = count(*) from student\n\twhere sname <'张3800' or sname >'张8800'\n\tset @nCount =@nCount + 1\nend\nexec usp_test --执行测试\n```\n### 善后\n```\ndrop procedure usp_makedata\ndrop procedure usp_test\n```\n## E-R图的画法\n---\n\n- 实体型(Entity)：用矩形表示，矩形框内写明实体名\n\n- 属性(Attribute)：用椭圆形表示，并用无向边将其与相应的实体连接起来\n\n- 联系(Relationship)：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型(1 : 1，1 : n或m : n)。 (一对一，一对多还是多对多)\n\n- 图例：\n![](/images/SQL/E-R graphe.png)\n\n- 示例：\n![](/images/SQL/TIM图片20180503210911.jpg)\n画图时先画实体型和联系，最后添加属性即可。对于那些有公共属性的两个实体型，属性应当连到联系上(菱形上的属性)\n\n### 从 E-R图转为关系模式：\n\n- 首先是看有几个实体，每个实体单独存放为一个关系，即表。**每个表的字段包含了这个实体所有的属性，即括号内的内容**\n\n- 然后分析实体间的联系。实体间联系有的要单独存一个表，有的不要。\n\n- **如果实体和实体间是多对一或者一对一的关系则不需要单独创建一个表，而是通过在参与联系的多方实体中，增加一个参与联系的1方的实体的主键作为一列来表示联系**。例如，车队和车辆是一对多的关系，这里 **多** 是车辆这个实体，1是车队这个实体。车队的实体的主键是车队号，所以，我们在多方(车辆)这个表中，增加1方(车队)的主键(车队号)作为一列来表示联系，即将  车队号  加到 车辆 这个实体的属性列表中。这里的 车队号 显然是 **外键**。\n\n- **如果两个实体之间的联系是多对多的，联系要单独存放为一个表**。这个表的主键，是参与联系的两个实体的主键的组合，而联系的属性作为其他列。例如：车辆和司机之间是多对多的关系，使用 `联系名(车牌号，司机编码，使用日期，公里数)` 这里的车牌号是 车辆 这一实体的主键，司机编码是 司机 这一实体的主键，而后面两个是联系的属性。外键是： 车牌号，司机编码。\n\n- 每个关系的主键都要标出来，外键写在关系的最后，属性括号的外面。\n\n\n\n\n- [简明教学](https://blog.csdn.net/sunzhenhua0608/article/details/8822871)\n\n- [详细教学](https://blog.csdn.net/zxq1138634642/article/details/9121363)\n\n<br>\n\n> 最后更新于2018.5.3\n","source":"_posts/2018-04-07-SQL-quary.md","raw":"---\nlayout:     post\ntitle:      \"数据库SQL语句\"\ndate:       2018-04-7 20:55:00\ncategories: Computer Programes\ntags: ๑SQL\n---\n\n> 不适合人类阅读的学习笔记\n\n- **数据库的命令语句均不区分大小写**\n\n## 创建语句\n---\n\n### 基本创建\n\n- 创建数据库 ：`create database XXX`\n\n- 带详细参数的数据库创建：\n```\ncreate database School on(\n\tname = 'School_data',\n\tfilename = 'c:\\data\\School_data.mdf',\n\tsize = 5mb,\n\tfilegrowth = 1mb --每次增长的大小\n)\n```\n\n- 创建表： `create table XXX`\n\n- 带属性的创建：\n```\ncreate table student(\n\tSno char(6) primary key,\n\tSname varchar(8),\n\tSsex char(2),\n\tSage smallint,\n\tSdept varchar(15)\n)\n```\n\n- 更加复杂的创建：\n```\ncreate table student(\n\tSno char(6) primary key,  --主键\n\tSname varchar(8) not null constraint ck_1 unique, --创建时加入约束条件\n\tSsex char(2) not null constraint ck_2 check(Ssex in('男','女')),\n\tSage smallint constraint ck_3 check(sage>16),\n\tSdept varchar(15) default 'JSJ'  --默认值\n)\ncreate table course(\n\tCno char(6) primary key,\n\tCname varchar(20),\n\tCpno char(4),\n\tCcredit tinyint\n)\ncreate table SC(\n\tSno char(6) not null, --要在表外添加主键的约束，则这个属性不能为空\n\tCno char(6) not null,\n\tGrade decimal(12,1) constraint ck_6 check(Grade <= 100 and Grade >=0)\n\tconstraint fk_1 foreign key (Sno) references student(sno)\n)\nalter table SC add constraint PK_SC primary key(Sno,Cno)\n```\ncheck语句是一种约束条件写法，与constraint功能类似\n\n- 在创建时设置foreign key：\n```\ncreate table sc(\n\tSno char(6),\n\tCno char(4),\n\tGrade decimal(12,2),\n\tprimary key(Sno,Cno),\n\tforeign key(Sno) references student(Sno),\n\tforeign key(Cno) references course(Cno)\n)\n```\n\n### 创建索引\n\n```\ncreate index Ix_student_sname on student(Sname)\ncreate index Ix_student_sdept on student(Sdept)\ncreate index Ix_sc_cno on SC(Cno)\ncreate index Ix_course_cname on Course(Cname)\nsp_help student  --查看索引等信息\ndrop index student.ix_student_sname    --删除索引\n```\n\n### 插入数据：\n>数据顺序和类型要与创建时的定义一致\n\n```\ninsert into student values('5001','赵强','男','20','SX')\ninsert into student values('5002','李丽华','女','21','JSJ')\ninsert into student values('5001','李静','女','20','SX')\n```\n### 将数据从一个表插入另一个表\n\n```\n--批量插入数据(从student 到 sc_name)\ninsert into sc_name (Sno,Sname,Ssex)\nselect Sno,Sname,Ssex from student where Sdept = 'SX'\n```\n\n\n## 在表外的更改操作\n---\n\n### 在表外更改表结构\n\n```\ncreate table student(\n\tSno char(6),\n\tSname varchar(8),\n\tSsex char(2),\n\tSage smallint,\n\tSdept varchar(15)\n)\nalter table student add address varchar(60) --添加列\nalter table student add inDate datetime --添加列，数据类型为datetime\nalter table student alter column adress varchar(50)\nalter table student drop column inDate\n```\n\n### 用户自定义完整性约束\n\n```\nalter table student add constraint cs_1 check(Ssex in ('男','女'))\nalter table student add constraint cs_2 check(Sage >16)\nalter table Course add constraint cs_3 check(Ccredit in (0,1,2,3,4,5))\nalter table Course add constraint cs_4 check(Cno != Cpno)\n```\n\n- 删除约束： `alter table student drop constraint cs_1`\n\n### 更新表数据\n\n- 使用update和查找条件： `update student set Sno = 4018 where Sno = 4003`\n\n## 获取详细信息\n---\n\n- `sp_help 表名`\n\n- `sp_helpdb 数据库名`\n\n## 查询语句\n---\n### 基本查询操作\n\n- `select [列名（逗号间隔）或者*] from 表名`\n\n### 进阶(单表)\n\n```\nselect Sno,Sname,Sage from student\nwhere Sage >= 19 and Sage <= 21 and Ssex = '女' order by Sage desc\n-- desc表示降序，asc表示升序\n```\n\n```\nselect Sno,Ssex from student where Sname like '_明%'  \n--'_'表示一个字符，%表示任意多个字符,这里筛选出名字第二个字为‘明’的人\n```\n\n```\nselect Sno,Cno from SC where Grade is null\n-- 如果用'= null'则查询结果为空\n```\n\n```\nselect Sno,Cno,cast((Grade/10) as int)from SC\n-- cast(a as int)转换数据类型\n```\n\n```\nselect distinct Sdept from student\n-- distinct写在最前面\n```\n\n### 进阶（统计）\n\n```\nselect count(*) as number from student\nwhere Sname like '%明%'\n-- 统计名字有‘明’的人数\n```\n\n```\nselect Cno,sum(Grade) as total_grade,avg(Grade) as avg_grade,max(Grade) as max_grade,min(Grade) as min_grade from SC  \ngroup by Cno\norder by avg_grade desc\n-- sum()求和\n```\n\n```\nselect Cno from SC\nwhere Grade >= 85\ngroup by Cno\nhaving count(Sno)>10\n-- where 筛选必须在group 之前，group之后可以用having筛选，两者可以并用\n```\n\n```\nselect Sno from SC\nwhere Grade <60  \ngroup by Sno\nhaving count(Cno) > 2\n```\n### 进阶（连接）\n\n```\nselect distinct Cno from student,SC\nwhere student.Sno = SC.Sno and Sdept = 'JSJ'\n-- 连接要写出连接条件\n```\n\n```\n-- 三种写法\nselect Sname from student,SC\nwhere student.Sno = SC.Sno and Cno = 1002\nXXXXXX\nselect Sname from student\njoin SC on student.Sno = Sc.Sno\nwhere Cno = 1002             -- JOIN..ON..语句\nXXXXXX\nselect Sname from student\nwhere Sno in(                --嵌套执行\n\tselect Sno from SC where Cno = 1002\n)\n```\n\n```\nselect student.Sno, Grade from student,course,SC\nwhere student.Sno = SC.Sno and course.Cno = SC.Cno and Cname = '数据库原理' and Grade <60\n--用表名.列名来获取具有相同列名的几个表中某个表的某一列\n```\n\n```\n-- 两种写法\nselect student.Sname from student,SC\nwhere student.Sno = SC.Sno and Grade >= 80 and Cno = 1004\nXXXXXX\nselect Sname from student\nwhere Sno in(                --嵌套写法\n\tselect Sno from SC where Grade > 80 and Cno in(\n\t\tselect Cno from course where Cname = '数据库原理'\n\t)\n)\n```\n###\n\n### 进阶（嵌套）\n\n```\n-- 找出平均成绩最大的一个（两种写法）\nselect  top 1 Sno,avg(Grade) as avg_grade from SC\ngroup by Sno\norder by avg(Grade) desc\nXXXXXX\nselect Sno,avg(Grade) as avg_grade from SC\ngroup by Sno\nhaving avg(Grade) >= all(select avg(Grade) from SC group by Sno)\n```\n\n## 删除\n---\n\n- 删除表： `drop table XXX`\n\n- 删除表中的内容： `delete from XXX`\n\n- 删除数据库： `drop database XXX`\n\n- 删除依赖： `drop constraint XXX`\n\n## 补充\n---\n\n### 循环生成数据\n```\n--生成大量数据\ncreate procedure usp_makedata as\ndeclare @nCnt int, @sNo char(6), @sname varchar(8)\nset @nCnt = 12000 --counter\nwhile @nCnt <999999\nbegin\n\tset @nCnt = @nCnt +1\n\tset @sNo = convert(varchar(6),@nCnt)\n\tset @sName = '张' +@sno\n\tinsert into student (sno,sname,ssex,sage) values (@sno,@sname,'男',20)\nend\nreturn\nexec usp_makedata\t--执行生成过程\n```\n### 测试生成的数据\n```\n--生成测试\ncreate procedure usp_test as\ndeclare @nCount int ,@data int\nset @nCount=0\nwhile @nCount <100\nbegin\n\tselect @data = count(*) from student\n\twhere sname <'张3800' or sname >'张8800'\n\tset @nCount =@nCount + 1\nend\nexec usp_test --执行测试\n```\n### 善后\n```\ndrop procedure usp_makedata\ndrop procedure usp_test\n```\n## E-R图的画法\n---\n\n- 实体型(Entity)：用矩形表示，矩形框内写明实体名\n\n- 属性(Attribute)：用椭圆形表示，并用无向边将其与相应的实体连接起来\n\n- 联系(Relationship)：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型(1 : 1，1 : n或m : n)。 (一对一，一对多还是多对多)\n\n- 图例：\n![](/images/SQL/E-R graphe.png)\n\n- 示例：\n![](/images/SQL/TIM图片20180503210911.jpg)\n画图时先画实体型和联系，最后添加属性即可。对于那些有公共属性的两个实体型，属性应当连到联系上(菱形上的属性)\n\n### 从 E-R图转为关系模式：\n\n- 首先是看有几个实体，每个实体单独存放为一个关系，即表。**每个表的字段包含了这个实体所有的属性，即括号内的内容**\n\n- 然后分析实体间的联系。实体间联系有的要单独存一个表，有的不要。\n\n- **如果实体和实体间是多对一或者一对一的关系则不需要单独创建一个表，而是通过在参与联系的多方实体中，增加一个参与联系的1方的实体的主键作为一列来表示联系**。例如，车队和车辆是一对多的关系，这里 **多** 是车辆这个实体，1是车队这个实体。车队的实体的主键是车队号，所以，我们在多方(车辆)这个表中，增加1方(车队)的主键(车队号)作为一列来表示联系，即将  车队号  加到 车辆 这个实体的属性列表中。这里的 车队号 显然是 **外键**。\n\n- **如果两个实体之间的联系是多对多的，联系要单独存放为一个表**。这个表的主键，是参与联系的两个实体的主键的组合，而联系的属性作为其他列。例如：车辆和司机之间是多对多的关系，使用 `联系名(车牌号，司机编码，使用日期，公里数)` 这里的车牌号是 车辆 这一实体的主键，司机编码是 司机 这一实体的主键，而后面两个是联系的属性。外键是： 车牌号，司机编码。\n\n- 每个关系的主键都要标出来，外键写在关系的最后，属性括号的外面。\n\n\n\n\n- [简明教学](https://blog.csdn.net/sunzhenhua0608/article/details/8822871)\n\n- [详细教学](https://blog.csdn.net/zxq1138634642/article/details/9121363)\n\n<br>\n\n> 最后更新于2018.5.3\n","slug":"2018-04-07-SQL-quary","published":1,"updated":"2018-09-03T13:19:13.490Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4h000w1m0o95rf8yug","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<ul>\n<li><strong>数据库的命令语句均不区分大小写</strong></li>\n</ul>\n<h2 id=\"创建语句\"><a href=\"#创建语句\" class=\"headerlink\" title=\"创建语句\"></a>创建语句</h2><hr>\n<h3 id=\"基本创建\"><a href=\"#基本创建\" class=\"headerlink\" title=\"基本创建\"></a>基本创建</h3><ul>\n<li><p>创建数据库 ：<code>create database XXX</code></p>\n</li>\n<li><p>带详细参数的数据库创建：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create database School on(</span><br><span class=\"line\">\tname = &apos;School_data&apos;,</span><br><span class=\"line\">\tfilename = &apos;c:\\data\\School_data.mdf&apos;,</span><br><span class=\"line\">\tsize = 5mb,</span><br><span class=\"line\">\tfilegrowth = 1mb --每次增长的大小</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建表： <code>create table XXX</code></p>\n</li>\n<li><p>带属性的创建：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table student(</span><br><span class=\"line\">\tSno char(6) primary key,</span><br><span class=\"line\">\tSname varchar(8),</span><br><span class=\"line\">\tSsex char(2),</span><br><span class=\"line\">\tSage smallint,</span><br><span class=\"line\">\tSdept varchar(15)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更加复杂的创建：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table student(</span><br><span class=\"line\">\tSno char(6) primary key,  --主键</span><br><span class=\"line\">\tSname varchar(8) not null constraint ck_1 unique, --创建时加入约束条件</span><br><span class=\"line\">\tSsex char(2) not null constraint ck_2 check(Ssex in(&apos;男&apos;,&apos;女&apos;)),</span><br><span class=\"line\">\tSage smallint constraint ck_3 check(sage&gt;16),</span><br><span class=\"line\">\tSdept varchar(15) default &apos;JSJ&apos;  --默认值</span><br><span class=\"line\">)</span><br><span class=\"line\">create table course(</span><br><span class=\"line\">\tCno char(6) primary key,</span><br><span class=\"line\">\tCname varchar(20),</span><br><span class=\"line\">\tCpno char(4),</span><br><span class=\"line\">\tCcredit tinyint</span><br><span class=\"line\">)</span><br><span class=\"line\">create table SC(</span><br><span class=\"line\">\tSno char(6) not null, --要在表外添加主键的约束，则这个属性不能为空</span><br><span class=\"line\">\tCno char(6) not null,</span><br><span class=\"line\">\tGrade decimal(12,1) constraint ck_6 check(Grade &lt;= 100 and Grade &gt;=0)</span><br><span class=\"line\">\tconstraint fk_1 foreign key (Sno) references student(sno)</span><br><span class=\"line\">)</span><br><span class=\"line\">alter table SC add constraint PK_SC primary key(Sno,Cno)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>check语句是一种约束条件写法，与constraint功能类似</p>\n<ul>\n<li>在创建时设置foreign key：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table sc(</span><br><span class=\"line\">\tSno char(6),</span><br><span class=\"line\">\tCno char(4),</span><br><span class=\"line\">\tGrade decimal(12,2),</span><br><span class=\"line\">\tprimary key(Sno,Cno),</span><br><span class=\"line\">\tforeign key(Sno) references student(Sno),</span><br><span class=\"line\">\tforeign key(Cno) references course(Cno)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create index Ix_student_sname on student(Sname)</span><br><span class=\"line\">create index Ix_student_sdept on student(Sdept)</span><br><span class=\"line\">create index Ix_sc_cno on SC(Cno)</span><br><span class=\"line\">create index Ix_course_cname on Course(Cname)</span><br><span class=\"line\">sp_help student  --查看索引等信息</span><br><span class=\"line\">drop index student.ix_student_sname    --删除索引</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入数据：\"><a href=\"#插入数据：\" class=\"headerlink\" title=\"插入数据：\"></a>插入数据：</h3><blockquote>\n<p>数据顺序和类型要与创建时的定义一致</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into student values(&apos;5001&apos;,&apos;赵强&apos;,&apos;男&apos;,&apos;20&apos;,&apos;SX&apos;)</span><br><span class=\"line\">insert into student values(&apos;5002&apos;,&apos;李丽华&apos;,&apos;女&apos;,&apos;21&apos;,&apos;JSJ&apos;)</span><br><span class=\"line\">insert into student values(&apos;5001&apos;,&apos;李静&apos;,&apos;女&apos;,&apos;20&apos;,&apos;SX&apos;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"将数据从一个表插入另一个表\"><a href=\"#将数据从一个表插入另一个表\" class=\"headerlink\" title=\"将数据从一个表插入另一个表\"></a>将数据从一个表插入另一个表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--批量插入数据(从student 到 sc_name)</span><br><span class=\"line\">insert into sc_name (Sno,Sname,Ssex)</span><br><span class=\"line\">select Sno,Sname,Ssex from student where Sdept = &apos;SX&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在表外的更改操作\"><a href=\"#在表外的更改操作\" class=\"headerlink\" title=\"在表外的更改操作\"></a>在表外的更改操作</h2><hr>\n<h3 id=\"在表外更改表结构\"><a href=\"#在表外更改表结构\" class=\"headerlink\" title=\"在表外更改表结构\"></a>在表外更改表结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table student(</span><br><span class=\"line\">\tSno char(6),</span><br><span class=\"line\">\tSname varchar(8),</span><br><span class=\"line\">\tSsex char(2),</span><br><span class=\"line\">\tSage smallint,</span><br><span class=\"line\">\tSdept varchar(15)</span><br><span class=\"line\">)</span><br><span class=\"line\">alter table student add address varchar(60) --添加列</span><br><span class=\"line\">alter table student add inDate datetime --添加列，数据类型为datetime</span><br><span class=\"line\">alter table student alter column adress varchar(50)</span><br><span class=\"line\">alter table student drop column inDate</span><br></pre></td></tr></table></figure>\n<h3 id=\"用户自定义完整性约束\"><a href=\"#用户自定义完整性约束\" class=\"headerlink\" title=\"用户自定义完整性约束\"></a>用户自定义完整性约束</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table student add constraint cs_1 check(Ssex in (&apos;男&apos;,&apos;女&apos;))</span><br><span class=\"line\">alter table student add constraint cs_2 check(Sage &gt;16)</span><br><span class=\"line\">alter table Course add constraint cs_3 check(Ccredit in (0,1,2,3,4,5))</span><br><span class=\"line\">alter table Course add constraint cs_4 check(Cno != Cpno)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除约束： <code>alter table student drop constraint cs_1</code></li>\n</ul>\n<h3 id=\"更新表数据\"><a href=\"#更新表数据\" class=\"headerlink\" title=\"更新表数据\"></a>更新表数据</h3><ul>\n<li>使用update和查找条件： <code>update student set Sno = 4018 where Sno = 4003</code></li>\n</ul>\n<h2 id=\"获取详细信息\"><a href=\"#获取详细信息\" class=\"headerlink\" title=\"获取详细信息\"></a>获取详细信息</h2><hr>\n<ul>\n<li><p><code>sp_help 表名</code></p>\n</li>\n<li><p><code>sp_helpdb 数据库名</code></p>\n</li>\n</ul>\n<h2 id=\"查询语句\"><a href=\"#查询语句\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h2><hr>\n<h3 id=\"基本查询操作\"><a href=\"#基本查询操作\" class=\"headerlink\" title=\"基本查询操作\"></a>基本查询操作</h3><ul>\n<li><code>select [列名（逗号间隔）或者*] from 表名</code></li>\n</ul>\n<h3 id=\"进阶-单表\"><a href=\"#进阶-单表\" class=\"headerlink\" title=\"进阶(单表)\"></a>进阶(单表)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Sno,Sname,Sage from student</span><br><span class=\"line\">where Sage &gt;= 19 and Sage &lt;= 21 and Ssex = &apos;女&apos; order by Sage desc</span><br><span class=\"line\">-- desc表示降序，asc表示升序</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Sno,Ssex from student where Sname like &apos;_明%&apos;  </span><br><span class=\"line\">--&apos;_&apos;表示一个字符，%表示任意多个字符,这里筛选出名字第二个字为‘明’的人</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Sno,Cno from SC where Grade is null</span><br><span class=\"line\">-- 如果用&apos;= null&apos;则查询结果为空</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Sno,Cno,cast((Grade/10) as int)from SC</span><br><span class=\"line\">-- cast(a as int)转换数据类型</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct Sdept from student</span><br><span class=\"line\">-- distinct写在最前面</span><br></pre></td></tr></table></figure>\n<h3 id=\"进阶（统计）\"><a href=\"#进阶（统计）\" class=\"headerlink\" title=\"进阶（统计）\"></a>进阶（统计）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select count(*) as number from student</span><br><span class=\"line\">where Sname like &apos;%明%&apos;</span><br><span class=\"line\">-- 统计名字有‘明’的人数</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Cno,sum(Grade) as total_grade,avg(Grade) as avg_grade,max(Grade) as max_grade,min(Grade) as min_grade from SC  </span><br><span class=\"line\">group by Cno</span><br><span class=\"line\">order by avg_grade desc</span><br><span class=\"line\">-- sum()求和</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Cno from SC</span><br><span class=\"line\">where Grade &gt;= 85</span><br><span class=\"line\">group by Cno</span><br><span class=\"line\">having count(Sno)&gt;10</span><br><span class=\"line\">-- where 筛选必须在group 之前，group之后可以用having筛选，两者可以并用</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Sno from SC</span><br><span class=\"line\">where Grade &lt;60  </span><br><span class=\"line\">group by Sno</span><br><span class=\"line\">having count(Cno) &gt; 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"进阶（连接）\"><a href=\"#进阶（连接）\" class=\"headerlink\" title=\"进阶（连接）\"></a>进阶（连接）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct Cno from student,SC</span><br><span class=\"line\">where student.Sno = SC.Sno and Sdept = &apos;JSJ&apos;</span><br><span class=\"line\">-- 连接要写出连接条件</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 三种写法</span><br><span class=\"line\">select Sname from student,SC</span><br><span class=\"line\">where student.Sno = SC.Sno and Cno = 1002</span><br><span class=\"line\">XXXXXX</span><br><span class=\"line\">select Sname from student</span><br><span class=\"line\">join SC on student.Sno = Sc.Sno</span><br><span class=\"line\">where Cno = 1002             -- JOIN..ON..语句</span><br><span class=\"line\">XXXXXX</span><br><span class=\"line\">select Sname from student</span><br><span class=\"line\">where Sno in(                --嵌套执行</span><br><span class=\"line\">\tselect Sno from SC where Cno = 1002</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select student.Sno, Grade from student,course,SC</span><br><span class=\"line\">where student.Sno = SC.Sno and course.Cno = SC.Cno and Cname = &apos;数据库原理&apos; and Grade &lt;60</span><br><span class=\"line\">--用表名.列名来获取具有相同列名的几个表中某个表的某一列</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 两种写法</span><br><span class=\"line\">select student.Sname from student,SC</span><br><span class=\"line\">where student.Sno = SC.Sno and Grade &gt;= 80 and Cno = 1004</span><br><span class=\"line\">XXXXXX</span><br><span class=\"line\">select Sname from student</span><br><span class=\"line\">where Sno in(                --嵌套写法</span><br><span class=\"line\">\tselect Sno from SC where Grade &gt; 80 and Cno in(</span><br><span class=\"line\">\t\tselect Cno from course where Cname = &apos;数据库原理&apos;</span><br><span class=\"line\">\t)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>###</p>\n<h3 id=\"进阶（嵌套）\"><a href=\"#进阶（嵌套）\" class=\"headerlink\" title=\"进阶（嵌套）\"></a>进阶（嵌套）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 找出平均成绩最大的一个（两种写法）</span><br><span class=\"line\">select  top 1 Sno,avg(Grade) as avg_grade from SC</span><br><span class=\"line\">group by Sno</span><br><span class=\"line\">order by avg(Grade) desc</span><br><span class=\"line\">XXXXXX</span><br><span class=\"line\">select Sno,avg(Grade) as avg_grade from SC</span><br><span class=\"line\">group by Sno</span><br><span class=\"line\">having avg(Grade) &gt;= all(select avg(Grade) from SC group by Sno)</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><hr>\n<ul>\n<li><p>删除表： <code>drop table XXX</code></p>\n</li>\n<li><p>删除表中的内容： <code>delete from XXX</code></p>\n</li>\n<li><p>删除数据库： <code>drop database XXX</code></p>\n</li>\n<li><p>删除依赖： <code>drop constraint XXX</code></p>\n</li>\n</ul>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><hr>\n<h3 id=\"循环生成数据\"><a href=\"#循环生成数据\" class=\"headerlink\" title=\"循环生成数据\"></a>循环生成数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--生成大量数据</span><br><span class=\"line\">create procedure usp_makedata as</span><br><span class=\"line\">declare @nCnt int, @sNo char(6), @sname varchar(8)</span><br><span class=\"line\">set @nCnt = 12000 --counter</span><br><span class=\"line\">while @nCnt &lt;999999</span><br><span class=\"line\">begin</span><br><span class=\"line\">\tset @nCnt = @nCnt +1</span><br><span class=\"line\">\tset @sNo = convert(varchar(6),@nCnt)</span><br><span class=\"line\">\tset @sName = &apos;张&apos; +@sno</span><br><span class=\"line\">\tinsert into student (sno,sname,ssex,sage) values (@sno,@sname,&apos;男&apos;,20)</span><br><span class=\"line\">end</span><br><span class=\"line\">return</span><br><span class=\"line\">exec usp_makedata\t--执行生成过程</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试生成的数据\"><a href=\"#测试生成的数据\" class=\"headerlink\" title=\"测试生成的数据\"></a>测试生成的数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--生成测试</span><br><span class=\"line\">create procedure usp_test as</span><br><span class=\"line\">declare @nCount int ,@data int</span><br><span class=\"line\">set @nCount=0</span><br><span class=\"line\">while @nCount &lt;100</span><br><span class=\"line\">begin</span><br><span class=\"line\">\tselect @data = count(*) from student</span><br><span class=\"line\">\twhere sname &lt;&apos;张3800&apos; or sname &gt;&apos;张8800&apos;</span><br><span class=\"line\">\tset @nCount =@nCount + 1</span><br><span class=\"line\">end</span><br><span class=\"line\">exec usp_test --执行测试</span><br></pre></td></tr></table></figure>\n<h3 id=\"善后\"><a href=\"#善后\" class=\"headerlink\" title=\"善后\"></a>善后</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop procedure usp_makedata</span><br><span class=\"line\">drop procedure usp_test</span><br></pre></td></tr></table></figure>\n<h2 id=\"E-R图的画法\"><a href=\"#E-R图的画法\" class=\"headerlink\" title=\"E-R图的画法\"></a>E-R图的画法</h2><hr>\n<ul>\n<li><p>实体型(Entity)：用矩形表示，矩形框内写明实体名</p>\n</li>\n<li><p>属性(Attribute)：用椭圆形表示，并用无向边将其与相应的实体连接起来</p>\n</li>\n<li><p>联系(Relationship)：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型(1 : 1，1 : n或m : n)。 (一对一，一对多还是多对多)</p>\n</li>\n<li><p>图例：<br><img src=\"/images/SQL/E-R graphe.png\" alt=\"\"></p>\n</li>\n<li><p>示例：<br><img src=\"/images/SQL/TIM图片20180503210911.jpg\" alt=\"\"><br>画图时先画实体型和联系，最后添加属性即可。对于那些有公共属性的两个实体型，属性应当连到联系上(菱形上的属性)</p>\n</li>\n</ul>\n<h3 id=\"从-E-R图转为关系模式：\"><a href=\"#从-E-R图转为关系模式：\" class=\"headerlink\" title=\"从 E-R图转为关系模式：\"></a>从 E-R图转为关系模式：</h3><ul>\n<li><p>首先是看有几个实体，每个实体单独存放为一个关系，即表。<strong>每个表的字段包含了这个实体所有的属性，即括号内的内容</strong></p>\n</li>\n<li><p>然后分析实体间的联系。实体间联系有的要单独存一个表，有的不要。</p>\n</li>\n<li><p><strong>如果实体和实体间是多对一或者一对一的关系则不需要单独创建一个表，而是通过在参与联系的多方实体中，增加一个参与联系的1方的实体的主键作为一列来表示联系</strong>。例如，车队和车辆是一对多的关系，这里 <strong>多</strong> 是车辆这个实体，1是车队这个实体。车队的实体的主键是车队号，所以，我们在多方(车辆)这个表中，增加1方(车队)的主键(车队号)作为一列来表示联系，即将  车队号  加到 车辆 这个实体的属性列表中。这里的 车队号 显然是 <strong>外键</strong>。</p>\n</li>\n<li><p><strong>如果两个实体之间的联系是多对多的，联系要单独存放为一个表</strong>。这个表的主键，是参与联系的两个实体的主键的组合，而联系的属性作为其他列。例如：车辆和司机之间是多对多的关系，使用 <code>联系名(车牌号，司机编码，使用日期，公里数)</code> 这里的车牌号是 车辆 这一实体的主键，司机编码是 司机 这一实体的主键，而后面两个是联系的属性。外键是： 车牌号，司机编码。</p>\n</li>\n<li><p>每个关系的主键都要标出来，外键写在关系的最后，属性括号的外面。</p>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/sunzhenhua0608/article/details/8822871\" target=\"_blank\" rel=\"noopener\">简明教学</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zxq1138634642/article/details/9121363\" target=\"_blank\" rel=\"noopener\">详细教学</a></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.3</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<ul>\n<li><strong>数据库的命令语句均不区分大小写</strong></li>\n</ul>\n<h2 id=\"创建语句\"><a href=\"#创建语句\" class=\"headerlink\" title=\"创建语句\"></a>创建语句</h2><hr>\n<h3 id=\"基本创建\"><a href=\"#基本创建\" class=\"headerlink\" title=\"基本创建\"></a>基本创建</h3><ul>\n<li><p>创建数据库 ：<code>create database XXX</code></p>\n</li>\n<li><p>带详细参数的数据库创建：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create database School on(</span><br><span class=\"line\">\tname = &apos;School_data&apos;,</span><br><span class=\"line\">\tfilename = &apos;c:\\data\\School_data.mdf&apos;,</span><br><span class=\"line\">\tsize = 5mb,</span><br><span class=\"line\">\tfilegrowth = 1mb --每次增长的大小</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建表： <code>create table XXX</code></p>\n</li>\n<li><p>带属性的创建：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table student(</span><br><span class=\"line\">\tSno char(6) primary key,</span><br><span class=\"line\">\tSname varchar(8),</span><br><span class=\"line\">\tSsex char(2),</span><br><span class=\"line\">\tSage smallint,</span><br><span class=\"line\">\tSdept varchar(15)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更加复杂的创建：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table student(</span><br><span class=\"line\">\tSno char(6) primary key,  --主键</span><br><span class=\"line\">\tSname varchar(8) not null constraint ck_1 unique, --创建时加入约束条件</span><br><span class=\"line\">\tSsex char(2) not null constraint ck_2 check(Ssex in(&apos;男&apos;,&apos;女&apos;)),</span><br><span class=\"line\">\tSage smallint constraint ck_3 check(sage&gt;16),</span><br><span class=\"line\">\tSdept varchar(15) default &apos;JSJ&apos;  --默认值</span><br><span class=\"line\">)</span><br><span class=\"line\">create table course(</span><br><span class=\"line\">\tCno char(6) primary key,</span><br><span class=\"line\">\tCname varchar(20),</span><br><span class=\"line\">\tCpno char(4),</span><br><span class=\"line\">\tCcredit tinyint</span><br><span class=\"line\">)</span><br><span class=\"line\">create table SC(</span><br><span class=\"line\">\tSno char(6) not null, --要在表外添加主键的约束，则这个属性不能为空</span><br><span class=\"line\">\tCno char(6) not null,</span><br><span class=\"line\">\tGrade decimal(12,1) constraint ck_6 check(Grade &lt;= 100 and Grade &gt;=0)</span><br><span class=\"line\">\tconstraint fk_1 foreign key (Sno) references student(sno)</span><br><span class=\"line\">)</span><br><span class=\"line\">alter table SC add constraint PK_SC primary key(Sno,Cno)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>check语句是一种约束条件写法，与constraint功能类似</p>\n<ul>\n<li>在创建时设置foreign key：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table sc(</span><br><span class=\"line\">\tSno char(6),</span><br><span class=\"line\">\tCno char(4),</span><br><span class=\"line\">\tGrade decimal(12,2),</span><br><span class=\"line\">\tprimary key(Sno,Cno),</span><br><span class=\"line\">\tforeign key(Sno) references student(Sno),</span><br><span class=\"line\">\tforeign key(Cno) references course(Cno)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create index Ix_student_sname on student(Sname)</span><br><span class=\"line\">create index Ix_student_sdept on student(Sdept)</span><br><span class=\"line\">create index Ix_sc_cno on SC(Cno)</span><br><span class=\"line\">create index Ix_course_cname on Course(Cname)</span><br><span class=\"line\">sp_help student  --查看索引等信息</span><br><span class=\"line\">drop index student.ix_student_sname    --删除索引</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入数据：\"><a href=\"#插入数据：\" class=\"headerlink\" title=\"插入数据：\"></a>插入数据：</h3><blockquote>\n<p>数据顺序和类型要与创建时的定义一致</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into student values(&apos;5001&apos;,&apos;赵强&apos;,&apos;男&apos;,&apos;20&apos;,&apos;SX&apos;)</span><br><span class=\"line\">insert into student values(&apos;5002&apos;,&apos;李丽华&apos;,&apos;女&apos;,&apos;21&apos;,&apos;JSJ&apos;)</span><br><span class=\"line\">insert into student values(&apos;5001&apos;,&apos;李静&apos;,&apos;女&apos;,&apos;20&apos;,&apos;SX&apos;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"将数据从一个表插入另一个表\"><a href=\"#将数据从一个表插入另一个表\" class=\"headerlink\" title=\"将数据从一个表插入另一个表\"></a>将数据从一个表插入另一个表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--批量插入数据(从student 到 sc_name)</span><br><span class=\"line\">insert into sc_name (Sno,Sname,Ssex)</span><br><span class=\"line\">select Sno,Sname,Ssex from student where Sdept = &apos;SX&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在表外的更改操作\"><a href=\"#在表外的更改操作\" class=\"headerlink\" title=\"在表外的更改操作\"></a>在表外的更改操作</h2><hr>\n<h3 id=\"在表外更改表结构\"><a href=\"#在表外更改表结构\" class=\"headerlink\" title=\"在表外更改表结构\"></a>在表外更改表结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table student(</span><br><span class=\"line\">\tSno char(6),</span><br><span class=\"line\">\tSname varchar(8),</span><br><span class=\"line\">\tSsex char(2),</span><br><span class=\"line\">\tSage smallint,</span><br><span class=\"line\">\tSdept varchar(15)</span><br><span class=\"line\">)</span><br><span class=\"line\">alter table student add address varchar(60) --添加列</span><br><span class=\"line\">alter table student add inDate datetime --添加列，数据类型为datetime</span><br><span class=\"line\">alter table student alter column adress varchar(50)</span><br><span class=\"line\">alter table student drop column inDate</span><br></pre></td></tr></table></figure>\n<h3 id=\"用户自定义完整性约束\"><a href=\"#用户自定义完整性约束\" class=\"headerlink\" title=\"用户自定义完整性约束\"></a>用户自定义完整性约束</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table student add constraint cs_1 check(Ssex in (&apos;男&apos;,&apos;女&apos;))</span><br><span class=\"line\">alter table student add constraint cs_2 check(Sage &gt;16)</span><br><span class=\"line\">alter table Course add constraint cs_3 check(Ccredit in (0,1,2,3,4,5))</span><br><span class=\"line\">alter table Course add constraint cs_4 check(Cno != Cpno)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除约束： <code>alter table student drop constraint cs_1</code></li>\n</ul>\n<h3 id=\"更新表数据\"><a href=\"#更新表数据\" class=\"headerlink\" title=\"更新表数据\"></a>更新表数据</h3><ul>\n<li>使用update和查找条件： <code>update student set Sno = 4018 where Sno = 4003</code></li>\n</ul>\n<h2 id=\"获取详细信息\"><a href=\"#获取详细信息\" class=\"headerlink\" title=\"获取详细信息\"></a>获取详细信息</h2><hr>\n<ul>\n<li><p><code>sp_help 表名</code></p>\n</li>\n<li><p><code>sp_helpdb 数据库名</code></p>\n</li>\n</ul>\n<h2 id=\"查询语句\"><a href=\"#查询语句\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h2><hr>\n<h3 id=\"基本查询操作\"><a href=\"#基本查询操作\" class=\"headerlink\" title=\"基本查询操作\"></a>基本查询操作</h3><ul>\n<li><code>select [列名（逗号间隔）或者*] from 表名</code></li>\n</ul>\n<h3 id=\"进阶-单表\"><a href=\"#进阶-单表\" class=\"headerlink\" title=\"进阶(单表)\"></a>进阶(单表)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Sno,Sname,Sage from student</span><br><span class=\"line\">where Sage &gt;= 19 and Sage &lt;= 21 and Ssex = &apos;女&apos; order by Sage desc</span><br><span class=\"line\">-- desc表示降序，asc表示升序</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Sno,Ssex from student where Sname like &apos;_明%&apos;  </span><br><span class=\"line\">--&apos;_&apos;表示一个字符，%表示任意多个字符,这里筛选出名字第二个字为‘明’的人</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Sno,Cno from SC where Grade is null</span><br><span class=\"line\">-- 如果用&apos;= null&apos;则查询结果为空</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Sno,Cno,cast((Grade/10) as int)from SC</span><br><span class=\"line\">-- cast(a as int)转换数据类型</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct Sdept from student</span><br><span class=\"line\">-- distinct写在最前面</span><br></pre></td></tr></table></figure>\n<h3 id=\"进阶（统计）\"><a href=\"#进阶（统计）\" class=\"headerlink\" title=\"进阶（统计）\"></a>进阶（统计）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select count(*) as number from student</span><br><span class=\"line\">where Sname like &apos;%明%&apos;</span><br><span class=\"line\">-- 统计名字有‘明’的人数</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Cno,sum(Grade) as total_grade,avg(Grade) as avg_grade,max(Grade) as max_grade,min(Grade) as min_grade from SC  </span><br><span class=\"line\">group by Cno</span><br><span class=\"line\">order by avg_grade desc</span><br><span class=\"line\">-- sum()求和</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Cno from SC</span><br><span class=\"line\">where Grade &gt;= 85</span><br><span class=\"line\">group by Cno</span><br><span class=\"line\">having count(Sno)&gt;10</span><br><span class=\"line\">-- where 筛选必须在group 之前，group之后可以用having筛选，两者可以并用</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Sno from SC</span><br><span class=\"line\">where Grade &lt;60  </span><br><span class=\"line\">group by Sno</span><br><span class=\"line\">having count(Cno) &gt; 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"进阶（连接）\"><a href=\"#进阶（连接）\" class=\"headerlink\" title=\"进阶（连接）\"></a>进阶（连接）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct Cno from student,SC</span><br><span class=\"line\">where student.Sno = SC.Sno and Sdept = &apos;JSJ&apos;</span><br><span class=\"line\">-- 连接要写出连接条件</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 三种写法</span><br><span class=\"line\">select Sname from student,SC</span><br><span class=\"line\">where student.Sno = SC.Sno and Cno = 1002</span><br><span class=\"line\">XXXXXX</span><br><span class=\"line\">select Sname from student</span><br><span class=\"line\">join SC on student.Sno = Sc.Sno</span><br><span class=\"line\">where Cno = 1002             -- JOIN..ON..语句</span><br><span class=\"line\">XXXXXX</span><br><span class=\"line\">select Sname from student</span><br><span class=\"line\">where Sno in(                --嵌套执行</span><br><span class=\"line\">\tselect Sno from SC where Cno = 1002</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select student.Sno, Grade from student,course,SC</span><br><span class=\"line\">where student.Sno = SC.Sno and course.Cno = SC.Cno and Cname = &apos;数据库原理&apos; and Grade &lt;60</span><br><span class=\"line\">--用表名.列名来获取具有相同列名的几个表中某个表的某一列</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 两种写法</span><br><span class=\"line\">select student.Sname from student,SC</span><br><span class=\"line\">where student.Sno = SC.Sno and Grade &gt;= 80 and Cno = 1004</span><br><span class=\"line\">XXXXXX</span><br><span class=\"line\">select Sname from student</span><br><span class=\"line\">where Sno in(                --嵌套写法</span><br><span class=\"line\">\tselect Sno from SC where Grade &gt; 80 and Cno in(</span><br><span class=\"line\">\t\tselect Cno from course where Cname = &apos;数据库原理&apos;</span><br><span class=\"line\">\t)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>###</p>\n<h3 id=\"进阶（嵌套）\"><a href=\"#进阶（嵌套）\" class=\"headerlink\" title=\"进阶（嵌套）\"></a>进阶（嵌套）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 找出平均成绩最大的一个（两种写法）</span><br><span class=\"line\">select  top 1 Sno,avg(Grade) as avg_grade from SC</span><br><span class=\"line\">group by Sno</span><br><span class=\"line\">order by avg(Grade) desc</span><br><span class=\"line\">XXXXXX</span><br><span class=\"line\">select Sno,avg(Grade) as avg_grade from SC</span><br><span class=\"line\">group by Sno</span><br><span class=\"line\">having avg(Grade) &gt;= all(select avg(Grade) from SC group by Sno)</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><hr>\n<ul>\n<li><p>删除表： <code>drop table XXX</code></p>\n</li>\n<li><p>删除表中的内容： <code>delete from XXX</code></p>\n</li>\n<li><p>删除数据库： <code>drop database XXX</code></p>\n</li>\n<li><p>删除依赖： <code>drop constraint XXX</code></p>\n</li>\n</ul>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><hr>\n<h3 id=\"循环生成数据\"><a href=\"#循环生成数据\" class=\"headerlink\" title=\"循环生成数据\"></a>循环生成数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--生成大量数据</span><br><span class=\"line\">create procedure usp_makedata as</span><br><span class=\"line\">declare @nCnt int, @sNo char(6), @sname varchar(8)</span><br><span class=\"line\">set @nCnt = 12000 --counter</span><br><span class=\"line\">while @nCnt &lt;999999</span><br><span class=\"line\">begin</span><br><span class=\"line\">\tset @nCnt = @nCnt +1</span><br><span class=\"line\">\tset @sNo = convert(varchar(6),@nCnt)</span><br><span class=\"line\">\tset @sName = &apos;张&apos; +@sno</span><br><span class=\"line\">\tinsert into student (sno,sname,ssex,sage) values (@sno,@sname,&apos;男&apos;,20)</span><br><span class=\"line\">end</span><br><span class=\"line\">return</span><br><span class=\"line\">exec usp_makedata\t--执行生成过程</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试生成的数据\"><a href=\"#测试生成的数据\" class=\"headerlink\" title=\"测试生成的数据\"></a>测试生成的数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--生成测试</span><br><span class=\"line\">create procedure usp_test as</span><br><span class=\"line\">declare @nCount int ,@data int</span><br><span class=\"line\">set @nCount=0</span><br><span class=\"line\">while @nCount &lt;100</span><br><span class=\"line\">begin</span><br><span class=\"line\">\tselect @data = count(*) from student</span><br><span class=\"line\">\twhere sname &lt;&apos;张3800&apos; or sname &gt;&apos;张8800&apos;</span><br><span class=\"line\">\tset @nCount =@nCount + 1</span><br><span class=\"line\">end</span><br><span class=\"line\">exec usp_test --执行测试</span><br></pre></td></tr></table></figure>\n<h3 id=\"善后\"><a href=\"#善后\" class=\"headerlink\" title=\"善后\"></a>善后</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop procedure usp_makedata</span><br><span class=\"line\">drop procedure usp_test</span><br></pre></td></tr></table></figure>\n<h2 id=\"E-R图的画法\"><a href=\"#E-R图的画法\" class=\"headerlink\" title=\"E-R图的画法\"></a>E-R图的画法</h2><hr>\n<ul>\n<li><p>实体型(Entity)：用矩形表示，矩形框内写明实体名</p>\n</li>\n<li><p>属性(Attribute)：用椭圆形表示，并用无向边将其与相应的实体连接起来</p>\n</li>\n<li><p>联系(Relationship)：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型(1 : 1，1 : n或m : n)。 (一对一，一对多还是多对多)</p>\n</li>\n<li><p>图例：<br><img src=\"/images/SQL/E-R graphe.png\" alt=\"\"></p>\n</li>\n<li><p>示例：<br><img src=\"/images/SQL/TIM图片20180503210911.jpg\" alt=\"\"><br>画图时先画实体型和联系，最后添加属性即可。对于那些有公共属性的两个实体型，属性应当连到联系上(菱形上的属性)</p>\n</li>\n</ul>\n<h3 id=\"从-E-R图转为关系模式：\"><a href=\"#从-E-R图转为关系模式：\" class=\"headerlink\" title=\"从 E-R图转为关系模式：\"></a>从 E-R图转为关系模式：</h3><ul>\n<li><p>首先是看有几个实体，每个实体单独存放为一个关系，即表。<strong>每个表的字段包含了这个实体所有的属性，即括号内的内容</strong></p>\n</li>\n<li><p>然后分析实体间的联系。实体间联系有的要单独存一个表，有的不要。</p>\n</li>\n<li><p><strong>如果实体和实体间是多对一或者一对一的关系则不需要单独创建一个表，而是通过在参与联系的多方实体中，增加一个参与联系的1方的实体的主键作为一列来表示联系</strong>。例如，车队和车辆是一对多的关系，这里 <strong>多</strong> 是车辆这个实体，1是车队这个实体。车队的实体的主键是车队号，所以，我们在多方(车辆)这个表中，增加1方(车队)的主键(车队号)作为一列来表示联系，即将  车队号  加到 车辆 这个实体的属性列表中。这里的 车队号 显然是 <strong>外键</strong>。</p>\n</li>\n<li><p><strong>如果两个实体之间的联系是多对多的，联系要单独存放为一个表</strong>。这个表的主键，是参与联系的两个实体的主键的组合，而联系的属性作为其他列。例如：车辆和司机之间是多对多的关系，使用 <code>联系名(车牌号，司机编码，使用日期，公里数)</code> 这里的车牌号是 车辆 这一实体的主键，司机编码是 司机 这一实体的主键，而后面两个是联系的属性。外键是： 车牌号，司机编码。</p>\n</li>\n<li><p>每个关系的主键都要标出来，外键写在关系的最后，属性括号的外面。</p>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/sunzhenhua0608/article/details/8822871\" target=\"_blank\" rel=\"noopener\">简明教学</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zxq1138634642/article/details/9121363\" target=\"_blank\" rel=\"noopener\">详细教学</a></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.3</p>\n</blockquote>\n"},{"layout":"post","title":"git 与 github 随笔","date":"2018-04-11T14:04:00.000Z","_content":"> 不适合人类阅读的随笔~\n\n## 本地初始化仓库并添加远程仓库\n---\n\n- 示例：\n```\ngit init //初始化本地仓库\ngit add .  //将本地所有文件加到仓库里\ngit commit -m \"...\" //设置提交信息\ngit remote add origin git@github.com: ...  //添加远程仓库\ngit push -u origin master\n```\n\n## 关于 多用fetch，merge少用pull\n---\n\n- 有一篇[文章](https://www.oschina.net/translate/git-fetch-and-merge)提到了pull的一些弊端，主要是数据会被直接覆盖掉，这样回溯会比较麻烦。\n\n## 关于windows和Ubuntu下的可视化git管理工具\n---\n\n### windows\n- windows下有一个非常好用的git管理工具，与github有很好的连接——[github desktop](https://desktop.github.com/)。界面美观，方便好用。\n\n- 同时要搭配Windows下的[git](https://git-scm.com/download/win)来使用。\n\n- 登录你的github账号之后，便可以非常轻松地clone，add，commit，push等操作。\n\n- 左上角点开选择clone到本地的repo，右键选择open in explorer 即可进入存放本地文件的位置。对文件进行过修改之后，按照下面的同步步骤即可。\n\n- 推荐使用命令行来实现同步。左上角点开后选择要修改的repo，右键选择 open in command 即可进入命令行。\n\n- 一些简单的命令操作：\n```\ngit add .  //把本地的所有修改add\ngit commit -m \"...\"  //commit本地的修改，“...”中写本次修改的备注（这个备注必须有）\ngit push   //将本地的修改同步到github上\n```\n这样修改同步就完成了，一共只需要三步即可。\n\n### Ubuntu\n\n- Ubuntu下找到一个甚至比Windows下的 github desktop更加好用的软件——[GitKraken](https://www.gitkraken.com/)\n\n- 在上面不仅可以进行查看同步等操作，甚至可以看到之前在这个repo当中所有的人做出的任何修改，并且可以查看修改了哪些内容！*但是唯一美中不足的是有些更加NB的功能要开vip...*\n\n- 比Windows更加便捷的是，这里想要进入对一个repo进行同步的命令行（终端）时，只需要在界面按下`Alt+T`的组合键就可以打开相应的终端了。\n\n### atom\n---\n- 讲道理第一次使用atom时我还是很震惊的，居然有这么好用的软件。atom是一款编辑器，Linux和Windows平台都有，但是这个小小的编辑器整合了许多功能于一身，诸如代码编辑，github仓库文件的编辑以及直接add-commit-push一条线操作等等，还有许许多多的插件等待你去发现。\n\n- Atom自带支持markdown文件的编辑和预览，组合键 `ctrl + shift + m` 弹出预览。\n\n- atom的[下载地址](https://atom.io/)\n\n<br>\n> 最后更新于2018.4.19\n","source":"_posts/2018-04-11-Git-and-Github.md","raw":"---\nlayout:     post\ntitle:      \"git 与 github 随笔\"\ndate:       2018-04-11 22:04:00\ncategories: Computer\ntags: [๑Git, ๑Ubuntu, ๑Linux]\n---\n> 不适合人类阅读的随笔~\n\n## 本地初始化仓库并添加远程仓库\n---\n\n- 示例：\n```\ngit init //初始化本地仓库\ngit add .  //将本地所有文件加到仓库里\ngit commit -m \"...\" //设置提交信息\ngit remote add origin git@github.com: ...  //添加远程仓库\ngit push -u origin master\n```\n\n## 关于 多用fetch，merge少用pull\n---\n\n- 有一篇[文章](https://www.oschina.net/translate/git-fetch-and-merge)提到了pull的一些弊端，主要是数据会被直接覆盖掉，这样回溯会比较麻烦。\n\n## 关于windows和Ubuntu下的可视化git管理工具\n---\n\n### windows\n- windows下有一个非常好用的git管理工具，与github有很好的连接——[github desktop](https://desktop.github.com/)。界面美观，方便好用。\n\n- 同时要搭配Windows下的[git](https://git-scm.com/download/win)来使用。\n\n- 登录你的github账号之后，便可以非常轻松地clone，add，commit，push等操作。\n\n- 左上角点开选择clone到本地的repo，右键选择open in explorer 即可进入存放本地文件的位置。对文件进行过修改之后，按照下面的同步步骤即可。\n\n- 推荐使用命令行来实现同步。左上角点开后选择要修改的repo，右键选择 open in command 即可进入命令行。\n\n- 一些简单的命令操作：\n```\ngit add .  //把本地的所有修改add\ngit commit -m \"...\"  //commit本地的修改，“...”中写本次修改的备注（这个备注必须有）\ngit push   //将本地的修改同步到github上\n```\n这样修改同步就完成了，一共只需要三步即可。\n\n### Ubuntu\n\n- Ubuntu下找到一个甚至比Windows下的 github desktop更加好用的软件——[GitKraken](https://www.gitkraken.com/)\n\n- 在上面不仅可以进行查看同步等操作，甚至可以看到之前在这个repo当中所有的人做出的任何修改，并且可以查看修改了哪些内容！*但是唯一美中不足的是有些更加NB的功能要开vip...*\n\n- 比Windows更加便捷的是，这里想要进入对一个repo进行同步的命令行（终端）时，只需要在界面按下`Alt+T`的组合键就可以打开相应的终端了。\n\n### atom\n---\n- 讲道理第一次使用atom时我还是很震惊的，居然有这么好用的软件。atom是一款编辑器，Linux和Windows平台都有，但是这个小小的编辑器整合了许多功能于一身，诸如代码编辑，github仓库文件的编辑以及直接add-commit-push一条线操作等等，还有许许多多的插件等待你去发现。\n\n- Atom自带支持markdown文件的编辑和预览，组合键 `ctrl + shift + m` 弹出预览。\n\n- atom的[下载地址](https://atom.io/)\n\n<br>\n> 最后更新于2018.4.19\n","slug":"2018-04-11-Git-and-Github","published":1,"updated":"2018-09-03T13:18:31.941Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4i000z1m0o95shftfw","content":"<blockquote>\n<p>不适合人类阅读的随笔~</p>\n</blockquote>\n<h2 id=\"本地初始化仓库并添加远程仓库\"><a href=\"#本地初始化仓库并添加远程仓库\" class=\"headerlink\" title=\"本地初始化仓库并添加远程仓库\"></a>本地初始化仓库并添加远程仓库</h2><hr>\n<ul>\n<li>示例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init //初始化本地仓库</span><br><span class=\"line\">git add .  //将本地所有文件加到仓库里</span><br><span class=\"line\">git commit -m &quot;...&quot; //设置提交信息</span><br><span class=\"line\">git remote add origin git@github.com: ...  //添加远程仓库</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"关于-多用fetch，merge少用pull\"><a href=\"#关于-多用fetch，merge少用pull\" class=\"headerlink\" title=\"关于 多用fetch，merge少用pull\"></a>关于 多用fetch，merge少用pull</h2><hr>\n<ul>\n<li>有一篇<a href=\"https://www.oschina.net/translate/git-fetch-and-merge\" target=\"_blank\" rel=\"noopener\">文章</a>提到了pull的一些弊端，主要是数据会被直接覆盖掉，这样回溯会比较麻烦。</li>\n</ul>\n<h2 id=\"关于windows和Ubuntu下的可视化git管理工具\"><a href=\"#关于windows和Ubuntu下的可视化git管理工具\" class=\"headerlink\" title=\"关于windows和Ubuntu下的可视化git管理工具\"></a>关于windows和Ubuntu下的可视化git管理工具</h2><hr>\n<h3 id=\"windows\"><a href=\"#windows\" class=\"headerlink\" title=\"windows\"></a>windows</h3><ul>\n<li><p>windows下有一个非常好用的git管理工具，与github有很好的连接——<a href=\"https://desktop.github.com/\" target=\"_blank\" rel=\"noopener\">github desktop</a>。界面美观，方便好用。</p>\n</li>\n<li><p>同时要搭配Windows下的<a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"noopener\">git</a>来使用。</p>\n</li>\n<li><p>登录你的github账号之后，便可以非常轻松地clone，add，commit，push等操作。</p>\n</li>\n<li><p>左上角点开选择clone到本地的repo，右键选择open in explorer 即可进入存放本地文件的位置。对文件进行过修改之后，按照下面的同步步骤即可。</p>\n</li>\n<li><p>推荐使用命令行来实现同步。左上角点开后选择要修改的repo，右键选择 open in command 即可进入命令行。</p>\n</li>\n<li><p>一些简单的命令操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .  //把本地的所有修改add</span><br><span class=\"line\">git commit -m &quot;...&quot;  //commit本地的修改，“...”中写本次修改的备注（这个备注必须有）</span><br><span class=\"line\">git push   //将本地的修改同步到github上</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样修改同步就完成了，一共只需要三步即可。</p>\n<h3 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h3><ul>\n<li><p>Ubuntu下找到一个甚至比Windows下的 github desktop更加好用的软件——<a href=\"https://www.gitkraken.com/\" target=\"_blank\" rel=\"noopener\">GitKraken</a></p>\n</li>\n<li><p>在上面不仅可以进行查看同步等操作，甚至可以看到之前在这个repo当中所有的人做出的任何修改，并且可以查看修改了哪些内容！<em>但是唯一美中不足的是有些更加NB的功能要开vip…</em></p>\n</li>\n<li><p>比Windows更加便捷的是，这里想要进入对一个repo进行同步的命令行（终端）时，只需要在界面按下<code>Alt+T</code>的组合键就可以打开相应的终端了。</p>\n</li>\n</ul>\n<h3 id=\"atom\"><a href=\"#atom\" class=\"headerlink\" title=\"atom\"></a>atom</h3><hr>\n<ul>\n<li><p>讲道理第一次使用atom时我还是很震惊的，居然有这么好用的软件。atom是一款编辑器，Linux和Windows平台都有，但是这个小小的编辑器整合了许多功能于一身，诸如代码编辑，github仓库文件的编辑以及直接add-commit-push一条线操作等等，还有许许多多的插件等待你去发现。</p>\n</li>\n<li><p>Atom自带支持markdown文件的编辑和预览，组合键 <code>ctrl + shift + m</code> 弹出预览。</p>\n</li>\n<li><p>atom的<a href=\"https://atom.io/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.19</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的随笔~</p>\n</blockquote>\n<h2 id=\"本地初始化仓库并添加远程仓库\"><a href=\"#本地初始化仓库并添加远程仓库\" class=\"headerlink\" title=\"本地初始化仓库并添加远程仓库\"></a>本地初始化仓库并添加远程仓库</h2><hr>\n<ul>\n<li>示例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init //初始化本地仓库</span><br><span class=\"line\">git add .  //将本地所有文件加到仓库里</span><br><span class=\"line\">git commit -m &quot;...&quot; //设置提交信息</span><br><span class=\"line\">git remote add origin git@github.com: ...  //添加远程仓库</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"关于-多用fetch，merge少用pull\"><a href=\"#关于-多用fetch，merge少用pull\" class=\"headerlink\" title=\"关于 多用fetch，merge少用pull\"></a>关于 多用fetch，merge少用pull</h2><hr>\n<ul>\n<li>有一篇<a href=\"https://www.oschina.net/translate/git-fetch-and-merge\" target=\"_blank\" rel=\"noopener\">文章</a>提到了pull的一些弊端，主要是数据会被直接覆盖掉，这样回溯会比较麻烦。</li>\n</ul>\n<h2 id=\"关于windows和Ubuntu下的可视化git管理工具\"><a href=\"#关于windows和Ubuntu下的可视化git管理工具\" class=\"headerlink\" title=\"关于windows和Ubuntu下的可视化git管理工具\"></a>关于windows和Ubuntu下的可视化git管理工具</h2><hr>\n<h3 id=\"windows\"><a href=\"#windows\" class=\"headerlink\" title=\"windows\"></a>windows</h3><ul>\n<li><p>windows下有一个非常好用的git管理工具，与github有很好的连接——<a href=\"https://desktop.github.com/\" target=\"_blank\" rel=\"noopener\">github desktop</a>。界面美观，方便好用。</p>\n</li>\n<li><p>同时要搭配Windows下的<a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"noopener\">git</a>来使用。</p>\n</li>\n<li><p>登录你的github账号之后，便可以非常轻松地clone，add，commit，push等操作。</p>\n</li>\n<li><p>左上角点开选择clone到本地的repo，右键选择open in explorer 即可进入存放本地文件的位置。对文件进行过修改之后，按照下面的同步步骤即可。</p>\n</li>\n<li><p>推荐使用命令行来实现同步。左上角点开后选择要修改的repo，右键选择 open in command 即可进入命令行。</p>\n</li>\n<li><p>一些简单的命令操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .  //把本地的所有修改add</span><br><span class=\"line\">git commit -m &quot;...&quot;  //commit本地的修改，“...”中写本次修改的备注（这个备注必须有）</span><br><span class=\"line\">git push   //将本地的修改同步到github上</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样修改同步就完成了，一共只需要三步即可。</p>\n<h3 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h3><ul>\n<li><p>Ubuntu下找到一个甚至比Windows下的 github desktop更加好用的软件——<a href=\"https://www.gitkraken.com/\" target=\"_blank\" rel=\"noopener\">GitKraken</a></p>\n</li>\n<li><p>在上面不仅可以进行查看同步等操作，甚至可以看到之前在这个repo当中所有的人做出的任何修改，并且可以查看修改了哪些内容！<em>但是唯一美中不足的是有些更加NB的功能要开vip…</em></p>\n</li>\n<li><p>比Windows更加便捷的是，这里想要进入对一个repo进行同步的命令行（终端）时，只需要在界面按下<code>Alt+T</code>的组合键就可以打开相应的终端了。</p>\n</li>\n</ul>\n<h3 id=\"atom\"><a href=\"#atom\" class=\"headerlink\" title=\"atom\"></a>atom</h3><hr>\n<ul>\n<li><p>讲道理第一次使用atom时我还是很震惊的，居然有这么好用的软件。atom是一款编辑器，Linux和Windows平台都有，但是这个小小的编辑器整合了许多功能于一身，诸如代码编辑，github仓库文件的编辑以及直接add-commit-push一条线操作等等，还有许许多多的插件等待你去发现。</p>\n</li>\n<li><p>Atom自带支持markdown文件的编辑和预览，组合键 <code>ctrl + shift + m</code> 弹出预览。</p>\n</li>\n<li><p>atom的<a href=\"https://atom.io/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.19</p>\n</blockquote>\n"},{"layout":"post","title":"Spark学习笔记——进阶","date":"2018-04-11T08:47:00.000Z","_content":"> 不适合人类阅读的学习笔记\n\n> **有问题经常去[stackoverflow.com](https://stackoverflow.com/)上找找**\n> 或者直接去看官方的API原版或者翻译版:[官方文档的中文版](http://spark.apachecn.org/)\n\n\n## DataSet 与 DataFrame\n---\n\n- Dataset是特定域对象中的强类型集合，它可以使用函数或者相关操作并行地进行转换等操作。每个Dataset都有一个称为DataFrame的非类型化的视图，这个视图是行的数据集。\n\n- DataSet和RDD主要的区别是：DataSet是特定域的对象集合；然而RDD是任何对象的集合。DataSet的API总是强类型的；而且可以利用这些模式进行优化，然而RDD却不行。\n\n- Dataset的定义中还提到了DataFrame，DataFrame是特殊的Dataset，它在编译时不会对模式进行检测。在未来版本的Spark，Dataset将会替代RDD成为我们开发编程使用的API。\n\n### 创建DataFrame\n```\nimport org.apache.spark.sql.SparkSession\n...\nval sparkses = SparkSession\n\t\t\t\t.builder()\n                .getOrCreate() //这两个为必须有的\nval df = sparkses.read.csv(\"...filename.csv\")\n//这里read后面的方法名称与具体要读的文件类型有关\ndf.show()  //打印内容\n```\n\n### 创建DataSet\n\n-  方法一：创建case class （对于复杂的数据没有成功）\n- 例如\n```\nval sparkses = SparkSession\n\t\t\t\t.builder()\n                .getOrCreate()\ncase class KeyValue(key: Int, value: String)\nimport sparkses.implicit._   //引入隐式转换库\nval df = Seq((1,\"asdf\"),(2,\"34234\")).toDF(\"key\", \"value\")\nval ds = df.as[KeyValue]\n// org.apache.spark.sql.Dataset[KeyValue] = [key: int, value: string]\n```\n\n- case class的参数上限为22\n\n- 方法二：以元组隐式转化\n- 例：\n```\nval tupDs = df.as[(Int,String)]\n// org.apache.spark.sql.Dataset[(Int, String)] = [_1: int, _2: string]\n```\n\n\n\n\n<br>\n> 最后更新于2018.4.21\n","source":"_posts/2018-04-11-Spark-superior.md","raw":"---\nlayout:     post\ntitle:      \"Spark学习笔记——进阶\"\ndate:       2018-04-11 16:47:00\ncategories: Computer Programes\ntags: [๑Spark, ๑BigData]\n---\n> 不适合人类阅读的学习笔记\n\n> **有问题经常去[stackoverflow.com](https://stackoverflow.com/)上找找**\n> 或者直接去看官方的API原版或者翻译版:[官方文档的中文版](http://spark.apachecn.org/)\n\n\n## DataSet 与 DataFrame\n---\n\n- Dataset是特定域对象中的强类型集合，它可以使用函数或者相关操作并行地进行转换等操作。每个Dataset都有一个称为DataFrame的非类型化的视图，这个视图是行的数据集。\n\n- DataSet和RDD主要的区别是：DataSet是特定域的对象集合；然而RDD是任何对象的集合。DataSet的API总是强类型的；而且可以利用这些模式进行优化，然而RDD却不行。\n\n- Dataset的定义中还提到了DataFrame，DataFrame是特殊的Dataset，它在编译时不会对模式进行检测。在未来版本的Spark，Dataset将会替代RDD成为我们开发编程使用的API。\n\n### 创建DataFrame\n```\nimport org.apache.spark.sql.SparkSession\n...\nval sparkses = SparkSession\n\t\t\t\t.builder()\n                .getOrCreate() //这两个为必须有的\nval df = sparkses.read.csv(\"...filename.csv\")\n//这里read后面的方法名称与具体要读的文件类型有关\ndf.show()  //打印内容\n```\n\n### 创建DataSet\n\n-  方法一：创建case class （对于复杂的数据没有成功）\n- 例如\n```\nval sparkses = SparkSession\n\t\t\t\t.builder()\n                .getOrCreate()\ncase class KeyValue(key: Int, value: String)\nimport sparkses.implicit._   //引入隐式转换库\nval df = Seq((1,\"asdf\"),(2,\"34234\")).toDF(\"key\", \"value\")\nval ds = df.as[KeyValue]\n// org.apache.spark.sql.Dataset[KeyValue] = [key: int, value: string]\n```\n\n- case class的参数上限为22\n\n- 方法二：以元组隐式转化\n- 例：\n```\nval tupDs = df.as[(Int,String)]\n// org.apache.spark.sql.Dataset[(Int, String)] = [_1: int, _2: string]\n```\n\n\n\n\n<br>\n> 最后更新于2018.4.21\n","slug":"2018-04-11-Spark-superior","published":1,"updated":"2018-09-03T13:17:58.256Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4k00131m0o06n1w2gr","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<blockquote>\n<p><strong>有问题经常去<a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow.com</a>上找找</strong><br>或者直接去看官方的API原版或者翻译版:<a href=\"http://spark.apachecn.org/\" target=\"_blank\" rel=\"noopener\">官方文档的中文版</a></p>\n</blockquote>\n<h2 id=\"DataSet-与-DataFrame\"><a href=\"#DataSet-与-DataFrame\" class=\"headerlink\" title=\"DataSet 与 DataFrame\"></a>DataSet 与 DataFrame</h2><hr>\n<ul>\n<li><p>Dataset是特定域对象中的强类型集合，它可以使用函数或者相关操作并行地进行转换等操作。每个Dataset都有一个称为DataFrame的非类型化的视图，这个视图是行的数据集。</p>\n</li>\n<li><p>DataSet和RDD主要的区别是：DataSet是特定域的对象集合；然而RDD是任何对象的集合。DataSet的API总是强类型的；而且可以利用这些模式进行优化，然而RDD却不行。</p>\n</li>\n<li><p>Dataset的定义中还提到了DataFrame，DataFrame是特殊的Dataset，它在编译时不会对模式进行检测。在未来版本的Spark，Dataset将会替代RDD成为我们开发编程使用的API。</p>\n</li>\n</ul>\n<h3 id=\"创建DataFrame\"><a href=\"#创建DataFrame\" class=\"headerlink\" title=\"创建DataFrame\"></a>创建DataFrame</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.spark.sql.SparkSession</span><br><span class=\"line\">...</span><br><span class=\"line\">val sparkses = SparkSession</span><br><span class=\"line\">\t\t\t\t.builder()</span><br><span class=\"line\">                .getOrCreate() //这两个为必须有的</span><br><span class=\"line\">val df = sparkses.read.csv(&quot;...filename.csv&quot;)</span><br><span class=\"line\">//这里read后面的方法名称与具体要读的文件类型有关</span><br><span class=\"line\">df.show()  //打印内容</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建DataSet\"><a href=\"#创建DataSet\" class=\"headerlink\" title=\"创建DataSet\"></a>创建DataSet</h3><ul>\n<li>方法一：创建case class （对于复杂的数据没有成功）</li>\n<li><p>例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val sparkses = SparkSession</span><br><span class=\"line\">\t\t\t\t.builder()</span><br><span class=\"line\">                .getOrCreate()</span><br><span class=\"line\">case class KeyValue(key: Int, value: String)</span><br><span class=\"line\">import sparkses.implicit._   //引入隐式转换库</span><br><span class=\"line\">val df = Seq((1,&quot;asdf&quot;),(2,&quot;34234&quot;)).toDF(&quot;key&quot;, &quot;value&quot;)</span><br><span class=\"line\">val ds = df.as[KeyValue]</span><br><span class=\"line\">// org.apache.spark.sql.Dataset[KeyValue] = [key: int, value: string]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>case class的参数上限为22</p>\n</li>\n<li><p>方法二：以元组隐式转化</p>\n</li>\n<li>例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val tupDs = df.as[(Int,String)]</span><br><span class=\"line\">// org.apache.spark.sql.Dataset[(Int, String)] = [_1: int, _2: string]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.21</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<blockquote>\n<p><strong>有问题经常去<a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow.com</a>上找找</strong><br>或者直接去看官方的API原版或者翻译版:<a href=\"http://spark.apachecn.org/\" target=\"_blank\" rel=\"noopener\">官方文档的中文版</a></p>\n</blockquote>\n<h2 id=\"DataSet-与-DataFrame\"><a href=\"#DataSet-与-DataFrame\" class=\"headerlink\" title=\"DataSet 与 DataFrame\"></a>DataSet 与 DataFrame</h2><hr>\n<ul>\n<li><p>Dataset是特定域对象中的强类型集合，它可以使用函数或者相关操作并行地进行转换等操作。每个Dataset都有一个称为DataFrame的非类型化的视图，这个视图是行的数据集。</p>\n</li>\n<li><p>DataSet和RDD主要的区别是：DataSet是特定域的对象集合；然而RDD是任何对象的集合。DataSet的API总是强类型的；而且可以利用这些模式进行优化，然而RDD却不行。</p>\n</li>\n<li><p>Dataset的定义中还提到了DataFrame，DataFrame是特殊的Dataset，它在编译时不会对模式进行检测。在未来版本的Spark，Dataset将会替代RDD成为我们开发编程使用的API。</p>\n</li>\n</ul>\n<h3 id=\"创建DataFrame\"><a href=\"#创建DataFrame\" class=\"headerlink\" title=\"创建DataFrame\"></a>创建DataFrame</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.spark.sql.SparkSession</span><br><span class=\"line\">...</span><br><span class=\"line\">val sparkses = SparkSession</span><br><span class=\"line\">\t\t\t\t.builder()</span><br><span class=\"line\">                .getOrCreate() //这两个为必须有的</span><br><span class=\"line\">val df = sparkses.read.csv(&quot;...filename.csv&quot;)</span><br><span class=\"line\">//这里read后面的方法名称与具体要读的文件类型有关</span><br><span class=\"line\">df.show()  //打印内容</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建DataSet\"><a href=\"#创建DataSet\" class=\"headerlink\" title=\"创建DataSet\"></a>创建DataSet</h3><ul>\n<li>方法一：创建case class （对于复杂的数据没有成功）</li>\n<li><p>例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val sparkses = SparkSession</span><br><span class=\"line\">\t\t\t\t.builder()</span><br><span class=\"line\">                .getOrCreate()</span><br><span class=\"line\">case class KeyValue(key: Int, value: String)</span><br><span class=\"line\">import sparkses.implicit._   //引入隐式转换库</span><br><span class=\"line\">val df = Seq((1,&quot;asdf&quot;),(2,&quot;34234&quot;)).toDF(&quot;key&quot;, &quot;value&quot;)</span><br><span class=\"line\">val ds = df.as[KeyValue]</span><br><span class=\"line\">// org.apache.spark.sql.Dataset[KeyValue] = [key: int, value: string]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>case class的参数上限为22</p>\n</li>\n<li><p>方法二：以元组隐式转化</p>\n</li>\n<li>例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val tupDs = df.as[(Int,String)]</span><br><span class=\"line\">// org.apache.spark.sql.Dataset[(Int, String)] = [_1: int, _2: string]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.21</p>\n</blockquote>\n"},{"layout":"post","title":"Spark学习笔记——基础","date":"2018-04-11T08:47:00.000Z","_content":"> 不适合人类阅读的学习笔记  \n\n> 有问题经常去 **[stackoverflow.com](https://stackoverflow.com/)** 上找找\n\n## 环境搭建\n---\n- 首先确保电脑安装了JAVA Development Kit JDK(使用java -version查看版本)\n\n- 安装hadoop（比如我在安装了hadoop-2.7.5），后面下载spark的版本时也要选择与hadoop版本一致的spark版本。然后添加hadoop路径到PATH（修改/etc/profile文件）\n\n- hadoop单机伪分布式环境搭建详细见我的另一篇博客——[hadoop单机伪分布式搭建](https://fleschier.github.io/2018/05/Hadoop-usage/)\n\n- 下载spark，解压，设置路径。 ———[详细设置](https://www.cnblogs.com/earendil/p/5564492.html)\n\n- 调整日志级别控制输出的信息量：在spark安装文件目录的conf目录下将log4j.properties.template 复制为  log4j.properties, 然后找到 log4j.rootCategory = INFO, console。将其中的INFO改为WARN即可。\n\n- 我的spark的安装目录是`/usr/local/Apache/`，可以使用命令`echo $SPARK_HOME`来查看spark的安装路径。\n\n- 将spark的安装路径加到系统PATH当中(修改`/etc/profile文件`)，然后重启生效之后可在终端通过`spark-shell`命令进入scala的解释器环境，如图：\n![](/images/spark/spark-shell.png)\n\n- [sbt安装网址](https://www.scala-sbt.org/download.html)\n\n## 编程环境\n---\n- spark支持多种语言的编写，包括Python，Java，scala以及R语言，**本篇中均采用scala作为编程语言**。\n- 使用的编译器为intellij IDEA，工程为maven项目\n\n### 编译器的一些使用技巧\n\n- ctrl + Q 在intellij中可以快速地查看变量的类型\n\n- Maven 项目使用maven自带的打jar包的即可，不推荐在build当中打jar包\n\n- 新建的Maven项目很可能缺失很多spark的库，需要修改pom文件来使得编译器引入这些库\n\n## 以maven项目创建scala工程\n\n- 详见 [spark开发环境搭建](https://blog.csdn.net/u012373815/article/details/53266301)\n\n- 其中包括修改pom配置文件。\n\n## spark下的 wordcount\n---\n> 摘自官方文档\n\n- 完整版：\n```\ntext_file = sc.textFile(\"hdfs://...\") //文件需要放在hdfs上\ncounts = text_file.flatMap(lambda line: line.split(\" \")) \\\n             .map(lambda word: (word, 1)) \\\n             .reduceByKey(lambda a, b: a + b)\ncounts.saveAsTextFile(\"hdfs://...\")\n```\n- 精简版(在spark-shell中执行就这一条语句即可)：  (足见scala的优美与强大)\n```\nval counts = sc.textFile(\"hdfs://...(文件路径，单机或者hdfs文件都可以)\").flatMap(_.split(\" \")).map(x => (x,1)).reduceByKey(_ + _).collect().foreach(println) //打印结果\n```\n- 注意：上面的.collect()不能少，因为这是一个action操作，一个语句如果没有action操作则spark什么也不会做。同时，**读取文件的路径一定要用引号括起来！**\n\n\n## 关于jar包以及提交集群运行\n---\n### `spark-submit`命令\n- spark-submit脚本用于在集群上启动应用程序,它位于Spark的bin目录中。\n\n#### 命令行提交\n\n- 命令行下切换到spark的安装目录，执行\n\n```\n./bin/spark-submit \\  \n --class <main-class> \\\n --master <master-url> \\\n --deploy-mode <deploy-mode> \\\n --conf <key>=<value> \\  \n     ... # other options  \n <application-jar> \\  \n [application-arguments]\n```\n\n#### 脚本方式：(创建并编辑.sh脚本文件，赋予执行权限即可)\n\n```\ninput=/data/\noutput=/AR_res/\n    hdfs dfs -rm -r $output\n    hdfs dfs -rm -r /user_res\n    spark-submit \\\n        -v \\\n        --name \"ARsMiner\" \\\n        --class \"com.hazzacheng.AR.Main\" \\\n        --executor-cores 4 \\\n        --executor-memory 10G \\\n        --driver-memory 20G \\\n        AR.jar \\\n        $input \\\n        $output \\\n        2>&1 | tee log/AR_log\n    rm -rf AR_res/\n    hdfs dfs -get $output\n    cat /root$output/part* > /root/res\n    #sort /root$output/part* > /root/res\n```\n\n#### 常用的参数讲解\n\n- --class：应用程序的入口点,main函数所在的类（例如org.apache.spark.examples.SparkPi）\n\n- --master：群集的主网址（例如spark：//23.195.26.187：7077）\n\n- --deploy-mode：是否将驱动程序部署在工作节点（cluster）上，或作为外部客户机（client）本地部署（默认值：client）\n\n- --conf：Key = value格式的任意Spark配置属性。对于包含空格的值，用引号括起“key = value”（参见示例）。\n\n- application-jar：包含应用程序和所有依赖关系的捆绑jar的路径。该URL必须在集群内全局可见，例如hdfs：//路径或所有节点上存在的file：//路径。\n\n- application-arguments：参数传递给主类的main方法（如果有的话）\n\n- 常见的部署策略是从与您的工作机器物理上位于的网关机器提交应用程序（例如，独立的EC2集群中的主节点）。在此设置中，client模式是适当的。在client模式下，驱动程序直接在spark-submit过程中启动，该过程充当集群的客户端。应用程序的输入和输出连接到控制台。因此，该模式特别适用于涉及REPL（例如Spark shell）的应用。\n\n- 或者，如果您的应用程序从远离工作机器（例如本地在笔记本电脑上）的机器提交，通常使用cluster模式来最大限度地减少驱动程序和执行程序之间的网络延迟。\n\n#### 其他的一些示例\n```\n# Run application locally on 8 cores\n./bin/spark-submit \\\n  --class org.apache.spark.examples.SparkPi \\\n  --master local[8] \\\n  /path/to/examples.jar \\\n  100\n```\n\n```\n# Run on a Spark standalone cluster in client deploy mode\n./bin/spark-submit \\\n  --class org.apache.spark.examples.SparkPi \\\n  --master spark://207.184.161.138:7077 \\\n  --executor-memory 20G \\\n  --total-executor-cores 100 \\\n  /path/to/examples.jar \\\n  1000\n```\n\n```\n# Run on a Spark standalone cluster in cluster deploy mode with supervise\n./bin/spark-submit \\\n  --class org.apache.spark.examples.SparkPi \\\n  --master spark://207.184.161.138:7077 \\\n  --deploy-mode cluster \\\n  --supervise \\\n  --executor-memory 20G \\\n  --total-executor-cores 100 \\\n  /path/to/examples.jar \\\n  1000\n```\n\n```\n# Run on a YARN cluster\nexport HADOOP_CONF_DIR=XXX\n./bin/spark-submit \\\n  --class org.apache.spark.examples.SparkPi \\\n  --master yarn \\\n  --deploy-mode cluster \\  # can be client for client mode\n  --executor-memory 20G \\\n  --num-executors 50 \\\n  /path/to/examples.jar \\\n  1000\n```\n\n```\n# Run a Python application on a Spark standalone cluster\n./bin/spark-submit \\\n  --master spark://207.184.161.138:7077 \\\n  examples/src/main/python/pi.py \\\n  1000\n```\n\n```\n# Run on a Mesos cluster in cluster deploy mode with supervise\n./bin/spark-submit \\\n  --class org.apache.spark.examples.SparkPi \\\n  --master mesos://207.184.161.138:7077 \\\n  --deploy-mode cluster \\\n  --supervise \\\n  --executor-memory 20G \\\n  --total-executor-cores 100 \\\n  http://path/to/examples.jar \\\n  1000\n```\n\n## spark程序入口\n\n- Spark SQL中所有功能的入口点是 SparkSession 类. 要创建一个 SparkSession, 仅使用 SparkSession.builder()就可以了：\n```\nimport org.apache.spark.sql.SparkSession\nval sparkses = SparkSession\n  .builder()\t//必须有\n  [.appName(\"Spark SQL basic example\") ]\n  [.config(\"spark.some.config.option\", \"some-value\")]\n  [.master(\"local\")]\n  .getOrCreate() //必须有\n// For implicit conversions like converting RDDs to DataFrames    //即需要用到类型转换时，要引入这个以你的变量名字开头的隐式转换包\nimport sparkses.implicits._\n```\n\n> 未来Dataset可能会取代RDD作为主要使用的API，而RDD会成为最底层的供用户使用的API\n\n- spark一般的入口是 sparkcontext类：\n```\nimport org.apache.spark.{SparkConf, SparkContext}\n...\n val conf = new SparkConf()[.set(...)...]\n val sc = new SparkContext(conf)\n```\n\n\n\n## 一些问题以及解决方法\n---\n> 如要学习spark请看官方文档以及源码\n\n> 有问题经常去 **[stackoverflow.com](https://stackoverflow.com/)** 上找找\n\n- **这里推荐一个[官方文档的中文版](http://spark.apachecn.org/)供英语薄弱的朋友阅读。**\n\n### 试验了FP-Growth算法，打包到集群运行时报错:\n```\nItems in a transaction must be unique but got WrappedArrayMaven\n```\n出现此问题的主要原因是fpg算法要求输入的数据是`RDD(Array[String])`类型，但是Array类型中是不允许出现重复的内容的，所以才会出现这个错误，只需要对输入的数据做个distinct即可\n\n### spark-shell进不去，提示Insufficient space for shared memory file\n\n- 出现这个问题的原因可能是某个文件分区的空间满了，一般可能是日志文件太多。\n\n- 使用`df`命令查看文件系统：\n![](/images/spark/集群文件系统的问题.png)\n可以看到挂载点 `/` 的使用率已经是100%了，所以spark-shell会打不开，删掉一些文件即可。\n\n## 一些小细节\n---\n\n- spark中出现一长细条的信息才是报错\n\n- List 的 `distinct` 方法会对列表去重\n\n- item::list 将新生成一个列表，item会成为新列表的有元素\n\n- Array 不能被`flatMap`,必须为`list.(?)`\n\n- scala中的`.sortBy()`方法如果在括号里最前面加上一个减号表示按逆序排序。\n\n\n\n<br>\n> 最后更新于2018.5.27\n","source":"_posts/2018-04-11-Spark-learning.md","raw":"---\nlayout:     post\ntitle:      \"Spark学习笔记——基础\"\ndate:       2018-04-11 16:47:00\ncategories: Computer Programes\ntags: [๑Spark, ๑BigData]\n---\n> 不适合人类阅读的学习笔记  \n\n> 有问题经常去 **[stackoverflow.com](https://stackoverflow.com/)** 上找找\n\n## 环境搭建\n---\n- 首先确保电脑安装了JAVA Development Kit JDK(使用java -version查看版本)\n\n- 安装hadoop（比如我在安装了hadoop-2.7.5），后面下载spark的版本时也要选择与hadoop版本一致的spark版本。然后添加hadoop路径到PATH（修改/etc/profile文件）\n\n- hadoop单机伪分布式环境搭建详细见我的另一篇博客——[hadoop单机伪分布式搭建](https://fleschier.github.io/2018/05/Hadoop-usage/)\n\n- 下载spark，解压，设置路径。 ———[详细设置](https://www.cnblogs.com/earendil/p/5564492.html)\n\n- 调整日志级别控制输出的信息量：在spark安装文件目录的conf目录下将log4j.properties.template 复制为  log4j.properties, 然后找到 log4j.rootCategory = INFO, console。将其中的INFO改为WARN即可。\n\n- 我的spark的安装目录是`/usr/local/Apache/`，可以使用命令`echo $SPARK_HOME`来查看spark的安装路径。\n\n- 将spark的安装路径加到系统PATH当中(修改`/etc/profile文件`)，然后重启生效之后可在终端通过`spark-shell`命令进入scala的解释器环境，如图：\n![](/images/spark/spark-shell.png)\n\n- [sbt安装网址](https://www.scala-sbt.org/download.html)\n\n## 编程环境\n---\n- spark支持多种语言的编写，包括Python，Java，scala以及R语言，**本篇中均采用scala作为编程语言**。\n- 使用的编译器为intellij IDEA，工程为maven项目\n\n### 编译器的一些使用技巧\n\n- ctrl + Q 在intellij中可以快速地查看变量的类型\n\n- Maven 项目使用maven自带的打jar包的即可，不推荐在build当中打jar包\n\n- 新建的Maven项目很可能缺失很多spark的库，需要修改pom文件来使得编译器引入这些库\n\n## 以maven项目创建scala工程\n\n- 详见 [spark开发环境搭建](https://blog.csdn.net/u012373815/article/details/53266301)\n\n- 其中包括修改pom配置文件。\n\n## spark下的 wordcount\n---\n> 摘自官方文档\n\n- 完整版：\n```\ntext_file = sc.textFile(\"hdfs://...\") //文件需要放在hdfs上\ncounts = text_file.flatMap(lambda line: line.split(\" \")) \\\n             .map(lambda word: (word, 1)) \\\n             .reduceByKey(lambda a, b: a + b)\ncounts.saveAsTextFile(\"hdfs://...\")\n```\n- 精简版(在spark-shell中执行就这一条语句即可)：  (足见scala的优美与强大)\n```\nval counts = sc.textFile(\"hdfs://...(文件路径，单机或者hdfs文件都可以)\").flatMap(_.split(\" \")).map(x => (x,1)).reduceByKey(_ + _).collect().foreach(println) //打印结果\n```\n- 注意：上面的.collect()不能少，因为这是一个action操作，一个语句如果没有action操作则spark什么也不会做。同时，**读取文件的路径一定要用引号括起来！**\n\n\n## 关于jar包以及提交集群运行\n---\n### `spark-submit`命令\n- spark-submit脚本用于在集群上启动应用程序,它位于Spark的bin目录中。\n\n#### 命令行提交\n\n- 命令行下切换到spark的安装目录，执行\n\n```\n./bin/spark-submit \\  \n --class <main-class> \\\n --master <master-url> \\\n --deploy-mode <deploy-mode> \\\n --conf <key>=<value> \\  \n     ... # other options  \n <application-jar> \\  \n [application-arguments]\n```\n\n#### 脚本方式：(创建并编辑.sh脚本文件，赋予执行权限即可)\n\n```\ninput=/data/\noutput=/AR_res/\n    hdfs dfs -rm -r $output\n    hdfs dfs -rm -r /user_res\n    spark-submit \\\n        -v \\\n        --name \"ARsMiner\" \\\n        --class \"com.hazzacheng.AR.Main\" \\\n        --executor-cores 4 \\\n        --executor-memory 10G \\\n        --driver-memory 20G \\\n        AR.jar \\\n        $input \\\n        $output \\\n        2>&1 | tee log/AR_log\n    rm -rf AR_res/\n    hdfs dfs -get $output\n    cat /root$output/part* > /root/res\n    #sort /root$output/part* > /root/res\n```\n\n#### 常用的参数讲解\n\n- --class：应用程序的入口点,main函数所在的类（例如org.apache.spark.examples.SparkPi）\n\n- --master：群集的主网址（例如spark：//23.195.26.187：7077）\n\n- --deploy-mode：是否将驱动程序部署在工作节点（cluster）上，或作为外部客户机（client）本地部署（默认值：client）\n\n- --conf：Key = value格式的任意Spark配置属性。对于包含空格的值，用引号括起“key = value”（参见示例）。\n\n- application-jar：包含应用程序和所有依赖关系的捆绑jar的路径。该URL必须在集群内全局可见，例如hdfs：//路径或所有节点上存在的file：//路径。\n\n- application-arguments：参数传递给主类的main方法（如果有的话）\n\n- 常见的部署策略是从与您的工作机器物理上位于的网关机器提交应用程序（例如，独立的EC2集群中的主节点）。在此设置中，client模式是适当的。在client模式下，驱动程序直接在spark-submit过程中启动，该过程充当集群的客户端。应用程序的输入和输出连接到控制台。因此，该模式特别适用于涉及REPL（例如Spark shell）的应用。\n\n- 或者，如果您的应用程序从远离工作机器（例如本地在笔记本电脑上）的机器提交，通常使用cluster模式来最大限度地减少驱动程序和执行程序之间的网络延迟。\n\n#### 其他的一些示例\n```\n# Run application locally on 8 cores\n./bin/spark-submit \\\n  --class org.apache.spark.examples.SparkPi \\\n  --master local[8] \\\n  /path/to/examples.jar \\\n  100\n```\n\n```\n# Run on a Spark standalone cluster in client deploy mode\n./bin/spark-submit \\\n  --class org.apache.spark.examples.SparkPi \\\n  --master spark://207.184.161.138:7077 \\\n  --executor-memory 20G \\\n  --total-executor-cores 100 \\\n  /path/to/examples.jar \\\n  1000\n```\n\n```\n# Run on a Spark standalone cluster in cluster deploy mode with supervise\n./bin/spark-submit \\\n  --class org.apache.spark.examples.SparkPi \\\n  --master spark://207.184.161.138:7077 \\\n  --deploy-mode cluster \\\n  --supervise \\\n  --executor-memory 20G \\\n  --total-executor-cores 100 \\\n  /path/to/examples.jar \\\n  1000\n```\n\n```\n# Run on a YARN cluster\nexport HADOOP_CONF_DIR=XXX\n./bin/spark-submit \\\n  --class org.apache.spark.examples.SparkPi \\\n  --master yarn \\\n  --deploy-mode cluster \\  # can be client for client mode\n  --executor-memory 20G \\\n  --num-executors 50 \\\n  /path/to/examples.jar \\\n  1000\n```\n\n```\n# Run a Python application on a Spark standalone cluster\n./bin/spark-submit \\\n  --master spark://207.184.161.138:7077 \\\n  examples/src/main/python/pi.py \\\n  1000\n```\n\n```\n# Run on a Mesos cluster in cluster deploy mode with supervise\n./bin/spark-submit \\\n  --class org.apache.spark.examples.SparkPi \\\n  --master mesos://207.184.161.138:7077 \\\n  --deploy-mode cluster \\\n  --supervise \\\n  --executor-memory 20G \\\n  --total-executor-cores 100 \\\n  http://path/to/examples.jar \\\n  1000\n```\n\n## spark程序入口\n\n- Spark SQL中所有功能的入口点是 SparkSession 类. 要创建一个 SparkSession, 仅使用 SparkSession.builder()就可以了：\n```\nimport org.apache.spark.sql.SparkSession\nval sparkses = SparkSession\n  .builder()\t//必须有\n  [.appName(\"Spark SQL basic example\") ]\n  [.config(\"spark.some.config.option\", \"some-value\")]\n  [.master(\"local\")]\n  .getOrCreate() //必须有\n// For implicit conversions like converting RDDs to DataFrames    //即需要用到类型转换时，要引入这个以你的变量名字开头的隐式转换包\nimport sparkses.implicits._\n```\n\n> 未来Dataset可能会取代RDD作为主要使用的API，而RDD会成为最底层的供用户使用的API\n\n- spark一般的入口是 sparkcontext类：\n```\nimport org.apache.spark.{SparkConf, SparkContext}\n...\n val conf = new SparkConf()[.set(...)...]\n val sc = new SparkContext(conf)\n```\n\n\n\n## 一些问题以及解决方法\n---\n> 如要学习spark请看官方文档以及源码\n\n> 有问题经常去 **[stackoverflow.com](https://stackoverflow.com/)** 上找找\n\n- **这里推荐一个[官方文档的中文版](http://spark.apachecn.org/)供英语薄弱的朋友阅读。**\n\n### 试验了FP-Growth算法，打包到集群运行时报错:\n```\nItems in a transaction must be unique but got WrappedArrayMaven\n```\n出现此问题的主要原因是fpg算法要求输入的数据是`RDD(Array[String])`类型，但是Array类型中是不允许出现重复的内容的，所以才会出现这个错误，只需要对输入的数据做个distinct即可\n\n### spark-shell进不去，提示Insufficient space for shared memory file\n\n- 出现这个问题的原因可能是某个文件分区的空间满了，一般可能是日志文件太多。\n\n- 使用`df`命令查看文件系统：\n![](/images/spark/集群文件系统的问题.png)\n可以看到挂载点 `/` 的使用率已经是100%了，所以spark-shell会打不开，删掉一些文件即可。\n\n## 一些小细节\n---\n\n- spark中出现一长细条的信息才是报错\n\n- List 的 `distinct` 方法会对列表去重\n\n- item::list 将新生成一个列表，item会成为新列表的有元素\n\n- Array 不能被`flatMap`,必须为`list.(?)`\n\n- scala中的`.sortBy()`方法如果在括号里最前面加上一个减号表示按逆序排序。\n\n\n\n<br>\n> 最后更新于2018.5.27\n","slug":"2018-04-11-Spark-learning","published":1,"updated":"2018-09-03T13:18:22.362Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4l00161m0oqgamtr6z","content":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<blockquote>\n<p>有问题经常去 <strong><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow.com</a></strong> 上找找</p>\n</blockquote>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><hr>\n<ul>\n<li><p>首先确保电脑安装了JAVA Development Kit JDK(使用java -version查看版本)</p>\n</li>\n<li><p>安装hadoop（比如我在安装了hadoop-2.7.5），后面下载spark的版本时也要选择与hadoop版本一致的spark版本。然后添加hadoop路径到PATH（修改/etc/profile文件）</p>\n</li>\n<li><p>hadoop单机伪分布式环境搭建详细见我的另一篇博客——<a href=\"https://fleschier.github.io/2018/05/Hadoop-usage/\" target=\"_blank\" rel=\"noopener\">hadoop单机伪分布式搭建</a></p>\n</li>\n<li><p>下载spark，解压，设置路径。 ———<a href=\"https://www.cnblogs.com/earendil/p/5564492.html\" target=\"_blank\" rel=\"noopener\">详细设置</a></p>\n</li>\n<li><p>调整日志级别控制输出的信息量：在spark安装文件目录的conf目录下将log4j.properties.template 复制为  log4j.properties, 然后找到 log4j.rootCategory = INFO, console。将其中的INFO改为WARN即可。</p>\n</li>\n<li><p>我的spark的安装目录是<code>/usr/local/Apache/</code>，可以使用命令<code>echo $SPARK_HOME</code>来查看spark的安装路径。</p>\n</li>\n<li><p>将spark的安装路径加到系统PATH当中(修改<code>/etc/profile文件</code>)，然后重启生效之后可在终端通过<code>spark-shell</code>命令进入scala的解释器环境，如图：<br><img src=\"/images/spark/spark-shell.png\" alt=\"\"></p>\n</li>\n<li><p><a href=\"https://www.scala-sbt.org/download.html\" target=\"_blank\" rel=\"noopener\">sbt安装网址</a></p>\n</li>\n</ul>\n<h2 id=\"编程环境\"><a href=\"#编程环境\" class=\"headerlink\" title=\"编程环境\"></a>编程环境</h2><hr>\n<ul>\n<li>spark支持多种语言的编写，包括Python，Java，scala以及R语言，<strong>本篇中均采用scala作为编程语言</strong>。</li>\n<li>使用的编译器为intellij IDEA，工程为maven项目</li>\n</ul>\n<h3 id=\"编译器的一些使用技巧\"><a href=\"#编译器的一些使用技巧\" class=\"headerlink\" title=\"编译器的一些使用技巧\"></a>编译器的一些使用技巧</h3><ul>\n<li><p>ctrl + Q 在intellij中可以快速地查看变量的类型</p>\n</li>\n<li><p>Maven 项目使用maven自带的打jar包的即可，不推荐在build当中打jar包</p>\n</li>\n<li><p>新建的Maven项目很可能缺失很多spark的库，需要修改pom文件来使得编译器引入这些库</p>\n</li>\n</ul>\n<h2 id=\"以maven项目创建scala工程\"><a href=\"#以maven项目创建scala工程\" class=\"headerlink\" title=\"以maven项目创建scala工程\"></a>以maven项目创建scala工程</h2><ul>\n<li><p>详见 <a href=\"https://blog.csdn.net/u012373815/article/details/53266301\" target=\"_blank\" rel=\"noopener\">spark开发环境搭建</a></p>\n</li>\n<li><p>其中包括修改pom配置文件。</p>\n</li>\n</ul>\n<h2 id=\"spark下的-wordcount\"><a href=\"#spark下的-wordcount\" class=\"headerlink\" title=\"spark下的 wordcount\"></a>spark下的 wordcount</h2><hr>\n<blockquote>\n<p>摘自官方文档</p>\n</blockquote>\n<ul>\n<li><p>完整版：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text_file = sc.textFile(&quot;hdfs://...&quot;) //文件需要放在hdfs上</span><br><span class=\"line\">counts = text_file.flatMap(lambda line: line.split(&quot; &quot;)) \\</span><br><span class=\"line\">             .map(lambda word: (word, 1)) \\</span><br><span class=\"line\">             .reduceByKey(lambda a, b: a + b)</span><br><span class=\"line\">counts.saveAsTextFile(&quot;hdfs://...&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>精简版(在spark-shell中执行就这一条语句即可)：  (足见scala的优美与强大)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val counts = sc.textFile(&quot;hdfs://...(文件路径，单机或者hdfs文件都可以)&quot;).flatMap(_.split(&quot; &quot;)).map(x =&gt; (x,1)).reduceByKey(_ + _).collect().foreach(println) //打印结果</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意：上面的.collect()不能少，因为这是一个action操作，一个语句如果没有action操作则spark什么也不会做。同时，<strong>读取文件的路径一定要用引号括起来！</strong></p>\n</li>\n</ul>\n<h2 id=\"关于jar包以及提交集群运行\"><a href=\"#关于jar包以及提交集群运行\" class=\"headerlink\" title=\"关于jar包以及提交集群运行\"></a>关于jar包以及提交集群运行</h2><hr>\n<h3 id=\"spark-submit命令\"><a href=\"#spark-submit命令\" class=\"headerlink\" title=\"spark-submit命令\"></a><code>spark-submit</code>命令</h3><ul>\n<li>spark-submit脚本用于在集群上启动应用程序,它位于Spark的bin目录中。</li>\n</ul>\n<h4 id=\"命令行提交\"><a href=\"#命令行提交\" class=\"headerlink\" title=\"命令行提交\"></a>命令行提交</h4><ul>\n<li>命令行下切换到spark的安装目录，执行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/spark-submit \\  </span><br><span class=\"line\"> --class &lt;main-class&gt; \\</span><br><span class=\"line\"> --master &lt;master-url&gt; \\</span><br><span class=\"line\"> --deploy-mode &lt;deploy-mode&gt; \\</span><br><span class=\"line\"> --conf &lt;key&gt;=&lt;value&gt; \\  </span><br><span class=\"line\">     ... # other options  </span><br><span class=\"line\"> &lt;application-jar&gt; \\  </span><br><span class=\"line\"> [application-arguments]</span><br></pre></td></tr></table></figure>\n<h4 id=\"脚本方式：-创建并编辑-sh脚本文件，赋予执行权限即可\"><a href=\"#脚本方式：-创建并编辑-sh脚本文件，赋予执行权限即可\" class=\"headerlink\" title=\"脚本方式：(创建并编辑.sh脚本文件，赋予执行权限即可)\"></a>脚本方式：(创建并编辑.sh脚本文件，赋予执行权限即可)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input=/data/</span><br><span class=\"line\">output=/AR_res/</span><br><span class=\"line\">    hdfs dfs -rm -r $output</span><br><span class=\"line\">    hdfs dfs -rm -r /user_res</span><br><span class=\"line\">    spark-submit \\</span><br><span class=\"line\">        -v \\</span><br><span class=\"line\">        --name &quot;ARsMiner&quot; \\</span><br><span class=\"line\">        --class &quot;com.hazzacheng.AR.Main&quot; \\</span><br><span class=\"line\">        --executor-cores 4 \\</span><br><span class=\"line\">        --executor-memory 10G \\</span><br><span class=\"line\">        --driver-memory 20G \\</span><br><span class=\"line\">        AR.jar \\</span><br><span class=\"line\">        $input \\</span><br><span class=\"line\">        $output \\</span><br><span class=\"line\">        2&gt;&amp;1 | tee log/AR_log</span><br><span class=\"line\">    rm -rf AR_res/</span><br><span class=\"line\">    hdfs dfs -get $output</span><br><span class=\"line\">    cat /root$output/part* &gt; /root/res</span><br><span class=\"line\">    #sort /root$output/part* &gt; /root/res</span><br></pre></td></tr></table></figure>\n<h4 id=\"常用的参数讲解\"><a href=\"#常用的参数讲解\" class=\"headerlink\" title=\"常用的参数讲解\"></a>常用的参数讲解</h4><ul>\n<li><p>–class：应用程序的入口点,main函数所在的类（例如org.apache.spark.examples.SparkPi）</p>\n</li>\n<li><p>–master：群集的主网址（例如spark：//23.195.26.187：7077）</p>\n</li>\n<li><p>–deploy-mode：是否将驱动程序部署在工作节点（cluster）上，或作为外部客户机（client）本地部署（默认值：client）</p>\n</li>\n<li><p>–conf：Key = value格式的任意Spark配置属性。对于包含空格的值，用引号括起“key = value”（参见示例）。</p>\n</li>\n<li><p>application-jar：包含应用程序和所有依赖关系的捆绑jar的路径。该URL必须在集群内全局可见，例如hdfs：//路径或所有节点上存在的file：//路径。</p>\n</li>\n<li><p>application-arguments：参数传递给主类的main方法（如果有的话）</p>\n</li>\n<li><p>常见的部署策略是从与您的工作机器物理上位于的网关机器提交应用程序（例如，独立的EC2集群中的主节点）。在此设置中，client模式是适当的。在client模式下，驱动程序直接在spark-submit过程中启动，该过程充当集群的客户端。应用程序的输入和输出连接到控制台。因此，该模式特别适用于涉及REPL（例如Spark shell）的应用。</p>\n</li>\n<li><p>或者，如果您的应用程序从远离工作机器（例如本地在笔记本电脑上）的机器提交，通常使用cluster模式来最大限度地减少驱动程序和执行程序之间的网络延迟。</p>\n</li>\n</ul>\n<h4 id=\"其他的一些示例\"><a href=\"#其他的一些示例\" class=\"headerlink\" title=\"其他的一些示例\"></a>其他的一些示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run application locally on 8 cores</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">  --master local[8] \\</span><br><span class=\"line\">  /path/to/examples.jar \\</span><br><span class=\"line\">  100</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run on a Spark standalone cluster in client deploy mode</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">  --master spark://207.184.161.138:7077 \\</span><br><span class=\"line\">  --executor-memory 20G \\</span><br><span class=\"line\">  --total-executor-cores 100 \\</span><br><span class=\"line\">  /path/to/examples.jar \\</span><br><span class=\"line\">  1000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run on a Spark standalone cluster in cluster deploy mode with supervise</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">  --master spark://207.184.161.138:7077 \\</span><br><span class=\"line\">  --deploy-mode cluster \\</span><br><span class=\"line\">  --supervise \\</span><br><span class=\"line\">  --executor-memory 20G \\</span><br><span class=\"line\">  --total-executor-cores 100 \\</span><br><span class=\"line\">  /path/to/examples.jar \\</span><br><span class=\"line\">  1000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run on a YARN cluster</span><br><span class=\"line\">export HADOOP_CONF_DIR=XXX</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">  --master yarn \\</span><br><span class=\"line\">  --deploy-mode cluster \\  # can be client for client mode</span><br><span class=\"line\">  --executor-memory 20G \\</span><br><span class=\"line\">  --num-executors 50 \\</span><br><span class=\"line\">  /path/to/examples.jar \\</span><br><span class=\"line\">  1000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run a Python application on a Spark standalone cluster</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --master spark://207.184.161.138:7077 \\</span><br><span class=\"line\">  examples/src/main/python/pi.py \\</span><br><span class=\"line\">  1000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run on a Mesos cluster in cluster deploy mode with supervise</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">  --master mesos://207.184.161.138:7077 \\</span><br><span class=\"line\">  --deploy-mode cluster \\</span><br><span class=\"line\">  --supervise \\</span><br><span class=\"line\">  --executor-memory 20G \\</span><br><span class=\"line\">  --total-executor-cores 100 \\</span><br><span class=\"line\">  http://path/to/examples.jar \\</span><br><span class=\"line\">  1000</span><br></pre></td></tr></table></figure>\n<h2 id=\"spark程序入口\"><a href=\"#spark程序入口\" class=\"headerlink\" title=\"spark程序入口\"></a>spark程序入口</h2><ul>\n<li>Spark SQL中所有功能的入口点是 SparkSession 类. 要创建一个 SparkSession, 仅使用 SparkSession.builder()就可以了：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.spark.sql.SparkSession</span><br><span class=\"line\">val sparkses = SparkSession</span><br><span class=\"line\">  .builder()\t//必须有</span><br><span class=\"line\">  [.appName(&quot;Spark SQL basic example&quot;) ]</span><br><span class=\"line\">  [.config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;)]</span><br><span class=\"line\">  [.master(&quot;local&quot;)]</span><br><span class=\"line\">  .getOrCreate() //必须有</span><br><span class=\"line\">// For implicit conversions like converting RDDs to DataFrames    //即需要用到类型转换时，要引入这个以你的变量名字开头的隐式转换包</span><br><span class=\"line\">import sparkses.implicits._</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>未来Dataset可能会取代RDD作为主要使用的API，而RDD会成为最底层的供用户使用的API</p>\n</blockquote>\n<ul>\n<li>spark一般的入口是 sparkcontext类：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.spark.&#123;SparkConf, SparkContext&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"> val conf = new SparkConf()[.set(...)...]</span><br><span class=\"line\"> val sc = new SparkContext(conf)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"一些问题以及解决方法\"><a href=\"#一些问题以及解决方法\" class=\"headerlink\" title=\"一些问题以及解决方法\"></a>一些问题以及解决方法</h2><hr>\n<blockquote>\n<p>如要学习spark请看官方文档以及源码</p>\n</blockquote>\n<blockquote>\n<p>有问题经常去 <strong><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow.com</a></strong> 上找找</p>\n</blockquote>\n<ul>\n<li><strong>这里推荐一个<a href=\"http://spark.apachecn.org/\" target=\"_blank\" rel=\"noopener\">官方文档的中文版</a>供英语薄弱的朋友阅读。</strong></li>\n</ul>\n<h3 id=\"试验了FP-Growth算法，打包到集群运行时报错\"><a href=\"#试验了FP-Growth算法，打包到集群运行时报错\" class=\"headerlink\" title=\"试验了FP-Growth算法，打包到集群运行时报错:\"></a>试验了FP-Growth算法，打包到集群运行时报错:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Items in a transaction must be unique but got WrappedArrayMaven</span><br></pre></td></tr></table></figure>\n<p>出现此问题的主要原因是fpg算法要求输入的数据是<code>RDD(Array[String])</code>类型，但是Array类型中是不允许出现重复的内容的，所以才会出现这个错误，只需要对输入的数据做个distinct即可</p>\n<h3 id=\"spark-shell进不去，提示Insufficient-space-for-shared-memory-file\"><a href=\"#spark-shell进不去，提示Insufficient-space-for-shared-memory-file\" class=\"headerlink\" title=\"spark-shell进不去，提示Insufficient space for shared memory file\"></a>spark-shell进不去，提示Insufficient space for shared memory file</h3><ul>\n<li><p>出现这个问题的原因可能是某个文件分区的空间满了，一般可能是日志文件太多。</p>\n</li>\n<li><p>使用<code>df</code>命令查看文件系统：<br><img src=\"/images/spark/集群文件系统的问题.png\" alt=\"\"><br>可以看到挂载点 <code>/</code> 的使用率已经是100%了，所以spark-shell会打不开，删掉一些文件即可。</p>\n</li>\n</ul>\n<h2 id=\"一些小细节\"><a href=\"#一些小细节\" class=\"headerlink\" title=\"一些小细节\"></a>一些小细节</h2><hr>\n<ul>\n<li><p>spark中出现一长细条的信息才是报错</p>\n</li>\n<li><p>List 的 <code>distinct</code> 方法会对列表去重</p>\n</li>\n<li><p>item::list 将新生成一个列表，item会成为新列表的有元素</p>\n</li>\n<li><p>Array 不能被<code>flatMap</code>,必须为<code>list.(?)</code></p>\n</li>\n<li><p>scala中的<code>.sortBy()</code>方法如果在括号里最前面加上一个减号表示按逆序排序。</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.27</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<blockquote>\n<p>有问题经常去 <strong><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow.com</a></strong> 上找找</p>\n</blockquote>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><hr>\n<ul>\n<li><p>首先确保电脑安装了JAVA Development Kit JDK(使用java -version查看版本)</p>\n</li>\n<li><p>安装hadoop（比如我在安装了hadoop-2.7.5），后面下载spark的版本时也要选择与hadoop版本一致的spark版本。然后添加hadoop路径到PATH（修改/etc/profile文件）</p>\n</li>\n<li><p>hadoop单机伪分布式环境搭建详细见我的另一篇博客——<a href=\"https://fleschier.github.io/2018/05/Hadoop-usage/\" target=\"_blank\" rel=\"noopener\">hadoop单机伪分布式搭建</a></p>\n</li>\n<li><p>下载spark，解压，设置路径。 ———<a href=\"https://www.cnblogs.com/earendil/p/5564492.html\" target=\"_blank\" rel=\"noopener\">详细设置</a></p>\n</li>\n<li><p>调整日志级别控制输出的信息量：在spark安装文件目录的conf目录下将log4j.properties.template 复制为  log4j.properties, 然后找到 log4j.rootCategory = INFO, console。将其中的INFO改为WARN即可。</p>\n</li>\n<li><p>我的spark的安装目录是<code>/usr/local/Apache/</code>，可以使用命令<code>echo $SPARK_HOME</code>来查看spark的安装路径。</p>\n</li>\n<li><p>将spark的安装路径加到系统PATH当中(修改<code>/etc/profile文件</code>)，然后重启生效之后可在终端通过<code>spark-shell</code>命令进入scala的解释器环境，如图：<br><img src=\"/images/spark/spark-shell.png\" alt=\"\"></p>\n</li>\n<li><p><a href=\"https://www.scala-sbt.org/download.html\" target=\"_blank\" rel=\"noopener\">sbt安装网址</a></p>\n</li>\n</ul>\n<h2 id=\"编程环境\"><a href=\"#编程环境\" class=\"headerlink\" title=\"编程环境\"></a>编程环境</h2><hr>\n<ul>\n<li>spark支持多种语言的编写，包括Python，Java，scala以及R语言，<strong>本篇中均采用scala作为编程语言</strong>。</li>\n<li>使用的编译器为intellij IDEA，工程为maven项目</li>\n</ul>\n<h3 id=\"编译器的一些使用技巧\"><a href=\"#编译器的一些使用技巧\" class=\"headerlink\" title=\"编译器的一些使用技巧\"></a>编译器的一些使用技巧</h3><ul>\n<li><p>ctrl + Q 在intellij中可以快速地查看变量的类型</p>\n</li>\n<li><p>Maven 项目使用maven自带的打jar包的即可，不推荐在build当中打jar包</p>\n</li>\n<li><p>新建的Maven项目很可能缺失很多spark的库，需要修改pom文件来使得编译器引入这些库</p>\n</li>\n</ul>\n<h2 id=\"以maven项目创建scala工程\"><a href=\"#以maven项目创建scala工程\" class=\"headerlink\" title=\"以maven项目创建scala工程\"></a>以maven项目创建scala工程</h2><ul>\n<li><p>详见 <a href=\"https://blog.csdn.net/u012373815/article/details/53266301\" target=\"_blank\" rel=\"noopener\">spark开发环境搭建</a></p>\n</li>\n<li><p>其中包括修改pom配置文件。</p>\n</li>\n</ul>\n<h2 id=\"spark下的-wordcount\"><a href=\"#spark下的-wordcount\" class=\"headerlink\" title=\"spark下的 wordcount\"></a>spark下的 wordcount</h2><hr>\n<blockquote>\n<p>摘自官方文档</p>\n</blockquote>\n<ul>\n<li><p>完整版：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text_file = sc.textFile(&quot;hdfs://...&quot;) //文件需要放在hdfs上</span><br><span class=\"line\">counts = text_file.flatMap(lambda line: line.split(&quot; &quot;)) \\</span><br><span class=\"line\">             .map(lambda word: (word, 1)) \\</span><br><span class=\"line\">             .reduceByKey(lambda a, b: a + b)</span><br><span class=\"line\">counts.saveAsTextFile(&quot;hdfs://...&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>精简版(在spark-shell中执行就这一条语句即可)：  (足见scala的优美与强大)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val counts = sc.textFile(&quot;hdfs://...(文件路径，单机或者hdfs文件都可以)&quot;).flatMap(_.split(&quot; &quot;)).map(x =&gt; (x,1)).reduceByKey(_ + _).collect().foreach(println) //打印结果</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意：上面的.collect()不能少，因为这是一个action操作，一个语句如果没有action操作则spark什么也不会做。同时，<strong>读取文件的路径一定要用引号括起来！</strong></p>\n</li>\n</ul>\n<h2 id=\"关于jar包以及提交集群运行\"><a href=\"#关于jar包以及提交集群运行\" class=\"headerlink\" title=\"关于jar包以及提交集群运行\"></a>关于jar包以及提交集群运行</h2><hr>\n<h3 id=\"spark-submit命令\"><a href=\"#spark-submit命令\" class=\"headerlink\" title=\"spark-submit命令\"></a><code>spark-submit</code>命令</h3><ul>\n<li>spark-submit脚本用于在集群上启动应用程序,它位于Spark的bin目录中。</li>\n</ul>\n<h4 id=\"命令行提交\"><a href=\"#命令行提交\" class=\"headerlink\" title=\"命令行提交\"></a>命令行提交</h4><ul>\n<li>命令行下切换到spark的安装目录，执行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/spark-submit \\  </span><br><span class=\"line\"> --class &lt;main-class&gt; \\</span><br><span class=\"line\"> --master &lt;master-url&gt; \\</span><br><span class=\"line\"> --deploy-mode &lt;deploy-mode&gt; \\</span><br><span class=\"line\"> --conf &lt;key&gt;=&lt;value&gt; \\  </span><br><span class=\"line\">     ... # other options  </span><br><span class=\"line\"> &lt;application-jar&gt; \\  </span><br><span class=\"line\"> [application-arguments]</span><br></pre></td></tr></table></figure>\n<h4 id=\"脚本方式：-创建并编辑-sh脚本文件，赋予执行权限即可\"><a href=\"#脚本方式：-创建并编辑-sh脚本文件，赋予执行权限即可\" class=\"headerlink\" title=\"脚本方式：(创建并编辑.sh脚本文件，赋予执行权限即可)\"></a>脚本方式：(创建并编辑.sh脚本文件，赋予执行权限即可)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input=/data/</span><br><span class=\"line\">output=/AR_res/</span><br><span class=\"line\">    hdfs dfs -rm -r $output</span><br><span class=\"line\">    hdfs dfs -rm -r /user_res</span><br><span class=\"line\">    spark-submit \\</span><br><span class=\"line\">        -v \\</span><br><span class=\"line\">        --name &quot;ARsMiner&quot; \\</span><br><span class=\"line\">        --class &quot;com.hazzacheng.AR.Main&quot; \\</span><br><span class=\"line\">        --executor-cores 4 \\</span><br><span class=\"line\">        --executor-memory 10G \\</span><br><span class=\"line\">        --driver-memory 20G \\</span><br><span class=\"line\">        AR.jar \\</span><br><span class=\"line\">        $input \\</span><br><span class=\"line\">        $output \\</span><br><span class=\"line\">        2&gt;&amp;1 | tee log/AR_log</span><br><span class=\"line\">    rm -rf AR_res/</span><br><span class=\"line\">    hdfs dfs -get $output</span><br><span class=\"line\">    cat /root$output/part* &gt; /root/res</span><br><span class=\"line\">    #sort /root$output/part* &gt; /root/res</span><br></pre></td></tr></table></figure>\n<h4 id=\"常用的参数讲解\"><a href=\"#常用的参数讲解\" class=\"headerlink\" title=\"常用的参数讲解\"></a>常用的参数讲解</h4><ul>\n<li><p>–class：应用程序的入口点,main函数所在的类（例如org.apache.spark.examples.SparkPi）</p>\n</li>\n<li><p>–master：群集的主网址（例如spark：//23.195.26.187：7077）</p>\n</li>\n<li><p>–deploy-mode：是否将驱动程序部署在工作节点（cluster）上，或作为外部客户机（client）本地部署（默认值：client）</p>\n</li>\n<li><p>–conf：Key = value格式的任意Spark配置属性。对于包含空格的值，用引号括起“key = value”（参见示例）。</p>\n</li>\n<li><p>application-jar：包含应用程序和所有依赖关系的捆绑jar的路径。该URL必须在集群内全局可见，例如hdfs：//路径或所有节点上存在的file：//路径。</p>\n</li>\n<li><p>application-arguments：参数传递给主类的main方法（如果有的话）</p>\n</li>\n<li><p>常见的部署策略是从与您的工作机器物理上位于的网关机器提交应用程序（例如，独立的EC2集群中的主节点）。在此设置中，client模式是适当的。在client模式下，驱动程序直接在spark-submit过程中启动，该过程充当集群的客户端。应用程序的输入和输出连接到控制台。因此，该模式特别适用于涉及REPL（例如Spark shell）的应用。</p>\n</li>\n<li><p>或者，如果您的应用程序从远离工作机器（例如本地在笔记本电脑上）的机器提交，通常使用cluster模式来最大限度地减少驱动程序和执行程序之间的网络延迟。</p>\n</li>\n</ul>\n<h4 id=\"其他的一些示例\"><a href=\"#其他的一些示例\" class=\"headerlink\" title=\"其他的一些示例\"></a>其他的一些示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run application locally on 8 cores</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">  --master local[8] \\</span><br><span class=\"line\">  /path/to/examples.jar \\</span><br><span class=\"line\">  100</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run on a Spark standalone cluster in client deploy mode</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">  --master spark://207.184.161.138:7077 \\</span><br><span class=\"line\">  --executor-memory 20G \\</span><br><span class=\"line\">  --total-executor-cores 100 \\</span><br><span class=\"line\">  /path/to/examples.jar \\</span><br><span class=\"line\">  1000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run on a Spark standalone cluster in cluster deploy mode with supervise</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">  --master spark://207.184.161.138:7077 \\</span><br><span class=\"line\">  --deploy-mode cluster \\</span><br><span class=\"line\">  --supervise \\</span><br><span class=\"line\">  --executor-memory 20G \\</span><br><span class=\"line\">  --total-executor-cores 100 \\</span><br><span class=\"line\">  /path/to/examples.jar \\</span><br><span class=\"line\">  1000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run on a YARN cluster</span><br><span class=\"line\">export HADOOP_CONF_DIR=XXX</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">  --master yarn \\</span><br><span class=\"line\">  --deploy-mode cluster \\  # can be client for client mode</span><br><span class=\"line\">  --executor-memory 20G \\</span><br><span class=\"line\">  --num-executors 50 \\</span><br><span class=\"line\">  /path/to/examples.jar \\</span><br><span class=\"line\">  1000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run a Python application on a Spark standalone cluster</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --master spark://207.184.161.138:7077 \\</span><br><span class=\"line\">  examples/src/main/python/pi.py \\</span><br><span class=\"line\">  1000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run on a Mesos cluster in cluster deploy mode with supervise</span><br><span class=\"line\">./bin/spark-submit \\</span><br><span class=\"line\">  --class org.apache.spark.examples.SparkPi \\</span><br><span class=\"line\">  --master mesos://207.184.161.138:7077 \\</span><br><span class=\"line\">  --deploy-mode cluster \\</span><br><span class=\"line\">  --supervise \\</span><br><span class=\"line\">  --executor-memory 20G \\</span><br><span class=\"line\">  --total-executor-cores 100 \\</span><br><span class=\"line\">  http://path/to/examples.jar \\</span><br><span class=\"line\">  1000</span><br></pre></td></tr></table></figure>\n<h2 id=\"spark程序入口\"><a href=\"#spark程序入口\" class=\"headerlink\" title=\"spark程序入口\"></a>spark程序入口</h2><ul>\n<li>Spark SQL中所有功能的入口点是 SparkSession 类. 要创建一个 SparkSession, 仅使用 SparkSession.builder()就可以了：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.spark.sql.SparkSession</span><br><span class=\"line\">val sparkses = SparkSession</span><br><span class=\"line\">  .builder()\t//必须有</span><br><span class=\"line\">  [.appName(&quot;Spark SQL basic example&quot;) ]</span><br><span class=\"line\">  [.config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;)]</span><br><span class=\"line\">  [.master(&quot;local&quot;)]</span><br><span class=\"line\">  .getOrCreate() //必须有</span><br><span class=\"line\">// For implicit conversions like converting RDDs to DataFrames    //即需要用到类型转换时，要引入这个以你的变量名字开头的隐式转换包</span><br><span class=\"line\">import sparkses.implicits._</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>未来Dataset可能会取代RDD作为主要使用的API，而RDD会成为最底层的供用户使用的API</p>\n</blockquote>\n<ul>\n<li>spark一般的入口是 sparkcontext类：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.spark.&#123;SparkConf, SparkContext&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"> val conf = new SparkConf()[.set(...)...]</span><br><span class=\"line\"> val sc = new SparkContext(conf)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"一些问题以及解决方法\"><a href=\"#一些问题以及解决方法\" class=\"headerlink\" title=\"一些问题以及解决方法\"></a>一些问题以及解决方法</h2><hr>\n<blockquote>\n<p>如要学习spark请看官方文档以及源码</p>\n</blockquote>\n<blockquote>\n<p>有问题经常去 <strong><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow.com</a></strong> 上找找</p>\n</blockquote>\n<ul>\n<li><strong>这里推荐一个<a href=\"http://spark.apachecn.org/\" target=\"_blank\" rel=\"noopener\">官方文档的中文版</a>供英语薄弱的朋友阅读。</strong></li>\n</ul>\n<h3 id=\"试验了FP-Growth算法，打包到集群运行时报错\"><a href=\"#试验了FP-Growth算法，打包到集群运行时报错\" class=\"headerlink\" title=\"试验了FP-Growth算法，打包到集群运行时报错:\"></a>试验了FP-Growth算法，打包到集群运行时报错:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Items in a transaction must be unique but got WrappedArrayMaven</span><br></pre></td></tr></table></figure>\n<p>出现此问题的主要原因是fpg算法要求输入的数据是<code>RDD(Array[String])</code>类型，但是Array类型中是不允许出现重复的内容的，所以才会出现这个错误，只需要对输入的数据做个distinct即可</p>\n<h3 id=\"spark-shell进不去，提示Insufficient-space-for-shared-memory-file\"><a href=\"#spark-shell进不去，提示Insufficient-space-for-shared-memory-file\" class=\"headerlink\" title=\"spark-shell进不去，提示Insufficient space for shared memory file\"></a>spark-shell进不去，提示Insufficient space for shared memory file</h3><ul>\n<li><p>出现这个问题的原因可能是某个文件分区的空间满了，一般可能是日志文件太多。</p>\n</li>\n<li><p>使用<code>df</code>命令查看文件系统：<br><img src=\"/images/spark/集群文件系统的问题.png\" alt=\"\"><br>可以看到挂载点 <code>/</code> 的使用率已经是100%了，所以spark-shell会打不开，删掉一些文件即可。</p>\n</li>\n</ul>\n<h2 id=\"一些小细节\"><a href=\"#一些小细节\" class=\"headerlink\" title=\"一些小细节\"></a>一些小细节</h2><hr>\n<ul>\n<li><p>spark中出现一长细条的信息才是报错</p>\n</li>\n<li><p>List 的 <code>distinct</code> 方法会对列表去重</p>\n</li>\n<li><p>item::list 将新生成一个列表，item会成为新列表的有元素</p>\n</li>\n<li><p>Array 不能被<code>flatMap</code>,必须为<code>list.(?)</code></p>\n</li>\n<li><p>scala中的<code>.sortBy()</code>方法如果在括号里最前面加上一个减号表示按逆序排序。</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.27</p>\n</blockquote>\n"},{"layout":"post","title":"区块链初涉","date":"2018-04-15T09:01:00.000Z","_content":"> 不适合人类阅读的学习笔记  \n\n## 简述\n---\n\n- 区块链在当今可以说是非常的火了，但也有人批判区块链被炒得过于浮夸了。这里我们姑且不论，毕竟这只是一门技术，关键在于我们怎么利用它。\n\n- 区块链是一种特殊的 **分布式数据库**，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。\n\n## 区块链的数据安全性问题\n---\n\n- 区块链由一个个区块(block)构成，*区块很像数据库的记录，每次写入数据，就是创建一个区块。*\n\n- 每个区块包含两个部分：区块头(head)——记录当前区块的元信息，区块体(body)——实际信息\n\n- 区块头的元信息包括：生成时间，实际数据（即区块体）的 Hash，上一个区块的 Hash等等。区块链的 Hash 长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的 Hash 一定是不同的。**因此，每个区块的hash值一定是不同的，可以根据hash值区分不同的区块。而如果区块的内容变了，那么他的hash值也一定会变**\n\n- 一个区块的hash是对这个区块的区块头计算的。区块头包含了区块体的hash(注意不是整个区块的hash)和上个区块的hash(这个是整个区块的hash)，只要这个区块的内容或者上个区块的hash(内容)变了，那么一定会引起这个区块内容的改变。**因此，要想修改某个区块，那么就会引起一系列连锁反应，被修改区块后面的所有的区块的内容都必须修改，否则这个被改掉的区块就脱离区块链了，而这是不可能的，因为计算hash值是非常耗费时间和资源的，除非他一个人控制了全网一半以上的计算能力。** 因此，区块一旦被写入便不可能被修改了，就像发生过的历史永远刻在时间上了一样，因此区块链的数据是十分安全可靠的。\n\n## 区块链的分叉\n---\n\n- 在上述区块链的添加过程中，有一个问题，就是：如果有一个节点同时有两个区块加入，他们都连向前一个区块，那么这时候就形成了 **分叉**。\n\n- 现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为\"六次确认\"）。按照10分钟一个区块计算，一小时就可以确认。(区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个)。因此新的区块链的生成规则就是，拥有计算能力更强的那条链，就是正宗的区块链。\n\n\n## 回顾\n---\n\n- 区块链作为无人管理的分布式数据库，从2009年运行至今无明显问题，体现了其设计的合理性。\n\n- 但是，有利必有弊。区块链的安全可靠是建立在效率和能耗的牺牲上的。生成一个区块最少要等待十分钟，而等待所有节点同步就更久了。同时，生成一个新的区块，需要矿工做许多无意义的挖矿，极其地耗费能源。\n\n## 展望\n---\n\n- 区块链虽然有许多争议，但是其在某些领域确实有其独特的作用。其最大的特点就是数据的追踪和溯源。对于管理那些流通的物品，比如虚拟货币，一些农产品，枪支等等，区块链可以十分有效地保证这些领域的物资安全可靠性。\n\n> 最后更新于2018.4.28\n","source":"_posts/2018-04-15-Block-Chain.md","raw":"---\nlayout:     post\ntitle:      \"区块链初涉\"\ndate:       2018-04-15 17:01:00\ncategories: Computer\ntags: ๑BlockChain\n---\n> 不适合人类阅读的学习笔记  \n\n## 简述\n---\n\n- 区块链在当今可以说是非常的火了，但也有人批判区块链被炒得过于浮夸了。这里我们姑且不论，毕竟这只是一门技术，关键在于我们怎么利用它。\n\n- 区块链是一种特殊的 **分布式数据库**，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。\n\n## 区块链的数据安全性问题\n---\n\n- 区块链由一个个区块(block)构成，*区块很像数据库的记录，每次写入数据，就是创建一个区块。*\n\n- 每个区块包含两个部分：区块头(head)——记录当前区块的元信息，区块体(body)——实际信息\n\n- 区块头的元信息包括：生成时间，实际数据（即区块体）的 Hash，上一个区块的 Hash等等。区块链的 Hash 长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的 Hash 一定是不同的。**因此，每个区块的hash值一定是不同的，可以根据hash值区分不同的区块。而如果区块的内容变了，那么他的hash值也一定会变**\n\n- 一个区块的hash是对这个区块的区块头计算的。区块头包含了区块体的hash(注意不是整个区块的hash)和上个区块的hash(这个是整个区块的hash)，只要这个区块的内容或者上个区块的hash(内容)变了，那么一定会引起这个区块内容的改变。**因此，要想修改某个区块，那么就会引起一系列连锁反应，被修改区块后面的所有的区块的内容都必须修改，否则这个被改掉的区块就脱离区块链了，而这是不可能的，因为计算hash值是非常耗费时间和资源的，除非他一个人控制了全网一半以上的计算能力。** 因此，区块一旦被写入便不可能被修改了，就像发生过的历史永远刻在时间上了一样，因此区块链的数据是十分安全可靠的。\n\n## 区块链的分叉\n---\n\n- 在上述区块链的添加过程中，有一个问题，就是：如果有一个节点同时有两个区块加入，他们都连向前一个区块，那么这时候就形成了 **分叉**。\n\n- 现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为\"六次确认\"）。按照10分钟一个区块计算，一小时就可以确认。(区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个)。因此新的区块链的生成规则就是，拥有计算能力更强的那条链，就是正宗的区块链。\n\n\n## 回顾\n---\n\n- 区块链作为无人管理的分布式数据库，从2009年运行至今无明显问题，体现了其设计的合理性。\n\n- 但是，有利必有弊。区块链的安全可靠是建立在效率和能耗的牺牲上的。生成一个区块最少要等待十分钟，而等待所有节点同步就更久了。同时，生成一个新的区块，需要矿工做许多无意义的挖矿，极其地耗费能源。\n\n## 展望\n---\n\n- 区块链虽然有许多争议，但是其在某些领域确实有其独特的作用。其最大的特点就是数据的追踪和溯源。对于管理那些流通的物品，比如虚拟货币，一些农产品，枪支等等，区块链可以十分有效地保证这些领域的物资安全可靠性。\n\n> 最后更新于2018.4.28\n","slug":"2018-04-15-Block-Chain","published":1,"updated":"2018-09-03T08:41:18.601Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4m001a1m0ogmjoywts","content":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><hr>\n<ul>\n<li><p>区块链在当今可以说是非常的火了，但也有人批判区块链被炒得过于浮夸了。这里我们姑且不论，毕竟这只是一门技术，关键在于我们怎么利用它。</p>\n</li>\n<li><p>区块链是一种特殊的 <strong>分布式数据库</strong>，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。</p>\n</li>\n</ul>\n<h2 id=\"区块链的数据安全性问题\"><a href=\"#区块链的数据安全性问题\" class=\"headerlink\" title=\"区块链的数据安全性问题\"></a>区块链的数据安全性问题</h2><hr>\n<ul>\n<li><p>区块链由一个个区块(block)构成，<em>区块很像数据库的记录，每次写入数据，就是创建一个区块。</em></p>\n</li>\n<li><p>每个区块包含两个部分：区块头(head)——记录当前区块的元信息，区块体(body)——实际信息</p>\n</li>\n<li><p>区块头的元信息包括：生成时间，实际数据（即区块体）的 Hash，上一个区块的 Hash等等。区块链的 Hash 长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的 Hash 一定是不同的。<strong>因此，每个区块的hash值一定是不同的，可以根据hash值区分不同的区块。而如果区块的内容变了，那么他的hash值也一定会变</strong></p>\n</li>\n<li><p>一个区块的hash是对这个区块的区块头计算的。区块头包含了区块体的hash(注意不是整个区块的hash)和上个区块的hash(这个是整个区块的hash)，只要这个区块的内容或者上个区块的hash(内容)变了，那么一定会引起这个区块内容的改变。<strong>因此，要想修改某个区块，那么就会引起一系列连锁反应，被修改区块后面的所有的区块的内容都必须修改，否则这个被改掉的区块就脱离区块链了，而这是不可能的，因为计算hash值是非常耗费时间和资源的，除非他一个人控制了全网一半以上的计算能力。</strong> 因此，区块一旦被写入便不可能被修改了，就像发生过的历史永远刻在时间上了一样，因此区块链的数据是十分安全可靠的。</p>\n</li>\n</ul>\n<h2 id=\"区块链的分叉\"><a href=\"#区块链的分叉\" class=\"headerlink\" title=\"区块链的分叉\"></a>区块链的分叉</h2><hr>\n<ul>\n<li><p>在上述区块链的添加过程中，有一个问题，就是：如果有一个节点同时有两个区块加入，他们都连向前一个区块，那么这时候就形成了 <strong>分叉</strong>。</p>\n</li>\n<li><p>现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为”六次确认”）。按照10分钟一个区块计算，一小时就可以确认。(区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个)。因此新的区块链的生成规则就是，拥有计算能力更强的那条链，就是正宗的区块链。</p>\n</li>\n</ul>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><hr>\n<ul>\n<li><p>区块链作为无人管理的分布式数据库，从2009年运行至今无明显问题，体现了其设计的合理性。</p>\n</li>\n<li><p>但是，有利必有弊。区块链的安全可靠是建立在效率和能耗的牺牲上的。生成一个区块最少要等待十分钟，而等待所有节点同步就更久了。同时，生成一个新的区块，需要矿工做许多无意义的挖矿，极其地耗费能源。</p>\n</li>\n</ul>\n<h2 id=\"展望\"><a href=\"#展望\" class=\"headerlink\" title=\"展望\"></a>展望</h2><hr>\n<ul>\n<li>区块链虽然有许多争议，但是其在某些领域确实有其独特的作用。其最大的特点就是数据的追踪和溯源。对于管理那些流通的物品，比如虚拟货币，一些农产品，枪支等等，区块链可以十分有效地保证这些领域的物资安全可靠性。</li>\n</ul>\n<blockquote>\n<p>最后更新于2018.4.28</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><hr>\n<ul>\n<li><p>区块链在当今可以说是非常的火了，但也有人批判区块链被炒得过于浮夸了。这里我们姑且不论，毕竟这只是一门技术，关键在于我们怎么利用它。</p>\n</li>\n<li><p>区块链是一种特殊的 <strong>分布式数据库</strong>，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。</p>\n</li>\n</ul>\n<h2 id=\"区块链的数据安全性问题\"><a href=\"#区块链的数据安全性问题\" class=\"headerlink\" title=\"区块链的数据安全性问题\"></a>区块链的数据安全性问题</h2><hr>\n<ul>\n<li><p>区块链由一个个区块(block)构成，<em>区块很像数据库的记录，每次写入数据，就是创建一个区块。</em></p>\n</li>\n<li><p>每个区块包含两个部分：区块头(head)——记录当前区块的元信息，区块体(body)——实际信息</p>\n</li>\n<li><p>区块头的元信息包括：生成时间，实际数据（即区块体）的 Hash，上一个区块的 Hash等等。区块链的 Hash 长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的 Hash 一定是不同的。<strong>因此，每个区块的hash值一定是不同的，可以根据hash值区分不同的区块。而如果区块的内容变了，那么他的hash值也一定会变</strong></p>\n</li>\n<li><p>一个区块的hash是对这个区块的区块头计算的。区块头包含了区块体的hash(注意不是整个区块的hash)和上个区块的hash(这个是整个区块的hash)，只要这个区块的内容或者上个区块的hash(内容)变了，那么一定会引起这个区块内容的改变。<strong>因此，要想修改某个区块，那么就会引起一系列连锁反应，被修改区块后面的所有的区块的内容都必须修改，否则这个被改掉的区块就脱离区块链了，而这是不可能的，因为计算hash值是非常耗费时间和资源的，除非他一个人控制了全网一半以上的计算能力。</strong> 因此，区块一旦被写入便不可能被修改了，就像发生过的历史永远刻在时间上了一样，因此区块链的数据是十分安全可靠的。</p>\n</li>\n</ul>\n<h2 id=\"区块链的分叉\"><a href=\"#区块链的分叉\" class=\"headerlink\" title=\"区块链的分叉\"></a>区块链的分叉</h2><hr>\n<ul>\n<li><p>在上述区块链的添加过程中，有一个问题，就是：如果有一个节点同时有两个区块加入，他们都连向前一个区块，那么这时候就形成了 <strong>分叉</strong>。</p>\n</li>\n<li><p>现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为”六次确认”）。按照10分钟一个区块计算，一小时就可以确认。(区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个)。因此新的区块链的生成规则就是，拥有计算能力更强的那条链，就是正宗的区块链。</p>\n</li>\n</ul>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><hr>\n<ul>\n<li><p>区块链作为无人管理的分布式数据库，从2009年运行至今无明显问题，体现了其设计的合理性。</p>\n</li>\n<li><p>但是，有利必有弊。区块链的安全可靠是建立在效率和能耗的牺牲上的。生成一个区块最少要等待十分钟，而等待所有节点同步就更久了。同时，生成一个新的区块，需要矿工做许多无意义的挖矿，极其地耗费能源。</p>\n</li>\n</ul>\n<h2 id=\"展望\"><a href=\"#展望\" class=\"headerlink\" title=\"展望\"></a>展望</h2><hr>\n<ul>\n<li>区块链虽然有许多争议，但是其在某些领域确实有其独特的作用。其最大的特点就是数据的追踪和溯源。对于管理那些流通的物品，比如虚拟货币，一些农产品，枪支等等，区块链可以十分有效地保证这些领域的物资安全可靠性。</li>\n</ul>\n<blockquote>\n<p>最后更新于2018.4.28</p>\n</blockquote>\n"},{"layout":"post","title":"一些文件类型记录","date":"2018-04-15T08:47:00.000Z","_content":"> 不适合人类阅读的学习笔记  \n\n## 一些特殊的符号收集\n---\n\n- [符号收集](https://blog.csdn.net/rhinemetal/article/details/6887172)\n\n- [符号大全](http://www.fuhao123.com/fuhao/1.shtml)\n\n## CSV文件（逗号分隔值文件格式）(XX.csv)\n---\n\n- .csv文件实际上就是一种文本文件，其**以纯文本形式存储表格数据**，一般以逗号或者制表符作为分隔符\n\n### 规则\n- 开头是不留空，以行为单位。（每行末尾只有换行符，没有别的分隔符）\n\n- 可含或不含列名，含列名则居文件第一行。\n\n- 一行数据不跨行，无空行。\n\n- 以半角逗号（即,）作分隔符，列为空也要表达其存在。\n\n- **不支持数字，不支持特殊字符**\n\n> 实际上csv文件就类似于一个没有线的表格\n\n## Markdown文件(XX.markdown / XX.md)\n---\n- Markdown 的目标是实现「易读易写」。可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法的目标是：成为一种适用于网络的书写语言。Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围\n\n- markdown可以直接在Atom中编辑和预览(ctrl + shift + m)\n\n- markdown可以转换为pdf文件。你可以选择下载一些markdown编辑器来完成这个转化，但是，我在这里要推荐一个大佬的web应用(完美支持UTF-8中文编码，不会像其他的一些外国的网站转化时中文全部变成乱码的问题)，知乎上看到的。[在线markdown转化为PDF](http://www.mdtr2pdf.com/index_en.html)\n\n\n## Appimage文件(XX.AppImage)\n---\n\n- AppImage是一种在Linux系统中用于分发便携式软件而不需要超级用户权限来安装它们的格式。[1] 它还试图让允许Linux的上游开发者来分发他们的程序而不用考虑不同Linux发行版间的区别。\n\n### 特性\n- AppImage不把Linux应用程序安装在文件系统相应的目录中。相反,它没有进行实际的安装。AppImage文件只是个压缩文件，在它运行时候挂载。\n\n- 用AppImage打包的程序，一个程序就是一个文件。每一个文件都包含了该程序在其所要运行的目标平台上所需的运行库。AppImage文件是基于ISO 9660并经过zisofs压缩的包含有一个最小化的AppDir目录和一个极小的运行环境的文件。只要把这个文件添加到live CD中，这个程序便可被轻而易举地添加进live CD中。\n\n- 用AppImage文件比安装一个应用程序更加简单。它不需要解压也不需要为系统环境做调整。使用主流Linux发行版的用户可以下载它，使其可执行，并且运行即可。\n\n### 运行方法\n\n- 添加可执行权限 `chmod a+x *.AppImage`\n\n- 执行 `./*.AppImage`\n\n- 或者 `右键 > 属性(properties) > 权限(Permissions) > 勾选Allow executing file as program`\n\n- 之后直接运行即可\n\n<br>\n> 最后更新于2018.5.23\n","source":"_posts/2018-04-15-File-types.md","raw":"---\nlayout:     post\ntitle:      \"一些文件类型记录\"\ndate:       2018-04-15 16:47:00\ncategories: Computer\ntags: ๑FileTypes\n---\n> 不适合人类阅读的学习笔记  \n\n## 一些特殊的符号收集\n---\n\n- [符号收集](https://blog.csdn.net/rhinemetal/article/details/6887172)\n\n- [符号大全](http://www.fuhao123.com/fuhao/1.shtml)\n\n## CSV文件（逗号分隔值文件格式）(XX.csv)\n---\n\n- .csv文件实际上就是一种文本文件，其**以纯文本形式存储表格数据**，一般以逗号或者制表符作为分隔符\n\n### 规则\n- 开头是不留空，以行为单位。（每行末尾只有换行符，没有别的分隔符）\n\n- 可含或不含列名，含列名则居文件第一行。\n\n- 一行数据不跨行，无空行。\n\n- 以半角逗号（即,）作分隔符，列为空也要表达其存在。\n\n- **不支持数字，不支持特殊字符**\n\n> 实际上csv文件就类似于一个没有线的表格\n\n## Markdown文件(XX.markdown / XX.md)\n---\n- Markdown 的目标是实现「易读易写」。可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法的目标是：成为一种适用于网络的书写语言。Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围\n\n- markdown可以直接在Atom中编辑和预览(ctrl + shift + m)\n\n- markdown可以转换为pdf文件。你可以选择下载一些markdown编辑器来完成这个转化，但是，我在这里要推荐一个大佬的web应用(完美支持UTF-8中文编码，不会像其他的一些外国的网站转化时中文全部变成乱码的问题)，知乎上看到的。[在线markdown转化为PDF](http://www.mdtr2pdf.com/index_en.html)\n\n\n## Appimage文件(XX.AppImage)\n---\n\n- AppImage是一种在Linux系统中用于分发便携式软件而不需要超级用户权限来安装它们的格式。[1] 它还试图让允许Linux的上游开发者来分发他们的程序而不用考虑不同Linux发行版间的区别。\n\n### 特性\n- AppImage不把Linux应用程序安装在文件系统相应的目录中。相反,它没有进行实际的安装。AppImage文件只是个压缩文件，在它运行时候挂载。\n\n- 用AppImage打包的程序，一个程序就是一个文件。每一个文件都包含了该程序在其所要运行的目标平台上所需的运行库。AppImage文件是基于ISO 9660并经过zisofs压缩的包含有一个最小化的AppDir目录和一个极小的运行环境的文件。只要把这个文件添加到live CD中，这个程序便可被轻而易举地添加进live CD中。\n\n- 用AppImage文件比安装一个应用程序更加简单。它不需要解压也不需要为系统环境做调整。使用主流Linux发行版的用户可以下载它，使其可执行，并且运行即可。\n\n### 运行方法\n\n- 添加可执行权限 `chmod a+x *.AppImage`\n\n- 执行 `./*.AppImage`\n\n- 或者 `右键 > 属性(properties) > 权限(Permissions) > 勾选Allow executing file as program`\n\n- 之后直接运行即可\n\n<br>\n> 最后更新于2018.5.23\n","slug":"2018-04-15-File-types","published":1,"updated":"2018-09-03T13:17:45.430Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4n001d1m0o8aftp9aj","content":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"一些特殊的符号收集\"><a href=\"#一些特殊的符号收集\" class=\"headerlink\" title=\"一些特殊的符号收集\"></a>一些特殊的符号收集</h2><hr>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/rhinemetal/article/details/6887172\" target=\"_blank\" rel=\"noopener\">符号收集</a></p>\n</li>\n<li><p><a href=\"http://www.fuhao123.com/fuhao/1.shtml\" target=\"_blank\" rel=\"noopener\">符号大全</a></p>\n</li>\n</ul>\n<h2 id=\"CSV文件（逗号分隔值文件格式）-XX-csv\"><a href=\"#CSV文件（逗号分隔值文件格式）-XX-csv\" class=\"headerlink\" title=\"CSV文件（逗号分隔值文件格式）(XX.csv)\"></a>CSV文件（逗号分隔值文件格式）(XX.csv)</h2><hr>\n<ul>\n<li>.csv文件实际上就是一种文本文件，其<strong>以纯文本形式存储表格数据</strong>，一般以逗号或者制表符作为分隔符</li>\n</ul>\n<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><ul>\n<li><p>开头是不留空，以行为单位。（每行末尾只有换行符，没有别的分隔符）</p>\n</li>\n<li><p>可含或不含列名，含列名则居文件第一行。</p>\n</li>\n<li><p>一行数据不跨行，无空行。</p>\n</li>\n<li><p>以半角逗号（即,）作分隔符，列为空也要表达其存在。</p>\n</li>\n<li><p><strong>不支持数字，不支持特殊字符</strong></p>\n</li>\n</ul>\n<blockquote>\n<p>实际上csv文件就类似于一个没有线的表格</p>\n</blockquote>\n<h2 id=\"Markdown文件-XX-markdown-XX-md\"><a href=\"#Markdown文件-XX-markdown-XX-md\" class=\"headerlink\" title=\"Markdown文件(XX.markdown / XX.md)\"></a>Markdown文件(XX.markdown / XX.md)</h2><hr>\n<ul>\n<li><p>Markdown 的目标是实现「易读易写」。可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法的目标是：成为一种适用于网络的书写语言。Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围</p>\n</li>\n<li><p>markdown可以直接在Atom中编辑和预览(ctrl + shift + m)</p>\n</li>\n<li><p>markdown可以转换为pdf文件。你可以选择下载一些markdown编辑器来完成这个转化，但是，我在这里要推荐一个大佬的web应用(完美支持UTF-8中文编码，不会像其他的一些外国的网站转化时中文全部变成乱码的问题)，知乎上看到的。<a href=\"http://www.mdtr2pdf.com/index_en.html\" target=\"_blank\" rel=\"noopener\">在线markdown转化为PDF</a></p>\n</li>\n</ul>\n<h2 id=\"Appimage文件-XX-AppImage\"><a href=\"#Appimage文件-XX-AppImage\" class=\"headerlink\" title=\"Appimage文件(XX.AppImage)\"></a>Appimage文件(XX.AppImage)</h2><hr>\n<ul>\n<li>AppImage是一种在Linux系统中用于分发便携式软件而不需要超级用户权限来安装它们的格式。[1] 它还试图让允许Linux的上游开发者来分发他们的程序而不用考虑不同Linux发行版间的区别。</li>\n</ul>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ul>\n<li><p>AppImage不把Linux应用程序安装在文件系统相应的目录中。相反,它没有进行实际的安装。AppImage文件只是个压缩文件，在它运行时候挂载。</p>\n</li>\n<li><p>用AppImage打包的程序，一个程序就是一个文件。每一个文件都包含了该程序在其所要运行的目标平台上所需的运行库。AppImage文件是基于ISO 9660并经过zisofs压缩的包含有一个最小化的AppDir目录和一个极小的运行环境的文件。只要把这个文件添加到live CD中，这个程序便可被轻而易举地添加进live CD中。</p>\n</li>\n<li><p>用AppImage文件比安装一个应用程序更加简单。它不需要解压也不需要为系统环境做调整。使用主流Linux发行版的用户可以下载它，使其可执行，并且运行即可。</p>\n</li>\n</ul>\n<h3 id=\"运行方法\"><a href=\"#运行方法\" class=\"headerlink\" title=\"运行方法\"></a>运行方法</h3><ul>\n<li><p>添加可执行权限 <code>chmod a+x *.AppImage</code></p>\n</li>\n<li><p>执行 <code>./*.AppImage</code></p>\n</li>\n<li><p>或者 <code>右键 &gt; 属性(properties) &gt; 权限(Permissions) &gt; 勾选Allow executing file as program</code></p>\n</li>\n<li><p>之后直接运行即可</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.23</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"一些特殊的符号收集\"><a href=\"#一些特殊的符号收集\" class=\"headerlink\" title=\"一些特殊的符号收集\"></a>一些特殊的符号收集</h2><hr>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/rhinemetal/article/details/6887172\" target=\"_blank\" rel=\"noopener\">符号收集</a></p>\n</li>\n<li><p><a href=\"http://www.fuhao123.com/fuhao/1.shtml\" target=\"_blank\" rel=\"noopener\">符号大全</a></p>\n</li>\n</ul>\n<h2 id=\"CSV文件（逗号分隔值文件格式）-XX-csv\"><a href=\"#CSV文件（逗号分隔值文件格式）-XX-csv\" class=\"headerlink\" title=\"CSV文件（逗号分隔值文件格式）(XX.csv)\"></a>CSV文件（逗号分隔值文件格式）(XX.csv)</h2><hr>\n<ul>\n<li>.csv文件实际上就是一种文本文件，其<strong>以纯文本形式存储表格数据</strong>，一般以逗号或者制表符作为分隔符</li>\n</ul>\n<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><ul>\n<li><p>开头是不留空，以行为单位。（每行末尾只有换行符，没有别的分隔符）</p>\n</li>\n<li><p>可含或不含列名，含列名则居文件第一行。</p>\n</li>\n<li><p>一行数据不跨行，无空行。</p>\n</li>\n<li><p>以半角逗号（即,）作分隔符，列为空也要表达其存在。</p>\n</li>\n<li><p><strong>不支持数字，不支持特殊字符</strong></p>\n</li>\n</ul>\n<blockquote>\n<p>实际上csv文件就类似于一个没有线的表格</p>\n</blockquote>\n<h2 id=\"Markdown文件-XX-markdown-XX-md\"><a href=\"#Markdown文件-XX-markdown-XX-md\" class=\"headerlink\" title=\"Markdown文件(XX.markdown / XX.md)\"></a>Markdown文件(XX.markdown / XX.md)</h2><hr>\n<ul>\n<li><p>Markdown 的目标是实现「易读易写」。可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法的目标是：成为一种适用于网络的书写语言。Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围</p>\n</li>\n<li><p>markdown可以直接在Atom中编辑和预览(ctrl + shift + m)</p>\n</li>\n<li><p>markdown可以转换为pdf文件。你可以选择下载一些markdown编辑器来完成这个转化，但是，我在这里要推荐一个大佬的web应用(完美支持UTF-8中文编码，不会像其他的一些外国的网站转化时中文全部变成乱码的问题)，知乎上看到的。<a href=\"http://www.mdtr2pdf.com/index_en.html\" target=\"_blank\" rel=\"noopener\">在线markdown转化为PDF</a></p>\n</li>\n</ul>\n<h2 id=\"Appimage文件-XX-AppImage\"><a href=\"#Appimage文件-XX-AppImage\" class=\"headerlink\" title=\"Appimage文件(XX.AppImage)\"></a>Appimage文件(XX.AppImage)</h2><hr>\n<ul>\n<li>AppImage是一种在Linux系统中用于分发便携式软件而不需要超级用户权限来安装它们的格式。[1] 它还试图让允许Linux的上游开发者来分发他们的程序而不用考虑不同Linux发行版间的区别。</li>\n</ul>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><ul>\n<li><p>AppImage不把Linux应用程序安装在文件系统相应的目录中。相反,它没有进行实际的安装。AppImage文件只是个压缩文件，在它运行时候挂载。</p>\n</li>\n<li><p>用AppImage打包的程序，一个程序就是一个文件。每一个文件都包含了该程序在其所要运行的目标平台上所需的运行库。AppImage文件是基于ISO 9660并经过zisofs压缩的包含有一个最小化的AppDir目录和一个极小的运行环境的文件。只要把这个文件添加到live CD中，这个程序便可被轻而易举地添加进live CD中。</p>\n</li>\n<li><p>用AppImage文件比安装一个应用程序更加简单。它不需要解压也不需要为系统环境做调整。使用主流Linux发行版的用户可以下载它，使其可执行，并且运行即可。</p>\n</li>\n</ul>\n<h3 id=\"运行方法\"><a href=\"#运行方法\" class=\"headerlink\" title=\"运行方法\"></a>运行方法</h3><ul>\n<li><p>添加可执行权限 <code>chmod a+x *.AppImage</code></p>\n</li>\n<li><p>执行 <code>./*.AppImage</code></p>\n</li>\n<li><p>或者 <code>右键 &gt; 属性(properties) &gt; 权限(Permissions) &gt; 勾选Allow executing file as program</code></p>\n</li>\n<li><p>之后直接运行即可</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.23</p>\n</blockquote>\n"},{"layout":"post","title":"Shadowsocks","date":"2018-05-28T07:34:00.000Z","_content":"> 科学上网从我做起  \n\n## 重大更新\n---\n\n- 现在大多数的ssr或者ss图形界面的在ubuntu18上已经歇菜了,但是这里分享一个命令行下的ss和一个图形界面的ssr(推荐)。\n\n### 命令行方式的ss\n---\n\n- ```\nsudo apt-get install python-pip\nsudo pip install shadowsocks\n```\n\n- 通过配置文件指定配置信息\n```\nmkdir ~/.shadowsocks\ncd .shadowsocks\ntouch ss.json\n//添加内容如下\n{\n    \"server\":\"1.1.1.1\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"your passwd\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\"\n}\n```\n- server填你的服务器ip，sever_port填远程端口号，local_address本地ip，local_part本地端口，password填密码，timeout是延迟时间，method是加密方式，按照实际情况填写并保存\n\n- 终端运行：`sslocal -c ~/.shadowsocks/ss.json`\n\n- 后台运行(不推荐)：`sslocal -c ~/.shadowsocks/ss.json -d start`\n\n- 现在运行的话会有报错，修改方法：\n```\nvim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py\n//跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup\n//\n将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)\n改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)\n//\n再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)\n改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)\n//然后就可以正常运行了\n```\n\n- 详细见[博客](https://blog.csdn.net/blackfrog_unique/article/details/60320737)\n\n### 图形界面的ssr\n---\n\n- 首先说一句，图形界面不仅美观好用，而且可以支持在线订阅，及时更新，总之，**我们又可以优雅地翻墙了**，美滋滋～\n\n- 这里我fork了一份相关github的代码，[链接](https://github.com/erguotou520/electron-ssr/releases)\n\n- 配置方法非常简单，可以导入json文件，或者从剪贴板导入等等。\n\n> [参考文档](https://blog.csdn.net/u010658816/article/details/79344970)\n\n## 重点\n---\n\n- 上面两种方式而选一即可，但是下面还有最关键的一步，配置浏览器代理。\n\n- 首先，想要实现全局模式请按如下方法设置：\n系统设置 >> 网络 >> 网络代理 >> 方法 >> 手动\n\n- 再将Socks主机的ip和端口填好，如图。\n![](/images/ssr/systemset.png)\n\n- 然后，需要在google商店下载SwitchyOmega插件，但是需要翻墙～这里可以进入如下[网址](http://googlehelper.net/),先下载一个googlehelper插件(打开chrome所有插件，把下载的插件直接拉进去即可添加完成)，用邮箱注册一个免费的体验账号，先翻了墙再说。\n\n- 然后去chrome网上应用商店下载SwitchyOmega，接下来便可以配置了。\n\n- 在SwitchyOmega的配置页面  \n先新建一个情景模式，选择代理服务器，名称为gfwlist(这个随意)  \n  配置时,代理服务器和代理端口分别是ssr config中的   \n    \"local_address\":\"127.0.0.1\"  \n    \"local_port\":1080  \n确认后无误后应用选项  \n![](/images/ssr/gfwlist.png)\n\n- 接下来点击情景模式中的自动切换，输入参数如下：\n```\n条件设置：raw.githubusercontent.com  \n规则列表网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt  \n点击立即更新情景模式  \n结束,在SwitchyOmega插件(chorme浏览器右上角处)那换成自动切换,大功告成.\n```\n![](/images/ssr/auto_switch_01.png)\n\n![](/images/ssr/auto_switch_02.png)\n\n![](/images/ssr/example.png)\n\n- 最后把多余的情景模式删除,看起来清爽一点。\n\n- 这样就相当于在chorme中启用的是pcd模式,在能穿墙的同时,既保证了访问国内网站速度不慢,又节省了ssr的流量。\n\n- 接下来就可以优雅地体验翻墙上网了～\n\n<br>\n> 最后更新于2018.5.28\n","source":"_posts/2018-04-19-Shaow-socks.md","raw":"---\nlayout:     post\ntitle:      \"Shadowsocks\"\ndate:       2018-05-28 15:34:00\ncategories: ScientificSurfing\ntags:   [๑ScientificSurfing, ๑Ubuntu, ๑Linux]\n---\n> 科学上网从我做起  \n\n## 重大更新\n---\n\n- 现在大多数的ssr或者ss图形界面的在ubuntu18上已经歇菜了,但是这里分享一个命令行下的ss和一个图形界面的ssr(推荐)。\n\n### 命令行方式的ss\n---\n\n- ```\nsudo apt-get install python-pip\nsudo pip install shadowsocks\n```\n\n- 通过配置文件指定配置信息\n```\nmkdir ~/.shadowsocks\ncd .shadowsocks\ntouch ss.json\n//添加内容如下\n{\n    \"server\":\"1.1.1.1\",\n    \"server_port\":8388,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"your passwd\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\"\n}\n```\n- server填你的服务器ip，sever_port填远程端口号，local_address本地ip，local_part本地端口，password填密码，timeout是延迟时间，method是加密方式，按照实际情况填写并保存\n\n- 终端运行：`sslocal -c ~/.shadowsocks/ss.json`\n\n- 后台运行(不推荐)：`sslocal -c ~/.shadowsocks/ss.json -d start`\n\n- 现在运行的话会有报错，修改方法：\n```\nvim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py\n//跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup\n//\n将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)\n改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)\n//\n再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)\n改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)\n//然后就可以正常运行了\n```\n\n- 详细见[博客](https://blog.csdn.net/blackfrog_unique/article/details/60320737)\n\n### 图形界面的ssr\n---\n\n- 首先说一句，图形界面不仅美观好用，而且可以支持在线订阅，及时更新，总之，**我们又可以优雅地翻墙了**，美滋滋～\n\n- 这里我fork了一份相关github的代码，[链接](https://github.com/erguotou520/electron-ssr/releases)\n\n- 配置方法非常简单，可以导入json文件，或者从剪贴板导入等等。\n\n> [参考文档](https://blog.csdn.net/u010658816/article/details/79344970)\n\n## 重点\n---\n\n- 上面两种方式而选一即可，但是下面还有最关键的一步，配置浏览器代理。\n\n- 首先，想要实现全局模式请按如下方法设置：\n系统设置 >> 网络 >> 网络代理 >> 方法 >> 手动\n\n- 再将Socks主机的ip和端口填好，如图。\n![](/images/ssr/systemset.png)\n\n- 然后，需要在google商店下载SwitchyOmega插件，但是需要翻墙～这里可以进入如下[网址](http://googlehelper.net/),先下载一个googlehelper插件(打开chrome所有插件，把下载的插件直接拉进去即可添加完成)，用邮箱注册一个免费的体验账号，先翻了墙再说。\n\n- 然后去chrome网上应用商店下载SwitchyOmega，接下来便可以配置了。\n\n- 在SwitchyOmega的配置页面  \n先新建一个情景模式，选择代理服务器，名称为gfwlist(这个随意)  \n  配置时,代理服务器和代理端口分别是ssr config中的   \n    \"local_address\":\"127.0.0.1\"  \n    \"local_port\":1080  \n确认后无误后应用选项  \n![](/images/ssr/gfwlist.png)\n\n- 接下来点击情景模式中的自动切换，输入参数如下：\n```\n条件设置：raw.githubusercontent.com  \n规则列表网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt  \n点击立即更新情景模式  \n结束,在SwitchyOmega插件(chorme浏览器右上角处)那换成自动切换,大功告成.\n```\n![](/images/ssr/auto_switch_01.png)\n\n![](/images/ssr/auto_switch_02.png)\n\n![](/images/ssr/example.png)\n\n- 最后把多余的情景模式删除,看起来清爽一点。\n\n- 这样就相当于在chorme中启用的是pcd模式,在能穿墙的同时,既保证了访问国内网站速度不慢,又节省了ssr的流量。\n\n- 接下来就可以优雅地体验翻墙上网了～\n\n<br>\n> 最后更新于2018.5.28\n","slug":"2018-04-19-Shaow-socks","published":1,"updated":"2018-09-03T13:17:33.983Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4o001g1m0ot7nopieo","content":"<blockquote>\n<p>科学上网从我做起  </p>\n</blockquote>\n<h2 id=\"重大更新\"><a href=\"#重大更新\" class=\"headerlink\" title=\"重大更新\"></a>重大更新</h2><hr>\n<ul>\n<li>现在大多数的ssr或者ss图形界面的在ubuntu18上已经歇菜了,但是这里分享一个命令行下的ss和一个图形界面的ssr(推荐)。</li>\n</ul>\n<h3 id=\"命令行方式的ss\"><a href=\"#命令行方式的ss\" class=\"headerlink\" title=\"命令行方式的ss\"></a>命令行方式的ss</h3><hr>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install python-pip</span><br><span class=\"line\">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过配置文件指定配置信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir ~/.shadowsocks</span><br><span class=\"line\">cd .shadowsocks</span><br><span class=\"line\">touch ss.json</span><br><span class=\"line\">//添加内容如下</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:&quot;1.1.1.1&quot;,</span><br><span class=\"line\">    &quot;server_port&quot;:8388,</span><br><span class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">    &quot;local_port&quot;:1080,</span><br><span class=\"line\">    &quot;password&quot;:&quot;your passwd&quot;,</span><br><span class=\"line\">    &quot;timeout&quot;:300,</span><br><span class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>server填你的服务器ip，sever_port填远程端口号，local_address本地ip，local_part本地端口，password填密码，timeout是延迟时间，method是加密方式，按照实际情况填写并保存</p>\n</li>\n<li><p>终端运行：<code>sslocal -c ~/.shadowsocks/ss.json</code></p>\n</li>\n<li><p>后台运行(不推荐)：<code>sslocal -c ~/.shadowsocks/ss.json -d start</code></p>\n</li>\n<li><p>现在运行的话会有报错，修改方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py</span><br><span class=\"line\">//跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup</span><br><span class=\"line\">//</span><br><span class=\"line\">将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)</span><br><span class=\"line\">改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)</span><br><span class=\"line\">//</span><br><span class=\"line\">再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)</span><br><span class=\"line\">改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)</span><br><span class=\"line\">//然后就可以正常运行了</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>详细见<a href=\"https://blog.csdn.net/blackfrog_unique/article/details/60320737\" target=\"_blank\" rel=\"noopener\">博客</a></p>\n</li>\n</ul>\n<h3 id=\"图形界面的ssr\"><a href=\"#图形界面的ssr\" class=\"headerlink\" title=\"图形界面的ssr\"></a>图形界面的ssr</h3><hr>\n<ul>\n<li><p>首先说一句，图形界面不仅美观好用，而且可以支持在线订阅，及时更新，总之，<strong>我们又可以优雅地翻墙了</strong>，美滋滋～</p>\n</li>\n<li><p>这里我fork了一份相关github的代码，<a href=\"https://github.com/erguotou520/electron-ssr/releases\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n</li>\n<li><p>配置方法非常简单，可以导入json文件，或者从剪贴板导入等等。</p>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/u010658816/article/details/79344970\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n</blockquote>\n<h2 id=\"重点\"><a href=\"#重点\" class=\"headerlink\" title=\"重点\"></a>重点</h2><hr>\n<ul>\n<li><p>上面两种方式而选一即可，但是下面还有最关键的一步，配置浏览器代理。</p>\n</li>\n<li><p>首先，想要实现全局模式请按如下方法设置：<br>系统设置 &gt;&gt; 网络 &gt;&gt; 网络代理 &gt;&gt; 方法 &gt;&gt; 手动</p>\n</li>\n<li><p>再将Socks主机的ip和端口填好，如图。<br><img src=\"/images/ssr/systemset.png\" alt=\"\"></p>\n</li>\n<li><p>然后，需要在google商店下载SwitchyOmega插件，但是需要翻墙～这里可以进入如下<a href=\"http://googlehelper.net/\" target=\"_blank\" rel=\"noopener\">网址</a>,先下载一个googlehelper插件(打开chrome所有插件，把下载的插件直接拉进去即可添加完成)，用邮箱注册一个免费的体验账号，先翻了墙再说。</p>\n</li>\n<li><p>然后去chrome网上应用商店下载SwitchyOmega，接下来便可以配置了。</p>\n</li>\n<li><p>在SwitchyOmega的配置页面<br>先新建一个情景模式，选择代理服务器，名称为gfwlist(这个随意)<br>配置时,代理服务器和代理端口分别是ssr config中的<br>  “local_address”:”127.0.0.1”<br>  “local_port”:1080<br>确认后无误后应用选项<br><img src=\"/images/ssr/gfwlist.png\" alt=\"\"></p>\n</li>\n<li><p>接下来点击情景模式中的自动切换，输入参数如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">条件设置：raw.githubusercontent.com  </span><br><span class=\"line\">规则列表网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt  </span><br><span class=\"line\">点击立即更新情景模式  </span><br><span class=\"line\">结束,在SwitchyOmega插件(chorme浏览器右上角处)那换成自动切换,大功告成.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"/images/ssr/auto_switch_01.png\" alt=\"\"></p>\n<p><img src=\"/images/ssr/auto_switch_02.png\" alt=\"\"></p>\n<p><img src=\"/images/ssr/example.png\" alt=\"\"></p>\n<ul>\n<li><p>最后把多余的情景模式删除,看起来清爽一点。</p>\n</li>\n<li><p>这样就相当于在chorme中启用的是pcd模式,在能穿墙的同时,既保证了访问国内网站速度不慢,又节省了ssr的流量。</p>\n</li>\n<li><p>接下来就可以优雅地体验翻墙上网了～</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.28</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>科学上网从我做起  </p>\n</blockquote>\n<h2 id=\"重大更新\"><a href=\"#重大更新\" class=\"headerlink\" title=\"重大更新\"></a>重大更新</h2><hr>\n<ul>\n<li>现在大多数的ssr或者ss图形界面的在ubuntu18上已经歇菜了,但是这里分享一个命令行下的ss和一个图形界面的ssr(推荐)。</li>\n</ul>\n<h3 id=\"命令行方式的ss\"><a href=\"#命令行方式的ss\" class=\"headerlink\" title=\"命令行方式的ss\"></a>命令行方式的ss</h3><hr>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install python-pip</span><br><span class=\"line\">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过配置文件指定配置信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir ~/.shadowsocks</span><br><span class=\"line\">cd .shadowsocks</span><br><span class=\"line\">touch ss.json</span><br><span class=\"line\">//添加内容如下</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:&quot;1.1.1.1&quot;,</span><br><span class=\"line\">    &quot;server_port&quot;:8388,</span><br><span class=\"line\">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">    &quot;local_port&quot;:1080,</span><br><span class=\"line\">    &quot;password&quot;:&quot;your passwd&quot;,</span><br><span class=\"line\">    &quot;timeout&quot;:300,</span><br><span class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>server填你的服务器ip，sever_port填远程端口号，local_address本地ip，local_part本地端口，password填密码，timeout是延迟时间，method是加密方式，按照实际情况填写并保存</p>\n</li>\n<li><p>终端运行：<code>sslocal -c ~/.shadowsocks/ss.json</code></p>\n</li>\n<li><p>后台运行(不推荐)：<code>sslocal -c ~/.shadowsocks/ss.json -d start</code></p>\n</li>\n<li><p>现在运行的话会有报错，修改方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py</span><br><span class=\"line\">//跳转到52行（shadowsocks2.8.2版本，其他版本搜索一下cleanup</span><br><span class=\"line\">//</span><br><span class=\"line\">将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)</span><br><span class=\"line\">改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)</span><br><span class=\"line\">//</span><br><span class=\"line\">再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)</span><br><span class=\"line\">改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)</span><br><span class=\"line\">//然后就可以正常运行了</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>详细见<a href=\"https://blog.csdn.net/blackfrog_unique/article/details/60320737\" target=\"_blank\" rel=\"noopener\">博客</a></p>\n</li>\n</ul>\n<h3 id=\"图形界面的ssr\"><a href=\"#图形界面的ssr\" class=\"headerlink\" title=\"图形界面的ssr\"></a>图形界面的ssr</h3><hr>\n<ul>\n<li><p>首先说一句，图形界面不仅美观好用，而且可以支持在线订阅，及时更新，总之，<strong>我们又可以优雅地翻墙了</strong>，美滋滋～</p>\n</li>\n<li><p>这里我fork了一份相关github的代码，<a href=\"https://github.com/erguotou520/electron-ssr/releases\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n</li>\n<li><p>配置方法非常简单，可以导入json文件，或者从剪贴板导入等等。</p>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/u010658816/article/details/79344970\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n</blockquote>\n<h2 id=\"重点\"><a href=\"#重点\" class=\"headerlink\" title=\"重点\"></a>重点</h2><hr>\n<ul>\n<li><p>上面两种方式而选一即可，但是下面还有最关键的一步，配置浏览器代理。</p>\n</li>\n<li><p>首先，想要实现全局模式请按如下方法设置：<br>系统设置 &gt;&gt; 网络 &gt;&gt; 网络代理 &gt;&gt; 方法 &gt;&gt; 手动</p>\n</li>\n<li><p>再将Socks主机的ip和端口填好，如图。<br><img src=\"/images/ssr/systemset.png\" alt=\"\"></p>\n</li>\n<li><p>然后，需要在google商店下载SwitchyOmega插件，但是需要翻墙～这里可以进入如下<a href=\"http://googlehelper.net/\" target=\"_blank\" rel=\"noopener\">网址</a>,先下载一个googlehelper插件(打开chrome所有插件，把下载的插件直接拉进去即可添加完成)，用邮箱注册一个免费的体验账号，先翻了墙再说。</p>\n</li>\n<li><p>然后去chrome网上应用商店下载SwitchyOmega，接下来便可以配置了。</p>\n</li>\n<li><p>在SwitchyOmega的配置页面<br>先新建一个情景模式，选择代理服务器，名称为gfwlist(这个随意)<br>配置时,代理服务器和代理端口分别是ssr config中的<br>  “local_address”:”127.0.0.1”<br>  “local_port”:1080<br>确认后无误后应用选项<br><img src=\"/images/ssr/gfwlist.png\" alt=\"\"></p>\n</li>\n<li><p>接下来点击情景模式中的自动切换，输入参数如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">条件设置：raw.githubusercontent.com  </span><br><span class=\"line\">规则列表网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt  </span><br><span class=\"line\">点击立即更新情景模式  </span><br><span class=\"line\">结束,在SwitchyOmega插件(chorme浏览器右上角处)那换成自动切换,大功告成.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"/images/ssr/auto_switch_01.png\" alt=\"\"></p>\n<p><img src=\"/images/ssr/auto_switch_02.png\" alt=\"\"></p>\n<p><img src=\"/images/ssr/example.png\" alt=\"\"></p>\n<ul>\n<li><p>最后把多余的情景模式删除,看起来清爽一点。</p>\n</li>\n<li><p>这样就相当于在chorme中启用的是pcd模式,在能穿墙的同时,既保证了访问国内网站速度不慢,又节省了ssr的流量。</p>\n</li>\n<li><p>接下来就可以优雅地体验翻墙上网了～</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.28</p>\n</blockquote>\n"},{"layout":"post","title":"Python学习笔记——进阶","date":"2018-04-29T08:47:00.000Z","_content":"\n> 不适合人类阅读的学习笔记  \n\n## 格式化输出方法\n---\n\n- 格式：`格式字符串.format(输出1, 输出2, ...输出n)`\n\n- 格式说明符使用大括号括起来，一般格式如下：`{[序号或键]:格式说明符}`\n> 其中可选序号对应于后面的输出项，从0开始\n\n- 例如：\n```\n>>> \"{0:.2f},{1}\".format(3.145,500)  .2f表示输出的是浮点数，小数部分占两位，整数部分默认(.2f或者0.2f)\n>>> \"3.15,500\"\n```\n\n- 注意前面格式字符串的引号不能少，**如果省略序号，则Python会按顺序匹配后面的输出项**，同时 **格式字符串里除了大括号里面的内容是换成后面的对应的输出项，其余的内容会原样输出**，比如`\"I\\'m {}，and {}\".format(\"Jake\",\"Hello!\")` 会输出 `I'm jake, and Hello!`\n\n### 一些例子\n\n- `print(\"{0:<15}\").format(12345) `：左对齐  \n\n- `print(\"{0:>15}\".format(12345))`：右对齐\n\n- `print(\"{0:*^15}\".format(12345))`：中间对齐，并且用 `*` 补齐空格\n\n- `print(\"{0:10b}\".format(65))`：以二进制输出\n\n- `print(\"{0:10o}\".format(65))`：以八进制输出\n\n- `print(\"{0:10x}\".format(65))`：以十六进制输出\n\n\n## 常用模块\n---\n\n- 使用方法：\n```\nimport 模块名  #引入整个模块\nfrom 模块名 import 函数名  //引入某个函数\nfrom 模块名 import *   //引入所有函数\n```\n\n- 如果引入多个模块，在使用模块的函数时最好使用 `模块名.函数` 的格式，防止各模块同名函数之间的冲突。\n\n### math模块常用函数\n\n- `e` ：返回常数e(自然对数的底)\n\n- `pi`： 返回圆周率π\n\n- `fabs(x)`： 返回x的绝对值，返回值为浮点数   #注：`abs(x)`为Python内置函数，返回值与参数一致，且abs()可以用来求解复数\n\n- `sqrt(x)`：返回X的平方根(x > 0)\n\n- `pow(x,y)`：返回x的y次方，返回值为浮点型\n\n- `log(x,[base])`：返回x以base为底的对数，默认底为e\n\n- `ceil(x)`：对x向上取整，例 `ceil(4.1)` 返回5\n\n- `floor(x)`：对x向下取整。\n\n### cmath模块\n\n> cmath模块与math模块函数类似，但是cmath提供对复数运算的支持\n\n- `complex(x,y)`：返回复数 x + yi\n\n### random模块\n\n- `seed([x])`：在生成随机数之前必须调用，否则每次生成的随机数都一样。seed()为随机数的生成产生一个种子(实际上就是Python的随机数从这个随机数开始计算)，可以直接无参调用，这样Python会自动设置种子。\n\n- `uniform(a,b)`：随机生成一个[a,b]范围内的实数\n\n- `randint(a,b)`：随机生成一个[a,b]范围内的整数\n\n## 一些内置模块的函数\n---\n\n### 字符相关\n\n- `ord(x)`：返回x的ASCII码\n\n- `chr(x)`：这里x是ASCII码，返回其所对应的字符\n\n- `lower(x)`：将字符串中所有的大写变为小写\n> #这里的lower()和upper()为方法，使用格式为x.lower()\n\n- `upper(x)`：将字符串中所有小写变为大写\n\n### 数值运算相关\n\n- `pow(x,y[,z])`：返回x的y次方，返回值保持x或y的类型。如果加上参数z，则结果再对z求余数，即x^y/z\n\n- `abs(x)`:见math模块的与fabs()的区别\n\n### 类型转换\n\n- `int(x)`：将x转化为整型 **存为一个拷贝，x本身的值没有变**\n\n- `float(x)`：将x转化为浮点数\n\n\n\n\n\n\n\n<br>\n> 最后更新于2018.4.29\n","source":"_posts/2018-04-29-Python-superior.md","raw":"---\nlayout:     post\ntitle:      \"Python学习笔记——进阶\"\ndate:       2018-04-29 16:47:00\ncategories: Computer Programes\ntags: ๑Python\n---\n\n> 不适合人类阅读的学习笔记  \n\n## 格式化输出方法\n---\n\n- 格式：`格式字符串.format(输出1, 输出2, ...输出n)`\n\n- 格式说明符使用大括号括起来，一般格式如下：`{[序号或键]:格式说明符}`\n> 其中可选序号对应于后面的输出项，从0开始\n\n- 例如：\n```\n>>> \"{0:.2f},{1}\".format(3.145,500)  .2f表示输出的是浮点数，小数部分占两位，整数部分默认(.2f或者0.2f)\n>>> \"3.15,500\"\n```\n\n- 注意前面格式字符串的引号不能少，**如果省略序号，则Python会按顺序匹配后面的输出项**，同时 **格式字符串里除了大括号里面的内容是换成后面的对应的输出项，其余的内容会原样输出**，比如`\"I\\'m {}，and {}\".format(\"Jake\",\"Hello!\")` 会输出 `I'm jake, and Hello!`\n\n### 一些例子\n\n- `print(\"{0:<15}\").format(12345) `：左对齐  \n\n- `print(\"{0:>15}\".format(12345))`：右对齐\n\n- `print(\"{0:*^15}\".format(12345))`：中间对齐，并且用 `*` 补齐空格\n\n- `print(\"{0:10b}\".format(65))`：以二进制输出\n\n- `print(\"{0:10o}\".format(65))`：以八进制输出\n\n- `print(\"{0:10x}\".format(65))`：以十六进制输出\n\n\n## 常用模块\n---\n\n- 使用方法：\n```\nimport 模块名  #引入整个模块\nfrom 模块名 import 函数名  //引入某个函数\nfrom 模块名 import *   //引入所有函数\n```\n\n- 如果引入多个模块，在使用模块的函数时最好使用 `模块名.函数` 的格式，防止各模块同名函数之间的冲突。\n\n### math模块常用函数\n\n- `e` ：返回常数e(自然对数的底)\n\n- `pi`： 返回圆周率π\n\n- `fabs(x)`： 返回x的绝对值，返回值为浮点数   #注：`abs(x)`为Python内置函数，返回值与参数一致，且abs()可以用来求解复数\n\n- `sqrt(x)`：返回X的平方根(x > 0)\n\n- `pow(x,y)`：返回x的y次方，返回值为浮点型\n\n- `log(x,[base])`：返回x以base为底的对数，默认底为e\n\n- `ceil(x)`：对x向上取整，例 `ceil(4.1)` 返回5\n\n- `floor(x)`：对x向下取整。\n\n### cmath模块\n\n> cmath模块与math模块函数类似，但是cmath提供对复数运算的支持\n\n- `complex(x,y)`：返回复数 x + yi\n\n### random模块\n\n- `seed([x])`：在生成随机数之前必须调用，否则每次生成的随机数都一样。seed()为随机数的生成产生一个种子(实际上就是Python的随机数从这个随机数开始计算)，可以直接无参调用，这样Python会自动设置种子。\n\n- `uniform(a,b)`：随机生成一个[a,b]范围内的实数\n\n- `randint(a,b)`：随机生成一个[a,b]范围内的整数\n\n## 一些内置模块的函数\n---\n\n### 字符相关\n\n- `ord(x)`：返回x的ASCII码\n\n- `chr(x)`：这里x是ASCII码，返回其所对应的字符\n\n- `lower(x)`：将字符串中所有的大写变为小写\n> #这里的lower()和upper()为方法，使用格式为x.lower()\n\n- `upper(x)`：将字符串中所有小写变为大写\n\n### 数值运算相关\n\n- `pow(x,y[,z])`：返回x的y次方，返回值保持x或y的类型。如果加上参数z，则结果再对z求余数，即x^y/z\n\n- `abs(x)`:见math模块的与fabs()的区别\n\n### 类型转换\n\n- `int(x)`：将x转化为整型 **存为一个拷贝，x本身的值没有变**\n\n- `float(x)`：将x转化为浮点数\n\n\n\n\n\n\n\n<br>\n> 最后更新于2018.4.29\n","slug":"2018-04-29-Python-superior","published":1,"updated":"2018-09-03T13:17:25.524Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4q001k1m0o8rqiudyq","content":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"格式化输出方法\"><a href=\"#格式化输出方法\" class=\"headerlink\" title=\"格式化输出方法\"></a>格式化输出方法</h2><hr>\n<ul>\n<li><p>格式：<code>格式字符串.format(输出1, 输出2, ...输出n)</code></p>\n</li>\n<li><p>格式说明符使用大括号括起来，一般格式如下：<code>{[序号或键]:格式说明符}</code></p>\n<blockquote>\n<p>其中可选序号对应于后面的输出项，从0开始</p>\n</blockquote>\n</li>\n<li><p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; &quot;&#123;0:.2f&#125;,&#123;1&#125;&quot;.format(3.145,500)  .2f表示输出的是浮点数，小数部分占两位，整数部分默认(.2f或者0.2f)</span><br><span class=\"line\">&gt;&gt;&gt; &quot;3.15,500&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意前面格式字符串的引号不能少，<strong>如果省略序号，则Python会按顺序匹配后面的输出项</strong>，同时 <strong>格式字符串里除了大括号里面的内容是换成后面的对应的输出项，其余的内容会原样输出</strong>，比如<code>&quot;I\\&#39;m {}，and {}&quot;.format(&quot;Jake&quot;,&quot;Hello!&quot;)</code> 会输出 <code>I&#39;m jake, and Hello!</code></p>\n</li>\n</ul>\n<h3 id=\"一些例子\"><a href=\"#一些例子\" class=\"headerlink\" title=\"一些例子\"></a>一些例子</h3><ul>\n<li><p><code>print(&quot;{0:&lt;15}&quot;).format(12345)</code>：左对齐  </p>\n</li>\n<li><p><code>print(&quot;{0:&gt;15}&quot;.format(12345))</code>：右对齐</p>\n</li>\n<li><p><code>print(&quot;{0:*^15}&quot;.format(12345))</code>：中间对齐，并且用 <code>*</code> 补齐空格</p>\n</li>\n<li><p><code>print(&quot;{0:10b}&quot;.format(65))</code>：以二进制输出</p>\n</li>\n<li><p><code>print(&quot;{0:10o}&quot;.format(65))</code>：以八进制输出</p>\n</li>\n<li><p><code>print(&quot;{0:10x}&quot;.format(65))</code>：以十六进制输出</p>\n</li>\n</ul>\n<h2 id=\"常用模块\"><a href=\"#常用模块\" class=\"headerlink\" title=\"常用模块\"></a>常用模块</h2><hr>\n<ul>\n<li><p>使用方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import 模块名  #引入整个模块</span><br><span class=\"line\">from 模块名 import 函数名  //引入某个函数</span><br><span class=\"line\">from 模块名 import *   //引入所有函数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果引入多个模块，在使用模块的函数时最好使用 <code>模块名.函数</code> 的格式，防止各模块同名函数之间的冲突。</p>\n</li>\n</ul>\n<h3 id=\"math模块常用函数\"><a href=\"#math模块常用函数\" class=\"headerlink\" title=\"math模块常用函数\"></a>math模块常用函数</h3><ul>\n<li><p><code>e</code> ：返回常数e(自然对数的底)</p>\n</li>\n<li><p><code>pi</code>： 返回圆周率π</p>\n</li>\n<li><p><code>fabs(x)</code>： 返回x的绝对值，返回值为浮点数   #注：<code>abs(x)</code>为Python内置函数，返回值与参数一致，且abs()可以用来求解复数</p>\n</li>\n<li><p><code>sqrt(x)</code>：返回X的平方根(x &gt; 0)</p>\n</li>\n<li><p><code>pow(x,y)</code>：返回x的y次方，返回值为浮点型</p>\n</li>\n<li><p><code>log(x,[base])</code>：返回x以base为底的对数，默认底为e</p>\n</li>\n<li><p><code>ceil(x)</code>：对x向上取整，例 <code>ceil(4.1)</code> 返回5</p>\n</li>\n<li><p><code>floor(x)</code>：对x向下取整。</p>\n</li>\n</ul>\n<h3 id=\"cmath模块\"><a href=\"#cmath模块\" class=\"headerlink\" title=\"cmath模块\"></a>cmath模块</h3><blockquote>\n<p>cmath模块与math模块函数类似，但是cmath提供对复数运算的支持</p>\n</blockquote>\n<ul>\n<li><code>complex(x,y)</code>：返回复数 x + yi</li>\n</ul>\n<h3 id=\"random模块\"><a href=\"#random模块\" class=\"headerlink\" title=\"random模块\"></a>random模块</h3><ul>\n<li><p><code>seed([x])</code>：在生成随机数之前必须调用，否则每次生成的随机数都一样。seed()为随机数的生成产生一个种子(实际上就是Python的随机数从这个随机数开始计算)，可以直接无参调用，这样Python会自动设置种子。</p>\n</li>\n<li><p><code>uniform(a,b)</code>：随机生成一个[a,b]范围内的实数</p>\n</li>\n<li><p><code>randint(a,b)</code>：随机生成一个[a,b]范围内的整数</p>\n</li>\n</ul>\n<h2 id=\"一些内置模块的函数\"><a href=\"#一些内置模块的函数\" class=\"headerlink\" title=\"一些内置模块的函数\"></a>一些内置模块的函数</h2><hr>\n<h3 id=\"字符相关\"><a href=\"#字符相关\" class=\"headerlink\" title=\"字符相关\"></a>字符相关</h3><ul>\n<li><p><code>ord(x)</code>：返回x的ASCII码</p>\n</li>\n<li><p><code>chr(x)</code>：这里x是ASCII码，返回其所对应的字符</p>\n</li>\n<li><p><code>lower(x)</code>：将字符串中所有的大写变为小写</p>\n<blockquote>\n<p>#这里的lower()和upper()为方法，使用格式为x.lower()</p>\n</blockquote>\n</li>\n<li><p><code>upper(x)</code>：将字符串中所有小写变为大写</p>\n</li>\n</ul>\n<h3 id=\"数值运算相关\"><a href=\"#数值运算相关\" class=\"headerlink\" title=\"数值运算相关\"></a>数值运算相关</h3><ul>\n<li><p><code>pow(x,y[,z])</code>：返回x的y次方，返回值保持x或y的类型。如果加上参数z，则结果再对z求余数，即x^y/z</p>\n</li>\n<li><p><code>abs(x)</code>:见math模块的与fabs()的区别</p>\n</li>\n</ul>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><ul>\n<li><p><code>int(x)</code>：将x转化为整型 <strong>存为一个拷贝，x本身的值没有变</strong></p>\n</li>\n<li><p><code>float(x)</code>：将x转化为浮点数</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.29</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记  </p>\n</blockquote>\n<h2 id=\"格式化输出方法\"><a href=\"#格式化输出方法\" class=\"headerlink\" title=\"格式化输出方法\"></a>格式化输出方法</h2><hr>\n<ul>\n<li><p>格式：<code>格式字符串.format(输出1, 输出2, ...输出n)</code></p>\n</li>\n<li><p>格式说明符使用大括号括起来，一般格式如下：<code>{[序号或键]:格式说明符}</code></p>\n<blockquote>\n<p>其中可选序号对应于后面的输出项，从0开始</p>\n</blockquote>\n</li>\n<li><p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; &quot;&#123;0:.2f&#125;,&#123;1&#125;&quot;.format(3.145,500)  .2f表示输出的是浮点数，小数部分占两位，整数部分默认(.2f或者0.2f)</span><br><span class=\"line\">&gt;&gt;&gt; &quot;3.15,500&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意前面格式字符串的引号不能少，<strong>如果省略序号，则Python会按顺序匹配后面的输出项</strong>，同时 <strong>格式字符串里除了大括号里面的内容是换成后面的对应的输出项，其余的内容会原样输出</strong>，比如<code>&quot;I\\&#39;m {}，and {}&quot;.format(&quot;Jake&quot;,&quot;Hello!&quot;)</code> 会输出 <code>I&#39;m jake, and Hello!</code></p>\n</li>\n</ul>\n<h3 id=\"一些例子\"><a href=\"#一些例子\" class=\"headerlink\" title=\"一些例子\"></a>一些例子</h3><ul>\n<li><p><code>print(&quot;{0:&lt;15}&quot;).format(12345)</code>：左对齐  </p>\n</li>\n<li><p><code>print(&quot;{0:&gt;15}&quot;.format(12345))</code>：右对齐</p>\n</li>\n<li><p><code>print(&quot;{0:*^15}&quot;.format(12345))</code>：中间对齐，并且用 <code>*</code> 补齐空格</p>\n</li>\n<li><p><code>print(&quot;{0:10b}&quot;.format(65))</code>：以二进制输出</p>\n</li>\n<li><p><code>print(&quot;{0:10o}&quot;.format(65))</code>：以八进制输出</p>\n</li>\n<li><p><code>print(&quot;{0:10x}&quot;.format(65))</code>：以十六进制输出</p>\n</li>\n</ul>\n<h2 id=\"常用模块\"><a href=\"#常用模块\" class=\"headerlink\" title=\"常用模块\"></a>常用模块</h2><hr>\n<ul>\n<li><p>使用方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import 模块名  #引入整个模块</span><br><span class=\"line\">from 模块名 import 函数名  //引入某个函数</span><br><span class=\"line\">from 模块名 import *   //引入所有函数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果引入多个模块，在使用模块的函数时最好使用 <code>模块名.函数</code> 的格式，防止各模块同名函数之间的冲突。</p>\n</li>\n</ul>\n<h3 id=\"math模块常用函数\"><a href=\"#math模块常用函数\" class=\"headerlink\" title=\"math模块常用函数\"></a>math模块常用函数</h3><ul>\n<li><p><code>e</code> ：返回常数e(自然对数的底)</p>\n</li>\n<li><p><code>pi</code>： 返回圆周率π</p>\n</li>\n<li><p><code>fabs(x)</code>： 返回x的绝对值，返回值为浮点数   #注：<code>abs(x)</code>为Python内置函数，返回值与参数一致，且abs()可以用来求解复数</p>\n</li>\n<li><p><code>sqrt(x)</code>：返回X的平方根(x &gt; 0)</p>\n</li>\n<li><p><code>pow(x,y)</code>：返回x的y次方，返回值为浮点型</p>\n</li>\n<li><p><code>log(x,[base])</code>：返回x以base为底的对数，默认底为e</p>\n</li>\n<li><p><code>ceil(x)</code>：对x向上取整，例 <code>ceil(4.1)</code> 返回5</p>\n</li>\n<li><p><code>floor(x)</code>：对x向下取整。</p>\n</li>\n</ul>\n<h3 id=\"cmath模块\"><a href=\"#cmath模块\" class=\"headerlink\" title=\"cmath模块\"></a>cmath模块</h3><blockquote>\n<p>cmath模块与math模块函数类似，但是cmath提供对复数运算的支持</p>\n</blockquote>\n<ul>\n<li><code>complex(x,y)</code>：返回复数 x + yi</li>\n</ul>\n<h3 id=\"random模块\"><a href=\"#random模块\" class=\"headerlink\" title=\"random模块\"></a>random模块</h3><ul>\n<li><p><code>seed([x])</code>：在生成随机数之前必须调用，否则每次生成的随机数都一样。seed()为随机数的生成产生一个种子(实际上就是Python的随机数从这个随机数开始计算)，可以直接无参调用，这样Python会自动设置种子。</p>\n</li>\n<li><p><code>uniform(a,b)</code>：随机生成一个[a,b]范围内的实数</p>\n</li>\n<li><p><code>randint(a,b)</code>：随机生成一个[a,b]范围内的整数</p>\n</li>\n</ul>\n<h2 id=\"一些内置模块的函数\"><a href=\"#一些内置模块的函数\" class=\"headerlink\" title=\"一些内置模块的函数\"></a>一些内置模块的函数</h2><hr>\n<h3 id=\"字符相关\"><a href=\"#字符相关\" class=\"headerlink\" title=\"字符相关\"></a>字符相关</h3><ul>\n<li><p><code>ord(x)</code>：返回x的ASCII码</p>\n</li>\n<li><p><code>chr(x)</code>：这里x是ASCII码，返回其所对应的字符</p>\n</li>\n<li><p><code>lower(x)</code>：将字符串中所有的大写变为小写</p>\n<blockquote>\n<p>#这里的lower()和upper()为方法，使用格式为x.lower()</p>\n</blockquote>\n</li>\n<li><p><code>upper(x)</code>：将字符串中所有小写变为大写</p>\n</li>\n</ul>\n<h3 id=\"数值运算相关\"><a href=\"#数值运算相关\" class=\"headerlink\" title=\"数值运算相关\"></a>数值运算相关</h3><ul>\n<li><p><code>pow(x,y[,z])</code>：返回x的y次方，返回值保持x或y的类型。如果加上参数z，则结果再对z求余数，即x^y/z</p>\n</li>\n<li><p><code>abs(x)</code>:见math模块的与fabs()的区别</p>\n</li>\n</ul>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><ul>\n<li><p><code>int(x)</code>：将x转化为整型 <strong>存为一个拷贝，x本身的值没有变</strong></p>\n</li>\n<li><p><code>float(x)</code>：将x转化为浮点数</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.4.29</p>\n</blockquote>\n"},{"layout":"post","title":"关于国产安卓机如何安装Google Play相关套件","date":"2018-05-03T01:47:00.000Z","_content":"\n\n## 前言\n---\n\n- 自从有了长城防火墙以来，国人的“翻墙”运动一直未曾间断\n\n- 本教程无需root权限即可完成\n\n- 但是！本教程需要你已经有科学上网的工具才行~ 而且是手机端的~ (因为无论是登录还是下载软件都要翻墙)\n\n## 正文\n---\n\n- 作为一个经常用到各式各样软件的用户，显然国产的软件市场只是能满足一般的国人用户，像我们这样的高端玩家看来那点国内的软件显然是不够的~\n\n- 就比如要下一个手机端的steam令牌，我用的是小米手机，之前还能在商店里找到下载，但是换了新手机之后莫名发现下架了，而且在商店里搜索所有有关谷歌的关键字都被自动屏蔽了...... 作为专业人士这怎么能忍？因此需要从google play store下载更全面的软件。\n\n- 谷歌服务框架： Google服务框架全称Google Mobile Service，其中包含了应用包，就是一些google应用。Android虽然是开源的，但是google的应用却不包含在其中。厂家如果要预装google应用，都要与google达成付费协议以及其他一些原因，因此许多国内厂商不会自带google套件。\n\n- 要体验完整的google服务，需要几个软件的支持：**google服务框架(Google Services Framework)，google账户管理程序(google login Service)，google play服务(google play services) 以及 google play 商店(google play store)**\n\n- 至于有个一键安装的软件叫 go谷歌安装器，自己百度即可找到。如果可以一键安装成功，那么恭喜你，你可以直接开始愉快的体验了。\n\n- 如果你也像我一样，安装时提示网络连接错误，挂了VPN也一样的话，那就只能自己去网上一个一个找上面提到的几款软件 **尤其要注意软件的英文名称，下载时以英文名称为准，防止下载到一些流氓软件或者是木马文件，下载最好去比较正规的网站**。\n> 注意只有google play store 是安装后显示在手机桌面上的，其他的都是系统级的服务软件，装好之后不会显示。\n\n- 全部安装完成之后，你可以打开 go谷歌安装器 主界面检测这几个软件是否正常安装，如果全是绿勾，则说明安装完成，这时候重启一下手机。\n\n- 最后，挂上VPN，打开google play store，登录或者注册google账号即可开始使用~\n\n\n> 备注：如果找不到科学上网工具的朋友可以email我，如果我看到了可以给一些推荐。\n\n<br>\n> 最后更新于2018.5.3\n","source":"_posts/2018-05-03-Google-play-Android.md","raw":"---\nlayout:     post\ntitle:      \"关于国产安卓机如何安装Google Play相关套件\"\ndate:       2018-05-03 09:47:00\ncategories: ScientificSurfing\ntags:   ๑ScientificSurfing\n---\n\n\n## 前言\n---\n\n- 自从有了长城防火墙以来，国人的“翻墙”运动一直未曾间断\n\n- 本教程无需root权限即可完成\n\n- 但是！本教程需要你已经有科学上网的工具才行~ 而且是手机端的~ (因为无论是登录还是下载软件都要翻墙)\n\n## 正文\n---\n\n- 作为一个经常用到各式各样软件的用户，显然国产的软件市场只是能满足一般的国人用户，像我们这样的高端玩家看来那点国内的软件显然是不够的~\n\n- 就比如要下一个手机端的steam令牌，我用的是小米手机，之前还能在商店里找到下载，但是换了新手机之后莫名发现下架了，而且在商店里搜索所有有关谷歌的关键字都被自动屏蔽了...... 作为专业人士这怎么能忍？因此需要从google play store下载更全面的软件。\n\n- 谷歌服务框架： Google服务框架全称Google Mobile Service，其中包含了应用包，就是一些google应用。Android虽然是开源的，但是google的应用却不包含在其中。厂家如果要预装google应用，都要与google达成付费协议以及其他一些原因，因此许多国内厂商不会自带google套件。\n\n- 要体验完整的google服务，需要几个软件的支持：**google服务框架(Google Services Framework)，google账户管理程序(google login Service)，google play服务(google play services) 以及 google play 商店(google play store)**\n\n- 至于有个一键安装的软件叫 go谷歌安装器，自己百度即可找到。如果可以一键安装成功，那么恭喜你，你可以直接开始愉快的体验了。\n\n- 如果你也像我一样，安装时提示网络连接错误，挂了VPN也一样的话，那就只能自己去网上一个一个找上面提到的几款软件 **尤其要注意软件的英文名称，下载时以英文名称为准，防止下载到一些流氓软件或者是木马文件，下载最好去比较正规的网站**。\n> 注意只有google play store 是安装后显示在手机桌面上的，其他的都是系统级的服务软件，装好之后不会显示。\n\n- 全部安装完成之后，你可以打开 go谷歌安装器 主界面检测这几个软件是否正常安装，如果全是绿勾，则说明安装完成，这时候重启一下手机。\n\n- 最后，挂上VPN，打开google play store，登录或者注册google账号即可开始使用~\n\n\n> 备注：如果找不到科学上网工具的朋友可以email我，如果我看到了可以给一些推荐。\n\n<br>\n> 最后更新于2018.5.3\n","slug":"2018-05-03-Google-play-Android","published":1,"updated":"2018-09-03T08:45:49.019Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4r001n1m0o2bmglss0","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><hr>\n<ul>\n<li><p>自从有了长城防火墙以来，国人的“翻墙”运动一直未曾间断</p>\n</li>\n<li><p>本教程无需root权限即可完成</p>\n</li>\n<li><p>但是！本教程需要你已经有科学上网的工具才行~ 而且是手机端的~ (因为无论是登录还是下载软件都要翻墙)</p>\n</li>\n</ul>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><hr>\n<ul>\n<li><p>作为一个经常用到各式各样软件的用户，显然国产的软件市场只是能满足一般的国人用户，像我们这样的高端玩家看来那点国内的软件显然是不够的~</p>\n</li>\n<li><p>就比如要下一个手机端的steam令牌，我用的是小米手机，之前还能在商店里找到下载，但是换了新手机之后莫名发现下架了，而且在商店里搜索所有有关谷歌的关键字都被自动屏蔽了…… 作为专业人士这怎么能忍？因此需要从google play store下载更全面的软件。</p>\n</li>\n<li><p>谷歌服务框架： Google服务框架全称Google Mobile Service，其中包含了应用包，就是一些google应用。Android虽然是开源的，但是google的应用却不包含在其中。厂家如果要预装google应用，都要与google达成付费协议以及其他一些原因，因此许多国内厂商不会自带google套件。</p>\n</li>\n<li><p>要体验完整的google服务，需要几个软件的支持：<strong>google服务框架(Google Services Framework)，google账户管理程序(google login Service)，google play服务(google play services) 以及 google play 商店(google play store)</strong></p>\n</li>\n<li><p>至于有个一键安装的软件叫 go谷歌安装器，自己百度即可找到。如果可以一键安装成功，那么恭喜你，你可以直接开始愉快的体验了。</p>\n</li>\n<li><p>如果你也像我一样，安装时提示网络连接错误，挂了VPN也一样的话，那就只能自己去网上一个一个找上面提到的几款软件 <strong>尤其要注意软件的英文名称，下载时以英文名称为准，防止下载到一些流氓软件或者是木马文件，下载最好去比较正规的网站</strong>。</p>\n<blockquote>\n<p>注意只有google play store 是安装后显示在手机桌面上的，其他的都是系统级的服务软件，装好之后不会显示。</p>\n</blockquote>\n</li>\n<li><p>全部安装完成之后，你可以打开 go谷歌安装器 主界面检测这几个软件是否正常安装，如果全是绿勾，则说明安装完成，这时候重启一下手机。</p>\n</li>\n<li><p>最后，挂上VPN，打开google play store，登录或者注册google账号即可开始使用~</p>\n</li>\n</ul>\n<blockquote>\n<p>备注：如果找不到科学上网工具的朋友可以email我，如果我看到了可以给一些推荐。</p>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.3</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><hr>\n<ul>\n<li><p>自从有了长城防火墙以来，国人的“翻墙”运动一直未曾间断</p>\n</li>\n<li><p>本教程无需root权限即可完成</p>\n</li>\n<li><p>但是！本教程需要你已经有科学上网的工具才行~ 而且是手机端的~ (因为无论是登录还是下载软件都要翻墙)</p>\n</li>\n</ul>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><hr>\n<ul>\n<li><p>作为一个经常用到各式各样软件的用户，显然国产的软件市场只是能满足一般的国人用户，像我们这样的高端玩家看来那点国内的软件显然是不够的~</p>\n</li>\n<li><p>就比如要下一个手机端的steam令牌，我用的是小米手机，之前还能在商店里找到下载，但是换了新手机之后莫名发现下架了，而且在商店里搜索所有有关谷歌的关键字都被自动屏蔽了…… 作为专业人士这怎么能忍？因此需要从google play store下载更全面的软件。</p>\n</li>\n<li><p>谷歌服务框架： Google服务框架全称Google Mobile Service，其中包含了应用包，就是一些google应用。Android虽然是开源的，但是google的应用却不包含在其中。厂家如果要预装google应用，都要与google达成付费协议以及其他一些原因，因此许多国内厂商不会自带google套件。</p>\n</li>\n<li><p>要体验完整的google服务，需要几个软件的支持：<strong>google服务框架(Google Services Framework)，google账户管理程序(google login Service)，google play服务(google play services) 以及 google play 商店(google play store)</strong></p>\n</li>\n<li><p>至于有个一键安装的软件叫 go谷歌安装器，自己百度即可找到。如果可以一键安装成功，那么恭喜你，你可以直接开始愉快的体验了。</p>\n</li>\n<li><p>如果你也像我一样，安装时提示网络连接错误，挂了VPN也一样的话，那就只能自己去网上一个一个找上面提到的几款软件 <strong>尤其要注意软件的英文名称，下载时以英文名称为准，防止下载到一些流氓软件或者是木马文件，下载最好去比较正规的网站</strong>。</p>\n<blockquote>\n<p>注意只有google play store 是安装后显示在手机桌面上的，其他的都是系统级的服务软件，装好之后不会显示。</p>\n</blockquote>\n</li>\n<li><p>全部安装完成之后，你可以打开 go谷歌安装器 主界面检测这几个软件是否正常安装，如果全是绿勾，则说明安装完成，这时候重启一下手机。</p>\n</li>\n<li><p>最后，挂上VPN，打开google play store，登录或者注册google账号即可开始使用~</p>\n</li>\n</ul>\n<blockquote>\n<p>备注：如果找不到科学上网工具的朋友可以email我，如果我看到了可以给一些推荐。</p>\n</blockquote>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.3</p>\n</blockquote>\n"},{"layout":"post","title":"Ubuntu进阶记录 & Ubuntu-18","date":"2018-05-10T01:47:00.000Z","_content":"\n## Ubuntu18 使用体验\n---\n\n>“哎呦不错哦”\n“哇，这是什嘛？~”\n“哇，又搞什嘛?~”\n”卧槽这也不行“\n“哎呦这又是什嘛？～～”\n“哎呦又有bug～”\n“mmp输入法又炸了～～～”\n“哎呦狗屎啊～～～”\n\"啊，坑爹啊～～～\"\n“唉～～～”\n\n\n## 一些装机软件的安装\n---\n\n- 由于Ubuntu 18 自带了 gnome3.0桌面,所以我们只需要下载一个tweak-tool据可以自定义桌面了：\n```\nsudo apt-get update\nsudo apt-get install gnome-tweak-tool\n```\n\n- 这次Ubuntu把标题栏改到了窗口的右侧，如果要改到左侧的话，打开tweak-tool转到窗口里面更改即可。\n\n- 在更改用户主题之前，我们需要添加一个拓展插件才能使用自定义的主题\n```\nsudo apt-get install gnome-shell-extensions\n```\n或者在gnome拓展网站上搜索 shell extensions ，找到这个插件并且安装最后重启tweak-tool即可。\n\n## 主题修改\n---\n\n- 在网上找好主题以及美化的图标之后，分别下载下来，在home下创建 `.themes` 和 `.icons`两个文件夹，把主题和图标分别放到两个文件夹下即可使用。\n\n- [一个mac风格的主题](https://imcn.me/html/y2017/29004.html)\n\n-\n\n## 使用ppa源时可能遇到的问题以及解决方案\n---\n\n- 遇到 `sudo apt-get update` 时提示 *无法安全地用该源进行更新，所以默认禁用该源*,使用`sudo apt -o Acquire::AllowInsecureRepositories=true update`来强制更新不安全的源。\n\n- 遇到没有签名的问题时，使用 `sudo apt-get update --allow-unauthenticated`\n\n\n## Ubuntu18装机的坑\n---\n\n- ubuntu对独立显卡的支持很有问题，导致我在安装时一进去就卡死，后来找到了解决方法。\n\n- 在进入安装界面之前(选择体验还是安装的那个界面)时侯按 e 进入启动参数编辑 ，找到 quiet splash 这一句，把它删掉，改为  `i915.modest=0  nouveau.modeset=0  nomodeset` (参数之间空格间隔) 然后 ctrl+x 就可以进入安装界面了。但是此时的安装界面分辨率是900*400的，贼坑，还好我只是覆盖安装之前的Ubuntu16，所以自动安装也还凑合，如果要手动分区安装的话就悲剧了...\n\n- 同样的，在安装完成之后重启进入ubuntu系统之前(在那个紫色的界面时)还要按 e 进入启动参数编辑界面，更改同上，进入系统之后，找到 系统设置>软件和更新>附加驱动，安装Nvidia的独显驱动然后重启即可。\n\n- 按下 alt + F7 之后就可以不受限制地自由移动窗口了。\n\n- 详见我知乎上的[文章](https://www.zhihu.com/question/276308597/answer/388030874)\n\n### 终端的字体\n\n- 如果要自己更改一些字体的话，在tweak-tools 里面其他的字体都可以随便改，但是等宽字体不能随便该，否则终端的字体会出现交叠错乱的情况。终端的字体由等宽字体来控制，一定要选择以 \"mono\" 开头或者结尾的字体才不会出现问题。\n\n\n## 相比较 Ubuntu 16.04LTS\n---\n\n- 网易云音乐比Ubuntu16更加坑了～我内心是万马奔腾的...\n\n- ss-Qt5也用不了，翻墙只能靠命令行ssr了\n\n- 搜狗输入法也是各种安装失败，我也懒得搞了，但是Ubuntu 18 的内置中文输入法手感贼舒服～搜狗装不上也就算了\n\n\n## Ubuntu的问题查询\n---\n\n- 很多时候国内的一些论坛无法解决我们在使用Ubuntu时遇到的一些问题，这时候就需要去一些国外的论坛上找我们需要的解答。这里推荐一个网站——[askUbuntu](https://askubuntu.com)\n\n## Ubuntu 18 下可以使用的 ssr\n---\n\n- [链接](https://github.com/erguotou520/electron-ssr/releases)\n\n- 配置方法与windows几乎一致\n\n## 关于网易云音乐安装之后必须要终端sudo才能打开的问题（巨坑已填！！）\n---\n\n- 首先sudo打开会有报错,但是会自动启动默认设置\n\n- 根据报错我们可以进行对应的安装: `sudo apt-get install libcanberra-gtk-module`\n\n- 然后修改网易云音乐的desktop文件，在exec那一行 `%U` 之前 加上 `--no-sandbox`然后保存退出，重启电脑即可愉快的使用了～～(注意修改文件之前先要切换到root用户)\n\n- 另一种神奇的打开方式(不需要上面的操作):启动之后，点关机按钮，弹出来确认框，随后网易乐音乐页面也弹出来了，这时取消关机，可以正常使用云音乐~~~~~~~\n\n## 关于ibus输入法的问题\n---\n\n- 最近输入法中文一直有问题，没办法选词。\n\n- [博客链接](https://blog.csdn.net/AshinLi/article/details/72773989)\n\n- 终端打开ibus设置命令：`ibus-setup`\n\n- 但是感觉上面这个办法并没有声什么卵用。。。。\n\n- 所以我弃坑了，还是选择了搜狗输入法\n\n### Ubuntu18 的搜狗输入法的安装\n\n- 首先安装fcitx的相关依赖\n```\nsudo apt-get install fictx-bin\nsudo apt-get install fictx-table\n```\n\n- 然后安装下载好的搜狗输入法deb包\n`dpkg -i sougou...`\n这里应该会提示缺少依赖，这时候可就需要执行修复依赖：\n```\nsudo apt-get update\nsudo apt-get upgrade -f\n```\n系统会自动修复缺少的依赖包\n\n- 然后我们就可以安装完搜狗输入法了。这时候在系统语言设置(右上角)里更改键盘输入法系统为fictx，然后把不用的输入法去掉。\n\n- 最后重启电脑，打开fictx配置下搜狗输入法，把他调到第一个即可。\n\n- 搜狗输入法支持登录一键同步，还是很好用的～\n\n### 搜狗輸入法的新坑\n\n- Ubuntu18 自从安装以来一直问题不断。\n\n- 最近启动电脑发现搜狗输入法的候选词栏全变成了乱码。。。坑爹啊\n\n- 后来百度了解决方法：\n\n- 首先遇到高级全都勾上以便显示出所有的可更改项\n进入fictx设置>>附加组件>>简繁转换>>点击配置>>勾上显示高级选项>>将`sogoupinyin:false`改为`sogoupinyin:true`\n\n- 但是这个方法只管用一次...下次重启还要手动改~~垃圾\n\n- 所以接下来这个方法貌似有用(亲测)\n\n- 输入如下命令：(就是把你个人用户的一些配置删除掉然后重新创建)\n```\ncd ~/.config\nsudo rm -rf SogouPY* sogou*\n```\n- 之后注销重新登录即可。\n\n- **就目前个人测试的结果看来，登录个人中心是元凶，登录之后必炸...还是老老实实地用最基本的功能吧，期待早日更新吧。**\n\n<br>\n> 最后更新于2018.5.14\n","source":"_posts/2018-05-10-Ubuntu-18.md","raw":"---\nlayout:     post\ntitle:      \"Ubuntu进阶记录 & Ubuntu-18\"\ndate:       2018-05-10 09:47:00\ncategories: Computer System\ntags:  [๑Ubuntu, ๑Linux]\n---\n\n## Ubuntu18 使用体验\n---\n\n>“哎呦不错哦”\n“哇，这是什嘛？~”\n“哇，又搞什嘛?~”\n”卧槽这也不行“\n“哎呦这又是什嘛？～～”\n“哎呦又有bug～”\n“mmp输入法又炸了～～～”\n“哎呦狗屎啊～～～”\n\"啊，坑爹啊～～～\"\n“唉～～～”\n\n\n## 一些装机软件的安装\n---\n\n- 由于Ubuntu 18 自带了 gnome3.0桌面,所以我们只需要下载一个tweak-tool据可以自定义桌面了：\n```\nsudo apt-get update\nsudo apt-get install gnome-tweak-tool\n```\n\n- 这次Ubuntu把标题栏改到了窗口的右侧，如果要改到左侧的话，打开tweak-tool转到窗口里面更改即可。\n\n- 在更改用户主题之前，我们需要添加一个拓展插件才能使用自定义的主题\n```\nsudo apt-get install gnome-shell-extensions\n```\n或者在gnome拓展网站上搜索 shell extensions ，找到这个插件并且安装最后重启tweak-tool即可。\n\n## 主题修改\n---\n\n- 在网上找好主题以及美化的图标之后，分别下载下来，在home下创建 `.themes` 和 `.icons`两个文件夹，把主题和图标分别放到两个文件夹下即可使用。\n\n- [一个mac风格的主题](https://imcn.me/html/y2017/29004.html)\n\n-\n\n## 使用ppa源时可能遇到的问题以及解决方案\n---\n\n- 遇到 `sudo apt-get update` 时提示 *无法安全地用该源进行更新，所以默认禁用该源*,使用`sudo apt -o Acquire::AllowInsecureRepositories=true update`来强制更新不安全的源。\n\n- 遇到没有签名的问题时，使用 `sudo apt-get update --allow-unauthenticated`\n\n\n## Ubuntu18装机的坑\n---\n\n- ubuntu对独立显卡的支持很有问题，导致我在安装时一进去就卡死，后来找到了解决方法。\n\n- 在进入安装界面之前(选择体验还是安装的那个界面)时侯按 e 进入启动参数编辑 ，找到 quiet splash 这一句，把它删掉，改为  `i915.modest=0  nouveau.modeset=0  nomodeset` (参数之间空格间隔) 然后 ctrl+x 就可以进入安装界面了。但是此时的安装界面分辨率是900*400的，贼坑，还好我只是覆盖安装之前的Ubuntu16，所以自动安装也还凑合，如果要手动分区安装的话就悲剧了...\n\n- 同样的，在安装完成之后重启进入ubuntu系统之前(在那个紫色的界面时)还要按 e 进入启动参数编辑界面，更改同上，进入系统之后，找到 系统设置>软件和更新>附加驱动，安装Nvidia的独显驱动然后重启即可。\n\n- 按下 alt + F7 之后就可以不受限制地自由移动窗口了。\n\n- 详见我知乎上的[文章](https://www.zhihu.com/question/276308597/answer/388030874)\n\n### 终端的字体\n\n- 如果要自己更改一些字体的话，在tweak-tools 里面其他的字体都可以随便改，但是等宽字体不能随便该，否则终端的字体会出现交叠错乱的情况。终端的字体由等宽字体来控制，一定要选择以 \"mono\" 开头或者结尾的字体才不会出现问题。\n\n\n## 相比较 Ubuntu 16.04LTS\n---\n\n- 网易云音乐比Ubuntu16更加坑了～我内心是万马奔腾的...\n\n- ss-Qt5也用不了，翻墙只能靠命令行ssr了\n\n- 搜狗输入法也是各种安装失败，我也懒得搞了，但是Ubuntu 18 的内置中文输入法手感贼舒服～搜狗装不上也就算了\n\n\n## Ubuntu的问题查询\n---\n\n- 很多时候国内的一些论坛无法解决我们在使用Ubuntu时遇到的一些问题，这时候就需要去一些国外的论坛上找我们需要的解答。这里推荐一个网站——[askUbuntu](https://askubuntu.com)\n\n## Ubuntu 18 下可以使用的 ssr\n---\n\n- [链接](https://github.com/erguotou520/electron-ssr/releases)\n\n- 配置方法与windows几乎一致\n\n## 关于网易云音乐安装之后必须要终端sudo才能打开的问题（巨坑已填！！）\n---\n\n- 首先sudo打开会有报错,但是会自动启动默认设置\n\n- 根据报错我们可以进行对应的安装: `sudo apt-get install libcanberra-gtk-module`\n\n- 然后修改网易云音乐的desktop文件，在exec那一行 `%U` 之前 加上 `--no-sandbox`然后保存退出，重启电脑即可愉快的使用了～～(注意修改文件之前先要切换到root用户)\n\n- 另一种神奇的打开方式(不需要上面的操作):启动之后，点关机按钮，弹出来确认框，随后网易乐音乐页面也弹出来了，这时取消关机，可以正常使用云音乐~~~~~~~\n\n## 关于ibus输入法的问题\n---\n\n- 最近输入法中文一直有问题，没办法选词。\n\n- [博客链接](https://blog.csdn.net/AshinLi/article/details/72773989)\n\n- 终端打开ibus设置命令：`ibus-setup`\n\n- 但是感觉上面这个办法并没有声什么卵用。。。。\n\n- 所以我弃坑了，还是选择了搜狗输入法\n\n### Ubuntu18 的搜狗输入法的安装\n\n- 首先安装fcitx的相关依赖\n```\nsudo apt-get install fictx-bin\nsudo apt-get install fictx-table\n```\n\n- 然后安装下载好的搜狗输入法deb包\n`dpkg -i sougou...`\n这里应该会提示缺少依赖，这时候可就需要执行修复依赖：\n```\nsudo apt-get update\nsudo apt-get upgrade -f\n```\n系统会自动修复缺少的依赖包\n\n- 然后我们就可以安装完搜狗输入法了。这时候在系统语言设置(右上角)里更改键盘输入法系统为fictx，然后把不用的输入法去掉。\n\n- 最后重启电脑，打开fictx配置下搜狗输入法，把他调到第一个即可。\n\n- 搜狗输入法支持登录一键同步，还是很好用的～\n\n### 搜狗輸入法的新坑\n\n- Ubuntu18 自从安装以来一直问题不断。\n\n- 最近启动电脑发现搜狗输入法的候选词栏全变成了乱码。。。坑爹啊\n\n- 后来百度了解决方法：\n\n- 首先遇到高级全都勾上以便显示出所有的可更改项\n进入fictx设置>>附加组件>>简繁转换>>点击配置>>勾上显示高级选项>>将`sogoupinyin:false`改为`sogoupinyin:true`\n\n- 但是这个方法只管用一次...下次重启还要手动改~~垃圾\n\n- 所以接下来这个方法貌似有用(亲测)\n\n- 输入如下命令：(就是把你个人用户的一些配置删除掉然后重新创建)\n```\ncd ~/.config\nsudo rm -rf SogouPY* sogou*\n```\n- 之后注销重新登录即可。\n\n- **就目前个人测试的结果看来，登录个人中心是元凶，登录之后必炸...还是老老实实地用最基本的功能吧，期待早日更新吧。**\n\n<br>\n> 最后更新于2018.5.14\n","slug":"2018-05-10-Ubuntu-18","published":1,"updated":"2018-09-03T13:17:09.062Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4t001r1m0orcj3g1z4","content":"<h2 id=\"Ubuntu18-使用体验\"><a href=\"#Ubuntu18-使用体验\" class=\"headerlink\" title=\"Ubuntu18 使用体验\"></a>Ubuntu18 使用体验</h2><hr>\n<blockquote>\n<p>“哎呦不错哦”<br>“哇，这是什嘛？~”<br>“哇，又搞什嘛?~”<br>”卧槽这也不行“<br>“哎呦这又是什嘛？～～”<br>“哎呦又有bug～”<br>“mmp输入法又炸了～～～”<br>“哎呦狗屎啊～～～”<br>“啊，坑爹啊～～～”<br>“唉～～～”</p>\n</blockquote>\n<h2 id=\"一些装机软件的安装\"><a href=\"#一些装机软件的安装\" class=\"headerlink\" title=\"一些装机软件的安装\"></a>一些装机软件的安装</h2><hr>\n<ul>\n<li><p>由于Ubuntu 18 自带了 gnome3.0桌面,所以我们只需要下载一个tweak-tool据可以自定义桌面了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install gnome-tweak-tool</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这次Ubuntu把标题栏改到了窗口的右侧，如果要改到左侧的话，打开tweak-tool转到窗口里面更改即可。</p>\n</li>\n<li><p>在更改用户主题之前，我们需要添加一个拓展插件才能使用自定义的主题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gnome-shell-extensions</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>或者在gnome拓展网站上搜索 shell extensions ，找到这个插件并且安装最后重启tweak-tool即可。</p>\n<h2 id=\"主题修改\"><a href=\"#主题修改\" class=\"headerlink\" title=\"主题修改\"></a>主题修改</h2><hr>\n<ul>\n<li><p>在网上找好主题以及美化的图标之后，分别下载下来，在home下创建 <code>.themes</code> 和 <code>.icons</code>两个文件夹，把主题和图标分别放到两个文件夹下即可使用。</p>\n</li>\n<li><p><a href=\"https://imcn.me/html/y2017/29004.html\" target=\"_blank\" rel=\"noopener\">一个mac风格的主题</a></p>\n</li>\n</ul>\n<p>-</p>\n<h2 id=\"使用ppa源时可能遇到的问题以及解决方案\"><a href=\"#使用ppa源时可能遇到的问题以及解决方案\" class=\"headerlink\" title=\"使用ppa源时可能遇到的问题以及解决方案\"></a>使用ppa源时可能遇到的问题以及解决方案</h2><hr>\n<ul>\n<li><p>遇到 <code>sudo apt-get update</code> 时提示 <em>无法安全地用该源进行更新，所以默认禁用该源</em>,使用<code>sudo apt -o Acquire::AllowInsecureRepositories=true update</code>来强制更新不安全的源。</p>\n</li>\n<li><p>遇到没有签名的问题时，使用 <code>sudo apt-get update --allow-unauthenticated</code></p>\n</li>\n</ul>\n<h2 id=\"Ubuntu18装机的坑\"><a href=\"#Ubuntu18装机的坑\" class=\"headerlink\" title=\"Ubuntu18装机的坑\"></a>Ubuntu18装机的坑</h2><hr>\n<ul>\n<li><p>ubuntu对独立显卡的支持很有问题，导致我在安装时一进去就卡死，后来找到了解决方法。</p>\n</li>\n<li><p>在进入安装界面之前(选择体验还是安装的那个界面)时侯按 e 进入启动参数编辑 ，找到 quiet splash 这一句，把它删掉，改为  <code>i915.modest=0  nouveau.modeset=0  nomodeset</code> (参数之间空格间隔) 然后 ctrl+x 就可以进入安装界面了。但是此时的安装界面分辨率是900*400的，贼坑，还好我只是覆盖安装之前的Ubuntu16，所以自动安装也还凑合，如果要手动分区安装的话就悲剧了…</p>\n</li>\n<li><p>同样的，在安装完成之后重启进入ubuntu系统之前(在那个紫色的界面时)还要按 e 进入启动参数编辑界面，更改同上，进入系统之后，找到 系统设置&gt;软件和更新&gt;附加驱动，安装Nvidia的独显驱动然后重启即可。</p>\n</li>\n<li><p>按下 alt + F7 之后就可以不受限制地自由移动窗口了。</p>\n</li>\n<li><p>详见我知乎上的<a href=\"https://www.zhihu.com/question/276308597/answer/388030874\" target=\"_blank\" rel=\"noopener\">文章</a></p>\n</li>\n</ul>\n<h3 id=\"终端的字体\"><a href=\"#终端的字体\" class=\"headerlink\" title=\"终端的字体\"></a>终端的字体</h3><ul>\n<li>如果要自己更改一些字体的话，在tweak-tools 里面其他的字体都可以随便改，但是等宽字体不能随便该，否则终端的字体会出现交叠错乱的情况。终端的字体由等宽字体来控制，一定要选择以 “mono” 开头或者结尾的字体才不会出现问题。</li>\n</ul>\n<h2 id=\"相比较-Ubuntu-16-04LTS\"><a href=\"#相比较-Ubuntu-16-04LTS\" class=\"headerlink\" title=\"相比较 Ubuntu 16.04LTS\"></a>相比较 Ubuntu 16.04LTS</h2><hr>\n<ul>\n<li><p>网易云音乐比Ubuntu16更加坑了～我内心是万马奔腾的…</p>\n</li>\n<li><p>ss-Qt5也用不了，翻墙只能靠命令行ssr了</p>\n</li>\n<li><p>搜狗输入法也是各种安装失败，我也懒得搞了，但是Ubuntu 18 的内置中文输入法手感贼舒服～搜狗装不上也就算了</p>\n</li>\n</ul>\n<h2 id=\"Ubuntu的问题查询\"><a href=\"#Ubuntu的问题查询\" class=\"headerlink\" title=\"Ubuntu的问题查询\"></a>Ubuntu的问题查询</h2><hr>\n<ul>\n<li>很多时候国内的一些论坛无法解决我们在使用Ubuntu时遇到的一些问题，这时候就需要去一些国外的论坛上找我们需要的解答。这里推荐一个网站——<a href=\"https://askubuntu.com\" target=\"_blank\" rel=\"noopener\">askUbuntu</a></li>\n</ul>\n<h2 id=\"Ubuntu-18-下可以使用的-ssr\"><a href=\"#Ubuntu-18-下可以使用的-ssr\" class=\"headerlink\" title=\"Ubuntu 18 下可以使用的 ssr\"></a>Ubuntu 18 下可以使用的 ssr</h2><hr>\n<ul>\n<li><p><a href=\"https://github.com/erguotou520/electron-ssr/releases\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n</li>\n<li><p>配置方法与windows几乎一致</p>\n</li>\n</ul>\n<h2 id=\"关于网易云音乐安装之后必须要终端sudo才能打开的问题（巨坑已填！！）\"><a href=\"#关于网易云音乐安装之后必须要终端sudo才能打开的问题（巨坑已填！！）\" class=\"headerlink\" title=\"关于网易云音乐安装之后必须要终端sudo才能打开的问题（巨坑已填！！）\"></a>关于网易云音乐安装之后必须要终端sudo才能打开的问题（巨坑已填！！）</h2><hr>\n<ul>\n<li><p>首先sudo打开会有报错,但是会自动启动默认设置</p>\n</li>\n<li><p>根据报错我们可以进行对应的安装: <code>sudo apt-get install libcanberra-gtk-module</code></p>\n</li>\n<li><p>然后修改网易云音乐的desktop文件，在exec那一行 <code>%U</code> 之前 加上 <code>--no-sandbox</code>然后保存退出，重启电脑即可愉快的使用了～～(注意修改文件之前先要切换到root用户)</p>\n</li>\n<li><p>另一种神奇的打开方式(不需要上面的操作):启动之后，点关机按钮，弹出来确认框，随后网易乐音乐页面也弹出来了，这时取消关机，可以正常使用云音乐<del>~</del>~~</p>\n</li>\n</ul>\n<h2 id=\"关于ibus输入法的问题\"><a href=\"#关于ibus输入法的问题\" class=\"headerlink\" title=\"关于ibus输入法的问题\"></a>关于ibus输入法的问题</h2><hr>\n<ul>\n<li><p>最近输入法中文一直有问题，没办法选词。</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/AshinLi/article/details/72773989\" target=\"_blank\" rel=\"noopener\">博客链接</a></p>\n</li>\n<li><p>终端打开ibus设置命令：<code>ibus-setup</code></p>\n</li>\n<li><p>但是感觉上面这个办法并没有声什么卵用。。。。</p>\n</li>\n<li><p>所以我弃坑了，还是选择了搜狗输入法</p>\n</li>\n</ul>\n<h3 id=\"Ubuntu18-的搜狗输入法的安装\"><a href=\"#Ubuntu18-的搜狗输入法的安装\" class=\"headerlink\" title=\"Ubuntu18 的搜狗输入法的安装\"></a>Ubuntu18 的搜狗输入法的安装</h3><ul>\n<li><p>首先安装fcitx的相关依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install fictx-bin</span><br><span class=\"line\">sudo apt-get install fictx-table</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后安装下载好的搜狗输入法deb包<br><code>dpkg -i sougou...</code><br>这里应该会提示缺少依赖，这时候可就需要执行修复依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade -f</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>系统会自动修复缺少的依赖包</p>\n<ul>\n<li><p>然后我们就可以安装完搜狗输入法了。这时候在系统语言设置(右上角)里更改键盘输入法系统为fictx，然后把不用的输入法去掉。</p>\n</li>\n<li><p>最后重启电脑，打开fictx配置下搜狗输入法，把他调到第一个即可。</p>\n</li>\n<li><p>搜狗输入法支持登录一键同步，还是很好用的～</p>\n</li>\n</ul>\n<h3 id=\"搜狗輸入法的新坑\"><a href=\"#搜狗輸入法的新坑\" class=\"headerlink\" title=\"搜狗輸入法的新坑\"></a>搜狗輸入法的新坑</h3><ul>\n<li><p>Ubuntu18 自从安装以来一直问题不断。</p>\n</li>\n<li><p>最近启动电脑发现搜狗输入法的候选词栏全变成了乱码。。。坑爹啊</p>\n</li>\n<li><p>后来百度了解决方法：</p>\n</li>\n<li><p>首先遇到高级全都勾上以便显示出所有的可更改项<br>进入fictx设置&gt;&gt;附加组件&gt;&gt;简繁转换&gt;&gt;点击配置&gt;&gt;勾上显示高级选项&gt;&gt;将<code>sogoupinyin:false</code>改为<code>sogoupinyin:true</code></p>\n</li>\n<li><p>但是这个方法只管用一次…下次重启还要手动改~~垃圾</p>\n</li>\n<li><p>所以接下来这个方法貌似有用(亲测)</p>\n</li>\n<li><p>输入如下命令：(就是把你个人用户的一些配置删除掉然后重新创建)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/.config</span><br><span class=\"line\">sudo rm -rf SogouPY* sogou*</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>之后注销重新登录即可。</p>\n</li>\n<li><p><strong>就目前个人测试的结果看来，登录个人中心是元凶，登录之后必炸…还是老老实实地用最基本的功能吧，期待早日更新吧。</strong></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.14</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Ubuntu18-使用体验\"><a href=\"#Ubuntu18-使用体验\" class=\"headerlink\" title=\"Ubuntu18 使用体验\"></a>Ubuntu18 使用体验</h2><hr>\n<blockquote>\n<p>“哎呦不错哦”<br>“哇，这是什嘛？~”<br>“哇，又搞什嘛?~”<br>”卧槽这也不行“<br>“哎呦这又是什嘛？～～”<br>“哎呦又有bug～”<br>“mmp输入法又炸了～～～”<br>“哎呦狗屎啊～～～”<br>“啊，坑爹啊～～～”<br>“唉～～～”</p>\n</blockquote>\n<h2 id=\"一些装机软件的安装\"><a href=\"#一些装机软件的安装\" class=\"headerlink\" title=\"一些装机软件的安装\"></a>一些装机软件的安装</h2><hr>\n<ul>\n<li><p>由于Ubuntu 18 自带了 gnome3.0桌面,所以我们只需要下载一个tweak-tool据可以自定义桌面了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install gnome-tweak-tool</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这次Ubuntu把标题栏改到了窗口的右侧，如果要改到左侧的话，打开tweak-tool转到窗口里面更改即可。</p>\n</li>\n<li><p>在更改用户主题之前，我们需要添加一个拓展插件才能使用自定义的主题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gnome-shell-extensions</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>或者在gnome拓展网站上搜索 shell extensions ，找到这个插件并且安装最后重启tweak-tool即可。</p>\n<h2 id=\"主题修改\"><a href=\"#主题修改\" class=\"headerlink\" title=\"主题修改\"></a>主题修改</h2><hr>\n<ul>\n<li><p>在网上找好主题以及美化的图标之后，分别下载下来，在home下创建 <code>.themes</code> 和 <code>.icons</code>两个文件夹，把主题和图标分别放到两个文件夹下即可使用。</p>\n</li>\n<li><p><a href=\"https://imcn.me/html/y2017/29004.html\" target=\"_blank\" rel=\"noopener\">一个mac风格的主题</a></p>\n</li>\n</ul>\n<p>-</p>\n<h2 id=\"使用ppa源时可能遇到的问题以及解决方案\"><a href=\"#使用ppa源时可能遇到的问题以及解决方案\" class=\"headerlink\" title=\"使用ppa源时可能遇到的问题以及解决方案\"></a>使用ppa源时可能遇到的问题以及解决方案</h2><hr>\n<ul>\n<li><p>遇到 <code>sudo apt-get update</code> 时提示 <em>无法安全地用该源进行更新，所以默认禁用该源</em>,使用<code>sudo apt -o Acquire::AllowInsecureRepositories=true update</code>来强制更新不安全的源。</p>\n</li>\n<li><p>遇到没有签名的问题时，使用 <code>sudo apt-get update --allow-unauthenticated</code></p>\n</li>\n</ul>\n<h2 id=\"Ubuntu18装机的坑\"><a href=\"#Ubuntu18装机的坑\" class=\"headerlink\" title=\"Ubuntu18装机的坑\"></a>Ubuntu18装机的坑</h2><hr>\n<ul>\n<li><p>ubuntu对独立显卡的支持很有问题，导致我在安装时一进去就卡死，后来找到了解决方法。</p>\n</li>\n<li><p>在进入安装界面之前(选择体验还是安装的那个界面)时侯按 e 进入启动参数编辑 ，找到 quiet splash 这一句，把它删掉，改为  <code>i915.modest=0  nouveau.modeset=0  nomodeset</code> (参数之间空格间隔) 然后 ctrl+x 就可以进入安装界面了。但是此时的安装界面分辨率是900*400的，贼坑，还好我只是覆盖安装之前的Ubuntu16，所以自动安装也还凑合，如果要手动分区安装的话就悲剧了…</p>\n</li>\n<li><p>同样的，在安装完成之后重启进入ubuntu系统之前(在那个紫色的界面时)还要按 e 进入启动参数编辑界面，更改同上，进入系统之后，找到 系统设置&gt;软件和更新&gt;附加驱动，安装Nvidia的独显驱动然后重启即可。</p>\n</li>\n<li><p>按下 alt + F7 之后就可以不受限制地自由移动窗口了。</p>\n</li>\n<li><p>详见我知乎上的<a href=\"https://www.zhihu.com/question/276308597/answer/388030874\" target=\"_blank\" rel=\"noopener\">文章</a></p>\n</li>\n</ul>\n<h3 id=\"终端的字体\"><a href=\"#终端的字体\" class=\"headerlink\" title=\"终端的字体\"></a>终端的字体</h3><ul>\n<li>如果要自己更改一些字体的话，在tweak-tools 里面其他的字体都可以随便改，但是等宽字体不能随便该，否则终端的字体会出现交叠错乱的情况。终端的字体由等宽字体来控制，一定要选择以 “mono” 开头或者结尾的字体才不会出现问题。</li>\n</ul>\n<h2 id=\"相比较-Ubuntu-16-04LTS\"><a href=\"#相比较-Ubuntu-16-04LTS\" class=\"headerlink\" title=\"相比较 Ubuntu 16.04LTS\"></a>相比较 Ubuntu 16.04LTS</h2><hr>\n<ul>\n<li><p>网易云音乐比Ubuntu16更加坑了～我内心是万马奔腾的…</p>\n</li>\n<li><p>ss-Qt5也用不了，翻墙只能靠命令行ssr了</p>\n</li>\n<li><p>搜狗输入法也是各种安装失败，我也懒得搞了，但是Ubuntu 18 的内置中文输入法手感贼舒服～搜狗装不上也就算了</p>\n</li>\n</ul>\n<h2 id=\"Ubuntu的问题查询\"><a href=\"#Ubuntu的问题查询\" class=\"headerlink\" title=\"Ubuntu的问题查询\"></a>Ubuntu的问题查询</h2><hr>\n<ul>\n<li>很多时候国内的一些论坛无法解决我们在使用Ubuntu时遇到的一些问题，这时候就需要去一些国外的论坛上找我们需要的解答。这里推荐一个网站——<a href=\"https://askubuntu.com\" target=\"_blank\" rel=\"noopener\">askUbuntu</a></li>\n</ul>\n<h2 id=\"Ubuntu-18-下可以使用的-ssr\"><a href=\"#Ubuntu-18-下可以使用的-ssr\" class=\"headerlink\" title=\"Ubuntu 18 下可以使用的 ssr\"></a>Ubuntu 18 下可以使用的 ssr</h2><hr>\n<ul>\n<li><p><a href=\"https://github.com/erguotou520/electron-ssr/releases\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n</li>\n<li><p>配置方法与windows几乎一致</p>\n</li>\n</ul>\n<h2 id=\"关于网易云音乐安装之后必须要终端sudo才能打开的问题（巨坑已填！！）\"><a href=\"#关于网易云音乐安装之后必须要终端sudo才能打开的问题（巨坑已填！！）\" class=\"headerlink\" title=\"关于网易云音乐安装之后必须要终端sudo才能打开的问题（巨坑已填！！）\"></a>关于网易云音乐安装之后必须要终端sudo才能打开的问题（巨坑已填！！）</h2><hr>\n<ul>\n<li><p>首先sudo打开会有报错,但是会自动启动默认设置</p>\n</li>\n<li><p>根据报错我们可以进行对应的安装: <code>sudo apt-get install libcanberra-gtk-module</code></p>\n</li>\n<li><p>然后修改网易云音乐的desktop文件，在exec那一行 <code>%U</code> 之前 加上 <code>--no-sandbox</code>然后保存退出，重启电脑即可愉快的使用了～～(注意修改文件之前先要切换到root用户)</p>\n</li>\n<li><p>另一种神奇的打开方式(不需要上面的操作):启动之后，点关机按钮，弹出来确认框，随后网易乐音乐页面也弹出来了，这时取消关机，可以正常使用云音乐<del>~</del>~~</p>\n</li>\n</ul>\n<h2 id=\"关于ibus输入法的问题\"><a href=\"#关于ibus输入法的问题\" class=\"headerlink\" title=\"关于ibus输入法的问题\"></a>关于ibus输入法的问题</h2><hr>\n<ul>\n<li><p>最近输入法中文一直有问题，没办法选词。</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/AshinLi/article/details/72773989\" target=\"_blank\" rel=\"noopener\">博客链接</a></p>\n</li>\n<li><p>终端打开ibus设置命令：<code>ibus-setup</code></p>\n</li>\n<li><p>但是感觉上面这个办法并没有声什么卵用。。。。</p>\n</li>\n<li><p>所以我弃坑了，还是选择了搜狗输入法</p>\n</li>\n</ul>\n<h3 id=\"Ubuntu18-的搜狗输入法的安装\"><a href=\"#Ubuntu18-的搜狗输入法的安装\" class=\"headerlink\" title=\"Ubuntu18 的搜狗输入法的安装\"></a>Ubuntu18 的搜狗输入法的安装</h3><ul>\n<li><p>首先安装fcitx的相关依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install fictx-bin</span><br><span class=\"line\">sudo apt-get install fictx-table</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后安装下载好的搜狗输入法deb包<br><code>dpkg -i sougou...</code><br>这里应该会提示缺少依赖，这时候可就需要执行修复依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade -f</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>系统会自动修复缺少的依赖包</p>\n<ul>\n<li><p>然后我们就可以安装完搜狗输入法了。这时候在系统语言设置(右上角)里更改键盘输入法系统为fictx，然后把不用的输入法去掉。</p>\n</li>\n<li><p>最后重启电脑，打开fictx配置下搜狗输入法，把他调到第一个即可。</p>\n</li>\n<li><p>搜狗输入法支持登录一键同步，还是很好用的～</p>\n</li>\n</ul>\n<h3 id=\"搜狗輸入法的新坑\"><a href=\"#搜狗輸入法的新坑\" class=\"headerlink\" title=\"搜狗輸入法的新坑\"></a>搜狗輸入法的新坑</h3><ul>\n<li><p>Ubuntu18 自从安装以来一直问题不断。</p>\n</li>\n<li><p>最近启动电脑发现搜狗输入法的候选词栏全变成了乱码。。。坑爹啊</p>\n</li>\n<li><p>后来百度了解决方法：</p>\n</li>\n<li><p>首先遇到高级全都勾上以便显示出所有的可更改项<br>进入fictx设置&gt;&gt;附加组件&gt;&gt;简繁转换&gt;&gt;点击配置&gt;&gt;勾上显示高级选项&gt;&gt;将<code>sogoupinyin:false</code>改为<code>sogoupinyin:true</code></p>\n</li>\n<li><p>但是这个方法只管用一次…下次重启还要手动改~~垃圾</p>\n</li>\n<li><p>所以接下来这个方法貌似有用(亲测)</p>\n</li>\n<li><p>输入如下命令：(就是把你个人用户的一些配置删除掉然后重新创建)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/.config</span><br><span class=\"line\">sudo rm -rf SogouPY* sogou*</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>之后注销重新登录即可。</p>\n</li>\n<li><p><strong>就目前个人测试的结果看来，登录个人中心是元凶，登录之后必炸…还是老老实实地用最基本的功能吧，期待早日更新吧。</strong></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.14</p>\n</blockquote>\n"},{"layout":"post","title":"区块链一些相关概念的记录","date":"2018-05-17T02:47:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n## 一些主要的平台\n---\n\n- 比特币\n\n- [以太坊](https://ethereum.org/) (**需要翻墙**)\n\n- fabric\n\n- [EOS](https://eos.io/)\n\n## 一些概念\n---\n\n- 智能合约：智能合约是1994年由密码学家尼克萨博（Nick Szabo）首次提出的理念，几乎与互联网同龄。**智能合约是指能够自动执行合约条款的计算机程序**，在比特币出现以前，因为不存在安全可靠的执行环境，智能合约一直不能够应用到现实中。区块链由于其去中心化、公开透明等特性，天生就可以为智能合约提供可信的执行环境。所以，新型的区块链框架几乎都会内置智能合约的功能。\n\n- 图灵完备：图灵完备性(Turing Compeleteness)是指针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称他具有图灵完备性。——[参考](https://www.zhihu.com/question/20115374)\n\n> 简单来说，对于任何一个可以由计算解决的问题都能解决的编程语言或者是虚拟机称为是图灵完备的\n\n### 共识算法\n\n- POW(proof-of-work)：\n> 工作量证明机制。工作量证明同时也是一种代币分发机制，它通过经济激励的方式来鼓励节点参与区块的构造过程，节点在构造区块的时候需要穷举一个随机数以使得区块符合规定的难度要求，一旦区块链出现分叉，诚实的节点将选择工作量较大的链条，而抛弃工作量较小的。由于假设所有节点都是逐利的，而选择工作量较小的链条就会使自己获得的激励无效，所以最终所有的节点都会是诚实的，从而使每个节点的区块链数据都保持一致。\n\n- BFT(Byzantine Fault Tolerance):\n> 拜占庭容错模型的共识机制。节点被分为普通节点和记账节点（Validating Peer），只有记账节点才会参与到区块的构造过程，这种角色的分离使得算法的设计者有机会将运行共识算法的节点数量限定在一个可控的规模内。\n\n- PBFT(Practical Byzantine Fault Tolerance)：\n> 实用拜占庭容错算法。PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到`|R|-1`的整数表示每一个副本。为了描述方便，假设`|R|=3f+1`，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。\n\n- POS(Proof of Stake)：\n> 股权证明。类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。\n\n- DPOS(Delegated Proof of Stake)：\n> 委任权益证明。股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上，类似演唱会的黄牛，大量囤票而丝毫不关心演唱会的内容。\n\n- 石墨烯技术：\n> 石墨烯技术是新一代的区块链技术，基于DPOS共识算法。目前市场上流行的区块链阵营有三种，一种是第一代以比特币为主的生态体系，他们是基于POW共识，纯粹的去中心化，基于p2p的加密数字货币技术；第二种就是以以太坊构成的生态体系，主要以基于智能合约的ERC20的代币体系，他们是基于POW共识，目前以太坊正准备切换到POW+POS的多共识体系；第三种就是进化到目前最强劲的石墨烯技术生态体系，它是基于DPOS（股份授权证明共识），支持高并发，高性能等大规模工业级商业场景的基础设施，诞生了BTS（BitShare）开源商业系统，Steem去中心化社交网络平台以及EOS。特点：转账速度特别快，吞吐量tps极高，安全性很高，没有原生bug出现，功能强大，应用性极高。\n\n\n### 其他\n\n- WebAssembly：\n> WebAssembly(缩写Wasm)是一种基于堆栈的虚拟机的二进制指令格式。Wasm设计作为一个便携式的针对高级语言的编译器，例如C/C++/Rust，使各种客户端或服务端应用程序都能够在web中部署。\n\n- TPS(transaction per second)：\n> 服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。\n\n- QPS(quary per second)：\n> 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。\n对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。\n\n\n\n<br>\n- 一些参考文章：[比特币、以太坊、Fabric…你知道它们的优缺点吗？](https://blog.csdn.net/Blockchain_lemon/article/details/79236199)、\n[区块链3.0：拥抱EOS](https://www.cnblogs.com/Evsward/p/eos-intro.html)\n\n<br>\n> 最后更新于2018.5.17\n","source":"_posts/2018-05-17-BlockChain-concepts.md","raw":"---\nlayout:     post\ntitle:      \"区块链一些相关概念的记录\"\ndate:       2018-05-17 10:47:00\ncategories: Computer\ntags:   ๑BlockChain\n---\n\n> 不适合人类阅读的学习笔记\n\n## 一些主要的平台\n---\n\n- 比特币\n\n- [以太坊](https://ethereum.org/) (**需要翻墙**)\n\n- fabric\n\n- [EOS](https://eos.io/)\n\n## 一些概念\n---\n\n- 智能合约：智能合约是1994年由密码学家尼克萨博（Nick Szabo）首次提出的理念，几乎与互联网同龄。**智能合约是指能够自动执行合约条款的计算机程序**，在比特币出现以前，因为不存在安全可靠的执行环境，智能合约一直不能够应用到现实中。区块链由于其去中心化、公开透明等特性，天生就可以为智能合约提供可信的执行环境。所以，新型的区块链框架几乎都会内置智能合约的功能。\n\n- 图灵完备：图灵完备性(Turing Compeleteness)是指针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称他具有图灵完备性。——[参考](https://www.zhihu.com/question/20115374)\n\n> 简单来说，对于任何一个可以由计算解决的问题都能解决的编程语言或者是虚拟机称为是图灵完备的\n\n### 共识算法\n\n- POW(proof-of-work)：\n> 工作量证明机制。工作量证明同时也是一种代币分发机制，它通过经济激励的方式来鼓励节点参与区块的构造过程，节点在构造区块的时候需要穷举一个随机数以使得区块符合规定的难度要求，一旦区块链出现分叉，诚实的节点将选择工作量较大的链条，而抛弃工作量较小的。由于假设所有节点都是逐利的，而选择工作量较小的链条就会使自己获得的激励无效，所以最终所有的节点都会是诚实的，从而使每个节点的区块链数据都保持一致。\n\n- BFT(Byzantine Fault Tolerance):\n> 拜占庭容错模型的共识机制。节点被分为普通节点和记账节点（Validating Peer），只有记账节点才会参与到区块的构造过程，这种角色的分离使得算法的设计者有机会将运行共识算法的节点数量限定在一个可控的规模内。\n\n- PBFT(Practical Byzantine Fault Tolerance)：\n> 实用拜占庭容错算法。PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到`|R|-1`的整数表示每一个副本。为了描述方便，假设`|R|=3f+1`，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。\n\n- POS(Proof of Stake)：\n> 股权证明。类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。\n\n- DPOS(Delegated Proof of Stake)：\n> 委任权益证明。股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上，类似演唱会的黄牛，大量囤票而丝毫不关心演唱会的内容。\n\n- 石墨烯技术：\n> 石墨烯技术是新一代的区块链技术，基于DPOS共识算法。目前市场上流行的区块链阵营有三种，一种是第一代以比特币为主的生态体系，他们是基于POW共识，纯粹的去中心化，基于p2p的加密数字货币技术；第二种就是以以太坊构成的生态体系，主要以基于智能合约的ERC20的代币体系，他们是基于POW共识，目前以太坊正准备切换到POW+POS的多共识体系；第三种就是进化到目前最强劲的石墨烯技术生态体系，它是基于DPOS（股份授权证明共识），支持高并发，高性能等大规模工业级商业场景的基础设施，诞生了BTS（BitShare）开源商业系统，Steem去中心化社交网络平台以及EOS。特点：转账速度特别快，吞吐量tps极高，安全性很高，没有原生bug出现，功能强大，应用性极高。\n\n\n### 其他\n\n- WebAssembly：\n> WebAssembly(缩写Wasm)是一种基于堆栈的虚拟机的二进制指令格式。Wasm设计作为一个便携式的针对高级语言的编译器，例如C/C++/Rust，使各种客户端或服务端应用程序都能够在web中部署。\n\n- TPS(transaction per second)：\n> 服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。\n\n- QPS(quary per second)：\n> 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。\n对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。\n\n\n\n<br>\n- 一些参考文章：[比特币、以太坊、Fabric…你知道它们的优缺点吗？](https://blog.csdn.net/Blockchain_lemon/article/details/79236199)、\n[区块链3.0：拥抱EOS](https://www.cnblogs.com/Evsward/p/eos-intro.html)\n\n<br>\n> 最后更新于2018.5.17\n","slug":"2018-05-17-BlockChain-concepts","published":1,"updated":"2018-09-03T13:16:54.280Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4u001v1m0o9cbrml0u","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"一些主要的平台\"><a href=\"#一些主要的平台\" class=\"headerlink\" title=\"一些主要的平台\"></a>一些主要的平台</h2><hr>\n<ul>\n<li><p>比特币</p>\n</li>\n<li><p><a href=\"https://ethereum.org/\" target=\"_blank\" rel=\"noopener\">以太坊</a> (<strong>需要翻墙</strong>)</p>\n</li>\n<li><p>fabric</p>\n</li>\n<li><p><a href=\"https://eos.io/\" target=\"_blank\" rel=\"noopener\">EOS</a></p>\n</li>\n</ul>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><hr>\n<ul>\n<li><p>智能合约：智能合约是1994年由密码学家尼克萨博（Nick Szabo）首次提出的理念，几乎与互联网同龄。<strong>智能合约是指能够自动执行合约条款的计算机程序</strong>，在比特币出现以前，因为不存在安全可靠的执行环境，智能合约一直不能够应用到现实中。区块链由于其去中心化、公开透明等特性，天生就可以为智能合约提供可信的执行环境。所以，新型的区块链框架几乎都会内置智能合约的功能。</p>\n</li>\n<li><p>图灵完备：图灵完备性(Turing Compeleteness)是指针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称他具有图灵完备性。——<a href=\"https://www.zhihu.com/question/20115374\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n</li>\n</ul>\n<blockquote>\n<p>简单来说，对于任何一个可以由计算解决的问题都能解决的编程语言或者是虚拟机称为是图灵完备的</p>\n</blockquote>\n<h3 id=\"共识算法\"><a href=\"#共识算法\" class=\"headerlink\" title=\"共识算法\"></a>共识算法</h3><ul>\n<li><p>POW(proof-of-work)：</p>\n<blockquote>\n<p>工作量证明机制。工作量证明同时也是一种代币分发机制，它通过经济激励的方式来鼓励节点参与区块的构造过程，节点在构造区块的时候需要穷举一个随机数以使得区块符合规定的难度要求，一旦区块链出现分叉，诚实的节点将选择工作量较大的链条，而抛弃工作量较小的。由于假设所有节点都是逐利的，而选择工作量较小的链条就会使自己获得的激励无效，所以最终所有的节点都会是诚实的，从而使每个节点的区块链数据都保持一致。</p>\n</blockquote>\n</li>\n<li><p>BFT(Byzantine Fault Tolerance):</p>\n<blockquote>\n<p>拜占庭容错模型的共识机制。节点被分为普通节点和记账节点（Validating Peer），只有记账节点才会参与到区块的构造过程，这种角色的分离使得算法的设计者有机会将运行共识算法的节点数量限定在一个可控的规模内。</p>\n</blockquote>\n</li>\n<li><p>PBFT(Practical Byzantine Fault Tolerance)：</p>\n<blockquote>\n<p>实用拜占庭容错算法。PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到<code>|R|-1</code>的整数表示每一个副本。为了描述方便，假设<code>|R|=3f+1</code>，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。</p>\n</blockquote>\n</li>\n<li><p>POS(Proof of Stake)：</p>\n<blockquote>\n<p>股权证明。类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。</p>\n</blockquote>\n</li>\n<li><p>DPOS(Delegated Proof of Stake)：</p>\n<blockquote>\n<p>委任权益证明。股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上，类似演唱会的黄牛，大量囤票而丝毫不关心演唱会的内容。</p>\n</blockquote>\n</li>\n<li><p>石墨烯技术：</p>\n<blockquote>\n<p>石墨烯技术是新一代的区块链技术，基于DPOS共识算法。目前市场上流行的区块链阵营有三种，一种是第一代以比特币为主的生态体系，他们是基于POW共识，纯粹的去中心化，基于p2p的加密数字货币技术；第二种就是以以太坊构成的生态体系，主要以基于智能合约的ERC20的代币体系，他们是基于POW共识，目前以太坊正准备切换到POW+POS的多共识体系；第三种就是进化到目前最强劲的石墨烯技术生态体系，它是基于DPOS（股份授权证明共识），支持高并发，高性能等大规模工业级商业场景的基础设施，诞生了BTS（BitShare）开源商业系统，Steem去中心化社交网络平台以及EOS。特点：转账速度特别快，吞吐量tps极高，安全性很高，没有原生bug出现，功能强大，应用性极高。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><p>WebAssembly：</p>\n<blockquote>\n<p>WebAssembly(缩写Wasm)是一种基于堆栈的虚拟机的二进制指令格式。Wasm设计作为一个便携式的针对高级语言的编译器，例如C/C++/Rust，使各种客户端或服务端应用程序都能够在web中部署。</p>\n</blockquote>\n</li>\n<li><p>TPS(transaction per second)：</p>\n<blockquote>\n<p>服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。</p>\n</blockquote>\n</li>\n<li><p>QPS(quary per second)：</p>\n<blockquote>\n<p>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。<br>对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</p>\n</blockquote>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li>一些参考文章：<a href=\"https://blog.csdn.net/Blockchain_lemon/article/details/79236199\" target=\"_blank\" rel=\"noopener\">比特币、以太坊、Fabric…你知道它们的优缺点吗？</a>、<br><a href=\"https://www.cnblogs.com/Evsward/p/eos-intro.html\" target=\"_blank\" rel=\"noopener\">区块链3.0：拥抱EOS</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.17</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"一些主要的平台\"><a href=\"#一些主要的平台\" class=\"headerlink\" title=\"一些主要的平台\"></a>一些主要的平台</h2><hr>\n<ul>\n<li><p>比特币</p>\n</li>\n<li><p><a href=\"https://ethereum.org/\" target=\"_blank\" rel=\"noopener\">以太坊</a> (<strong>需要翻墙</strong>)</p>\n</li>\n<li><p>fabric</p>\n</li>\n<li><p><a href=\"https://eos.io/\" target=\"_blank\" rel=\"noopener\">EOS</a></p>\n</li>\n</ul>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><hr>\n<ul>\n<li><p>智能合约：智能合约是1994年由密码学家尼克萨博（Nick Szabo）首次提出的理念，几乎与互联网同龄。<strong>智能合约是指能够自动执行合约条款的计算机程序</strong>，在比特币出现以前，因为不存在安全可靠的执行环境，智能合约一直不能够应用到现实中。区块链由于其去中心化、公开透明等特性，天生就可以为智能合约提供可信的执行环境。所以，新型的区块链框架几乎都会内置智能合约的功能。</p>\n</li>\n<li><p>图灵完备：图灵完备性(Turing Compeleteness)是指针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称他具有图灵完备性。——<a href=\"https://www.zhihu.com/question/20115374\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n</li>\n</ul>\n<blockquote>\n<p>简单来说，对于任何一个可以由计算解决的问题都能解决的编程语言或者是虚拟机称为是图灵完备的</p>\n</blockquote>\n<h3 id=\"共识算法\"><a href=\"#共识算法\" class=\"headerlink\" title=\"共识算法\"></a>共识算法</h3><ul>\n<li><p>POW(proof-of-work)：</p>\n<blockquote>\n<p>工作量证明机制。工作量证明同时也是一种代币分发机制，它通过经济激励的方式来鼓励节点参与区块的构造过程，节点在构造区块的时候需要穷举一个随机数以使得区块符合规定的难度要求，一旦区块链出现分叉，诚实的节点将选择工作量较大的链条，而抛弃工作量较小的。由于假设所有节点都是逐利的，而选择工作量较小的链条就会使自己获得的激励无效，所以最终所有的节点都会是诚实的，从而使每个节点的区块链数据都保持一致。</p>\n</blockquote>\n</li>\n<li><p>BFT(Byzantine Fault Tolerance):</p>\n<blockquote>\n<p>拜占庭容错模型的共识机制。节点被分为普通节点和记账节点（Validating Peer），只有记账节点才会参与到区块的构造过程，这种角色的分离使得算法的设计者有机会将运行共识算法的节点数量限定在一个可控的规模内。</p>\n</blockquote>\n</li>\n<li><p>PBFT(Practical Byzantine Fault Tolerance)：</p>\n<blockquote>\n<p>实用拜占庭容错算法。PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到<code>|R|-1</code>的整数表示每一个副本。为了描述方便，假设<code>|R|=3f+1</code>，这里f是有可能失效的副本的最大个数。尽管可以存在多于3f+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。</p>\n</blockquote>\n</li>\n<li><p>POS(Proof of Stake)：</p>\n<blockquote>\n<p>股权证明。类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。</p>\n</blockquote>\n</li>\n<li><p>DPOS(Delegated Proof of Stake)：</p>\n<blockquote>\n<p>委任权益证明。股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上，类似演唱会的黄牛，大量囤票而丝毫不关心演唱会的内容。</p>\n</blockquote>\n</li>\n<li><p>石墨烯技术：</p>\n<blockquote>\n<p>石墨烯技术是新一代的区块链技术，基于DPOS共识算法。目前市场上流行的区块链阵营有三种，一种是第一代以比特币为主的生态体系，他们是基于POW共识，纯粹的去中心化，基于p2p的加密数字货币技术；第二种就是以以太坊构成的生态体系，主要以基于智能合约的ERC20的代币体系，他们是基于POW共识，目前以太坊正准备切换到POW+POS的多共识体系；第三种就是进化到目前最强劲的石墨烯技术生态体系，它是基于DPOS（股份授权证明共识），支持高并发，高性能等大规模工业级商业场景的基础设施，诞生了BTS（BitShare）开源商业系统，Steem去中心化社交网络平台以及EOS。特点：转账速度特别快，吞吐量tps极高，安全性很高，没有原生bug出现，功能强大，应用性极高。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><p>WebAssembly：</p>\n<blockquote>\n<p>WebAssembly(缩写Wasm)是一种基于堆栈的虚拟机的二进制指令格式。Wasm设计作为一个便携式的针对高级语言的编译器，例如C/C++/Rust，使各种客户端或服务端应用程序都能够在web中部署。</p>\n</blockquote>\n</li>\n<li><p>TPS(transaction per second)：</p>\n<blockquote>\n<p>服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。</p>\n</blockquote>\n</li>\n<li><p>QPS(quary per second)：</p>\n<blockquote>\n<p>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。<br>对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</p>\n</blockquote>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li>一些参考文章：<a href=\"https://blog.csdn.net/Blockchain_lemon/article/details/79236199\" target=\"_blank\" rel=\"noopener\">比特币、以太坊、Fabric…你知道它们的优缺点吗？</a>、<br><a href=\"https://www.cnblogs.com/Evsward/p/eos-intro.html\" target=\"_blank\" rel=\"noopener\">区块链3.0：拥抱EOS</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.17</p>\n</blockquote>\n"},{"layout":"post","title":"Node.js学习笔记","date":"2018-05-21T02:47:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n- **javascript每个语句结尾不要忘了分号**\n\n## Ubuntu 下的node.js环境搭建\n---\n\n- 首先去nodejs的官网下载最新的版本，解压缩。然后移动到 `/opt/`目录下 (纯粹个人习惯)\n\n- 然后编辑路径：\n```\nsudo su\nvim /etc/profile\n```\n\n- 然后在最后插入:(具体路径以实际为准)\n```\nexport NODEJS_HOME=/opt/node-v8.11.2-linux-x64\nexport PATH=$NODEJS_HOME/bin:$PATH\n```\n\n- 最后执行`source /etc/profile` 或者重启电脑即可使之生效。\n\n- 终端输入：`node -v`查看，如果能正确现实版本号，则说明配置成功。\n\n\n## Hello world\n---\n\n- 在常用目录下新建一个`HelloWorld.js`纯文本文件，在其中写入：\n```\n'use strict';\nconsole.log('Hello, world.');\n```\n\n- 第一行总是写上 `'use strict';` 是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。\n\n- 保存退出，执行 `node HellowWorld.js`即可得到结果。(终端输出“Hello,world.”)\n\n- 在交互模式下，单行命令一般不用加分号(有时候加分号还会报错)\n\n## 交互模式\n---\n\n- 在终端输入 `node` 即可进入 node.js的交互环境，我们可以直接输入javascript代码并直接执行。\n\n- 进入交互模式实际上是进入了node的解释器，交互模式下node会直接打印每一个语句的结果，而写在js文件里的代码想要输出结果，必须自己用console.log()打印出来。(这与python，scala的命令行解释器特性一致)\n\n## 使用严格模式\n---\n\n- 如果在JavaScript文件开头写上`'use strict'`;，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上`'use strict'`;很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：`node --use_strict XXX.js`\n\n## IDE开发环境\n---\n\n### 在集成开发环境intellij IDEA下使用nodejs\n\n- 我们可以尝试获取免费的注册码。\n\n- 上述注册码的[获取地址](http://idea.lanyus.com/)\n\n\n#### hosts 文件路径\n\n- 在 iOS 系统中中，hosts文件的位置为：`~/private/etc`\n\n- 在 Windows 系统中，hosts文件的位置为：`C:\\Windows\\System32\\drivers\\etc`\n\n- 在 Ubuntu 系统中，hosts文件的位置为：`/etc`\n\n## jetbrains学生免费账号申请\n---\n\n- [Jetbrains学生免费账号申请](https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F)\n\n- 申请流程其实很简单，你需要一个你们学校的邮箱即可。然后验证通过之后会发送验证邮件，依次填写并且最终注册完账号即可激活。**有效期至毕业。**\n\n- 成功激活：\n\n![](/images/node.js/info.png)\n\n\n## 模块\n---\n\n- 在Node环境中，一个.js文件就称之为一个模块（module）。\n\n- 分模块的好处是编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。\n\n- 例如，我们在一个js文件(hello.js)中写一个函数：\n```\n'use strict';\nvar s = 'Hello';\nfunction greet(name) {\n    console.log(s + ', ' + name + '!');\n}\nmodule.exports = greet;\n```\n- 函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。\n\n- 其他模块对本模块的调用,此处写一个main.js：\n```\n'use strict';\n// 引入hello模块:\nvar greet = require('./hello');\nvar s = 'Michael';\ngreet(s); // Hello, Michael!\n```\n\n- 引入hello模块用Node提供的require函数,引入的模块作为变量保存在greet变量中。`./hello`表明hello.js和main.js是在同一个目录下，这里需要写 **相对目录**。\n\n### CommonJS规范\n\n- 这个规范保证了各个模块之间的同名变量和函数不会冲突\n\n- 一个模块想要对外暴露变量（函数也是变量），可以用`module.exports = variable;`，一个模块要引用其他模块暴露的变量，用`var ref = require('module_name');`就拿到了引用模块的变量。\n\n- 输出的变量可以是任意对象、函数、数组等等\n\n- 引入的对象具体是什么，取决于引入模块输出的对象\n\n- javascript本身并不支持同名函数或者变量冲突的处理，而node.js实现这一功能的原理是，JavaScript是一个函数式编程语言，node.js将每个模块包装为一个函数，这样这个模块里的变量就都成为了局部变量，这样就避免了冲突。——[详细教程](https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000)\n\n<br>\n> 最后更新于2018.5.24\n","source":"_posts/2018-05-21-NodeJS.md","raw":"---\nlayout:     post\ntitle:      \"Node.js学习笔记\"\ndate:       2018-05-21 10:47:00\ncategories: FrontEnd\ntags:   [๑JS, ๑FrontEnd]\n---\n\n> 不适合人类阅读的学习笔记\n\n- **javascript每个语句结尾不要忘了分号**\n\n## Ubuntu 下的node.js环境搭建\n---\n\n- 首先去nodejs的官网下载最新的版本，解压缩。然后移动到 `/opt/`目录下 (纯粹个人习惯)\n\n- 然后编辑路径：\n```\nsudo su\nvim /etc/profile\n```\n\n- 然后在最后插入:(具体路径以实际为准)\n```\nexport NODEJS_HOME=/opt/node-v8.11.2-linux-x64\nexport PATH=$NODEJS_HOME/bin:$PATH\n```\n\n- 最后执行`source /etc/profile` 或者重启电脑即可使之生效。\n\n- 终端输入：`node -v`查看，如果能正确现实版本号，则说明配置成功。\n\n\n## Hello world\n---\n\n- 在常用目录下新建一个`HelloWorld.js`纯文本文件，在其中写入：\n```\n'use strict';\nconsole.log('Hello, world.');\n```\n\n- 第一行总是写上 `'use strict';` 是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。\n\n- 保存退出，执行 `node HellowWorld.js`即可得到结果。(终端输出“Hello,world.”)\n\n- 在交互模式下，单行命令一般不用加分号(有时候加分号还会报错)\n\n## 交互模式\n---\n\n- 在终端输入 `node` 即可进入 node.js的交互环境，我们可以直接输入javascript代码并直接执行。\n\n- 进入交互模式实际上是进入了node的解释器，交互模式下node会直接打印每一个语句的结果，而写在js文件里的代码想要输出结果，必须自己用console.log()打印出来。(这与python，scala的命令行解释器特性一致)\n\n## 使用严格模式\n---\n\n- 如果在JavaScript文件开头写上`'use strict'`;，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上`'use strict'`;很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：`node --use_strict XXX.js`\n\n## IDE开发环境\n---\n\n### 在集成开发环境intellij IDEA下使用nodejs\n\n- 我们可以尝试获取免费的注册码。\n\n- 上述注册码的[获取地址](http://idea.lanyus.com/)\n\n\n#### hosts 文件路径\n\n- 在 iOS 系统中中，hosts文件的位置为：`~/private/etc`\n\n- 在 Windows 系统中，hosts文件的位置为：`C:\\Windows\\System32\\drivers\\etc`\n\n- 在 Ubuntu 系统中，hosts文件的位置为：`/etc`\n\n## jetbrains学生免费账号申请\n---\n\n- [Jetbrains学生免费账号申请](https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F)\n\n- 申请流程其实很简单，你需要一个你们学校的邮箱即可。然后验证通过之后会发送验证邮件，依次填写并且最终注册完账号即可激活。**有效期至毕业。**\n\n- 成功激活：\n\n![](/images/node.js/info.png)\n\n\n## 模块\n---\n\n- 在Node环境中，一个.js文件就称之为一个模块（module）。\n\n- 分模块的好处是编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。\n\n- 例如，我们在一个js文件(hello.js)中写一个函数：\n```\n'use strict';\nvar s = 'Hello';\nfunction greet(name) {\n    console.log(s + ', ' + name + '!');\n}\nmodule.exports = greet;\n```\n- 函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。\n\n- 其他模块对本模块的调用,此处写一个main.js：\n```\n'use strict';\n// 引入hello模块:\nvar greet = require('./hello');\nvar s = 'Michael';\ngreet(s); // Hello, Michael!\n```\n\n- 引入hello模块用Node提供的require函数,引入的模块作为变量保存在greet变量中。`./hello`表明hello.js和main.js是在同一个目录下，这里需要写 **相对目录**。\n\n### CommonJS规范\n\n- 这个规范保证了各个模块之间的同名变量和函数不会冲突\n\n- 一个模块想要对外暴露变量（函数也是变量），可以用`module.exports = variable;`，一个模块要引用其他模块暴露的变量，用`var ref = require('module_name');`就拿到了引用模块的变量。\n\n- 输出的变量可以是任意对象、函数、数组等等\n\n- 引入的对象具体是什么，取决于引入模块输出的对象\n\n- javascript本身并不支持同名函数或者变量冲突的处理，而node.js实现这一功能的原理是，JavaScript是一个函数式编程语言，node.js将每个模块包装为一个函数，这样这个模块里的变量就都成为了局部变量，这样就避免了冲突。——[详细教程](https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000)\n\n<br>\n> 最后更新于2018.5.24\n","slug":"2018-05-21-NodeJS","published":1,"updated":"2018-09-03T13:41:55.721Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4v001y1m0oc1tkgvia","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<ul>\n<li><strong>javascript每个语句结尾不要忘了分号</strong></li>\n</ul>\n<h2 id=\"Ubuntu-下的node-js环境搭建\"><a href=\"#Ubuntu-下的node-js环境搭建\" class=\"headerlink\" title=\"Ubuntu 下的node.js环境搭建\"></a>Ubuntu 下的node.js环境搭建</h2><hr>\n<ul>\n<li><p>首先去nodejs的官网下载最新的版本，解压缩。然后移动到 <code>/opt/</code>目录下 (纯粹个人习惯)</p>\n</li>\n<li><p>然后编辑路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo su</span><br><span class=\"line\">vim /etc/profile</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在最后插入:(具体路径以实际为准)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export NODEJS_HOME=/opt/node-v8.11.2-linux-x64</span><br><span class=\"line\">export PATH=$NODEJS_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后执行<code>source /etc/profile</code> 或者重启电脑即可使之生效。</p>\n</li>\n<li><p>终端输入：<code>node -v</code>查看，如果能正确现实版本号，则说明配置成功。</p>\n</li>\n</ul>\n<h2 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h2><hr>\n<ul>\n<li><p>在常用目录下新建一个<code>HelloWorld.js</code>纯文本文件，在其中写入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">console.log(&apos;Hello, world.&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第一行总是写上 <code>&#39;use strict&#39;;</code> 是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。</p>\n</li>\n<li><p>保存退出，执行 <code>node HellowWorld.js</code>即可得到结果。(终端输出“Hello,world.”)</p>\n</li>\n<li><p>在交互模式下，单行命令一般不用加分号(有时候加分号还会报错)</p>\n</li>\n</ul>\n<h2 id=\"交互模式\"><a href=\"#交互模式\" class=\"headerlink\" title=\"交互模式\"></a>交互模式</h2><hr>\n<ul>\n<li><p>在终端输入 <code>node</code> 即可进入 node.js的交互环境，我们可以直接输入javascript代码并直接执行。</p>\n</li>\n<li><p>进入交互模式实际上是进入了node的解释器，交互模式下node会直接打印每一个语句的结果，而写在js文件里的代码想要输出结果，必须自己用console.log()打印出来。(这与python，scala的命令行解释器特性一致)</p>\n</li>\n</ul>\n<h2 id=\"使用严格模式\"><a href=\"#使用严格模式\" class=\"headerlink\" title=\"使用严格模式\"></a>使用严格模式</h2><hr>\n<ul>\n<li>如果在JavaScript文件开头写上<code>&#39;use strict&#39;</code>;，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上<code>&#39;use strict&#39;</code>;很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：<code>node --use_strict XXX.js</code></li>\n</ul>\n<h2 id=\"IDE开发环境\"><a href=\"#IDE开发环境\" class=\"headerlink\" title=\"IDE开发环境\"></a>IDE开发环境</h2><hr>\n<h3 id=\"在集成开发环境intellij-IDEA下使用nodejs\"><a href=\"#在集成开发环境intellij-IDEA下使用nodejs\" class=\"headerlink\" title=\"在集成开发环境intellij IDEA下使用nodejs\"></a>在集成开发环境intellij IDEA下使用nodejs</h3><ul>\n<li><p>我们可以尝试获取免费的注册码。</p>\n</li>\n<li><p>上述注册码的<a href=\"http://idea.lanyus.com/\" target=\"_blank\" rel=\"noopener\">获取地址</a></p>\n</li>\n</ul>\n<h4 id=\"hosts-文件路径\"><a href=\"#hosts-文件路径\" class=\"headerlink\" title=\"hosts 文件路径\"></a>hosts 文件路径</h4><ul>\n<li><p>在 iOS 系统中中，hosts文件的位置为：<code>~/private/etc</code></p>\n</li>\n<li><p>在 Windows 系统中，hosts文件的位置为：<code>C:\\Windows\\System32\\drivers\\etc</code></p>\n</li>\n<li><p>在 Ubuntu 系统中，hosts文件的位置为：<code>/etc</code></p>\n</li>\n</ul>\n<h2 id=\"jetbrains学生免费账号申请\"><a href=\"#jetbrains学生免费账号申请\" class=\"headerlink\" title=\"jetbrains学生免费账号申请\"></a>jetbrains学生免费账号申请</h2><hr>\n<ul>\n<li><p><a href=\"https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">Jetbrains学生免费账号申请</a></p>\n</li>\n<li><p>申请流程其实很简单，你需要一个你们学校的邮箱即可。然后验证通过之后会发送验证邮件，依次填写并且最终注册完账号即可激活。<strong>有效期至毕业。</strong></p>\n</li>\n<li><p>成功激活：</p>\n</li>\n</ul>\n<p><img src=\"/images/node.js/info.png\" alt=\"\"></p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><hr>\n<ul>\n<li><p>在Node环境中，一个.js文件就称之为一个模块（module）。</p>\n</li>\n<li><p>分模块的好处是编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。</p>\n</li>\n<li><p>例如，我们在一个js文件(hello.js)中写一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">var s = &apos;Hello&apos;;</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">    console.log(s + &apos;, &apos; + name + &apos;!&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = greet;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。</p>\n</li>\n<li><p>其他模块对本模块的调用,此处写一个main.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">// 引入hello模块:</span><br><span class=\"line\">var greet = require(&apos;./hello&apos;);</span><br><span class=\"line\">var s = &apos;Michael&apos;;</span><br><span class=\"line\">greet(s); // Hello, Michael!</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入hello模块用Node提供的require函数,引入的模块作为变量保存在greet变量中。<code>./hello</code>表明hello.js和main.js是在同一个目录下，这里需要写 <strong>相对目录</strong>。</p>\n</li>\n</ul>\n<h3 id=\"CommonJS规范\"><a href=\"#CommonJS规范\" class=\"headerlink\" title=\"CommonJS规范\"></a>CommonJS规范</h3><ul>\n<li><p>这个规范保证了各个模块之间的同名变量和函数不会冲突</p>\n</li>\n<li><p>一个模块想要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用<code>var ref = require(&#39;module_name&#39;);</code>就拿到了引用模块的变量。</p>\n</li>\n<li><p>输出的变量可以是任意对象、函数、数组等等</p>\n</li>\n<li><p>引入的对象具体是什么，取决于引入模块输出的对象</p>\n</li>\n<li><p>javascript本身并不支持同名函数或者变量冲突的处理，而node.js实现这一功能的原理是，JavaScript是一个函数式编程语言，node.js将每个模块包装为一个函数，这样这个模块里的变量就都成为了局部变量，这样就避免了冲突。——<a href=\"https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000\" target=\"_blank\" rel=\"noopener\">详细教程</a></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.24</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<ul>\n<li><strong>javascript每个语句结尾不要忘了分号</strong></li>\n</ul>\n<h2 id=\"Ubuntu-下的node-js环境搭建\"><a href=\"#Ubuntu-下的node-js环境搭建\" class=\"headerlink\" title=\"Ubuntu 下的node.js环境搭建\"></a>Ubuntu 下的node.js环境搭建</h2><hr>\n<ul>\n<li><p>首先去nodejs的官网下载最新的版本，解压缩。然后移动到 <code>/opt/</code>目录下 (纯粹个人习惯)</p>\n</li>\n<li><p>然后编辑路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo su</span><br><span class=\"line\">vim /etc/profile</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在最后插入:(具体路径以实际为准)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export NODEJS_HOME=/opt/node-v8.11.2-linux-x64</span><br><span class=\"line\">export PATH=$NODEJS_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后执行<code>source /etc/profile</code> 或者重启电脑即可使之生效。</p>\n</li>\n<li><p>终端输入：<code>node -v</code>查看，如果能正确现实版本号，则说明配置成功。</p>\n</li>\n</ul>\n<h2 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h2><hr>\n<ul>\n<li><p>在常用目录下新建一个<code>HelloWorld.js</code>纯文本文件，在其中写入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">console.log(&apos;Hello, world.&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第一行总是写上 <code>&#39;use strict&#39;;</code> 是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。</p>\n</li>\n<li><p>保存退出，执行 <code>node HellowWorld.js</code>即可得到结果。(终端输出“Hello,world.”)</p>\n</li>\n<li><p>在交互模式下，单行命令一般不用加分号(有时候加分号还会报错)</p>\n</li>\n</ul>\n<h2 id=\"交互模式\"><a href=\"#交互模式\" class=\"headerlink\" title=\"交互模式\"></a>交互模式</h2><hr>\n<ul>\n<li><p>在终端输入 <code>node</code> 即可进入 node.js的交互环境，我们可以直接输入javascript代码并直接执行。</p>\n</li>\n<li><p>进入交互模式实际上是进入了node的解释器，交互模式下node会直接打印每一个语句的结果，而写在js文件里的代码想要输出结果，必须自己用console.log()打印出来。(这与python，scala的命令行解释器特性一致)</p>\n</li>\n</ul>\n<h2 id=\"使用严格模式\"><a href=\"#使用严格模式\" class=\"headerlink\" title=\"使用严格模式\"></a>使用严格模式</h2><hr>\n<ul>\n<li>如果在JavaScript文件开头写上<code>&#39;use strict&#39;</code>;，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上<code>&#39;use strict&#39;</code>;很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：<code>node --use_strict XXX.js</code></li>\n</ul>\n<h2 id=\"IDE开发环境\"><a href=\"#IDE开发环境\" class=\"headerlink\" title=\"IDE开发环境\"></a>IDE开发环境</h2><hr>\n<h3 id=\"在集成开发环境intellij-IDEA下使用nodejs\"><a href=\"#在集成开发环境intellij-IDEA下使用nodejs\" class=\"headerlink\" title=\"在集成开发环境intellij IDEA下使用nodejs\"></a>在集成开发环境intellij IDEA下使用nodejs</h3><ul>\n<li><p>我们可以尝试获取免费的注册码。</p>\n</li>\n<li><p>上述注册码的<a href=\"http://idea.lanyus.com/\" target=\"_blank\" rel=\"noopener\">获取地址</a></p>\n</li>\n</ul>\n<h4 id=\"hosts-文件路径\"><a href=\"#hosts-文件路径\" class=\"headerlink\" title=\"hosts 文件路径\"></a>hosts 文件路径</h4><ul>\n<li><p>在 iOS 系统中中，hosts文件的位置为：<code>~/private/etc</code></p>\n</li>\n<li><p>在 Windows 系统中，hosts文件的位置为：<code>C:\\Windows\\System32\\drivers\\etc</code></p>\n</li>\n<li><p>在 Ubuntu 系统中，hosts文件的位置为：<code>/etc</code></p>\n</li>\n</ul>\n<h2 id=\"jetbrains学生免费账号申请\"><a href=\"#jetbrains学生免费账号申请\" class=\"headerlink\" title=\"jetbrains学生免费账号申请\"></a>jetbrains学生免费账号申请</h2><hr>\n<ul>\n<li><p><a href=\"https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">Jetbrains学生免费账号申请</a></p>\n</li>\n<li><p>申请流程其实很简单，你需要一个你们学校的邮箱即可。然后验证通过之后会发送验证邮件，依次填写并且最终注册完账号即可激活。<strong>有效期至毕业。</strong></p>\n</li>\n<li><p>成功激活：</p>\n</li>\n</ul>\n<p><img src=\"/images/node.js/info.png\" alt=\"\"></p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><hr>\n<ul>\n<li><p>在Node环境中，一个.js文件就称之为一个模块（module）。</p>\n</li>\n<li><p>分模块的好处是编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。</p>\n</li>\n<li><p>例如，我们在一个js文件(hello.js)中写一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">var s = &apos;Hello&apos;;</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">    console.log(s + &apos;, &apos; + name + &apos;!&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = greet;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。</p>\n</li>\n<li><p>其他模块对本模块的调用,此处写一个main.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">// 引入hello模块:</span><br><span class=\"line\">var greet = require(&apos;./hello&apos;);</span><br><span class=\"line\">var s = &apos;Michael&apos;;</span><br><span class=\"line\">greet(s); // Hello, Michael!</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入hello模块用Node提供的require函数,引入的模块作为变量保存在greet变量中。<code>./hello</code>表明hello.js和main.js是在同一个目录下，这里需要写 <strong>相对目录</strong>。</p>\n</li>\n</ul>\n<h3 id=\"CommonJS规范\"><a href=\"#CommonJS规范\" class=\"headerlink\" title=\"CommonJS规范\"></a>CommonJS规范</h3><ul>\n<li><p>这个规范保证了各个模块之间的同名变量和函数不会冲突</p>\n</li>\n<li><p>一个模块想要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用<code>var ref = require(&#39;module_name&#39;);</code>就拿到了引用模块的变量。</p>\n</li>\n<li><p>输出的变量可以是任意对象、函数、数组等等</p>\n</li>\n<li><p>引入的对象具体是什么，取决于引入模块输出的对象</p>\n</li>\n<li><p>javascript本身并不支持同名函数或者变量冲突的处理，而node.js实现这一功能的原理是，JavaScript是一个函数式编程语言，node.js将每个模块包装为一个函数，这样这个模块里的变量就都成为了局部变量，这样就避免了冲突。——<a href=\"https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000\" target=\"_blank\" rel=\"noopener\">详细教程</a></p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.24</p>\n</blockquote>\n"},{"layout":"post","title":"以太坊(ethereum)开发","date":"2018-05-22T21:59:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n- **[以太坊社区](https://ethfans.org/)**\n\n## 安装Truffle\n---\n### Node.js安装\n\n- 先要进行node.js环境的安装，见上一篇博客。\n\n### 命令行安装truffle\n\n- 执行命令 ` npm install -g truffle`\n\n## 创建工程\n---\n\n-  执行命令 `truffle init`\n\n- truffle init会默认创建一个构建在以太坊内的代币demo应用。我们可以使用这个工程来进行快速的学习。\n\n- `init` 之后目录下就会有若干文件和文件夹。结构如下：\n![](images/block_chain/structure.png)\n\n- contracts目录中包含Solidity合约代码，其中Migrations.sol是必须有的，其他就是你自己写的合约代码了。\n\n- migrations目录中包含合约部署脚本，其中1_initial_migration.js就是用来部署Migrations.sol的，其他的脚本会按照顺序依次执行。\n\n- test目录保存用来测试应用和合约的测试文件\n\n- truffle.js - Truffle的配置文件\n\n- 官方文档(命令行指令，前面要加truffle)：\n\n```\nCommands:\n  init      //Initialize new and empty Ethereum project\n  compile   //Compile contract source files\n  migrate   //Run migrations to deploy contracts\n  deploy    //(alias for migrate)\n  build     //Execute build pipeline (if configuration present)\n  test      //Run JavaScript and Solidity tests\n  debug     //Interactively debug any transaction on the blockchain (experimental)\n  opcode    //Print the compiled opcodes for a given contract\n  console   //Run a console with contract abstractions and commands available\n  develop   //Open a console with a local development blockchain\n  create    //Helper to create new contracts, migrations and tests\n  install   //Install a package from the Ethereum Package Registry\n  publish   //Publish a package to the Ethereum Package Registry\n  networks  //Show addresses for deployed contracts on each network\n  watch     //Watch filesystem for changes and rebuild the project automatically\n  serve     //Serve the build directory on localhost and watch for changes\n  exec      //Execute a JS module within this Truffle environment\n  unbox     //Download a Truffle Box, a pre-built Truffle project\n  version   //Show version number and exit\n```\n终端输入`truffle`即可查看上述命令\n\n## 安装以太坊客户端\n---\n\n- 这里我们选择了Ganache——[github项目](https://github.com/trufflesuite/ganache-cli)\n\n- [图形版本下载地址](https://github.com/trufflesuite/ganache/releases)(linux下载 XX.AppImage文件格式的)\n\n- 命令行版本（ganache-cli）下载 `npm install -g ganache-cli`\n\n- Ganache的前身是testRPC\n\n## 编译和部署合约\n---\n\n- Ganache默认运行在7545端口，可以在界面右上方的“设置”里进行更改。运行后默认创建10个账号，每个账号里有100ETH的余额。\n要部署到链上，需要把IP、端口、网络ID告诉truffle。\n\n- 若要修改，则修改truffle.js：\n```\nmodule.exports = {  \n    networks: {  \n        development: {  \n            host: 'localhost',  \n            port: '7545',  \n            network_id: '*' // Match any network id  \n        }  \n    }  \n};  \n```\n\n### 编译合约\n\n#### 合约位置\n\n- 所有你的合约应该位于`./contracts`目录。默认我们提供了一个合约文件，一个库文件，均以.sol结尾作为示例。尽管库文件有一定的特殊性，但为简单起见，当前均称之为合约。\n\n- `truffle cmpile` 仅默认编译自上次编译后被修改过的文件，来减少不必要的编译。如果你想编译全部文件，可以使用--compile-all选项。\n\n#### 约定\n\n- Truffle需要定义的合约名称和文件名准确匹配。例如，如果文件名为 `MyContract.sol`，那么合约文件须为如下两者之一(并且匹配 **区分大小写**)：\n```\ncontract MyContract {\n  ...\n}\n// or\nlibrary MyContract {\n  ...\n}\n```\n\n- 编译目录:编译的输出位于`./build/contracts` 目录。如果目录不存在会自动创建。这些编译文件对于Truffle框架能否正常工作至关重要。你不应该在正常的编译或发布以外手动修改这些文件。\n\n### 移植\n\n- 命令 `truffle migrate`\n\n- 这个命令会执行所有的位于 `migrations` 目录内的移植脚本。如果你之前的移植是成功执行的。`truffle migrate` 仅会执行新创建的移植。如果没有新的移植脚本，这个命令不同执行任何操作。可以使用选项 `--reset`来从头执行移植脚本。\n\n### 修改配置\n\n- Ganache默认运行在7545端口，可以在界面右上方的“设置”里进行更改。运行后默认创建10个账号，每个账号里有100ETH的余额。\n要部署到链上，需要把IP、端口、网络ID告诉truffle。修改truffle.js：\n```\nmodule.exports = {\n  networks: {\n    development: {\n      host: \"127.0.0.1\",\n      port: 8545,\n      network_id: \"*\" // Match any network id\n    }\n  }\n};\n```\n\n- 详见[官方文档](http://truffleframework.com/docs/advanced/configuration)\n\n\n\n\n## 测试合约\n---\n\n- 直接执行命令：`truffle unbox metacoin `,创建这个项目。\n\n- 由于metacoin的示例代码里已经把测试代码写好了，按照上面的修改完truffle.js之后，**我们就可以编译部署测试我们的代码了：**\n```\ntruffle compile\ntruffle migrate\ntruffle test\n```\n\n- 结果如下:\n![](/images/block_chain/metacion_test_result.png)\n\n- 然后打开 ganache查看区块链的变化。 Accounts标签：第一个账户里ETH略有减少，因为交易消耗了gas；Blocks标签：Ganache是自动挖矿，生成了6个新区块，每个区块里有一个交易；Transactions标签：有6笔新交易，可以点开看交易详情；Logs标签：显示交易和挖矿日志\n\n\n\n<br>\n> 最后更新于2018.5.23\n","source":"_posts/2018-05-23-Ethereum.md","raw":"---\nlayout:     post\ntitle:      \"以太坊(ethereum)开发\"\ndate:       2018-05-23 05:59:00\ncategories: Computer\ntags:   ๑BlockChain\n---\n\n> 不适合人类阅读的学习笔记\n\n- **[以太坊社区](https://ethfans.org/)**\n\n## 安装Truffle\n---\n### Node.js安装\n\n- 先要进行node.js环境的安装，见上一篇博客。\n\n### 命令行安装truffle\n\n- 执行命令 ` npm install -g truffle`\n\n## 创建工程\n---\n\n-  执行命令 `truffle init`\n\n- truffle init会默认创建一个构建在以太坊内的代币demo应用。我们可以使用这个工程来进行快速的学习。\n\n- `init` 之后目录下就会有若干文件和文件夹。结构如下：\n![](images/block_chain/structure.png)\n\n- contracts目录中包含Solidity合约代码，其中Migrations.sol是必须有的，其他就是你自己写的合约代码了。\n\n- migrations目录中包含合约部署脚本，其中1_initial_migration.js就是用来部署Migrations.sol的，其他的脚本会按照顺序依次执行。\n\n- test目录保存用来测试应用和合约的测试文件\n\n- truffle.js - Truffle的配置文件\n\n- 官方文档(命令行指令，前面要加truffle)：\n\n```\nCommands:\n  init      //Initialize new and empty Ethereum project\n  compile   //Compile contract source files\n  migrate   //Run migrations to deploy contracts\n  deploy    //(alias for migrate)\n  build     //Execute build pipeline (if configuration present)\n  test      //Run JavaScript and Solidity tests\n  debug     //Interactively debug any transaction on the blockchain (experimental)\n  opcode    //Print the compiled opcodes for a given contract\n  console   //Run a console with contract abstractions and commands available\n  develop   //Open a console with a local development blockchain\n  create    //Helper to create new contracts, migrations and tests\n  install   //Install a package from the Ethereum Package Registry\n  publish   //Publish a package to the Ethereum Package Registry\n  networks  //Show addresses for deployed contracts on each network\n  watch     //Watch filesystem for changes and rebuild the project automatically\n  serve     //Serve the build directory on localhost and watch for changes\n  exec      //Execute a JS module within this Truffle environment\n  unbox     //Download a Truffle Box, a pre-built Truffle project\n  version   //Show version number and exit\n```\n终端输入`truffle`即可查看上述命令\n\n## 安装以太坊客户端\n---\n\n- 这里我们选择了Ganache——[github项目](https://github.com/trufflesuite/ganache-cli)\n\n- [图形版本下载地址](https://github.com/trufflesuite/ganache/releases)(linux下载 XX.AppImage文件格式的)\n\n- 命令行版本（ganache-cli）下载 `npm install -g ganache-cli`\n\n- Ganache的前身是testRPC\n\n## 编译和部署合约\n---\n\n- Ganache默认运行在7545端口，可以在界面右上方的“设置”里进行更改。运行后默认创建10个账号，每个账号里有100ETH的余额。\n要部署到链上，需要把IP、端口、网络ID告诉truffle。\n\n- 若要修改，则修改truffle.js：\n```\nmodule.exports = {  \n    networks: {  \n        development: {  \n            host: 'localhost',  \n            port: '7545',  \n            network_id: '*' // Match any network id  \n        }  \n    }  \n};  \n```\n\n### 编译合约\n\n#### 合约位置\n\n- 所有你的合约应该位于`./contracts`目录。默认我们提供了一个合约文件，一个库文件，均以.sol结尾作为示例。尽管库文件有一定的特殊性，但为简单起见，当前均称之为合约。\n\n- `truffle cmpile` 仅默认编译自上次编译后被修改过的文件，来减少不必要的编译。如果你想编译全部文件，可以使用--compile-all选项。\n\n#### 约定\n\n- Truffle需要定义的合约名称和文件名准确匹配。例如，如果文件名为 `MyContract.sol`，那么合约文件须为如下两者之一(并且匹配 **区分大小写**)：\n```\ncontract MyContract {\n  ...\n}\n// or\nlibrary MyContract {\n  ...\n}\n```\n\n- 编译目录:编译的输出位于`./build/contracts` 目录。如果目录不存在会自动创建。这些编译文件对于Truffle框架能否正常工作至关重要。你不应该在正常的编译或发布以外手动修改这些文件。\n\n### 移植\n\n- 命令 `truffle migrate`\n\n- 这个命令会执行所有的位于 `migrations` 目录内的移植脚本。如果你之前的移植是成功执行的。`truffle migrate` 仅会执行新创建的移植。如果没有新的移植脚本，这个命令不同执行任何操作。可以使用选项 `--reset`来从头执行移植脚本。\n\n### 修改配置\n\n- Ganache默认运行在7545端口，可以在界面右上方的“设置”里进行更改。运行后默认创建10个账号，每个账号里有100ETH的余额。\n要部署到链上，需要把IP、端口、网络ID告诉truffle。修改truffle.js：\n```\nmodule.exports = {\n  networks: {\n    development: {\n      host: \"127.0.0.1\",\n      port: 8545,\n      network_id: \"*\" // Match any network id\n    }\n  }\n};\n```\n\n- 详见[官方文档](http://truffleframework.com/docs/advanced/configuration)\n\n\n\n\n## 测试合约\n---\n\n- 直接执行命令：`truffle unbox metacoin `,创建这个项目。\n\n- 由于metacoin的示例代码里已经把测试代码写好了，按照上面的修改完truffle.js之后，**我们就可以编译部署测试我们的代码了：**\n```\ntruffle compile\ntruffle migrate\ntruffle test\n```\n\n- 结果如下:\n![](/images/block_chain/metacion_test_result.png)\n\n- 然后打开 ganache查看区块链的变化。 Accounts标签：第一个账户里ETH略有减少，因为交易消耗了gas；Blocks标签：Ganache是自动挖矿，生成了6个新区块，每个区块里有一个交易；Transactions标签：有6笔新交易，可以点开看交易详情；Logs标签：显示交易和挖矿日志\n\n\n\n<br>\n> 最后更新于2018.5.23\n","slug":"2018-05-23-Ethereum","published":1,"updated":"2018-09-03T13:16:24.393Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4w00211m0o5030n2jt","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<ul>\n<li><strong><a href=\"https://ethfans.org/\" target=\"_blank\" rel=\"noopener\">以太坊社区</a></strong></li>\n</ul>\n<h2 id=\"安装Truffle\"><a href=\"#安装Truffle\" class=\"headerlink\" title=\"安装Truffle\"></a>安装Truffle</h2><hr>\n<h3 id=\"Node-js安装\"><a href=\"#Node-js安装\" class=\"headerlink\" title=\"Node.js安装\"></a>Node.js安装</h3><ul>\n<li>先要进行node.js环境的安装，见上一篇博客。</li>\n</ul>\n<h3 id=\"命令行安装truffle\"><a href=\"#命令行安装truffle\" class=\"headerlink\" title=\"命令行安装truffle\"></a>命令行安装truffle</h3><ul>\n<li>执行命令 <code>npm install -g truffle</code></li>\n</ul>\n<h2 id=\"创建工程\"><a href=\"#创建工程\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h2><hr>\n<ul>\n<li><p>执行命令 <code>truffle init</code></p>\n</li>\n<li><p>truffle init会默认创建一个构建在以太坊内的代币demo应用。我们可以使用这个工程来进行快速的学习。</p>\n</li>\n<li><p><code>init</code> 之后目录下就会有若干文件和文件夹。结构如下：<br><img src=\"images/block_chain/structure.png\" alt=\"\"></p>\n</li>\n<li><p>contracts目录中包含Solidity合约代码，其中Migrations.sol是必须有的，其他就是你自己写的合约代码了。</p>\n</li>\n<li><p>migrations目录中包含合约部署脚本，其中1_initial_migration.js就是用来部署Migrations.sol的，其他的脚本会按照顺序依次执行。</p>\n</li>\n<li><p>test目录保存用来测试应用和合约的测试文件</p>\n</li>\n<li><p>truffle.js - Truffle的配置文件</p>\n</li>\n<li><p>官方文档(命令行指令，前面要加truffle)：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Commands:</span><br><span class=\"line\">  init      //Initialize new and empty Ethereum project</span><br><span class=\"line\">  compile   //Compile contract source files</span><br><span class=\"line\">  migrate   //Run migrations to deploy contracts</span><br><span class=\"line\">  deploy    //(alias for migrate)</span><br><span class=\"line\">  build     //Execute build pipeline (if configuration present)</span><br><span class=\"line\">  test      //Run JavaScript and Solidity tests</span><br><span class=\"line\">  debug     //Interactively debug any transaction on the blockchain (experimental)</span><br><span class=\"line\">  opcode    //Print the compiled opcodes for a given contract</span><br><span class=\"line\">  console   //Run a console with contract abstractions and commands available</span><br><span class=\"line\">  develop   //Open a console with a local development blockchain</span><br><span class=\"line\">  create    //Helper to create new contracts, migrations and tests</span><br><span class=\"line\">  install   //Install a package from the Ethereum Package Registry</span><br><span class=\"line\">  publish   //Publish a package to the Ethereum Package Registry</span><br><span class=\"line\">  networks  //Show addresses for deployed contracts on each network</span><br><span class=\"line\">  watch     //Watch filesystem for changes and rebuild the project automatically</span><br><span class=\"line\">  serve     //Serve the build directory on localhost and watch for changes</span><br><span class=\"line\">  exec      //Execute a JS module within this Truffle environment</span><br><span class=\"line\">  unbox     //Download a Truffle Box, a pre-built Truffle project</span><br><span class=\"line\">  version   //Show version number and exit</span><br></pre></td></tr></table></figure>\n<p>终端输入<code>truffle</code>即可查看上述命令</p>\n<h2 id=\"安装以太坊客户端\"><a href=\"#安装以太坊客户端\" class=\"headerlink\" title=\"安装以太坊客户端\"></a>安装以太坊客户端</h2><hr>\n<ul>\n<li><p>这里我们选择了Ganache——<a href=\"https://github.com/trufflesuite/ganache-cli\" target=\"_blank\" rel=\"noopener\">github项目</a></p>\n</li>\n<li><p><a href=\"https://github.com/trufflesuite/ganache/releases\" target=\"_blank\" rel=\"noopener\">图形版本下载地址</a>(linux下载 XX.AppImage文件格式的)</p>\n</li>\n<li><p>命令行版本（ganache-cli）下载 <code>npm install -g ganache-cli</code></p>\n</li>\n<li><p>Ganache的前身是testRPC</p>\n</li>\n</ul>\n<h2 id=\"编译和部署合约\"><a href=\"#编译和部署合约\" class=\"headerlink\" title=\"编译和部署合约\"></a>编译和部署合约</h2><hr>\n<ul>\n<li><p>Ganache默认运行在7545端口，可以在界面右上方的“设置”里进行更改。运行后默认创建10个账号，每个账号里有100ETH的余额。<br>要部署到链上，需要把IP、端口、网络ID告诉truffle。</p>\n</li>\n<li><p>若要修改，则修改truffle.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;  </span><br><span class=\"line\">    networks: &#123;  </span><br><span class=\"line\">        development: &#123;  </span><br><span class=\"line\">            host: &apos;localhost&apos;,  </span><br><span class=\"line\">            port: &apos;7545&apos;,  </span><br><span class=\"line\">            network_id: &apos;*&apos; // Match any network id  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"编译合约\"><a href=\"#编译合约\" class=\"headerlink\" title=\"编译合约\"></a>编译合约</h3><h4 id=\"合约位置\"><a href=\"#合约位置\" class=\"headerlink\" title=\"合约位置\"></a>合约位置</h4><ul>\n<li><p>所有你的合约应该位于<code>./contracts</code>目录。默认我们提供了一个合约文件，一个库文件，均以.sol结尾作为示例。尽管库文件有一定的特殊性，但为简单起见，当前均称之为合约。</p>\n</li>\n<li><p><code>truffle cmpile</code> 仅默认编译自上次编译后被修改过的文件，来减少不必要的编译。如果你想编译全部文件，可以使用–compile-all选项。</p>\n</li>\n</ul>\n<h4 id=\"约定\"><a href=\"#约定\" class=\"headerlink\" title=\"约定\"></a>约定</h4><ul>\n<li><p>Truffle需要定义的合约名称和文件名准确匹配。例如，如果文件名为 <code>MyContract.sol</code>，那么合约文件须为如下两者之一(并且匹配 <strong>区分大小写</strong>)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// or</span><br><span class=\"line\">library MyContract &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译目录:编译的输出位于<code>./build/contracts</code> 目录。如果目录不存在会自动创建。这些编译文件对于Truffle框架能否正常工作至关重要。你不应该在正常的编译或发布以外手动修改这些文件。</p>\n</li>\n</ul>\n<h3 id=\"移植\"><a href=\"#移植\" class=\"headerlink\" title=\"移植\"></a>移植</h3><ul>\n<li><p>命令 <code>truffle migrate</code></p>\n</li>\n<li><p>这个命令会执行所有的位于 <code>migrations</code> 目录内的移植脚本。如果你之前的移植是成功执行的。<code>truffle migrate</code> 仅会执行新创建的移植。如果没有新的移植脚本，这个命令不同执行任何操作。可以使用选项 <code>--reset</code>来从头执行移植脚本。</p>\n</li>\n</ul>\n<h3 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h3><ul>\n<li><p>Ganache默认运行在7545端口，可以在界面右上方的“设置”里进行更改。运行后默认创建10个账号，每个账号里有100ETH的余额。<br>要部署到链上，需要把IP、端口、网络ID告诉truffle。修改truffle.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  networks: &#123;</span><br><span class=\"line\">    development: &#123;</span><br><span class=\"line\">      host: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">      port: 8545,</span><br><span class=\"line\">      network_id: &quot;*&quot; // Match any network id</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>详见<a href=\"http://truffleframework.com/docs/advanced/configuration\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n</li>\n</ul>\n<h2 id=\"测试合约\"><a href=\"#测试合约\" class=\"headerlink\" title=\"测试合约\"></a>测试合约</h2><hr>\n<ul>\n<li><p>直接执行命令：<code>truffle unbox metacoin</code>,创建这个项目。</p>\n</li>\n<li><p>由于metacoin的示例代码里已经把测试代码写好了，按照上面的修改完truffle.js之后，<strong>我们就可以编译部署测试我们的代码了：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">truffle compile</span><br><span class=\"line\">truffle migrate</span><br><span class=\"line\">truffle test</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>结果如下:<br><img src=\"/images/block_chain/metacion_test_result.png\" alt=\"\"></p>\n</li>\n<li><p>然后打开 ganache查看区块链的变化。 Accounts标签：第一个账户里ETH略有减少，因为交易消耗了gas；Blocks标签：Ganache是自动挖矿，生成了6个新区块，每个区块里有一个交易；Transactions标签：有6笔新交易，可以点开看交易详情；Logs标签：显示交易和挖矿日志</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.23</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<ul>\n<li><strong><a href=\"https://ethfans.org/\" target=\"_blank\" rel=\"noopener\">以太坊社区</a></strong></li>\n</ul>\n<h2 id=\"安装Truffle\"><a href=\"#安装Truffle\" class=\"headerlink\" title=\"安装Truffle\"></a>安装Truffle</h2><hr>\n<h3 id=\"Node-js安装\"><a href=\"#Node-js安装\" class=\"headerlink\" title=\"Node.js安装\"></a>Node.js安装</h3><ul>\n<li>先要进行node.js环境的安装，见上一篇博客。</li>\n</ul>\n<h3 id=\"命令行安装truffle\"><a href=\"#命令行安装truffle\" class=\"headerlink\" title=\"命令行安装truffle\"></a>命令行安装truffle</h3><ul>\n<li>执行命令 <code>npm install -g truffle</code></li>\n</ul>\n<h2 id=\"创建工程\"><a href=\"#创建工程\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h2><hr>\n<ul>\n<li><p>执行命令 <code>truffle init</code></p>\n</li>\n<li><p>truffle init会默认创建一个构建在以太坊内的代币demo应用。我们可以使用这个工程来进行快速的学习。</p>\n</li>\n<li><p><code>init</code> 之后目录下就会有若干文件和文件夹。结构如下：<br><img src=\"images/block_chain/structure.png\" alt=\"\"></p>\n</li>\n<li><p>contracts目录中包含Solidity合约代码，其中Migrations.sol是必须有的，其他就是你自己写的合约代码了。</p>\n</li>\n<li><p>migrations目录中包含合约部署脚本，其中1_initial_migration.js就是用来部署Migrations.sol的，其他的脚本会按照顺序依次执行。</p>\n</li>\n<li><p>test目录保存用来测试应用和合约的测试文件</p>\n</li>\n<li><p>truffle.js - Truffle的配置文件</p>\n</li>\n<li><p>官方文档(命令行指令，前面要加truffle)：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Commands:</span><br><span class=\"line\">  init      //Initialize new and empty Ethereum project</span><br><span class=\"line\">  compile   //Compile contract source files</span><br><span class=\"line\">  migrate   //Run migrations to deploy contracts</span><br><span class=\"line\">  deploy    //(alias for migrate)</span><br><span class=\"line\">  build     //Execute build pipeline (if configuration present)</span><br><span class=\"line\">  test      //Run JavaScript and Solidity tests</span><br><span class=\"line\">  debug     //Interactively debug any transaction on the blockchain (experimental)</span><br><span class=\"line\">  opcode    //Print the compiled opcodes for a given contract</span><br><span class=\"line\">  console   //Run a console with contract abstractions and commands available</span><br><span class=\"line\">  develop   //Open a console with a local development blockchain</span><br><span class=\"line\">  create    //Helper to create new contracts, migrations and tests</span><br><span class=\"line\">  install   //Install a package from the Ethereum Package Registry</span><br><span class=\"line\">  publish   //Publish a package to the Ethereum Package Registry</span><br><span class=\"line\">  networks  //Show addresses for deployed contracts on each network</span><br><span class=\"line\">  watch     //Watch filesystem for changes and rebuild the project automatically</span><br><span class=\"line\">  serve     //Serve the build directory on localhost and watch for changes</span><br><span class=\"line\">  exec      //Execute a JS module within this Truffle environment</span><br><span class=\"line\">  unbox     //Download a Truffle Box, a pre-built Truffle project</span><br><span class=\"line\">  version   //Show version number and exit</span><br></pre></td></tr></table></figure>\n<p>终端输入<code>truffle</code>即可查看上述命令</p>\n<h2 id=\"安装以太坊客户端\"><a href=\"#安装以太坊客户端\" class=\"headerlink\" title=\"安装以太坊客户端\"></a>安装以太坊客户端</h2><hr>\n<ul>\n<li><p>这里我们选择了Ganache——<a href=\"https://github.com/trufflesuite/ganache-cli\" target=\"_blank\" rel=\"noopener\">github项目</a></p>\n</li>\n<li><p><a href=\"https://github.com/trufflesuite/ganache/releases\" target=\"_blank\" rel=\"noopener\">图形版本下载地址</a>(linux下载 XX.AppImage文件格式的)</p>\n</li>\n<li><p>命令行版本（ganache-cli）下载 <code>npm install -g ganache-cli</code></p>\n</li>\n<li><p>Ganache的前身是testRPC</p>\n</li>\n</ul>\n<h2 id=\"编译和部署合约\"><a href=\"#编译和部署合约\" class=\"headerlink\" title=\"编译和部署合约\"></a>编译和部署合约</h2><hr>\n<ul>\n<li><p>Ganache默认运行在7545端口，可以在界面右上方的“设置”里进行更改。运行后默认创建10个账号，每个账号里有100ETH的余额。<br>要部署到链上，需要把IP、端口、网络ID告诉truffle。</p>\n</li>\n<li><p>若要修改，则修改truffle.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;  </span><br><span class=\"line\">    networks: &#123;  </span><br><span class=\"line\">        development: &#123;  </span><br><span class=\"line\">            host: &apos;localhost&apos;,  </span><br><span class=\"line\">            port: &apos;7545&apos;,  </span><br><span class=\"line\">            network_id: &apos;*&apos; // Match any network id  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"编译合约\"><a href=\"#编译合约\" class=\"headerlink\" title=\"编译合约\"></a>编译合约</h3><h4 id=\"合约位置\"><a href=\"#合约位置\" class=\"headerlink\" title=\"合约位置\"></a>合约位置</h4><ul>\n<li><p>所有你的合约应该位于<code>./contracts</code>目录。默认我们提供了一个合约文件，一个库文件，均以.sol结尾作为示例。尽管库文件有一定的特殊性，但为简单起见，当前均称之为合约。</p>\n</li>\n<li><p><code>truffle cmpile</code> 仅默认编译自上次编译后被修改过的文件，来减少不必要的编译。如果你想编译全部文件，可以使用–compile-all选项。</p>\n</li>\n</ul>\n<h4 id=\"约定\"><a href=\"#约定\" class=\"headerlink\" title=\"约定\"></a>约定</h4><ul>\n<li><p>Truffle需要定义的合约名称和文件名准确匹配。例如，如果文件名为 <code>MyContract.sol</code>，那么合约文件须为如下两者之一(并且匹配 <strong>区分大小写</strong>)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// or</span><br><span class=\"line\">library MyContract &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译目录:编译的输出位于<code>./build/contracts</code> 目录。如果目录不存在会自动创建。这些编译文件对于Truffle框架能否正常工作至关重要。你不应该在正常的编译或发布以外手动修改这些文件。</p>\n</li>\n</ul>\n<h3 id=\"移植\"><a href=\"#移植\" class=\"headerlink\" title=\"移植\"></a>移植</h3><ul>\n<li><p>命令 <code>truffle migrate</code></p>\n</li>\n<li><p>这个命令会执行所有的位于 <code>migrations</code> 目录内的移植脚本。如果你之前的移植是成功执行的。<code>truffle migrate</code> 仅会执行新创建的移植。如果没有新的移植脚本，这个命令不同执行任何操作。可以使用选项 <code>--reset</code>来从头执行移植脚本。</p>\n</li>\n</ul>\n<h3 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h3><ul>\n<li><p>Ganache默认运行在7545端口，可以在界面右上方的“设置”里进行更改。运行后默认创建10个账号，每个账号里有100ETH的余额。<br>要部署到链上，需要把IP、端口、网络ID告诉truffle。修改truffle.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  networks: &#123;</span><br><span class=\"line\">    development: &#123;</span><br><span class=\"line\">      host: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">      port: 8545,</span><br><span class=\"line\">      network_id: &quot;*&quot; // Match any network id</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>详见<a href=\"http://truffleframework.com/docs/advanced/configuration\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n</li>\n</ul>\n<h2 id=\"测试合约\"><a href=\"#测试合约\" class=\"headerlink\" title=\"测试合约\"></a>测试合约</h2><hr>\n<ul>\n<li><p>直接执行命令：<code>truffle unbox metacoin</code>,创建这个项目。</p>\n</li>\n<li><p>由于metacoin的示例代码里已经把测试代码写好了，按照上面的修改完truffle.js之后，<strong>我们就可以编译部署测试我们的代码了：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">truffle compile</span><br><span class=\"line\">truffle migrate</span><br><span class=\"line\">truffle test</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>结果如下:<br><img src=\"/images/block_chain/metacion_test_result.png\" alt=\"\"></p>\n</li>\n<li><p>然后打开 ganache查看区块链的变化。 Accounts标签：第一个账户里ETH略有减少，因为交易消耗了gas；Blocks标签：Ganache是自动挖矿，生成了6个新区块，每个区块里有一个交易；Transactions标签：有6笔新交易，可以点开看交易详情；Logs标签：显示交易和挖矿日志</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.23</p>\n</blockquote>\n"},{"layout":"post","title":"Intellij IDEA Ultimate版本使用","date":"2018-05-25T01:46:00.000Z","_content":"\n## JetBrains Toolbox\n---\n\n- 如果你决定使用jetbrains的开发环境的话，那么去官网上获取一个jetbrains toolbox会是个不错的主意～\n\n- 这个工具可以很方便地管理你的所有jetbrains的产品，避免了太多快捷方式的麻烦。\n\n## 免费获取Ultimate版本\n---\n\n- jetbrains给学生的优惠还是非常大的，我们可以用我们学校的邮箱免费获取JetBrains全家桶\n\n- 这个在我上一篇文章里也提到了，这里再作一次系统的记录。\n\n- [Jetbrains学生免费账号申请](https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F)\n\n- 申请流程其实很简单，你需要一个你们学校的邮箱即可。然后验证通过之后会发送验证邮件，依次填写并且最终注册完账号即可激活。注册的时候一定要确定邮箱的地址填写正确，不出于意外一分钟之内就能收到确认邮件。\n\n- 如果填错了也没关系，你可以一遍一遍地写邮箱然后申请，jetbrains好像对此没有什么限制。\n\n- 成功激活：\n\n![](/images/node.js/info.png)\n\n## 初始配置\n---\n\n- 装好Ultimate版本之后我们就可以开始配置一些东西了。\n\n- 首先打开intellij IDEA，不用进入某个项目，在初始界面设置(这样这些设置便是对全局生效)\n\n- 在plugins里面添加一些我们需要的插件。比如 scala , nodejs, junitGenerator2.0等，这些插件比community版本要丰富很多。\n\n- 在 system settings 里面把 reopen previous project勾掉，这样每次打开我们就可以手动选择要打开的项目了。\n\n- 然后在global lib里面点击绿色的加号，添加我们用到的编成语言的lib，在弹出的选择框里找到我们安装的目录。比如添加scala的lib，要找到scala sdk的安装目录即可，intellij 会自己扫描目录然后添加lib，最后保存确定即可。\n\n## 添加已有工程时遇到的坑\n---\n\n- 最近老师布置了个jdbc的作业，是个eclipse的工程。但是在intellij打开的话，test部分始终有问题，不能访问到src里的代码。。\n\n- 然后换了一种导入工程的方式，但是无论是eclipse方式导入还是maven方式导入，都会出现没有工程可以导入的错误???(No projects are found to import 这个问题在用eclipse来导入工程的时候也可能遇到) 上网查阅之后发现，可能是缺少`.classpath`文件和`.project`文件(或者有可能是这两个文件有问题)。\n\n- 解决方法就是，用eclipse重新建立一个同名的工程，然后把这个工程里面的这两个文件复制到要导入的工程里再试着导入。\n\n- 或者如果代码不太多的话，直接新建一个工程，把代码复制进去就好了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<br>\n> 最后更新于2018.6.4\n","source":"_posts/2018-05-25-jetbrains.md","raw":"---\nlayout:     post\ntitle:      \"Intellij IDEA Ultimate版本使用\"\ndate:       2018-05-25 09:46:00\ncategories: Computer Software\ntags:   [๑JetBrains, ๑JS]\n---\n\n## JetBrains Toolbox\n---\n\n- 如果你决定使用jetbrains的开发环境的话，那么去官网上获取一个jetbrains toolbox会是个不错的主意～\n\n- 这个工具可以很方便地管理你的所有jetbrains的产品，避免了太多快捷方式的麻烦。\n\n## 免费获取Ultimate版本\n---\n\n- jetbrains给学生的优惠还是非常大的，我们可以用我们学校的邮箱免费获取JetBrains全家桶\n\n- 这个在我上一篇文章里也提到了，这里再作一次系统的记录。\n\n- [Jetbrains学生免费账号申请](https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F)\n\n- 申请流程其实很简单，你需要一个你们学校的邮箱即可。然后验证通过之后会发送验证邮件，依次填写并且最终注册完账号即可激活。注册的时候一定要确定邮箱的地址填写正确，不出于意外一分钟之内就能收到确认邮件。\n\n- 如果填错了也没关系，你可以一遍一遍地写邮箱然后申请，jetbrains好像对此没有什么限制。\n\n- 成功激活：\n\n![](/images/node.js/info.png)\n\n## 初始配置\n---\n\n- 装好Ultimate版本之后我们就可以开始配置一些东西了。\n\n- 首先打开intellij IDEA，不用进入某个项目，在初始界面设置(这样这些设置便是对全局生效)\n\n- 在plugins里面添加一些我们需要的插件。比如 scala , nodejs, junitGenerator2.0等，这些插件比community版本要丰富很多。\n\n- 在 system settings 里面把 reopen previous project勾掉，这样每次打开我们就可以手动选择要打开的项目了。\n\n- 然后在global lib里面点击绿色的加号，添加我们用到的编成语言的lib，在弹出的选择框里找到我们安装的目录。比如添加scala的lib，要找到scala sdk的安装目录即可，intellij 会自己扫描目录然后添加lib，最后保存确定即可。\n\n## 添加已有工程时遇到的坑\n---\n\n- 最近老师布置了个jdbc的作业，是个eclipse的工程。但是在intellij打开的话，test部分始终有问题，不能访问到src里的代码。。\n\n- 然后换了一种导入工程的方式，但是无论是eclipse方式导入还是maven方式导入，都会出现没有工程可以导入的错误???(No projects are found to import 这个问题在用eclipse来导入工程的时候也可能遇到) 上网查阅之后发现，可能是缺少`.classpath`文件和`.project`文件(或者有可能是这两个文件有问题)。\n\n- 解决方法就是，用eclipse重新建立一个同名的工程，然后把这个工程里面的这两个文件复制到要导入的工程里再试着导入。\n\n- 或者如果代码不太多的话，直接新建一个工程，把代码复制进去就好了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<br>\n> 最后更新于2018.6.4\n","slug":"2018-05-25-jetbrains","published":1,"updated":"2018-09-03T08:47:10.999Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4x00241m0og0s91nps","content":"<h2 id=\"JetBrains-Toolbox\"><a href=\"#JetBrains-Toolbox\" class=\"headerlink\" title=\"JetBrains Toolbox\"></a>JetBrains Toolbox</h2><hr>\n<ul>\n<li><p>如果你决定使用jetbrains的开发环境的话，那么去官网上获取一个jetbrains toolbox会是个不错的主意～</p>\n</li>\n<li><p>这个工具可以很方便地管理你的所有jetbrains的产品，避免了太多快捷方式的麻烦。</p>\n</li>\n</ul>\n<h2 id=\"免费获取Ultimate版本\"><a href=\"#免费获取Ultimate版本\" class=\"headerlink\" title=\"免费获取Ultimate版本\"></a>免费获取Ultimate版本</h2><hr>\n<ul>\n<li><p>jetbrains给学生的优惠还是非常大的，我们可以用我们学校的邮箱免费获取JetBrains全家桶</p>\n</li>\n<li><p>这个在我上一篇文章里也提到了，这里再作一次系统的记录。</p>\n</li>\n<li><p><a href=\"https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">Jetbrains学生免费账号申请</a></p>\n</li>\n<li><p>申请流程其实很简单，你需要一个你们学校的邮箱即可。然后验证通过之后会发送验证邮件，依次填写并且最终注册完账号即可激活。注册的时候一定要确定邮箱的地址填写正确，不出于意外一分钟之内就能收到确认邮件。</p>\n</li>\n<li><p>如果填错了也没关系，你可以一遍一遍地写邮箱然后申请，jetbrains好像对此没有什么限制。</p>\n</li>\n<li><p>成功激活：</p>\n</li>\n</ul>\n<p><img src=\"/images/node.js/info.png\" alt=\"\"></p>\n<h2 id=\"初始配置\"><a href=\"#初始配置\" class=\"headerlink\" title=\"初始配置\"></a>初始配置</h2><hr>\n<ul>\n<li><p>装好Ultimate版本之后我们就可以开始配置一些东西了。</p>\n</li>\n<li><p>首先打开intellij IDEA，不用进入某个项目，在初始界面设置(这样这些设置便是对全局生效)</p>\n</li>\n<li><p>在plugins里面添加一些我们需要的插件。比如 scala , nodejs, junitGenerator2.0等，这些插件比community版本要丰富很多。</p>\n</li>\n<li><p>在 system settings 里面把 reopen previous project勾掉，这样每次打开我们就可以手动选择要打开的项目了。</p>\n</li>\n<li><p>然后在global lib里面点击绿色的加号，添加我们用到的编成语言的lib，在弹出的选择框里找到我们安装的目录。比如添加scala的lib，要找到scala sdk的安装目录即可，intellij 会自己扫描目录然后添加lib，最后保存确定即可。</p>\n</li>\n</ul>\n<h2 id=\"添加已有工程时遇到的坑\"><a href=\"#添加已有工程时遇到的坑\" class=\"headerlink\" title=\"添加已有工程时遇到的坑\"></a>添加已有工程时遇到的坑</h2><hr>\n<ul>\n<li><p>最近老师布置了个jdbc的作业，是个eclipse的工程。但是在intellij打开的话，test部分始终有问题，不能访问到src里的代码。。</p>\n</li>\n<li><p>然后换了一种导入工程的方式，但是无论是eclipse方式导入还是maven方式导入，都会出现没有工程可以导入的错误???(No projects are found to import 这个问题在用eclipse来导入工程的时候也可能遇到) 上网查阅之后发现，可能是缺少<code>.classpath</code>文件和<code>.project</code>文件(或者有可能是这两个文件有问题)。</p>\n</li>\n<li><p>解决方法就是，用eclipse重新建立一个同名的工程，然后把这个工程里面的这两个文件复制到要导入的工程里再试着导入。</p>\n</li>\n<li><p>或者如果代码不太多的话，直接新建一个工程，把代码复制进去就好了。</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.6.4</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JetBrains-Toolbox\"><a href=\"#JetBrains-Toolbox\" class=\"headerlink\" title=\"JetBrains Toolbox\"></a>JetBrains Toolbox</h2><hr>\n<ul>\n<li><p>如果你决定使用jetbrains的开发环境的话，那么去官网上获取一个jetbrains toolbox会是个不错的主意～</p>\n</li>\n<li><p>这个工具可以很方便地管理你的所有jetbrains的产品，避免了太多快捷方式的麻烦。</p>\n</li>\n</ul>\n<h2 id=\"免费获取Ultimate版本\"><a href=\"#免费获取Ultimate版本\" class=\"headerlink\" title=\"免费获取Ultimate版本\"></a>免费获取Ultimate版本</h2><hr>\n<ul>\n<li><p>jetbrains给学生的优惠还是非常大的，我们可以用我们学校的邮箱免费获取JetBrains全家桶</p>\n</li>\n<li><p>这个在我上一篇文章里也提到了，这里再作一次系统的记录。</p>\n</li>\n<li><p><a href=\"https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">Jetbrains学生免费账号申请</a></p>\n</li>\n<li><p>申请流程其实很简单，你需要一个你们学校的邮箱即可。然后验证通过之后会发送验证邮件，依次填写并且最终注册完账号即可激活。注册的时候一定要确定邮箱的地址填写正确，不出于意外一分钟之内就能收到确认邮件。</p>\n</li>\n<li><p>如果填错了也没关系，你可以一遍一遍地写邮箱然后申请，jetbrains好像对此没有什么限制。</p>\n</li>\n<li><p>成功激活：</p>\n</li>\n</ul>\n<p><img src=\"/images/node.js/info.png\" alt=\"\"></p>\n<h2 id=\"初始配置\"><a href=\"#初始配置\" class=\"headerlink\" title=\"初始配置\"></a>初始配置</h2><hr>\n<ul>\n<li><p>装好Ultimate版本之后我们就可以开始配置一些东西了。</p>\n</li>\n<li><p>首先打开intellij IDEA，不用进入某个项目，在初始界面设置(这样这些设置便是对全局生效)</p>\n</li>\n<li><p>在plugins里面添加一些我们需要的插件。比如 scala , nodejs, junitGenerator2.0等，这些插件比community版本要丰富很多。</p>\n</li>\n<li><p>在 system settings 里面把 reopen previous project勾掉，这样每次打开我们就可以手动选择要打开的项目了。</p>\n</li>\n<li><p>然后在global lib里面点击绿色的加号，添加我们用到的编成语言的lib，在弹出的选择框里找到我们安装的目录。比如添加scala的lib，要找到scala sdk的安装目录即可，intellij 会自己扫描目录然后添加lib，最后保存确定即可。</p>\n</li>\n</ul>\n<h2 id=\"添加已有工程时遇到的坑\"><a href=\"#添加已有工程时遇到的坑\" class=\"headerlink\" title=\"添加已有工程时遇到的坑\"></a>添加已有工程时遇到的坑</h2><hr>\n<ul>\n<li><p>最近老师布置了个jdbc的作业，是个eclipse的工程。但是在intellij打开的话，test部分始终有问题，不能访问到src里的代码。。</p>\n</li>\n<li><p>然后换了一种导入工程的方式，但是无论是eclipse方式导入还是maven方式导入，都会出现没有工程可以导入的错误???(No projects are found to import 这个问题在用eclipse来导入工程的时候也可能遇到) 上网查阅之后发现，可能是缺少<code>.classpath</code>文件和<code>.project</code>文件(或者有可能是这两个文件有问题)。</p>\n</li>\n<li><p>解决方法就是，用eclipse重新建立一个同名的工程，然后把这个工程里面的这两个文件复制到要导入的工程里再试着导入。</p>\n</li>\n<li><p>或者如果代码不太多的话，直接新建一个工程，把代码复制进去就好了。</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.6.4</p>\n</blockquote>\n"},{"layout":"post","title":"Hadoop单机伪分布式环境搭建","date":"2018-05-30T01:46:00.000Z","_content":"\n## Hadoop 单机伪分布式环境搭建\n---\n\n### 前言\n\n- 这是对之前spark环境搭建的一点补充。\n\n- 首先要了解一下Hadoop的运行模式：\n\n- 单机模式（standalone）:单机模式是Hadoop的默认模式。当首次解压Hadoop的源码包时，Hadoop无法了解硬件安装环境，便保守地选择了最小配置。在这种默认模式下所有3个XML文件均为空。当配置文件为空时，Hadoop会完全运行在本地。因为不需要与其他节点交互，单机模式就不使用HDFS，也不加载任何Hadoop的守护进程。该模式主要用于开发调试MapReduce程序的应用逻辑。\n\n- 伪分布模式（Pseudo-Distributed Mode）: 伪分布模式在“单节点集群”上运行Hadoop，其中所有的守护进程都运行在同一台机器上。该模式在单机模式之上增加了代码调试功能，允许你检查内存使用情况，HDFS输入输出，以及其他的守护进程交互。\n\n- 全分布模式（Fully Distributed Mode）:Hadoop守护进程运行在一个集群上。\n\n### 新建用户\n\n- 添加一个名为hadoop到系统用户，专门用来做Hadoop测试:\n```\nsudo addgroup hadoop\nsudo adduser --ingroup hadoop hadoop\n```\n\n- 再赋予hadoop用户 sudo的权限：`sudo usermod -aG sudo hadoop\n`\n- 这里`sudo`是我的电脑上有sudo权限的用户组的名称，你可以`cat /etc/group`看看有哪些用户组以及这些用户组下的用户。\n\n- 实在不行就吧你原来用户在的组都加一个hadoop用户\n\n- [创建新用户并增加管理员详解](https://blog.csdn.net/lymemoryzz/article/details/50627767)\n\n### 安装ssh\n\n- **注意先切换到hadoop用户**\n\n- 命令：`sudo apt-get install openssh-server `\n\n- 启动服务：`sudo /etc/init.d/ssh start `\n\n- 检查服务是否正确启动：`ps -e | grep ssh  `\n\n![](/images/Hadoop/ssh_log.png)\n\n#### 配置ssh无密码登录\n\n- 这个也要在hadoop用户下完成(因为这会在你这个用户的文件夹下的.ssh文件夹生成key)\n\n- 我们要设置成免密码登录，生成私钥和公钥：`ssh-keygen -t rsa -P \"\"`\n\n![](/images/Hadoop/ssh_key.png)\n\n- 第一次操作时会提示输入密码，按Enter直接过，这时会在～/home/{username}/.ssh下生成两个文件：id_rsa和id_rsa.pub，前者为私钥，后者为公钥，现在我们将公钥追加到到authorized_keys中（authorized_keys用于保存所有允许以当前用户身份登录到ssh客户端用户的公钥内容）：\n- `cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys  `\n\n- 多台实体机进行通信（发送或者读取数据，namenode和datanode之间）就是借助ssh，在通信过程中如果需要操作人员频繁输入密码是不切实际的，所以需要ssh的无密码登录。\n\n- 现在登录就不需要密码了：`ssh localhost `\n\n- `exit`命令退出登录localhost\n\n#### 安装hadoop\n\n- 我下载的是hadoop-2.7.6版本\n\n- 存放的路径是`/uer/local/Apache/hadoop-2.7.6`\n\n- 然后修改path环境变量，路径对应自己的实际存放路径：\n![](/images/Hadoop/path.png)\n\n- 修改hadoop-env.sh: **(这个不能用默认的，否则会报错)**\n```\nexport JAVA_HOME=${JAVA_HOME} #将这个改成JDK路径，如下  \nexport JAVA_HOME=/opt/jdk1.8.0_172\n```\n\n- 确保下面的操作在hadoop用户下完成：`sudo chown -R  hadoop:hadoop /usr/local/Apache/hadoop-2.7.6 (自己hadoop的安装路径)`\n\n- 最后输入 `hadoop version` 确认安装\n\n- 至此单机模式配置完成(在hadoop用户下的单机模式)\n\n### 伪分布式环境搭建\n\n-设定*-site.xml:这里需要设定三个文件。我的三个文件的路径是`/usr/local/Apache/hadoop-2.7.6/etc/hadoop/`\n\n- core-site.xml:  Hadoop Core的配置项，例如HDFS和MapReduce常用的I/O设置等。\n- hdfs-site.xml:  Hadoop 守护进程的配置项，包括namenode，辅助namenode和datanode等。\n- mapred-site.xml： MapReduce 守护进程的配置项，包括jobtracker和tasktracker。\n\n#### 首先在hadoop根目录下新建几个文件夹：\n```\nmkdir hdfs\nmkdir hdfs/name\nmkdir hdfs/data\nmkdir tmp\n```\n\n- 接下来编辑这三个文件：\n\ncore-site.xml:\n```\n<configuration>  \n    <property>  \n        <name>fs.default.name</name>  \n        <value>hdfs://localhost:9000</value>  \n    </property>  \n    <property>  \n        <name>hadoop.tmp.dir</name>  \n        <value>/usr/local/Apache/hadoop-2.7.1/tmp</value>  \n    </property>  \n</configuration>  \n```\n\nhdfs-site.xml:\n```\n<configuration>  \n    <property>  <!--设置副本数1，不写默认是3份-->\n        <name>dfs.replication</name>  \n        <value>1</value>  \n    </property>  \n    <property>  \n        <name>dfs.name.dir</name>  \n        <value>/usr/local/Apache/hadoop-2.7.1/hdfs/name</value>  \n    </property>  \n    <property>  \n        <name>dfs.data.dir</name>  \n        <value>/usr/local/Apache/hadoop-2.7.1/hdfs/data</value>  \n    </property>  \n</configuration>  \n```\n\nmapred-site.xml:\n```\n<configuration>  \n    <property>  \n        <name>mapred.job.tracker</name>  \n        <value>localhost:9001</value>  \n    </property>  \n</configuration>  \n```\n#### 格式化hdfs\n\n- 启动Hadoop到相关服务，格式化namenode,secondarynamenode,tasktracker的文件系统目录:\n```\nsource /usr/local/Apache/hadoop-2.7.1/etc/hadoop/hadoop-env.sh\nhadoop namenode -format\n```\n\n#### 启动hadoop\n\n- **首先要先连接到localhost!!**(否则无法在网页上查看节点)。\n`ssh localhost`\n\n- 我的`start-all.sh`脚本在sbin目录下，各个版本可能不太一样，如果这个文件夹没有就去别的文件夹找找。\n\n- 执行start-all.sh来启动所有服务:\n```\ncd sbin\n./start-all.sh\n```\n\n- 使用命令`jps`查看是否启动成功：\n![](/images/Hadoop/launch_info.png)\n如果出现NodeManager DataNode Jps SecondaryNameNode ResourceManager NameNode则表示启动成功(缺一不可)\n\n- 检查运行状态:\n所有的设置已完成，Hadoop也启动了，现在可以通过下面的操作来查看服务是否正常，在Hadoop中用于监控集群健康状态的Web界面：\n\n`http://localhost:50030/     - Hadoop 管理介面`\n\n`http://localhost:50060/     - Hadoop Task Tracker 状态`\n\n`http://localhost:50070/     - Hadoop DFS 状态`\n\n- 目前我只有50070是正常访问的，其余的还不能访问，原因有待进一步探究\n![](/images/Hadoop/datanode_info.png)\n\n\n- 停止服务：\n`./stop-all.sh`\n\n ![](/images/Hadoop/stop_all.png)\n\n- 由于之前已经将hadoop的`bin`和`sbin`两个目录添加到系统环境路径里去了，这样下次启动直接就可以是\n```\nssh localhost\nstart-all.sh\n...\nstop-all.sh\n```\n这样就方便很多了。\n\n- 参考博客——[hadoop伪分布式搭建](https://blog.csdn.net/hitwengqi/article/details/8008203)，[很详细的搭建步骤(Hadoop-2.7.2版本)](https://blog.csdn.net/Dr_Guo/article/details/50886667)\n\n<br>\n> 最后更新于2018.5.31\n","source":"_posts/2018-05-30-Hadoop-usage.md","raw":"---\nlayout:     post\ntitle:      \"Hadoop单机伪分布式环境搭建\"\ndate:       2018-05-30 09:46:00\ncategories: Hadoop CLuster\ntags:   [๑Hadoop, ๑BigData]\n---\n\n## Hadoop 单机伪分布式环境搭建\n---\n\n### 前言\n\n- 这是对之前spark环境搭建的一点补充。\n\n- 首先要了解一下Hadoop的运行模式：\n\n- 单机模式（standalone）:单机模式是Hadoop的默认模式。当首次解压Hadoop的源码包时，Hadoop无法了解硬件安装环境，便保守地选择了最小配置。在这种默认模式下所有3个XML文件均为空。当配置文件为空时，Hadoop会完全运行在本地。因为不需要与其他节点交互，单机模式就不使用HDFS，也不加载任何Hadoop的守护进程。该模式主要用于开发调试MapReduce程序的应用逻辑。\n\n- 伪分布模式（Pseudo-Distributed Mode）: 伪分布模式在“单节点集群”上运行Hadoop，其中所有的守护进程都运行在同一台机器上。该模式在单机模式之上增加了代码调试功能，允许你检查内存使用情况，HDFS输入输出，以及其他的守护进程交互。\n\n- 全分布模式（Fully Distributed Mode）:Hadoop守护进程运行在一个集群上。\n\n### 新建用户\n\n- 添加一个名为hadoop到系统用户，专门用来做Hadoop测试:\n```\nsudo addgroup hadoop\nsudo adduser --ingroup hadoop hadoop\n```\n\n- 再赋予hadoop用户 sudo的权限：`sudo usermod -aG sudo hadoop\n`\n- 这里`sudo`是我的电脑上有sudo权限的用户组的名称，你可以`cat /etc/group`看看有哪些用户组以及这些用户组下的用户。\n\n- 实在不行就吧你原来用户在的组都加一个hadoop用户\n\n- [创建新用户并增加管理员详解](https://blog.csdn.net/lymemoryzz/article/details/50627767)\n\n### 安装ssh\n\n- **注意先切换到hadoop用户**\n\n- 命令：`sudo apt-get install openssh-server `\n\n- 启动服务：`sudo /etc/init.d/ssh start `\n\n- 检查服务是否正确启动：`ps -e | grep ssh  `\n\n![](/images/Hadoop/ssh_log.png)\n\n#### 配置ssh无密码登录\n\n- 这个也要在hadoop用户下完成(因为这会在你这个用户的文件夹下的.ssh文件夹生成key)\n\n- 我们要设置成免密码登录，生成私钥和公钥：`ssh-keygen -t rsa -P \"\"`\n\n![](/images/Hadoop/ssh_key.png)\n\n- 第一次操作时会提示输入密码，按Enter直接过，这时会在～/home/{username}/.ssh下生成两个文件：id_rsa和id_rsa.pub，前者为私钥，后者为公钥，现在我们将公钥追加到到authorized_keys中（authorized_keys用于保存所有允许以当前用户身份登录到ssh客户端用户的公钥内容）：\n- `cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys  `\n\n- 多台实体机进行通信（发送或者读取数据，namenode和datanode之间）就是借助ssh，在通信过程中如果需要操作人员频繁输入密码是不切实际的，所以需要ssh的无密码登录。\n\n- 现在登录就不需要密码了：`ssh localhost `\n\n- `exit`命令退出登录localhost\n\n#### 安装hadoop\n\n- 我下载的是hadoop-2.7.6版本\n\n- 存放的路径是`/uer/local/Apache/hadoop-2.7.6`\n\n- 然后修改path环境变量，路径对应自己的实际存放路径：\n![](/images/Hadoop/path.png)\n\n- 修改hadoop-env.sh: **(这个不能用默认的，否则会报错)**\n```\nexport JAVA_HOME=${JAVA_HOME} #将这个改成JDK路径，如下  \nexport JAVA_HOME=/opt/jdk1.8.0_172\n```\n\n- 确保下面的操作在hadoop用户下完成：`sudo chown -R  hadoop:hadoop /usr/local/Apache/hadoop-2.7.6 (自己hadoop的安装路径)`\n\n- 最后输入 `hadoop version` 确认安装\n\n- 至此单机模式配置完成(在hadoop用户下的单机模式)\n\n### 伪分布式环境搭建\n\n-设定*-site.xml:这里需要设定三个文件。我的三个文件的路径是`/usr/local/Apache/hadoop-2.7.6/etc/hadoop/`\n\n- core-site.xml:  Hadoop Core的配置项，例如HDFS和MapReduce常用的I/O设置等。\n- hdfs-site.xml:  Hadoop 守护进程的配置项，包括namenode，辅助namenode和datanode等。\n- mapred-site.xml： MapReduce 守护进程的配置项，包括jobtracker和tasktracker。\n\n#### 首先在hadoop根目录下新建几个文件夹：\n```\nmkdir hdfs\nmkdir hdfs/name\nmkdir hdfs/data\nmkdir tmp\n```\n\n- 接下来编辑这三个文件：\n\ncore-site.xml:\n```\n<configuration>  \n    <property>  \n        <name>fs.default.name</name>  \n        <value>hdfs://localhost:9000</value>  \n    </property>  \n    <property>  \n        <name>hadoop.tmp.dir</name>  \n        <value>/usr/local/Apache/hadoop-2.7.1/tmp</value>  \n    </property>  \n</configuration>  \n```\n\nhdfs-site.xml:\n```\n<configuration>  \n    <property>  <!--设置副本数1，不写默认是3份-->\n        <name>dfs.replication</name>  \n        <value>1</value>  \n    </property>  \n    <property>  \n        <name>dfs.name.dir</name>  \n        <value>/usr/local/Apache/hadoop-2.7.1/hdfs/name</value>  \n    </property>  \n    <property>  \n        <name>dfs.data.dir</name>  \n        <value>/usr/local/Apache/hadoop-2.7.1/hdfs/data</value>  \n    </property>  \n</configuration>  \n```\n\nmapred-site.xml:\n```\n<configuration>  \n    <property>  \n        <name>mapred.job.tracker</name>  \n        <value>localhost:9001</value>  \n    </property>  \n</configuration>  \n```\n#### 格式化hdfs\n\n- 启动Hadoop到相关服务，格式化namenode,secondarynamenode,tasktracker的文件系统目录:\n```\nsource /usr/local/Apache/hadoop-2.7.1/etc/hadoop/hadoop-env.sh\nhadoop namenode -format\n```\n\n#### 启动hadoop\n\n- **首先要先连接到localhost!!**(否则无法在网页上查看节点)。\n`ssh localhost`\n\n- 我的`start-all.sh`脚本在sbin目录下，各个版本可能不太一样，如果这个文件夹没有就去别的文件夹找找。\n\n- 执行start-all.sh来启动所有服务:\n```\ncd sbin\n./start-all.sh\n```\n\n- 使用命令`jps`查看是否启动成功：\n![](/images/Hadoop/launch_info.png)\n如果出现NodeManager DataNode Jps SecondaryNameNode ResourceManager NameNode则表示启动成功(缺一不可)\n\n- 检查运行状态:\n所有的设置已完成，Hadoop也启动了，现在可以通过下面的操作来查看服务是否正常，在Hadoop中用于监控集群健康状态的Web界面：\n\n`http://localhost:50030/     - Hadoop 管理介面`\n\n`http://localhost:50060/     - Hadoop Task Tracker 状态`\n\n`http://localhost:50070/     - Hadoop DFS 状态`\n\n- 目前我只有50070是正常访问的，其余的还不能访问，原因有待进一步探究\n![](/images/Hadoop/datanode_info.png)\n\n\n- 停止服务：\n`./stop-all.sh`\n\n ![](/images/Hadoop/stop_all.png)\n\n- 由于之前已经将hadoop的`bin`和`sbin`两个目录添加到系统环境路径里去了，这样下次启动直接就可以是\n```\nssh localhost\nstart-all.sh\n...\nstop-all.sh\n```\n这样就方便很多了。\n\n- 参考博客——[hadoop伪分布式搭建](https://blog.csdn.net/hitwengqi/article/details/8008203)，[很详细的搭建步骤(Hadoop-2.7.2版本)](https://blog.csdn.net/Dr_Guo/article/details/50886667)\n\n<br>\n> 最后更新于2018.5.31\n","slug":"2018-05-30-Hadoop-usage","published":1,"updated":"2018-09-03T13:16:00.761Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j4y00281m0obiw20ezk","content":"<h2 id=\"Hadoop-单机伪分布式环境搭建\"><a href=\"#Hadoop-单机伪分布式环境搭建\" class=\"headerlink\" title=\"Hadoop 单机伪分布式环境搭建\"></a>Hadoop 单机伪分布式环境搭建</h2><hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><ul>\n<li><p>这是对之前spark环境搭建的一点补充。</p>\n</li>\n<li><p>首先要了解一下Hadoop的运行模式：</p>\n</li>\n<li><p>单机模式（standalone）:单机模式是Hadoop的默认模式。当首次解压Hadoop的源码包时，Hadoop无法了解硬件安装环境，便保守地选择了最小配置。在这种默认模式下所有3个XML文件均为空。当配置文件为空时，Hadoop会完全运行在本地。因为不需要与其他节点交互，单机模式就不使用HDFS，也不加载任何Hadoop的守护进程。该模式主要用于开发调试MapReduce程序的应用逻辑。</p>\n</li>\n<li><p>伪分布模式（Pseudo-Distributed Mode）: 伪分布模式在“单节点集群”上运行Hadoop，其中所有的守护进程都运行在同一台机器上。该模式在单机模式之上增加了代码调试功能，允许你检查内存使用情况，HDFS输入输出，以及其他的守护进程交互。</p>\n</li>\n<li><p>全分布模式（Fully Distributed Mode）:Hadoop守护进程运行在一个集群上。</p>\n</li>\n</ul>\n<h3 id=\"新建用户\"><a href=\"#新建用户\" class=\"headerlink\" title=\"新建用户\"></a>新建用户</h3><ul>\n<li><p>添加一个名为hadoop到系统用户，专门用来做Hadoop测试:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo addgroup hadoop</span><br><span class=\"line\">sudo adduser --ingroup hadoop hadoop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>再赋予hadoop用户 sudo的权限：<code>sudo usermod -aG sudo hadoop</code></p>\n</li>\n<li><p>这里<code>sudo</code>是我的电脑上有sudo权限的用户组的名称，你可以<code>cat /etc/group</code>看看有哪些用户组以及这些用户组下的用户。</p>\n</li>\n<li><p>实在不行就吧你原来用户在的组都加一个hadoop用户</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/lymemoryzz/article/details/50627767\" target=\"_blank\" rel=\"noopener\">创建新用户并增加管理员详解</a></p>\n</li>\n</ul>\n<h3 id=\"安装ssh\"><a href=\"#安装ssh\" class=\"headerlink\" title=\"安装ssh\"></a>安装ssh</h3><ul>\n<li><p><strong>注意先切换到hadoop用户</strong></p>\n</li>\n<li><p>命令：<code>sudo apt-get install openssh-server</code></p>\n</li>\n<li><p>启动服务：<code>sudo /etc/init.d/ssh start</code></p>\n</li>\n<li><p>检查服务是否正确启动：<code>ps -e | grep ssh</code></p>\n</li>\n</ul>\n<p><img src=\"/images/Hadoop/ssh_log.png\" alt=\"\"></p>\n<h4 id=\"配置ssh无密码登录\"><a href=\"#配置ssh无密码登录\" class=\"headerlink\" title=\"配置ssh无密码登录\"></a>配置ssh无密码登录</h4><ul>\n<li><p>这个也要在hadoop用户下完成(因为这会在你这个用户的文件夹下的.ssh文件夹生成key)</p>\n</li>\n<li><p>我们要设置成免密码登录，生成私钥和公钥：<code>ssh-keygen -t rsa -P &quot;&quot;</code></p>\n</li>\n</ul>\n<p><img src=\"/images/Hadoop/ssh_key.png\" alt=\"\"></p>\n<ul>\n<li>第一次操作时会提示输入密码，按Enter直接过，这时会在～/home/{username}/.ssh下生成两个文件：id_rsa和id_rsa.pub，前者为私钥，后者为公钥，现在我们将公钥追加到到authorized_keys中（authorized_keys用于保存所有允许以当前用户身份登录到ssh客户端用户的公钥内容）：</li>\n<li><p><code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></p>\n</li>\n<li><p>多台实体机进行通信（发送或者读取数据，namenode和datanode之间）就是借助ssh，在通信过程中如果需要操作人员频繁输入密码是不切实际的，所以需要ssh的无密码登录。</p>\n</li>\n<li><p>现在登录就不需要密码了：<code>ssh localhost</code></p>\n</li>\n<li><p><code>exit</code>命令退出登录localhost</p>\n</li>\n</ul>\n<h4 id=\"安装hadoop\"><a href=\"#安装hadoop\" class=\"headerlink\" title=\"安装hadoop\"></a>安装hadoop</h4><ul>\n<li><p>我下载的是hadoop-2.7.6版本</p>\n</li>\n<li><p>存放的路径是<code>/uer/local/Apache/hadoop-2.7.6</code></p>\n</li>\n<li><p>然后修改path环境变量，路径对应自己的实际存放路径：<br><img src=\"/images/Hadoop/path.png\" alt=\"\"></p>\n</li>\n<li><p>修改hadoop-env.sh: <strong>(这个不能用默认的，否则会报错)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=$&#123;JAVA_HOME&#125; #将这个改成JDK路径，如下  </span><br><span class=\"line\">export JAVA_HOME=/opt/jdk1.8.0_172</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确保下面的操作在hadoop用户下完成：<code>sudo chown -R  hadoop:hadoop /usr/local/Apache/hadoop-2.7.6 (自己hadoop的安装路径)</code></p>\n</li>\n<li><p>最后输入 <code>hadoop version</code> 确认安装</p>\n</li>\n<li><p>至此单机模式配置完成(在hadoop用户下的单机模式)</p>\n</li>\n</ul>\n<h3 id=\"伪分布式环境搭建\"><a href=\"#伪分布式环境搭建\" class=\"headerlink\" title=\"伪分布式环境搭建\"></a>伪分布式环境搭建</h3><p>-设定*-site.xml:这里需要设定三个文件。我的三个文件的路径是<code>/usr/local/Apache/hadoop-2.7.6/etc/hadoop/</code></p>\n<ul>\n<li>core-site.xml:  Hadoop Core的配置项，例如HDFS和MapReduce常用的I/O设置等。</li>\n<li>hdfs-site.xml:  Hadoop 守护进程的配置项，包括namenode，辅助namenode和datanode等。</li>\n<li>mapred-site.xml： MapReduce 守护进程的配置项，包括jobtracker和tasktracker。</li>\n</ul>\n<h4 id=\"首先在hadoop根目录下新建几个文件夹：\"><a href=\"#首先在hadoop根目录下新建几个文件夹：\" class=\"headerlink\" title=\"首先在hadoop根目录下新建几个文件夹：\"></a>首先在hadoop根目录下新建几个文件夹：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir hdfs</span><br><span class=\"line\">mkdir hdfs/name</span><br><span class=\"line\">mkdir hdfs/data</span><br><span class=\"line\">mkdir tmp</span><br></pre></td></tr></table></figure>\n<ul>\n<li>接下来编辑这三个文件：</li>\n</ul>\n<p>core-site.xml:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;  </span><br><span class=\"line\">    &lt;property&gt;  </span><br><span class=\"line\">        &lt;name&gt;fs.default.name&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">    &lt;property&gt;  </span><br><span class=\"line\">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;/usr/local/Apache/hadoop-2.7.1/tmp&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>\n<p>hdfs-site.xml:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;  </span><br><span class=\"line\">    &lt;property&gt;  &lt;!--设置副本数1，不写默认是3份--&gt;</span><br><span class=\"line\">        &lt;name&gt;dfs.replication&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;1&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">    &lt;property&gt;  </span><br><span class=\"line\">        &lt;name&gt;dfs.name.dir&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;/usr/local/Apache/hadoop-2.7.1/hdfs/name&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">    &lt;property&gt;  </span><br><span class=\"line\">        &lt;name&gt;dfs.data.dir&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;/usr/local/Apache/hadoop-2.7.1/hdfs/data&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>\n<p>mapred-site.xml:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;  </span><br><span class=\"line\">    &lt;property&gt;  </span><br><span class=\"line\">        &lt;name&gt;mapred.job.tracker&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;localhost:9001&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"格式化hdfs\"><a href=\"#格式化hdfs\" class=\"headerlink\" title=\"格式化hdfs\"></a>格式化hdfs</h4><ul>\n<li>启动Hadoop到相关服务，格式化namenode,secondarynamenode,tasktracker的文件系统目录:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /usr/local/Apache/hadoop-2.7.1/etc/hadoop/hadoop-env.sh</span><br><span class=\"line\">hadoop namenode -format</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"启动hadoop\"><a href=\"#启动hadoop\" class=\"headerlink\" title=\"启动hadoop\"></a>启动hadoop</h4><ul>\n<li><p><strong>首先要先连接到localhost!!</strong>(否则无法在网页上查看节点)。<br><code>ssh localhost</code></p>\n</li>\n<li><p>我的<code>start-all.sh</code>脚本在sbin目录下，各个版本可能不太一样，如果这个文件夹没有就去别的文件夹找找。</p>\n</li>\n<li><p>执行start-all.sh来启动所有服务:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd sbin</span><br><span class=\"line\">./start-all.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用命令<code>jps</code>查看是否启动成功：<br><img src=\"/images/Hadoop/launch_info.png\" alt=\"\"><br>如果出现NodeManager DataNode Jps SecondaryNameNode ResourceManager NameNode则表示启动成功(缺一不可)</p>\n</li>\n<li><p>检查运行状态:<br>所有的设置已完成，Hadoop也启动了，现在可以通过下面的操作来查看服务是否正常，在Hadoop中用于监控集群健康状态的Web界面：</p>\n</li>\n</ul>\n<p><code>http://localhost:50030/     - Hadoop 管理介面</code></p>\n<p><code>http://localhost:50060/     - Hadoop Task Tracker 状态</code></p>\n<p><code>http://localhost:50070/     - Hadoop DFS 状态</code></p>\n<ul>\n<li>目前我只有50070是正常访问的，其余的还不能访问，原因有待进一步探究<br><img src=\"/images/Hadoop/datanode_info.png\" alt=\"\"></li>\n</ul>\n<ul>\n<li><p>停止服务：<br><code>./stop-all.sh</code></p>\n<p><img src=\"/images/Hadoop/stop_all.png\" alt=\"\"></p>\n</li>\n<li><p>由于之前已经将hadoop的<code>bin</code>和<code>sbin</code>两个目录添加到系统环境路径里去了，这样下次启动直接就可以是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh localhost</span><br><span class=\"line\">start-all.sh</span><br><span class=\"line\">...</span><br><span class=\"line\">stop-all.sh</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样就方便很多了。</p>\n<ul>\n<li>参考博客——<a href=\"https://blog.csdn.net/hitwengqi/article/details/8008203\" target=\"_blank\" rel=\"noopener\">hadoop伪分布式搭建</a>，<a href=\"https://blog.csdn.net/Dr_Guo/article/details/50886667\" target=\"_blank\" rel=\"noopener\">很详细的搭建步骤(Hadoop-2.7.2版本)</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.31</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Hadoop-单机伪分布式环境搭建\"><a href=\"#Hadoop-单机伪分布式环境搭建\" class=\"headerlink\" title=\"Hadoop 单机伪分布式环境搭建\"></a>Hadoop 单机伪分布式环境搭建</h2><hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><ul>\n<li><p>这是对之前spark环境搭建的一点补充。</p>\n</li>\n<li><p>首先要了解一下Hadoop的运行模式：</p>\n</li>\n<li><p>单机模式（standalone）:单机模式是Hadoop的默认模式。当首次解压Hadoop的源码包时，Hadoop无法了解硬件安装环境，便保守地选择了最小配置。在这种默认模式下所有3个XML文件均为空。当配置文件为空时，Hadoop会完全运行在本地。因为不需要与其他节点交互，单机模式就不使用HDFS，也不加载任何Hadoop的守护进程。该模式主要用于开发调试MapReduce程序的应用逻辑。</p>\n</li>\n<li><p>伪分布模式（Pseudo-Distributed Mode）: 伪分布模式在“单节点集群”上运行Hadoop，其中所有的守护进程都运行在同一台机器上。该模式在单机模式之上增加了代码调试功能，允许你检查内存使用情况，HDFS输入输出，以及其他的守护进程交互。</p>\n</li>\n<li><p>全分布模式（Fully Distributed Mode）:Hadoop守护进程运行在一个集群上。</p>\n</li>\n</ul>\n<h3 id=\"新建用户\"><a href=\"#新建用户\" class=\"headerlink\" title=\"新建用户\"></a>新建用户</h3><ul>\n<li><p>添加一个名为hadoop到系统用户，专门用来做Hadoop测试:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo addgroup hadoop</span><br><span class=\"line\">sudo adduser --ingroup hadoop hadoop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>再赋予hadoop用户 sudo的权限：<code>sudo usermod -aG sudo hadoop</code></p>\n</li>\n<li><p>这里<code>sudo</code>是我的电脑上有sudo权限的用户组的名称，你可以<code>cat /etc/group</code>看看有哪些用户组以及这些用户组下的用户。</p>\n</li>\n<li><p>实在不行就吧你原来用户在的组都加一个hadoop用户</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/lymemoryzz/article/details/50627767\" target=\"_blank\" rel=\"noopener\">创建新用户并增加管理员详解</a></p>\n</li>\n</ul>\n<h3 id=\"安装ssh\"><a href=\"#安装ssh\" class=\"headerlink\" title=\"安装ssh\"></a>安装ssh</h3><ul>\n<li><p><strong>注意先切换到hadoop用户</strong></p>\n</li>\n<li><p>命令：<code>sudo apt-get install openssh-server</code></p>\n</li>\n<li><p>启动服务：<code>sudo /etc/init.d/ssh start</code></p>\n</li>\n<li><p>检查服务是否正确启动：<code>ps -e | grep ssh</code></p>\n</li>\n</ul>\n<p><img src=\"/images/Hadoop/ssh_log.png\" alt=\"\"></p>\n<h4 id=\"配置ssh无密码登录\"><a href=\"#配置ssh无密码登录\" class=\"headerlink\" title=\"配置ssh无密码登录\"></a>配置ssh无密码登录</h4><ul>\n<li><p>这个也要在hadoop用户下完成(因为这会在你这个用户的文件夹下的.ssh文件夹生成key)</p>\n</li>\n<li><p>我们要设置成免密码登录，生成私钥和公钥：<code>ssh-keygen -t rsa -P &quot;&quot;</code></p>\n</li>\n</ul>\n<p><img src=\"/images/Hadoop/ssh_key.png\" alt=\"\"></p>\n<ul>\n<li>第一次操作时会提示输入密码，按Enter直接过，这时会在～/home/{username}/.ssh下生成两个文件：id_rsa和id_rsa.pub，前者为私钥，后者为公钥，现在我们将公钥追加到到authorized_keys中（authorized_keys用于保存所有允许以当前用户身份登录到ssh客户端用户的公钥内容）：</li>\n<li><p><code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></p>\n</li>\n<li><p>多台实体机进行通信（发送或者读取数据，namenode和datanode之间）就是借助ssh，在通信过程中如果需要操作人员频繁输入密码是不切实际的，所以需要ssh的无密码登录。</p>\n</li>\n<li><p>现在登录就不需要密码了：<code>ssh localhost</code></p>\n</li>\n<li><p><code>exit</code>命令退出登录localhost</p>\n</li>\n</ul>\n<h4 id=\"安装hadoop\"><a href=\"#安装hadoop\" class=\"headerlink\" title=\"安装hadoop\"></a>安装hadoop</h4><ul>\n<li><p>我下载的是hadoop-2.7.6版本</p>\n</li>\n<li><p>存放的路径是<code>/uer/local/Apache/hadoop-2.7.6</code></p>\n</li>\n<li><p>然后修改path环境变量，路径对应自己的实际存放路径：<br><img src=\"/images/Hadoop/path.png\" alt=\"\"></p>\n</li>\n<li><p>修改hadoop-env.sh: <strong>(这个不能用默认的，否则会报错)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=$&#123;JAVA_HOME&#125; #将这个改成JDK路径，如下  </span><br><span class=\"line\">export JAVA_HOME=/opt/jdk1.8.0_172</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确保下面的操作在hadoop用户下完成：<code>sudo chown -R  hadoop:hadoop /usr/local/Apache/hadoop-2.7.6 (自己hadoop的安装路径)</code></p>\n</li>\n<li><p>最后输入 <code>hadoop version</code> 确认安装</p>\n</li>\n<li><p>至此单机模式配置完成(在hadoop用户下的单机模式)</p>\n</li>\n</ul>\n<h3 id=\"伪分布式环境搭建\"><a href=\"#伪分布式环境搭建\" class=\"headerlink\" title=\"伪分布式环境搭建\"></a>伪分布式环境搭建</h3><p>-设定*-site.xml:这里需要设定三个文件。我的三个文件的路径是<code>/usr/local/Apache/hadoop-2.7.6/etc/hadoop/</code></p>\n<ul>\n<li>core-site.xml:  Hadoop Core的配置项，例如HDFS和MapReduce常用的I/O设置等。</li>\n<li>hdfs-site.xml:  Hadoop 守护进程的配置项，包括namenode，辅助namenode和datanode等。</li>\n<li>mapred-site.xml： MapReduce 守护进程的配置项，包括jobtracker和tasktracker。</li>\n</ul>\n<h4 id=\"首先在hadoop根目录下新建几个文件夹：\"><a href=\"#首先在hadoop根目录下新建几个文件夹：\" class=\"headerlink\" title=\"首先在hadoop根目录下新建几个文件夹：\"></a>首先在hadoop根目录下新建几个文件夹：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir hdfs</span><br><span class=\"line\">mkdir hdfs/name</span><br><span class=\"line\">mkdir hdfs/data</span><br><span class=\"line\">mkdir tmp</span><br></pre></td></tr></table></figure>\n<ul>\n<li>接下来编辑这三个文件：</li>\n</ul>\n<p>core-site.xml:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;  </span><br><span class=\"line\">    &lt;property&gt;  </span><br><span class=\"line\">        &lt;name&gt;fs.default.name&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">    &lt;property&gt;  </span><br><span class=\"line\">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;/usr/local/Apache/hadoop-2.7.1/tmp&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>\n<p>hdfs-site.xml:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;  </span><br><span class=\"line\">    &lt;property&gt;  &lt;!--设置副本数1，不写默认是3份--&gt;</span><br><span class=\"line\">        &lt;name&gt;dfs.replication&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;1&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">    &lt;property&gt;  </span><br><span class=\"line\">        &lt;name&gt;dfs.name.dir&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;/usr/local/Apache/hadoop-2.7.1/hdfs/name&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">    &lt;property&gt;  </span><br><span class=\"line\">        &lt;name&gt;dfs.data.dir&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;/usr/local/Apache/hadoop-2.7.1/hdfs/data&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>\n<p>mapred-site.xml:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;  </span><br><span class=\"line\">    &lt;property&gt;  </span><br><span class=\"line\">        &lt;name&gt;mapred.job.tracker&lt;/name&gt;  </span><br><span class=\"line\">        &lt;value&gt;localhost:9001&lt;/value&gt;  </span><br><span class=\"line\">    &lt;/property&gt;  </span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"格式化hdfs\"><a href=\"#格式化hdfs\" class=\"headerlink\" title=\"格式化hdfs\"></a>格式化hdfs</h4><ul>\n<li>启动Hadoop到相关服务，格式化namenode,secondarynamenode,tasktracker的文件系统目录:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /usr/local/Apache/hadoop-2.7.1/etc/hadoop/hadoop-env.sh</span><br><span class=\"line\">hadoop namenode -format</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"启动hadoop\"><a href=\"#启动hadoop\" class=\"headerlink\" title=\"启动hadoop\"></a>启动hadoop</h4><ul>\n<li><p><strong>首先要先连接到localhost!!</strong>(否则无法在网页上查看节点)。<br><code>ssh localhost</code></p>\n</li>\n<li><p>我的<code>start-all.sh</code>脚本在sbin目录下，各个版本可能不太一样，如果这个文件夹没有就去别的文件夹找找。</p>\n</li>\n<li><p>执行start-all.sh来启动所有服务:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd sbin</span><br><span class=\"line\">./start-all.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用命令<code>jps</code>查看是否启动成功：<br><img src=\"/images/Hadoop/launch_info.png\" alt=\"\"><br>如果出现NodeManager DataNode Jps SecondaryNameNode ResourceManager NameNode则表示启动成功(缺一不可)</p>\n</li>\n<li><p>检查运行状态:<br>所有的设置已完成，Hadoop也启动了，现在可以通过下面的操作来查看服务是否正常，在Hadoop中用于监控集群健康状态的Web界面：</p>\n</li>\n</ul>\n<p><code>http://localhost:50030/     - Hadoop 管理介面</code></p>\n<p><code>http://localhost:50060/     - Hadoop Task Tracker 状态</code></p>\n<p><code>http://localhost:50070/     - Hadoop DFS 状态</code></p>\n<ul>\n<li>目前我只有50070是正常访问的，其余的还不能访问，原因有待进一步探究<br><img src=\"/images/Hadoop/datanode_info.png\" alt=\"\"></li>\n</ul>\n<ul>\n<li><p>停止服务：<br><code>./stop-all.sh</code></p>\n<p><img src=\"/images/Hadoop/stop_all.png\" alt=\"\"></p>\n</li>\n<li><p>由于之前已经将hadoop的<code>bin</code>和<code>sbin</code>两个目录添加到系统环境路径里去了，这样下次启动直接就可以是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh localhost</span><br><span class=\"line\">start-all.sh</span><br><span class=\"line\">...</span><br><span class=\"line\">stop-all.sh</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样就方便很多了。</p>\n<ul>\n<li>参考博客——<a href=\"https://blog.csdn.net/hitwengqi/article/details/8008203\" target=\"_blank\" rel=\"noopener\">hadoop伪分布式搭建</a>，<a href=\"https://blog.csdn.net/Dr_Guo/article/details/50886667\" target=\"_blank\" rel=\"noopener\">很详细的搭建步骤(Hadoop-2.7.2版本)</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.31</p>\n</blockquote>\n"},{"layout":"post","title":"HDFS相关笔记","date":"2018-05-30T01:46:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n## 前言\n\n- 马上就六一了，赶在月底结束之前再记录一些东西吧～\n\n- 以下HDFS的操作是基于Ubuntu18的\n\n## HDFS简介\n---\n\n- [Hadoop分布式文件系统(HDFS)官方中文文档](https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html)\n\n### Namenode 和 Datanode\n\n- HDFS采用master/slave架构。一个HDFS集群是由一个Namenode和一定数目的Datanodes组成。\n\n- HDFS采用Java语言开发，因此任何支持Java的机器都可以部署Namenode或Datanode。\n\n- Namenode是一个中心服务器，负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。集群中的Datanode一般是一个节点一个，负责管理它所在节点上的存储。HDFS暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。\n\n- 从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组Datanode上。Namenode执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体Datanode节点的映射。Datanode负责处理文件系统客户端的读写请求。在Namenode的统一调度下进行数据块的创建、删除和复制。\n\n- Namenode负责维护文件系统的名字空间，任何对文件系统名字空间或属性的修改都将被Namenode记录下来。应用程序可以设置HDFS保存的文件的副本数目。文件副本的数目称为文件的副本系数，这个信息也是由Namenode保存的。\n\n- Namenode全权管理数据块的复制，它周期性地从集群中的每个Datanode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该Datanode节点工作正常。块状态报告包含了一个该Datanode上所有数据块的列表。\n\n- HDFS中的文件都是一次性写入的，并且 **严格要求在任何时候只能有一个写入者**。\n\n## HDFS文件系统\n---\n\n### DFSShell\n\n- HDFS以文件和目录的形式组织用户数据。它提供了一个命令行的接口(DFSShell)让用户与HDFS中的数据进行交互。命令的语法和用户熟悉的其他shell(例如 bash, csh)工具类似。下面是一些动作/命令的示例：\n\n- 创建一个名为 `/foodir` 的目录:\t`bin/hadoop dfs -mkdir /foodir`\n\n- 创建一个名为 `/foodir` 的目录:\t`bin/hadoop dfs -mkdir /foodir`\n\n- 查看名为 `/foodir/myfile.txt` 的文件内容:\t`bin/hadoop dfs -cat /foodir/myfile.txt`\n\n#### 常用\n\n- **注意，分布式文件系统中没有切换到某个目录下的概念，因为其文件全是分散在各个节点上的**\n\n- 分布式文件系统的文件路径完整格式为 `hdfs://namenode|master:编号/root/...`\n\n- 例如：`hdfs://master:8020/dataset/evaluation/bots_10m_10.csv`\n\n- `hdfs dfs -ls  /...`显示分布式文件系统中某个目录（实际并不存在，只是逻辑上的）下的文件\n\n- `hdfs dfs -rm -r file_name|directory_name` 删除某个文件或者目录\n\n### 通讯协议\n\n- 所有的HDFS通讯协议都是建立在TCP/IP协议之上。客户端通过一个可配置的TCP端口连接到Namenode，通过ClientProtocol协议与Namenode交互。而Datanode使用DatanodeProtocol协议与Namenode交互。\n\n- 一个远程过程调用(RPC)模型被抽象出来封装ClientProtocol和Datanodeprotocol协议。在设计上，Namenode不会主动发起RPC，而是响应来自客户端或 Datanode 的RPC请求。\n\n### 数据块\n\n- HDFS被设计成支持大文件，适用HDFS的是那些需要处理大规模的数据集的应用。这些应用都是只写入数据一次，但却读取一次或多次，并且读取速度应能满足流式读取的需要。HDFS支持文件的“一次写入多次读取”语义。一个典型的数据块大小是64MB。因而，HDFS中的文件总是按照64M被切分成不同的块，每个块尽可能地存储于不同的Datanode中。\n\n\n\n\n<br>\n> 最后更新于2018.5.31\n","source":"_posts/2018-05-31-HDFS.md","raw":"---\nlayout:     post\ntitle:      \"HDFS相关笔记\"\ndate:       2018-05-30 09:46:00\ncategories: Computer System\ntags:   [๑Hadoop, ๑BigData, ๑HDFS, ๑Spark]\n---\n\n> 不适合人类阅读的学习笔记\n\n## 前言\n\n- 马上就六一了，赶在月底结束之前再记录一些东西吧～\n\n- 以下HDFS的操作是基于Ubuntu18的\n\n## HDFS简介\n---\n\n- [Hadoop分布式文件系统(HDFS)官方中文文档](https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html)\n\n### Namenode 和 Datanode\n\n- HDFS采用master/slave架构。一个HDFS集群是由一个Namenode和一定数目的Datanodes组成。\n\n- HDFS采用Java语言开发，因此任何支持Java的机器都可以部署Namenode或Datanode。\n\n- Namenode是一个中心服务器，负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。集群中的Datanode一般是一个节点一个，负责管理它所在节点上的存储。HDFS暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。\n\n- 从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组Datanode上。Namenode执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体Datanode节点的映射。Datanode负责处理文件系统客户端的读写请求。在Namenode的统一调度下进行数据块的创建、删除和复制。\n\n- Namenode负责维护文件系统的名字空间，任何对文件系统名字空间或属性的修改都将被Namenode记录下来。应用程序可以设置HDFS保存的文件的副本数目。文件副本的数目称为文件的副本系数，这个信息也是由Namenode保存的。\n\n- Namenode全权管理数据块的复制，它周期性地从集群中的每个Datanode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该Datanode节点工作正常。块状态报告包含了一个该Datanode上所有数据块的列表。\n\n- HDFS中的文件都是一次性写入的，并且 **严格要求在任何时候只能有一个写入者**。\n\n## HDFS文件系统\n---\n\n### DFSShell\n\n- HDFS以文件和目录的形式组织用户数据。它提供了一个命令行的接口(DFSShell)让用户与HDFS中的数据进行交互。命令的语法和用户熟悉的其他shell(例如 bash, csh)工具类似。下面是一些动作/命令的示例：\n\n- 创建一个名为 `/foodir` 的目录:\t`bin/hadoop dfs -mkdir /foodir`\n\n- 创建一个名为 `/foodir` 的目录:\t`bin/hadoop dfs -mkdir /foodir`\n\n- 查看名为 `/foodir/myfile.txt` 的文件内容:\t`bin/hadoop dfs -cat /foodir/myfile.txt`\n\n#### 常用\n\n- **注意，分布式文件系统中没有切换到某个目录下的概念，因为其文件全是分散在各个节点上的**\n\n- 分布式文件系统的文件路径完整格式为 `hdfs://namenode|master:编号/root/...`\n\n- 例如：`hdfs://master:8020/dataset/evaluation/bots_10m_10.csv`\n\n- `hdfs dfs -ls  /...`显示分布式文件系统中某个目录（实际并不存在，只是逻辑上的）下的文件\n\n- `hdfs dfs -rm -r file_name|directory_name` 删除某个文件或者目录\n\n### 通讯协议\n\n- 所有的HDFS通讯协议都是建立在TCP/IP协议之上。客户端通过一个可配置的TCP端口连接到Namenode，通过ClientProtocol协议与Namenode交互。而Datanode使用DatanodeProtocol协议与Namenode交互。\n\n- 一个远程过程调用(RPC)模型被抽象出来封装ClientProtocol和Datanodeprotocol协议。在设计上，Namenode不会主动发起RPC，而是响应来自客户端或 Datanode 的RPC请求。\n\n### 数据块\n\n- HDFS被设计成支持大文件，适用HDFS的是那些需要处理大规模的数据集的应用。这些应用都是只写入数据一次，但却读取一次或多次，并且读取速度应能满足流式读取的需要。HDFS支持文件的“一次写入多次读取”语义。一个典型的数据块大小是64MB。因而，HDFS中的文件总是按照64M被切分成不同的块，每个块尽可能地存储于不同的Datanode中。\n\n\n\n\n<br>\n> 最后更新于2018.5.31\n","slug":"2018-05-31-HDFS","published":1,"updated":"2018-09-03T13:15:40.361Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j50002c1m0obnc7wexm","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li><p>马上就六一了，赶在月底结束之前再记录一些东西吧～</p>\n</li>\n<li><p>以下HDFS的操作是基于Ubuntu18的</p>\n</li>\n</ul>\n<h2 id=\"HDFS简介\"><a href=\"#HDFS简介\" class=\"headerlink\" title=\"HDFS简介\"></a>HDFS简介</h2><hr>\n<ul>\n<li><a href=\"https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html\" target=\"_blank\" rel=\"noopener\">Hadoop分布式文件系统(HDFS)官方中文文档</a></li>\n</ul>\n<h3 id=\"Namenode-和-Datanode\"><a href=\"#Namenode-和-Datanode\" class=\"headerlink\" title=\"Namenode 和 Datanode\"></a>Namenode 和 Datanode</h3><ul>\n<li><p>HDFS采用master/slave架构。一个HDFS集群是由一个Namenode和一定数目的Datanodes组成。</p>\n</li>\n<li><p>HDFS采用Java语言开发，因此任何支持Java的机器都可以部署Namenode或Datanode。</p>\n</li>\n<li><p>Namenode是一个中心服务器，负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。集群中的Datanode一般是一个节点一个，负责管理它所在节点上的存储。HDFS暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。</p>\n</li>\n<li><p>从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组Datanode上。Namenode执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体Datanode节点的映射。Datanode负责处理文件系统客户端的读写请求。在Namenode的统一调度下进行数据块的创建、删除和复制。</p>\n</li>\n<li><p>Namenode负责维护文件系统的名字空间，任何对文件系统名字空间或属性的修改都将被Namenode记录下来。应用程序可以设置HDFS保存的文件的副本数目。文件副本的数目称为文件的副本系数，这个信息也是由Namenode保存的。</p>\n</li>\n<li><p>Namenode全权管理数据块的复制，它周期性地从集群中的每个Datanode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该Datanode节点工作正常。块状态报告包含了一个该Datanode上所有数据块的列表。</p>\n</li>\n<li><p>HDFS中的文件都是一次性写入的，并且 <strong>严格要求在任何时候只能有一个写入者</strong>。</p>\n</li>\n</ul>\n<h2 id=\"HDFS文件系统\"><a href=\"#HDFS文件系统\" class=\"headerlink\" title=\"HDFS文件系统\"></a>HDFS文件系统</h2><hr>\n<h3 id=\"DFSShell\"><a href=\"#DFSShell\" class=\"headerlink\" title=\"DFSShell\"></a>DFSShell</h3><ul>\n<li><p>HDFS以文件和目录的形式组织用户数据。它提供了一个命令行的接口(DFSShell)让用户与HDFS中的数据进行交互。命令的语法和用户熟悉的其他shell(例如 bash, csh)工具类似。下面是一些动作/命令的示例：</p>\n</li>\n<li><p>创建一个名为 <code>/foodir</code> 的目录:    <code>bin/hadoop dfs -mkdir /foodir</code></p>\n</li>\n<li><p>创建一个名为 <code>/foodir</code> 的目录:    <code>bin/hadoop dfs -mkdir /foodir</code></p>\n</li>\n<li><p>查看名为 <code>/foodir/myfile.txt</code> 的文件内容:    <code>bin/hadoop dfs -cat /foodir/myfile.txt</code></p>\n</li>\n</ul>\n<h4 id=\"常用\"><a href=\"#常用\" class=\"headerlink\" title=\"常用\"></a>常用</h4><ul>\n<li><p><strong>注意，分布式文件系统中没有切换到某个目录下的概念，因为其文件全是分散在各个节点上的</strong></p>\n</li>\n<li><p>分布式文件系统的文件路径完整格式为 <code>hdfs://namenode|master:编号/root/...</code></p>\n</li>\n<li><p>例如：<code>hdfs://master:8020/dataset/evaluation/bots_10m_10.csv</code></p>\n</li>\n<li><p><code>hdfs dfs -ls  /...</code>显示分布式文件系统中某个目录（实际并不存在，只是逻辑上的）下的文件</p>\n</li>\n<li><p><code>hdfs dfs -rm -r file_name|directory_name</code> 删除某个文件或者目录</p>\n</li>\n</ul>\n<h3 id=\"通讯协议\"><a href=\"#通讯协议\" class=\"headerlink\" title=\"通讯协议\"></a>通讯协议</h3><ul>\n<li><p>所有的HDFS通讯协议都是建立在TCP/IP协议之上。客户端通过一个可配置的TCP端口连接到Namenode，通过ClientProtocol协议与Namenode交互。而Datanode使用DatanodeProtocol协议与Namenode交互。</p>\n</li>\n<li><p>一个远程过程调用(RPC)模型被抽象出来封装ClientProtocol和Datanodeprotocol协议。在设计上，Namenode不会主动发起RPC，而是响应来自客户端或 Datanode 的RPC请求。</p>\n</li>\n</ul>\n<h3 id=\"数据块\"><a href=\"#数据块\" class=\"headerlink\" title=\"数据块\"></a>数据块</h3><ul>\n<li>HDFS被设计成支持大文件，适用HDFS的是那些需要处理大规模的数据集的应用。这些应用都是只写入数据一次，但却读取一次或多次，并且读取速度应能满足流式读取的需要。HDFS支持文件的“一次写入多次读取”语义。一个典型的数据块大小是64MB。因而，HDFS中的文件总是按照64M被切分成不同的块，每个块尽可能地存储于不同的Datanode中。</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.31</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li><p>马上就六一了，赶在月底结束之前再记录一些东西吧～</p>\n</li>\n<li><p>以下HDFS的操作是基于Ubuntu18的</p>\n</li>\n</ul>\n<h2 id=\"HDFS简介\"><a href=\"#HDFS简介\" class=\"headerlink\" title=\"HDFS简介\"></a>HDFS简介</h2><hr>\n<ul>\n<li><a href=\"https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html\" target=\"_blank\" rel=\"noopener\">Hadoop分布式文件系统(HDFS)官方中文文档</a></li>\n</ul>\n<h3 id=\"Namenode-和-Datanode\"><a href=\"#Namenode-和-Datanode\" class=\"headerlink\" title=\"Namenode 和 Datanode\"></a>Namenode 和 Datanode</h3><ul>\n<li><p>HDFS采用master/slave架构。一个HDFS集群是由一个Namenode和一定数目的Datanodes组成。</p>\n</li>\n<li><p>HDFS采用Java语言开发，因此任何支持Java的机器都可以部署Namenode或Datanode。</p>\n</li>\n<li><p>Namenode是一个中心服务器，负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。集群中的Datanode一般是一个节点一个，负责管理它所在节点上的存储。HDFS暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。</p>\n</li>\n<li><p>从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组Datanode上。Namenode执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体Datanode节点的映射。Datanode负责处理文件系统客户端的读写请求。在Namenode的统一调度下进行数据块的创建、删除和复制。</p>\n</li>\n<li><p>Namenode负责维护文件系统的名字空间，任何对文件系统名字空间或属性的修改都将被Namenode记录下来。应用程序可以设置HDFS保存的文件的副本数目。文件副本的数目称为文件的副本系数，这个信息也是由Namenode保存的。</p>\n</li>\n<li><p>Namenode全权管理数据块的复制，它周期性地从集群中的每个Datanode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该Datanode节点工作正常。块状态报告包含了一个该Datanode上所有数据块的列表。</p>\n</li>\n<li><p>HDFS中的文件都是一次性写入的，并且 <strong>严格要求在任何时候只能有一个写入者</strong>。</p>\n</li>\n</ul>\n<h2 id=\"HDFS文件系统\"><a href=\"#HDFS文件系统\" class=\"headerlink\" title=\"HDFS文件系统\"></a>HDFS文件系统</h2><hr>\n<h3 id=\"DFSShell\"><a href=\"#DFSShell\" class=\"headerlink\" title=\"DFSShell\"></a>DFSShell</h3><ul>\n<li><p>HDFS以文件和目录的形式组织用户数据。它提供了一个命令行的接口(DFSShell)让用户与HDFS中的数据进行交互。命令的语法和用户熟悉的其他shell(例如 bash, csh)工具类似。下面是一些动作/命令的示例：</p>\n</li>\n<li><p>创建一个名为 <code>/foodir</code> 的目录:    <code>bin/hadoop dfs -mkdir /foodir</code></p>\n</li>\n<li><p>创建一个名为 <code>/foodir</code> 的目录:    <code>bin/hadoop dfs -mkdir /foodir</code></p>\n</li>\n<li><p>查看名为 <code>/foodir/myfile.txt</code> 的文件内容:    <code>bin/hadoop dfs -cat /foodir/myfile.txt</code></p>\n</li>\n</ul>\n<h4 id=\"常用\"><a href=\"#常用\" class=\"headerlink\" title=\"常用\"></a>常用</h4><ul>\n<li><p><strong>注意，分布式文件系统中没有切换到某个目录下的概念，因为其文件全是分散在各个节点上的</strong></p>\n</li>\n<li><p>分布式文件系统的文件路径完整格式为 <code>hdfs://namenode|master:编号/root/...</code></p>\n</li>\n<li><p>例如：<code>hdfs://master:8020/dataset/evaluation/bots_10m_10.csv</code></p>\n</li>\n<li><p><code>hdfs dfs -ls  /...</code>显示分布式文件系统中某个目录（实际并不存在，只是逻辑上的）下的文件</p>\n</li>\n<li><p><code>hdfs dfs -rm -r file_name|directory_name</code> 删除某个文件或者目录</p>\n</li>\n</ul>\n<h3 id=\"通讯协议\"><a href=\"#通讯协议\" class=\"headerlink\" title=\"通讯协议\"></a>通讯协议</h3><ul>\n<li><p>所有的HDFS通讯协议都是建立在TCP/IP协议之上。客户端通过一个可配置的TCP端口连接到Namenode，通过ClientProtocol协议与Namenode交互。而Datanode使用DatanodeProtocol协议与Namenode交互。</p>\n</li>\n<li><p>一个远程过程调用(RPC)模型被抽象出来封装ClientProtocol和Datanodeprotocol协议。在设计上，Namenode不会主动发起RPC，而是响应来自客户端或 Datanode 的RPC请求。</p>\n</li>\n</ul>\n<h3 id=\"数据块\"><a href=\"#数据块\" class=\"headerlink\" title=\"数据块\"></a>数据块</h3><ul>\n<li>HDFS被设计成支持大文件，适用HDFS的是那些需要处理大规模的数据集的应用。这些应用都是只写入数据一次，但却读取一次或多次，并且读取速度应能满足流式读取的需要。HDFS支持文件的“一次写入多次读取”语义。一个典型的数据块大小是64MB。因而，HDFS中的文件总是按照64M被切分成不同的块，每个块尽可能地存储于不同的Datanode中。</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.5.31</p>\n</blockquote>\n"},{"layout":"post","title":"前端学习——CSS","date":"2018-06-17T08:46:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n- CSS全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。\n\n- **在CSS代码中不要随便加空格**\n\n- [CSS3动画效果](https://www.jianshu.com/p/57ba5da7f9f6)\n\n## CSS代码语法\n---\n\n### 基础\n\n> 注意各个语句之间以分号间隔\n\n- css 样式由选择符和声明组成，而声明又由属性和值组成，例如：`p{color:blue}`\n\n- 其中，`p`为 **选择符**，`{..}`为 **声明**，`color`为 **属性**，`blue`为 **值**。\n\n- 选择符：又称选择器，**指明网页中要应用样式规则的元素**，如本例中是网页中所有的段（p）的文字将变成蓝色，而其他的元素（如ol）不会受到影响。\n\n- 声明：在英文大括号`｛ ｝`中的的就是声明，属性和值之间用英文冒号`：`分隔。当有多条声明时，中间可以英文分号`；`分隔，如：`p{font-size:12px;color:red;}`\n\n- 最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号\n\n- 为了使用样式更加容易阅读，可以将每条代码写在一个新行内，所以上面的应该写为：\n\n```\np{\n  font-size:12px;\n  color:red;\n}\n```\n\n### CSS中的注释\n\n- 格式：`/*注释语句*/`\n\n## 三种CSS样式\n---\n\n- 从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式、嵌入式和外部式三种。\n\n### 内联式css样式，直接写在现有的HTML标签中\n\n- 内联式css样式表就是把css代码直接写在现有的HTML标签中，如下面代码：\n\n```\n<p style=\"color:red\">这里文字是红色</p>\n```\n> 注意要写在元素的开始标签里\n\n- 并且css样式代码要写在`style=\"\"`双引号中，如果有多条css样式代码设置可以写在一起，中间用分号隔开。如下代码：\n\n```\n<p style=\"color:red;font-size:12px\">这里文字是红色</p>\n```\n\n### 嵌入式css样式，写在当前的文件中\n\n- 嵌入式css样式，就是可以把css样式代码写在`<style type=\"text/css\"> </style>`标签之间。如下面代码实现把三个`<span>`标签中的文字设置为红色：\n\n```\n<style type=\"text/css\">\nspan{\ncolor:red;\n}\n</style>\n```\n\n- 嵌入式css样式必须写在`<style> </style>`之间，并且一般情况下嵌入式css样式写在`<head> </head>`之间\n\n\n### 外部式css样式，写在单独的一个文件中\n\n- 外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以`.css`为扩展名，在`<head>`内（不是在`<style>`标签内）使用`<link>`标签将css样式文件链接到HTML文件内，如下面代码：\n\n```\n<link href=\"base.css\" rel=\"stylesheet\" type=\"text/css\" />\n```\n\n- css样式文件名称以有意义的英文字母命名，如 main.css。\n\n- `rel=\"stylesheet\" type=\"text/css\"` 是 **固定写法** 不可修改。\n\n- `<link>`标签位置一般写在`<head>`标签之内。\n\n### 三种方法的优先级\n\n- 前提：在相同的权值的情况下。\n\n- 优先级：`内联式 > 嵌入式 > 外部式`\n\n- 总而言之，就是就近原则（离被设置元素越近优先级别越高）。\n\n\n## 选择器\n---\n\n- 每一条css样式声明（定义）由两部分组成，形式如下：\n\n```\n选择器{\n    样式;\n}\n```\n在`{}`之前的部分就是“选择器”，“选择器”指明了`{}`中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素。\n\n- 例：\n\n```\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<title>选择器</title>\n<style type=\"text/css\">\nbody{\n    font-size:12px;\n    color:red;\n}\n</style>\n</head>\n<body>\n<p>\nXXXXXXXX\n</p>\n</body>\n</html>\n```\n其中`body{..}`就是一个选择器（标签选择器），他作用于`<body>`部分\n\n\n### 标签选择器\n\n- 标签选择器其实就是html代码中的标签。\n\n- 例：`p{font-size:12px;line-height:1.6em;}`这个就为p标签（`<p>`标签是段落部分）设置12px字号，行间距设置1.6em的样式。\n\n### **类选择器**\n\n- 语法：`.类选器名称{css样式代码;}`\n\n- 注意：以英文圆点开头。类选择器可以任意起名字。\n\n- 用法：\n\n1. 使用合适的标签把要修饰的内容标记起来，如：`<span>胆小如鼠</span>`\n\n2. 使用`class=\"类选择器名称\"`为标签设置一个类，如：`<span class=\"stress\">胆小如鼠</span>`\n\n3. 设置类选器css样式，如：`.stress{color:red;} /*类前面要加入一个英文圆点*/`\n\n- 类选择器使得我们可以灵活地自定义不同的部分的格式。\n\n### **ID选择器**\n\n- 在很多方面，ID选择器都类似于类选择符，但也有一些重要的区别：\n\n1. **为标签设置`id=\"ID名称\"`，而不是`class=\"类名称\"`。**\n\n2. ID选择符的前面是井号（#），而不是英文圆点（.）\n\n- 例如：\n\n```\n#test{\n  color:blue;\n}\n...\nXXX<span id=\"test\">...</span>\n```\n\n### id选择器和类选择器的区别与联系\n\n#### 相同点\n\n- 可以应用于任何元素\n\n#### 不同点\n\n- **ID选择器只能在文档中使用一次**。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而**类选择器可以使用多次**。\n\n- **这里只能使用一次是指同一个id选择器只能修饰一个地方，而类选择器可以同时修饰多个地方。当然我们可以定义多个id选择器来修饰不同的地方**\n\n- 可以使用类选择器词列表方法为一个元素**同时设置多个样式**。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（不能使用 ID 词列表）。\n\n- **正确示例**：\n\n```\n.stress{\n    color:red;\n}\n.bigsize{\n    font-size:25px;\n}\n<p>\n到了<span class=\"stress bigsize\">三年级</span>下学期时，我们班上了一节公开课...\n</p>\n```\n以上代码在`<span>`里定义两个类来修饰，这样的语法是可以的。上面代码的作用是为“三年级”三个文字设置文本颜色为红色并且字号为25px。\n\n- 错误的例子：\n\n```\n#stressid{\n    color:red;\n}\n#bigsizeid{\n    font-size:25px;\n}\n<p>\n到了<span id=\"stressid bigsizeid\">三年级</span>下学期时，我们班上了一节公开课...\n</p>\n```\n以上代码是错误的，一个地方只能用一个id选择器来修饰。以上代码不能起到修饰的作用。\n\n### 子选择器\n\n- 还有一个比较有用的选择器子选择器，即大于符号(>),用于选择指定标签元素的**第一代子元素**。\n\n- 例如：(以下代码会使class名为food下的子元素 li 加入红色实线边框。)\n\n```\n...\n.food>li{border:1px solid red;}\n...\n<h1>食物</h1>\n<ul class=\"food\">\n    <li>水果\n        <ul>\n        \t<li>香蕉</li>\n            <li>苹果</li>\n            <li>梨</li>\n        </ul>\n    </li>\n    <li>蔬菜\n    \t<ul>\n        \t<li>白菜</li>\n            <li>油菜</li>\n            <li>卷心菜</li>\n        </ul>\n    </li>\n</ul>\n...\n```\n\n### 包含(后代)选择器\n\n- 包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。如：`.first  span{color:red;}`\n\n- 请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的**直接后代**，或者你可以理解为作用于子元素的**第一代后代**。而后代选择器是作用于**所有子后代元素**。后代选择器通过**空格**来进行选择，而子选择器是通过`>`进行选择。\n\n- 总而言之就是，空格选择所有后代元素，`>`只选择第一代后代。\n\n### **通用选择器**\n\n- 通用选择器是功能最强大的选择器，它使用一个`*`号指定，它的作用是匹配html中所有标签元素，如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色：`* {color:red;}`\n\n### 伪类选择符\n\n- 它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：`a:hover{color:red;}`  \n这句代码就实现了`<a>`(超链接)鼠标划过的特效，当鼠标划过超链接时，超链接的字体颜色会变成红色。\n\n- 一般`:hover`都是用来控制鼠标滑过的效果\n\n- 其实 `:hover` 可以放在任意的标签上，比如说 `p:hover`，但是它们的兼容性也是很不好的，所以一般用在`a:hover`的组合。(**现在也可以用在其他的地方**)\n\n### **分组选择符**\n\n- 当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（，），如下代码将`<h1>`、`<span>`标签同时设置字体颜色为红色：`h1,span{color:red;}`\n\n- 以上代码相当于下面两行代码：\n\n```\nh1{color:red;}\nspan{color:red;}\n```\n\n### 继承\n\n- CSS的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。就是对某一些标签的样式的修改会对其子代也产生影响。\n\n###　权值\n\n- 如果对同一个标签设置了不同的样式，浏览器是根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。\n\n- 权值的规则：**标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。**\n\n- 例如：\n\n```\np{color:red;} /*权值为1*/\np span{color:green;} /*权值为1+1=2*/\n.warning{color:white;} /*权值为10*/\np span.warning{color:purple;} /*权值为1+1+10=12*/\n#footer .note p{color:yellow;} /*权值为100+10+1=111*/\n```\n注意：还有一个权值比较特殊--继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。\n\n- 使用`!important`来使样式获得最高权值：`p{color:red!important;}`\n> 注意：!important要写在分号的前面,中间不需要空格。\n\n### 层叠\n\n- 如果在html文件中对于同一个元素可以有多个css样式存在并且这多个css样式具有相同权重值怎么办？这时候我们就会用到层叠。\n\n- 层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于**最后面的css样式**会被应用。\n\n- 简单来说，就是，就是后面的样式会覆盖前面的样式。\n\n- 所以之前的内外优先级关系：`内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）。` 也就很好理解了。\n\n## 文字排版\n---\n\n### 字体\n\n- 例：为网页设置字体 `body{font-family:\"Microsoft Yahei\";}` //字体为微软雅黑\n\n- 注意：这里设置的字体能否显示，取决于用户本地有没有安装这个字体。\n\n### 字号颜色\n\n- 设置网页中文字的字号为12像素，并把字体颜色设置为#666(灰色)：`body{font-size:12px;color:#666}`\n\n- `font-size`:字体大小\n\n- `color`：颜色(一般以`#`加数字来表示颜色，以增加颜色的多样化)\n\n### 一些字体样式：粗体、斜体等\n\n- `font-weight`:字体粗细\n\n- 例：`span{font-weight:bold;}`  //粗体\n\n- `font-style`:字体特点\n\n- 例：`span{font-style:italic;}`  //斜体(意大利体)\n\n- `text-decoration`:文字修饰\n\n- 例：`a{text-decoration:underline;}`  //下划线\n\n- 例：`.oldPrice{text-decoration:line-through;}`    //删除线(将文字划去)\n\n### 段落排版\n\n#### 首行缩进\n\n- 设置段落缩进两个字宽：`p{text-indent:2em;}`\n\n- `2em`的意思就是文字的2倍大小。\n\n#### 行间距\n\n- 例：`p{line-height:1.5em;}`\n\n#### 中文字间距、字母间距\n\n- 如果想在网页排版中设置**文字间隔**或者**字母间隔**就可以使用`letter-spacing`来实现。\n\n- 例：`h1{letter-spacing:10px;}`\n\n- 注意：这个样式使用在英文单词时，是设置**字母与字母之间**的间距。\n\n- 如果我想设置英文单词之间的间距，可以使用 `word-spacing` 来实现。\n\n- 例：`h1{word-spacing:20px;}`\n\n#### 对齐\n\n- 为块状元素中的文本、图片设置居中样式，可以使用`text-align`样式代码。\n\n- 例：`h1{text-align:center/left/right;}`  //居中/左对齐/右对齐\n\n\n## 元素分类\n---\n\n- 在CSS中，html中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。\n\n- 常用的块状元素有：`<div>、<p>、<h1>...<h6>、<ol>、<ul>、<dl>、<table>、<address>、<blockquote> 、<form>`\n\n- 常用的内联元素有：`<a>、<span>、<br>、<i>、<em>、<strong>、<label>、<q>、<var>、<cite>、<code>`\n\n- 常用的内联块状元素有：`<img>、<input>`\n\n### 块级元素\n\n- 设置`display:block`就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点：`a{display:block;}`\n\n- 块级元素特点：\n\n1. 每个块级元素都从新的一行开始，并且其后的元素也另起一行。\n\n2. 元素的高度、宽度、行高以及顶和底边距都可设置。\n\n3. 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。\n\n### 内联元素\n\n- 块状元素也可以通过代码`display:inline`将元素设置为内联元素。\n\n- 如下代码就是将块状元素div转换为内联元素，从而使 div 元素具有内联元素特点：`div{display:inline;}`\n\n- 内联元素特点：\n\n1. 和其他元素都在一行上\n\n2. 元素的高度、宽度及顶部和底部边距不可设置\n\n3. 元素的宽度就是它包含的文字或图片的宽度，不可改变\n\n### 内联块状元素\n\n- 内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码`display:inline-block`就是将元素设置为内联块状元素。\n\n- inline-block 元素特点：\n\n1. 和其他元素都在一行上\n\n2. 元素的高度、宽度、行高以及顶和底边距都可设置\n\n## 颜色值\n---\n\n- 英文命令颜色：`p{color:red;}`\n\n- RGB颜色：这个与 photoshop 中的 RGB 颜色是一致的，由 R(red)、G(green)、B(blue) 三种颜色的比例来配色。\n\n- 例：`p{color:rgb(133,45,200);}` 每一项的值可以是 0~255 之间的整数，也可以是 0%~100% 的百分数，例如：`p{color:rgb(20%,33%,25%);}`\n\n- **十六进制颜色**：这种颜色设置方法是现在比较普遍使用的方法，其原理其实也是 RGB 设置，但是其每一项的值由 0-255 变成了十六进制 00-ff。\n\n- 例：`p{color:#00ffff;}`  //以`#`开头\n\n![](/images/CSS/color.jpg)\n\n![](/images/CSS/color_list.jpg)\n\n## 长度值\n---\n\n- 目前比较常用到px（像素）、em、% 百分比。(但是这三种单位都是相对值)\n\n### 像素\n\n- 像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS规范中假设“90像素=1英寸”）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。\n\n### em\n\n- 就是本元素给定字体的 font-size 值，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。如下代码：`p{font-size:12px;text-indent:2em;}`就是可以实现段落首行缩进 24px（也就是两个字体大小的距离）。\n\n### 百分比\n\n- `p{font-size:12px;line-height:130%}` 设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。\n\n## 一些补充\n---\n### 元素宽度相关\n\n- `calc()`用法：[详解](https://www.w3cplus.com/css3/how-to-use-css3-calc-function.html)\n\n- 如果你的元素宽度是100%时，只要你在元素中添加了border,padding,margin任何一值，都将会把元素盒子撑破（标准模式下，除IE怪异模式）。\n\n#### opacity属性\n\n- 设置div元素的不透明级别\n\n- 语法：`opacity: value|inherit;`\n\n- 值： value: 规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）; inherit: 应该从父元素继承 opacity 属性的值。\n\n#### data-toggle属性\n\n- data-toggle一般是a元素(即链接)的属性。data-toggle指以什么事件触发。[详细的介绍](https://blog.csdn.net/d295968572/article/details/56667863)\n\n#### -webkit-tap-highlight-color属性\n\n- `-webkit-tap-highlight-color` 是一个没有标准化的属性，能够设置点击链接的时候出现的高亮颜色。显示给用户的高光是他们成功点击的标识，以及暗示了他们点击的元素。\n\n### `@media` 用法\n\n- `@media`可以让你根据不同的屏幕大小而使用不同的样式，这可以使得不需要js代码就能实现响应式布局。(即根据不同大小的页面重新排版)\n\n- 语法：\n\n```\n@media mediatype and|not|only (media feature) {\n    CSS-Code;\n}\n```\n- 其中mediatype就是媒体类型，可以包括好多种，最常用的就是screen，其他多数已经作废。\n\n- media feature就定义了这个media设备的一些特征，简单的说就是媒体满足什么条件，常用的就是max-width，min-width。\n\n- [具体的例子](http://blog.51cto.com/cnn237111/1602797)\n\n### margin属性\n\n- 定义和用法：margin 简写属性在一个声明中设置所有外边距属性。该属性可以有 1 到 4 个值。\n\n- 块级元素的垂直相邻外边距会合并，而行内元素实际上不占上下外边距。行内元素的的左右外边距不会合并。同样地，浮动元素的外边距也不会合并。允许指定负的外边距值，不过使用时要小心。\n\n>注释：允许使用负值。\n\n- 例子 1：`margin:10px 5px 15px 20px;`\n上外边距是 10px;\n右外边距是 5px;\n下外边距是 15px;\n左外边距是 20px;\n\n- 例子 2: `margin:10px 5px 15px;`\n上外边距是 10px;\n右外边距和左外边距是 5px;\n下外边距是 15px;\n\n- 例子 3:`margin:10px 5px;`\n上外边距和下外边距是 10px;\n右外边距和左外边距是 5px;\n\n- 例子 4:`margin:10px;`\n所有 4 个外边距都是 10px\n\n### `@media`用法\n\n- [用法详解](http://www.runoob.com/cssref/css3-pr-mediaquery.html)\n\n<br>\n> 最后更新与2018.7.9\n","source":"_posts/2018-06-17-FrontEnd-CSS.md","raw":"---\nlayout:     post\ntitle:      \"前端学习——CSS\"\ndate:       2018-06-17 16:46:00\ncategories: FrontEnd\ntags:   [๑FrontEnd, ๑CSS]\n---\n\n> 不适合人类阅读的学习笔记\n\n- CSS全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。\n\n- **在CSS代码中不要随便加空格**\n\n- [CSS3动画效果](https://www.jianshu.com/p/57ba5da7f9f6)\n\n## CSS代码语法\n---\n\n### 基础\n\n> 注意各个语句之间以分号间隔\n\n- css 样式由选择符和声明组成，而声明又由属性和值组成，例如：`p{color:blue}`\n\n- 其中，`p`为 **选择符**，`{..}`为 **声明**，`color`为 **属性**，`blue`为 **值**。\n\n- 选择符：又称选择器，**指明网页中要应用样式规则的元素**，如本例中是网页中所有的段（p）的文字将变成蓝色，而其他的元素（如ol）不会受到影响。\n\n- 声明：在英文大括号`｛ ｝`中的的就是声明，属性和值之间用英文冒号`：`分隔。当有多条声明时，中间可以英文分号`；`分隔，如：`p{font-size:12px;color:red;}`\n\n- 最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号\n\n- 为了使用样式更加容易阅读，可以将每条代码写在一个新行内，所以上面的应该写为：\n\n```\np{\n  font-size:12px;\n  color:red;\n}\n```\n\n### CSS中的注释\n\n- 格式：`/*注释语句*/`\n\n## 三种CSS样式\n---\n\n- 从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式、嵌入式和外部式三种。\n\n### 内联式css样式，直接写在现有的HTML标签中\n\n- 内联式css样式表就是把css代码直接写在现有的HTML标签中，如下面代码：\n\n```\n<p style=\"color:red\">这里文字是红色</p>\n```\n> 注意要写在元素的开始标签里\n\n- 并且css样式代码要写在`style=\"\"`双引号中，如果有多条css样式代码设置可以写在一起，中间用分号隔开。如下代码：\n\n```\n<p style=\"color:red;font-size:12px\">这里文字是红色</p>\n```\n\n### 嵌入式css样式，写在当前的文件中\n\n- 嵌入式css样式，就是可以把css样式代码写在`<style type=\"text/css\"> </style>`标签之间。如下面代码实现把三个`<span>`标签中的文字设置为红色：\n\n```\n<style type=\"text/css\">\nspan{\ncolor:red;\n}\n</style>\n```\n\n- 嵌入式css样式必须写在`<style> </style>`之间，并且一般情况下嵌入式css样式写在`<head> </head>`之间\n\n\n### 外部式css样式，写在单独的一个文件中\n\n- 外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以`.css`为扩展名，在`<head>`内（不是在`<style>`标签内）使用`<link>`标签将css样式文件链接到HTML文件内，如下面代码：\n\n```\n<link href=\"base.css\" rel=\"stylesheet\" type=\"text/css\" />\n```\n\n- css样式文件名称以有意义的英文字母命名，如 main.css。\n\n- `rel=\"stylesheet\" type=\"text/css\"` 是 **固定写法** 不可修改。\n\n- `<link>`标签位置一般写在`<head>`标签之内。\n\n### 三种方法的优先级\n\n- 前提：在相同的权值的情况下。\n\n- 优先级：`内联式 > 嵌入式 > 外部式`\n\n- 总而言之，就是就近原则（离被设置元素越近优先级别越高）。\n\n\n## 选择器\n---\n\n- 每一条css样式声明（定义）由两部分组成，形式如下：\n\n```\n选择器{\n    样式;\n}\n```\n在`{}`之前的部分就是“选择器”，“选择器”指明了`{}`中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素。\n\n- 例：\n\n```\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<title>选择器</title>\n<style type=\"text/css\">\nbody{\n    font-size:12px;\n    color:red;\n}\n</style>\n</head>\n<body>\n<p>\nXXXXXXXX\n</p>\n</body>\n</html>\n```\n其中`body{..}`就是一个选择器（标签选择器），他作用于`<body>`部分\n\n\n### 标签选择器\n\n- 标签选择器其实就是html代码中的标签。\n\n- 例：`p{font-size:12px;line-height:1.6em;}`这个就为p标签（`<p>`标签是段落部分）设置12px字号，行间距设置1.6em的样式。\n\n### **类选择器**\n\n- 语法：`.类选器名称{css样式代码;}`\n\n- 注意：以英文圆点开头。类选择器可以任意起名字。\n\n- 用法：\n\n1. 使用合适的标签把要修饰的内容标记起来，如：`<span>胆小如鼠</span>`\n\n2. 使用`class=\"类选择器名称\"`为标签设置一个类，如：`<span class=\"stress\">胆小如鼠</span>`\n\n3. 设置类选器css样式，如：`.stress{color:red;} /*类前面要加入一个英文圆点*/`\n\n- 类选择器使得我们可以灵活地自定义不同的部分的格式。\n\n### **ID选择器**\n\n- 在很多方面，ID选择器都类似于类选择符，但也有一些重要的区别：\n\n1. **为标签设置`id=\"ID名称\"`，而不是`class=\"类名称\"`。**\n\n2. ID选择符的前面是井号（#），而不是英文圆点（.）\n\n- 例如：\n\n```\n#test{\n  color:blue;\n}\n...\nXXX<span id=\"test\">...</span>\n```\n\n### id选择器和类选择器的区别与联系\n\n#### 相同点\n\n- 可以应用于任何元素\n\n#### 不同点\n\n- **ID选择器只能在文档中使用一次**。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而**类选择器可以使用多次**。\n\n- **这里只能使用一次是指同一个id选择器只能修饰一个地方，而类选择器可以同时修饰多个地方。当然我们可以定义多个id选择器来修饰不同的地方**\n\n- 可以使用类选择器词列表方法为一个元素**同时设置多个样式**。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（不能使用 ID 词列表）。\n\n- **正确示例**：\n\n```\n.stress{\n    color:red;\n}\n.bigsize{\n    font-size:25px;\n}\n<p>\n到了<span class=\"stress bigsize\">三年级</span>下学期时，我们班上了一节公开课...\n</p>\n```\n以上代码在`<span>`里定义两个类来修饰，这样的语法是可以的。上面代码的作用是为“三年级”三个文字设置文本颜色为红色并且字号为25px。\n\n- 错误的例子：\n\n```\n#stressid{\n    color:red;\n}\n#bigsizeid{\n    font-size:25px;\n}\n<p>\n到了<span id=\"stressid bigsizeid\">三年级</span>下学期时，我们班上了一节公开课...\n</p>\n```\n以上代码是错误的，一个地方只能用一个id选择器来修饰。以上代码不能起到修饰的作用。\n\n### 子选择器\n\n- 还有一个比较有用的选择器子选择器，即大于符号(>),用于选择指定标签元素的**第一代子元素**。\n\n- 例如：(以下代码会使class名为food下的子元素 li 加入红色实线边框。)\n\n```\n...\n.food>li{border:1px solid red;}\n...\n<h1>食物</h1>\n<ul class=\"food\">\n    <li>水果\n        <ul>\n        \t<li>香蕉</li>\n            <li>苹果</li>\n            <li>梨</li>\n        </ul>\n    </li>\n    <li>蔬菜\n    \t<ul>\n        \t<li>白菜</li>\n            <li>油菜</li>\n            <li>卷心菜</li>\n        </ul>\n    </li>\n</ul>\n...\n```\n\n### 包含(后代)选择器\n\n- 包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。如：`.first  span{color:red;}`\n\n- 请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的**直接后代**，或者你可以理解为作用于子元素的**第一代后代**。而后代选择器是作用于**所有子后代元素**。后代选择器通过**空格**来进行选择，而子选择器是通过`>`进行选择。\n\n- 总而言之就是，空格选择所有后代元素，`>`只选择第一代后代。\n\n### **通用选择器**\n\n- 通用选择器是功能最强大的选择器，它使用一个`*`号指定，它的作用是匹配html中所有标签元素，如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色：`* {color:red;}`\n\n### 伪类选择符\n\n- 它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：`a:hover{color:red;}`  \n这句代码就实现了`<a>`(超链接)鼠标划过的特效，当鼠标划过超链接时，超链接的字体颜色会变成红色。\n\n- 一般`:hover`都是用来控制鼠标滑过的效果\n\n- 其实 `:hover` 可以放在任意的标签上，比如说 `p:hover`，但是它们的兼容性也是很不好的，所以一般用在`a:hover`的组合。(**现在也可以用在其他的地方**)\n\n### **分组选择符**\n\n- 当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（，），如下代码将`<h1>`、`<span>`标签同时设置字体颜色为红色：`h1,span{color:red;}`\n\n- 以上代码相当于下面两行代码：\n\n```\nh1{color:red;}\nspan{color:red;}\n```\n\n### 继承\n\n- CSS的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。就是对某一些标签的样式的修改会对其子代也产生影响。\n\n###　权值\n\n- 如果对同一个标签设置了不同的样式，浏览器是根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。\n\n- 权值的规则：**标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。**\n\n- 例如：\n\n```\np{color:red;} /*权值为1*/\np span{color:green;} /*权值为1+1=2*/\n.warning{color:white;} /*权值为10*/\np span.warning{color:purple;} /*权值为1+1+10=12*/\n#footer .note p{color:yellow;} /*权值为100+10+1=111*/\n```\n注意：还有一个权值比较特殊--继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。\n\n- 使用`!important`来使样式获得最高权值：`p{color:red!important;}`\n> 注意：!important要写在分号的前面,中间不需要空格。\n\n### 层叠\n\n- 如果在html文件中对于同一个元素可以有多个css样式存在并且这多个css样式具有相同权重值怎么办？这时候我们就会用到层叠。\n\n- 层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于**最后面的css样式**会被应用。\n\n- 简单来说，就是，就是后面的样式会覆盖前面的样式。\n\n- 所以之前的内外优先级关系：`内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）。` 也就很好理解了。\n\n## 文字排版\n---\n\n### 字体\n\n- 例：为网页设置字体 `body{font-family:\"Microsoft Yahei\";}` //字体为微软雅黑\n\n- 注意：这里设置的字体能否显示，取决于用户本地有没有安装这个字体。\n\n### 字号颜色\n\n- 设置网页中文字的字号为12像素，并把字体颜色设置为#666(灰色)：`body{font-size:12px;color:#666}`\n\n- `font-size`:字体大小\n\n- `color`：颜色(一般以`#`加数字来表示颜色，以增加颜色的多样化)\n\n### 一些字体样式：粗体、斜体等\n\n- `font-weight`:字体粗细\n\n- 例：`span{font-weight:bold;}`  //粗体\n\n- `font-style`:字体特点\n\n- 例：`span{font-style:italic;}`  //斜体(意大利体)\n\n- `text-decoration`:文字修饰\n\n- 例：`a{text-decoration:underline;}`  //下划线\n\n- 例：`.oldPrice{text-decoration:line-through;}`    //删除线(将文字划去)\n\n### 段落排版\n\n#### 首行缩进\n\n- 设置段落缩进两个字宽：`p{text-indent:2em;}`\n\n- `2em`的意思就是文字的2倍大小。\n\n#### 行间距\n\n- 例：`p{line-height:1.5em;}`\n\n#### 中文字间距、字母间距\n\n- 如果想在网页排版中设置**文字间隔**或者**字母间隔**就可以使用`letter-spacing`来实现。\n\n- 例：`h1{letter-spacing:10px;}`\n\n- 注意：这个样式使用在英文单词时，是设置**字母与字母之间**的间距。\n\n- 如果我想设置英文单词之间的间距，可以使用 `word-spacing` 来实现。\n\n- 例：`h1{word-spacing:20px;}`\n\n#### 对齐\n\n- 为块状元素中的文本、图片设置居中样式，可以使用`text-align`样式代码。\n\n- 例：`h1{text-align:center/left/right;}`  //居中/左对齐/右对齐\n\n\n## 元素分类\n---\n\n- 在CSS中，html中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。\n\n- 常用的块状元素有：`<div>、<p>、<h1>...<h6>、<ol>、<ul>、<dl>、<table>、<address>、<blockquote> 、<form>`\n\n- 常用的内联元素有：`<a>、<span>、<br>、<i>、<em>、<strong>、<label>、<q>、<var>、<cite>、<code>`\n\n- 常用的内联块状元素有：`<img>、<input>`\n\n### 块级元素\n\n- 设置`display:block`就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点：`a{display:block;}`\n\n- 块级元素特点：\n\n1. 每个块级元素都从新的一行开始，并且其后的元素也另起一行。\n\n2. 元素的高度、宽度、行高以及顶和底边距都可设置。\n\n3. 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。\n\n### 内联元素\n\n- 块状元素也可以通过代码`display:inline`将元素设置为内联元素。\n\n- 如下代码就是将块状元素div转换为内联元素，从而使 div 元素具有内联元素特点：`div{display:inline;}`\n\n- 内联元素特点：\n\n1. 和其他元素都在一行上\n\n2. 元素的高度、宽度及顶部和底部边距不可设置\n\n3. 元素的宽度就是它包含的文字或图片的宽度，不可改变\n\n### 内联块状元素\n\n- 内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码`display:inline-block`就是将元素设置为内联块状元素。\n\n- inline-block 元素特点：\n\n1. 和其他元素都在一行上\n\n2. 元素的高度、宽度、行高以及顶和底边距都可设置\n\n## 颜色值\n---\n\n- 英文命令颜色：`p{color:red;}`\n\n- RGB颜色：这个与 photoshop 中的 RGB 颜色是一致的，由 R(red)、G(green)、B(blue) 三种颜色的比例来配色。\n\n- 例：`p{color:rgb(133,45,200);}` 每一项的值可以是 0~255 之间的整数，也可以是 0%~100% 的百分数，例如：`p{color:rgb(20%,33%,25%);}`\n\n- **十六进制颜色**：这种颜色设置方法是现在比较普遍使用的方法，其原理其实也是 RGB 设置，但是其每一项的值由 0-255 变成了十六进制 00-ff。\n\n- 例：`p{color:#00ffff;}`  //以`#`开头\n\n![](/images/CSS/color.jpg)\n\n![](/images/CSS/color_list.jpg)\n\n## 长度值\n---\n\n- 目前比较常用到px（像素）、em、% 百分比。(但是这三种单位都是相对值)\n\n### 像素\n\n- 像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS规范中假设“90像素=1英寸”）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。\n\n### em\n\n- 就是本元素给定字体的 font-size 值，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。如下代码：`p{font-size:12px;text-indent:2em;}`就是可以实现段落首行缩进 24px（也就是两个字体大小的距离）。\n\n### 百分比\n\n- `p{font-size:12px;line-height:130%}` 设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。\n\n## 一些补充\n---\n### 元素宽度相关\n\n- `calc()`用法：[详解](https://www.w3cplus.com/css3/how-to-use-css3-calc-function.html)\n\n- 如果你的元素宽度是100%时，只要你在元素中添加了border,padding,margin任何一值，都将会把元素盒子撑破（标准模式下，除IE怪异模式）。\n\n#### opacity属性\n\n- 设置div元素的不透明级别\n\n- 语法：`opacity: value|inherit;`\n\n- 值： value: 规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）; inherit: 应该从父元素继承 opacity 属性的值。\n\n#### data-toggle属性\n\n- data-toggle一般是a元素(即链接)的属性。data-toggle指以什么事件触发。[详细的介绍](https://blog.csdn.net/d295968572/article/details/56667863)\n\n#### -webkit-tap-highlight-color属性\n\n- `-webkit-tap-highlight-color` 是一个没有标准化的属性，能够设置点击链接的时候出现的高亮颜色。显示给用户的高光是他们成功点击的标识，以及暗示了他们点击的元素。\n\n### `@media` 用法\n\n- `@media`可以让你根据不同的屏幕大小而使用不同的样式，这可以使得不需要js代码就能实现响应式布局。(即根据不同大小的页面重新排版)\n\n- 语法：\n\n```\n@media mediatype and|not|only (media feature) {\n    CSS-Code;\n}\n```\n- 其中mediatype就是媒体类型，可以包括好多种，最常用的就是screen，其他多数已经作废。\n\n- media feature就定义了这个media设备的一些特征，简单的说就是媒体满足什么条件，常用的就是max-width，min-width。\n\n- [具体的例子](http://blog.51cto.com/cnn237111/1602797)\n\n### margin属性\n\n- 定义和用法：margin 简写属性在一个声明中设置所有外边距属性。该属性可以有 1 到 4 个值。\n\n- 块级元素的垂直相邻外边距会合并，而行内元素实际上不占上下外边距。行内元素的的左右外边距不会合并。同样地，浮动元素的外边距也不会合并。允许指定负的外边距值，不过使用时要小心。\n\n>注释：允许使用负值。\n\n- 例子 1：`margin:10px 5px 15px 20px;`\n上外边距是 10px;\n右外边距是 5px;\n下外边距是 15px;\n左外边距是 20px;\n\n- 例子 2: `margin:10px 5px 15px;`\n上外边距是 10px;\n右外边距和左外边距是 5px;\n下外边距是 15px;\n\n- 例子 3:`margin:10px 5px;`\n上外边距和下外边距是 10px;\n右外边距和左外边距是 5px;\n\n- 例子 4:`margin:10px;`\n所有 4 个外边距都是 10px\n\n### `@media`用法\n\n- [用法详解](http://www.runoob.com/cssref/css3-pr-mediaquery.html)\n\n<br>\n> 最后更新与2018.7.9\n","slug":"2018-06-17-FrontEnd-CSS","published":1,"updated":"2018-09-03T13:15:21.621Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j51002f1m0ournd36lq","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<ul>\n<li><p>CSS全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。</p>\n</li>\n<li><p><strong>在CSS代码中不要随便加空格</strong></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/57ba5da7f9f6\" target=\"_blank\" rel=\"noopener\">CSS3动画效果</a></p>\n</li>\n</ul>\n<h2 id=\"CSS代码语法\"><a href=\"#CSS代码语法\" class=\"headerlink\" title=\"CSS代码语法\"></a>CSS代码语法</h2><hr>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><blockquote>\n<p>注意各个语句之间以分号间隔</p>\n</blockquote>\n<ul>\n<li><p>css 样式由选择符和声明组成，而声明又由属性和值组成，例如：<code>p{color:blue}</code></p>\n</li>\n<li><p>其中，<code>p</code>为 <strong>选择符</strong>，<code>{..}</code>为 <strong>声明</strong>，<code>color</code>为 <strong>属性</strong>，<code>blue</code>为 <strong>值</strong>。</p>\n</li>\n<li><p>选择符：又称选择器，<strong>指明网页中要应用样式规则的元素</strong>，如本例中是网页中所有的段（p）的文字将变成蓝色，而其他的元素（如ol）不会受到影响。</p>\n</li>\n<li><p>声明：在英文大括号<code>｛ ｝</code>中的的就是声明，属性和值之间用英文冒号<code>：</code>分隔。当有多条声明时，中间可以英文分号<code>；</code>分隔，如：<code>p{font-size:12px;color:red;}</code></p>\n</li>\n<li><p>最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号</p>\n</li>\n<li><p>为了使用样式更加容易阅读，可以将每条代码写在一个新行内，所以上面的应该写为：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p&#123;</span><br><span class=\"line\">  font-size:12px;</span><br><span class=\"line\">  color:red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CSS中的注释\"><a href=\"#CSS中的注释\" class=\"headerlink\" title=\"CSS中的注释\"></a>CSS中的注释</h3><ul>\n<li>格式：<code>/*注释语句*/</code></li>\n</ul>\n<h2 id=\"三种CSS样式\"><a href=\"#三种CSS样式\" class=\"headerlink\" title=\"三种CSS样式\"></a>三种CSS样式</h2><hr>\n<ul>\n<li>从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式、嵌入式和外部式三种。</li>\n</ul>\n<h3 id=\"内联式css样式，直接写在现有的HTML标签中\"><a href=\"#内联式css样式，直接写在现有的HTML标签中\" class=\"headerlink\" title=\"内联式css样式，直接写在现有的HTML标签中\"></a>内联式css样式，直接写在现有的HTML标签中</h3><ul>\n<li>内联式css样式表就是把css代码直接写在现有的HTML标签中，如下面代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p style=&quot;color:red&quot;&gt;这里文字是红色&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意要写在元素的开始标签里</p>\n</blockquote>\n<ul>\n<li>并且css样式代码要写在<code>style=&quot;&quot;</code>双引号中，如果有多条css样式代码设置可以写在一起，中间用分号隔开。如下代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p style=&quot;color:red;font-size:12px&quot;&gt;这里文字是红色&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌入式css样式，写在当前的文件中\"><a href=\"#嵌入式css样式，写在当前的文件中\" class=\"headerlink\" title=\"嵌入式css样式，写在当前的文件中\"></a>嵌入式css样式，写在当前的文件中</h3><ul>\n<li>嵌入式css样式，就是可以把css样式代码写在<code>&lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt;</code>标签之间。如下面代码实现把三个<code>&lt;span&gt;</code>标签中的文字设置为红色：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">span&#123;</span><br><span class=\"line\">color:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>嵌入式css样式必须写在<code>&lt;style&gt; &lt;/style&gt;</code>之间，并且一般情况下嵌入式css样式写在<code>&lt;head&gt; &lt;/head&gt;</code>之间</li>\n</ul>\n<h3 id=\"外部式css样式，写在单独的一个文件中\"><a href=\"#外部式css样式，写在单独的一个文件中\" class=\"headerlink\" title=\"外部式css样式，写在单独的一个文件中\"></a>外部式css样式，写在单独的一个文件中</h3><ul>\n<li>外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以<code>.css</code>为扩展名，在<code>&lt;head&gt;</code>内（不是在<code>&lt;style&gt;</code>标签内）使用<code>&lt;link&gt;</code>标签将css样式文件链接到HTML文件内，如下面代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>css样式文件名称以有意义的英文字母命名，如 main.css。</p>\n</li>\n<li><p><code>rel=&quot;stylesheet&quot; type=&quot;text/css&quot;</code> 是 <strong>固定写法</strong> 不可修改。</p>\n</li>\n<li><p><code>&lt;link&gt;</code>标签位置一般写在<code>&lt;head&gt;</code>标签之内。</p>\n</li>\n</ul>\n<h3 id=\"三种方法的优先级\"><a href=\"#三种方法的优先级\" class=\"headerlink\" title=\"三种方法的优先级\"></a>三种方法的优先级</h3><ul>\n<li><p>前提：在相同的权值的情况下。</p>\n</li>\n<li><p>优先级：<code>内联式 &gt; 嵌入式 &gt; 外部式</code></p>\n</li>\n<li><p>总而言之，就是就近原则（离被设置元素越近优先级别越高）。</p>\n</li>\n</ul>\n<h2 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h2><hr>\n<ul>\n<li>每一条css样式声明（定义）由两部分组成，形式如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">选择器&#123;</span><br><span class=\"line\">    样式;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>{}</code>之前的部分就是“选择器”，“选择器”指明了<code>{}</code>中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素。</p>\n<ul>\n<li>例：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;选择器&lt;/title&gt;</span><br><span class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">body&#123;</span><br><span class=\"line\">    font-size:12px;</span><br><span class=\"line\">    color:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">XXXXXXXX</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>其中<code>body{..}</code>就是一个选择器（标签选择器），他作用于<code>&lt;body&gt;</code>部分</p>\n<h3 id=\"标签选择器\"><a href=\"#标签选择器\" class=\"headerlink\" title=\"标签选择器\"></a>标签选择器</h3><ul>\n<li><p>标签选择器其实就是html代码中的标签。</p>\n</li>\n<li><p>例：<code>p{font-size:12px;line-height:1.6em;}</code>这个就为p标签（<code>&lt;p&gt;</code>标签是段落部分）设置12px字号，行间距设置1.6em的样式。</p>\n</li>\n</ul>\n<h3 id=\"类选择器\"><a href=\"#类选择器\" class=\"headerlink\" title=\"类选择器\"></a><strong>类选择器</strong></h3><ul>\n<li><p>语法：<code>.类选器名称{css样式代码;}</code></p>\n</li>\n<li><p>注意：以英文圆点开头。类选择器可以任意起名字。</p>\n</li>\n<li><p>用法：</p>\n</li>\n</ul>\n<ol>\n<li><p>使用合适的标签把要修饰的内容标记起来，如：<code>&lt;span&gt;胆小如鼠&lt;/span&gt;</code></p>\n</li>\n<li><p>使用<code>class=&quot;类选择器名称&quot;</code>为标签设置一个类，如：<code>&lt;span class=&quot;stress&quot;&gt;胆小如鼠&lt;/span&gt;</code></p>\n</li>\n<li><p>设置类选器css样式，如：<code>.stress{color:red;} /*类前面要加入一个英文圆点*/</code></p>\n</li>\n</ol>\n<ul>\n<li>类选择器使得我们可以灵活地自定义不同的部分的格式。</li>\n</ul>\n<h3 id=\"ID选择器\"><a href=\"#ID选择器\" class=\"headerlink\" title=\"ID选择器\"></a><strong>ID选择器</strong></h3><ul>\n<li>在很多方面，ID选择器都类似于类选择符，但也有一些重要的区别：</li>\n</ul>\n<ol>\n<li><p><strong>为标签设置<code>id=&quot;ID名称&quot;</code>，而不是<code>class=&quot;类名称&quot;</code>。</strong></p>\n</li>\n<li><p>ID选择符的前面是井号（#），而不是英文圆点（.）</p>\n</li>\n</ol>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#test&#123;</span><br><span class=\"line\">  color:blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">XXX&lt;span id=&quot;test&quot;&gt;...&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"id选择器和类选择器的区别与联系\"><a href=\"#id选择器和类选择器的区别与联系\" class=\"headerlink\" title=\"id选择器和类选择器的区别与联系\"></a>id选择器和类选择器的区别与联系</h3><h4 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h4><ul>\n<li>可以应用于任何元素</li>\n</ul>\n<h4 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h4><ul>\n<li><p><strong>ID选择器只能在文档中使用一次</strong>。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而<strong>类选择器可以使用多次</strong>。</p>\n</li>\n<li><p><strong>这里只能使用一次是指同一个id选择器只能修饰一个地方，而类选择器可以同时修饰多个地方。当然我们可以定义多个id选择器来修饰不同的地方</strong></p>\n</li>\n<li><p>可以使用类选择器词列表方法为一个元素<strong>同时设置多个样式</strong>。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（不能使用 ID 词列表）。</p>\n</li>\n<li><p><strong>正确示例</strong>：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.stress&#123;</span><br><span class=\"line\">    color:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.bigsize&#123;</span><br><span class=\"line\">    font-size:25px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">到了&lt;span class=&quot;stress bigsize&quot;&gt;三年级&lt;/span&gt;下学期时，我们班上了一节公开课...</span><br><span class=\"line\">&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>以上代码在<code>&lt;span&gt;</code>里定义两个类来修饰，这样的语法是可以的。上面代码的作用是为“三年级”三个文字设置文本颜色为红色并且字号为25px。</p>\n<ul>\n<li>错误的例子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#stressid&#123;</span><br><span class=\"line\">    color:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#bigsizeid&#123;</span><br><span class=\"line\">    font-size:25px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">到了&lt;span id=&quot;stressid bigsizeid&quot;&gt;三年级&lt;/span&gt;下学期时，我们班上了一节公开课...</span><br><span class=\"line\">&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>以上代码是错误的，一个地方只能用一个id选择器来修饰。以上代码不能起到修饰的作用。</p>\n<h3 id=\"子选择器\"><a href=\"#子选择器\" class=\"headerlink\" title=\"子选择器\"></a>子选择器</h3><ul>\n<li><p>还有一个比较有用的选择器子选择器，即大于符号(&gt;),用于选择指定标签元素的<strong>第一代子元素</strong>。</p>\n</li>\n<li><p>例如：(以下代码会使class名为food下的子元素 li 加入红色实线边框。)</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">.food&gt;li&#123;border:1px solid red;&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;h1&gt;食物&lt;/h1&gt;</span><br><span class=\"line\">&lt;ul class=&quot;food&quot;&gt;</span><br><span class=\"line\">    &lt;li&gt;水果</span><br><span class=\"line\">        &lt;ul&gt;</span><br><span class=\"line\">        \t&lt;li&gt;香蕉&lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;苹果&lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;梨&lt;/li&gt;</span><br><span class=\"line\">        &lt;/ul&gt;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;蔬菜</span><br><span class=\"line\">    \t&lt;ul&gt;</span><br><span class=\"line\">        \t&lt;li&gt;白菜&lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;油菜&lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;卷心菜&lt;/li&gt;</span><br><span class=\"line\">        &lt;/ul&gt;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"包含-后代-选择器\"><a href=\"#包含-后代-选择器\" class=\"headerlink\" title=\"包含(后代)选择器\"></a>包含(后代)选择器</h3><ul>\n<li><p>包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。如：<code>.first  span{color:red;}</code></p>\n</li>\n<li><p>请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的<strong>直接后代</strong>，或者你可以理解为作用于子元素的<strong>第一代后代</strong>。而后代选择器是作用于<strong>所有子后代元素</strong>。后代选择器通过<strong>空格</strong>来进行选择，而子选择器是通过<code>&gt;</code>进行选择。</p>\n</li>\n<li><p>总而言之就是，空格选择所有后代元素，<code>&gt;</code>只选择第一代后代。</p>\n</li>\n</ul>\n<h3 id=\"通用选择器\"><a href=\"#通用选择器\" class=\"headerlink\" title=\"通用选择器\"></a><strong>通用选择器</strong></h3><ul>\n<li>通用选择器是功能最强大的选择器，它使用一个<code>*</code>号指定，它的作用是匹配html中所有标签元素，如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色：<code>* {color:red;}</code></li>\n</ul>\n<h3 id=\"伪类选择符\"><a href=\"#伪类选择符\" class=\"headerlink\" title=\"伪类选择符\"></a>伪类选择符</h3><ul>\n<li><p>它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：<code>a:hover{color:red;}</code><br>这句代码就实现了<code>&lt;a&gt;</code>(超链接)鼠标划过的特效，当鼠标划过超链接时，超链接的字体颜色会变成红色。</p>\n</li>\n<li><p>一般<code>:hover</code>都是用来控制鼠标滑过的效果</p>\n</li>\n<li><p>其实 <code>:hover</code> 可以放在任意的标签上，比如说 <code>p:hover</code>，但是它们的兼容性也是很不好的，所以一般用在<code>a:hover</code>的组合。(<strong>现在也可以用在其他的地方</strong>)</p>\n</li>\n</ul>\n<h3 id=\"分组选择符\"><a href=\"#分组选择符\" class=\"headerlink\" title=\"分组选择符\"></a><strong>分组选择符</strong></h3><ul>\n<li><p>当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（，），如下代码将<code>&lt;h1&gt;</code>、<code>&lt;span&gt;</code>标签同时设置字体颜色为红色：<code>h1,span{color:red;}</code></p>\n</li>\n<li><p>以上代码相当于下面两行代码：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h1&#123;color:red;&#125;</span><br><span class=\"line\">span&#123;color:red;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><ul>\n<li>CSS的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。就是对某一些标签的样式的修改会对其子代也产生影响。</li>\n</ul>\n<p>###　权值</p>\n<ul>\n<li><p>如果对同一个标签设置了不同的样式，浏览器是根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。</p>\n</li>\n<li><p>权值的规则：<strong>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。</strong></p>\n</li>\n<li><p>例如：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p&#123;color:red;&#125; /*权值为1*/</span><br><span class=\"line\">p span&#123;color:green;&#125; /*权值为1+1=2*/</span><br><span class=\"line\">.warning&#123;color:white;&#125; /*权值为10*/</span><br><span class=\"line\">p span.warning&#123;color:purple;&#125; /*权值为1+1+10=12*/</span><br><span class=\"line\">#footer .note p&#123;color:yellow;&#125; /*权值为100+10+1=111*/</span><br></pre></td></tr></table></figure>\n<p>注意：还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。</p>\n<ul>\n<li>使用<code>!important</code>来使样式获得最高权值：<code>p{color:red!important;}</code><blockquote>\n<p>注意：!important要写在分号的前面,中间不需要空格。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"层叠\"><a href=\"#层叠\" class=\"headerlink\" title=\"层叠\"></a>层叠</h3><ul>\n<li><p>如果在html文件中对于同一个元素可以有多个css样式存在并且这多个css样式具有相同权重值怎么办？这时候我们就会用到层叠。</p>\n</li>\n<li><p>层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于<strong>最后面的css样式</strong>会被应用。</p>\n</li>\n<li><p>简单来说，就是，就是后面的样式会覆盖前面的样式。</p>\n</li>\n<li><p>所以之前的内外优先级关系：<code>内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</code> 也就很好理解了。</p>\n</li>\n</ul>\n<h2 id=\"文字排版\"><a href=\"#文字排版\" class=\"headerlink\" title=\"文字排版\"></a>文字排版</h2><hr>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><ul>\n<li><p>例：为网页设置字体 <code>body{font-family:&quot;Microsoft Yahei&quot;;}</code> //字体为微软雅黑</p>\n</li>\n<li><p>注意：这里设置的字体能否显示，取决于用户本地有没有安装这个字体。</p>\n</li>\n</ul>\n<h3 id=\"字号颜色\"><a href=\"#字号颜色\" class=\"headerlink\" title=\"字号颜色\"></a>字号颜色</h3><ul>\n<li><p>设置网页中文字的字号为12像素，并把字体颜色设置为#666(灰色)：<code>body{font-size:12px;color:#666}</code></p>\n</li>\n<li><p><code>font-size</code>:字体大小</p>\n</li>\n<li><p><code>color</code>：颜色(一般以<code>#</code>加数字来表示颜色，以增加颜色的多样化)</p>\n</li>\n</ul>\n<h3 id=\"一些字体样式：粗体、斜体等\"><a href=\"#一些字体样式：粗体、斜体等\" class=\"headerlink\" title=\"一些字体样式：粗体、斜体等\"></a>一些字体样式：粗体、斜体等</h3><ul>\n<li><p><code>font-weight</code>:字体粗细</p>\n</li>\n<li><p>例：<code>span{font-weight:bold;}</code>  //粗体</p>\n</li>\n<li><p><code>font-style</code>:字体特点</p>\n</li>\n<li><p>例：<code>span{font-style:italic;}</code>  //斜体(意大利体)</p>\n</li>\n<li><p><code>text-decoration</code>:文字修饰</p>\n</li>\n<li><p>例：<code>a{text-decoration:underline;}</code>  //下划线</p>\n</li>\n<li><p>例：<code>.oldPrice{text-decoration:line-through;}</code>    //删除线(将文字划去)</p>\n</li>\n</ul>\n<h3 id=\"段落排版\"><a href=\"#段落排版\" class=\"headerlink\" title=\"段落排版\"></a>段落排版</h3><h4 id=\"首行缩进\"><a href=\"#首行缩进\" class=\"headerlink\" title=\"首行缩进\"></a>首行缩进</h4><ul>\n<li><p>设置段落缩进两个字宽：<code>p{text-indent:2em;}</code></p>\n</li>\n<li><p><code>2em</code>的意思就是文字的2倍大小。</p>\n</li>\n</ul>\n<h4 id=\"行间距\"><a href=\"#行间距\" class=\"headerlink\" title=\"行间距\"></a>行间距</h4><ul>\n<li>例：<code>p{line-height:1.5em;}</code></li>\n</ul>\n<h4 id=\"中文字间距、字母间距\"><a href=\"#中文字间距、字母间距\" class=\"headerlink\" title=\"中文字间距、字母间距\"></a>中文字间距、字母间距</h4><ul>\n<li><p>如果想在网页排版中设置<strong>文字间隔</strong>或者<strong>字母间隔</strong>就可以使用<code>letter-spacing</code>来实现。</p>\n</li>\n<li><p>例：<code>h1{letter-spacing:10px;}</code></p>\n</li>\n<li><p>注意：这个样式使用在英文单词时，是设置<strong>字母与字母之间</strong>的间距。</p>\n</li>\n<li><p>如果我想设置英文单词之间的间距，可以使用 <code>word-spacing</code> 来实现。</p>\n</li>\n<li><p>例：<code>h1{word-spacing:20px;}</code></p>\n</li>\n</ul>\n<h4 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h4><ul>\n<li><p>为块状元素中的文本、图片设置居中样式，可以使用<code>text-align</code>样式代码。</p>\n</li>\n<li><p>例：<code>h1{text-align:center/left/right;}</code>  //居中/左对齐/右对齐</p>\n</li>\n</ul>\n<h2 id=\"元素分类\"><a href=\"#元素分类\" class=\"headerlink\" title=\"元素分类\"></a>元素分类</h2><hr>\n<ul>\n<li><p>在CSS中，html中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。</p>\n</li>\n<li><p>常用的块状元素有：<code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</code></p>\n</li>\n<li><p>常用的内联元素有：<code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</code></p>\n</li>\n<li><p>常用的内联块状元素有：<code>&lt;img&gt;、&lt;input&gt;</code></p>\n</li>\n</ul>\n<h3 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h3><ul>\n<li><p>设置<code>display:block</code>就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点：<code>a{display:block;}</code></p>\n</li>\n<li><p>块级元素特点：</p>\n</li>\n</ul>\n<ol>\n<li><p>每个块级元素都从新的一行开始，并且其后的元素也另起一行。</p>\n</li>\n<li><p>元素的高度、宽度、行高以及顶和底边距都可设置。</p>\n</li>\n<li><p>元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</p>\n</li>\n</ol>\n<h3 id=\"内联元素\"><a href=\"#内联元素\" class=\"headerlink\" title=\"内联元素\"></a>内联元素</h3><ul>\n<li><p>块状元素也可以通过代码<code>display:inline</code>将元素设置为内联元素。</p>\n</li>\n<li><p>如下代码就是将块状元素div转换为内联元素，从而使 div 元素具有内联元素特点：<code>div{display:inline;}</code></p>\n</li>\n<li><p>内联元素特点：</p>\n</li>\n</ul>\n<ol>\n<li><p>和其他元素都在一行上</p>\n</li>\n<li><p>元素的高度、宽度及顶部和底部边距不可设置</p>\n</li>\n<li><p>元素的宽度就是它包含的文字或图片的宽度，不可改变</p>\n</li>\n</ol>\n<h3 id=\"内联块状元素\"><a href=\"#内联块状元素\" class=\"headerlink\" title=\"内联块状元素\"></a>内联块状元素</h3><ul>\n<li><p>内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码<code>display:inline-block</code>就是将元素设置为内联块状元素。</p>\n</li>\n<li><p>inline-block 元素特点：</p>\n</li>\n</ul>\n<ol>\n<li><p>和其他元素都在一行上</p>\n</li>\n<li><p>元素的高度、宽度、行高以及顶和底边距都可设置</p>\n</li>\n</ol>\n<h2 id=\"颜色值\"><a href=\"#颜色值\" class=\"headerlink\" title=\"颜色值\"></a>颜色值</h2><hr>\n<ul>\n<li><p>英文命令颜色：<code>p{color:red;}</code></p>\n</li>\n<li><p>RGB颜色：这个与 photoshop 中的 RGB 颜色是一致的，由 R(red)、G(green)、B(blue) 三种颜色的比例来配色。</p>\n</li>\n<li><p>例：<code>p{color:rgb(133,45,200);}</code> 每一项的值可以是 0~255 之间的整数，也可以是 0%~100% 的百分数，例如：<code>p{color:rgb(20%,33%,25%);}</code></p>\n</li>\n<li><p><strong>十六进制颜色</strong>：这种颜色设置方法是现在比较普遍使用的方法，其原理其实也是 RGB 设置，但是其每一项的值由 0-255 变成了十六进制 00-ff。</p>\n</li>\n<li><p>例：<code>p{color:#00ffff;}</code>  //以<code>#</code>开头</p>\n</li>\n</ul>\n<p><img src=\"/images/CSS/color.jpg\" alt=\"\"></p>\n<p><img src=\"/images/CSS/color_list.jpg\" alt=\"\"></p>\n<h2 id=\"长度值\"><a href=\"#长度值\" class=\"headerlink\" title=\"长度值\"></a>长度值</h2><hr>\n<ul>\n<li>目前比较常用到px（像素）、em、% 百分比。(但是这三种单位都是相对值)</li>\n</ul>\n<h3 id=\"像素\"><a href=\"#像素\" class=\"headerlink\" title=\"像素\"></a>像素</h3><ul>\n<li>像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS规范中假设“90像素=1英寸”）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。</li>\n</ul>\n<h3 id=\"em\"><a href=\"#em\" class=\"headerlink\" title=\"em\"></a>em</h3><ul>\n<li>就是本元素给定字体的 font-size 值，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。如下代码：<code>p{font-size:12px;text-indent:2em;}</code>就是可以实现段落首行缩进 24px（也就是两个字体大小的距离）。</li>\n</ul>\n<h3 id=\"百分比\"><a href=\"#百分比\" class=\"headerlink\" title=\"百分比\"></a>百分比</h3><ul>\n<li><code>p{font-size:12px;line-height:130%}</code> 设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。</li>\n</ul>\n<h2 id=\"一些补充\"><a href=\"#一些补充\" class=\"headerlink\" title=\"一些补充\"></a>一些补充</h2><hr>\n<h3 id=\"元素宽度相关\"><a href=\"#元素宽度相关\" class=\"headerlink\" title=\"元素宽度相关\"></a>元素宽度相关</h3><ul>\n<li><p><code>calc()</code>用法：<a href=\"https://www.w3cplus.com/css3/how-to-use-css3-calc-function.html\" target=\"_blank\" rel=\"noopener\">详解</a></p>\n</li>\n<li><p>如果你的元素宽度是100%时，只要你在元素中添加了border,padding,margin任何一值，都将会把元素盒子撑破（标准模式下，除IE怪异模式）。</p>\n</li>\n</ul>\n<h4 id=\"opacity属性\"><a href=\"#opacity属性\" class=\"headerlink\" title=\"opacity属性\"></a>opacity属性</h4><ul>\n<li><p>设置div元素的不透明级别</p>\n</li>\n<li><p>语法：<code>opacity: value|inherit;</code></p>\n</li>\n<li><p>值： value: 规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）; inherit: 应该从父元素继承 opacity 属性的值。</p>\n</li>\n</ul>\n<h4 id=\"data-toggle属性\"><a href=\"#data-toggle属性\" class=\"headerlink\" title=\"data-toggle属性\"></a>data-toggle属性</h4><ul>\n<li>data-toggle一般是a元素(即链接)的属性。data-toggle指以什么事件触发。<a href=\"https://blog.csdn.net/d295968572/article/details/56667863\" target=\"_blank\" rel=\"noopener\">详细的介绍</a></li>\n</ul>\n<h4 id=\"webkit-tap-highlight-color属性\"><a href=\"#webkit-tap-highlight-color属性\" class=\"headerlink\" title=\"-webkit-tap-highlight-color属性\"></a>-webkit-tap-highlight-color属性</h4><ul>\n<li><code>-webkit-tap-highlight-color</code> 是一个没有标准化的属性，能够设置点击链接的时候出现的高亮颜色。显示给用户的高光是他们成功点击的标识，以及暗示了他们点击的元素。</li>\n</ul>\n<h3 id=\"media-用法\"><a href=\"#media-用法\" class=\"headerlink\" title=\"@media 用法\"></a><code>@media</code> 用法</h3><ul>\n<li><p><code>@media</code>可以让你根据不同的屏幕大小而使用不同的样式，这可以使得不需要js代码就能实现响应式布局。(即根据不同大小的页面重新排版)</p>\n</li>\n<li><p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media mediatype and|not|only (media feature) &#123;</span><br><span class=\"line\">    CSS-Code;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>其中mediatype就是媒体类型，可以包括好多种，最常用的就是screen，其他多数已经作废。</p>\n</li>\n<li><p>media feature就定义了这个media设备的一些特征，简单的说就是媒体满足什么条件，常用的就是max-width，min-width。</p>\n</li>\n<li><p><a href=\"http://blog.51cto.com/cnn237111/1602797\" target=\"_blank\" rel=\"noopener\">具体的例子</a></p>\n</li>\n</ul>\n<h3 id=\"margin属性\"><a href=\"#margin属性\" class=\"headerlink\" title=\"margin属性\"></a>margin属性</h3><ul>\n<li><p>定义和用法：margin 简写属性在一个声明中设置所有外边距属性。该属性可以有 1 到 4 个值。</p>\n</li>\n<li><p>块级元素的垂直相邻外边距会合并，而行内元素实际上不占上下外边距。行内元素的的左右外边距不会合并。同样地，浮动元素的外边距也不会合并。允许指定负的外边距值，不过使用时要小心。</p>\n</li>\n</ul>\n<blockquote>\n<p>注释：允许使用负值。</p>\n</blockquote>\n<ul>\n<li><p>例子 1：<code>margin:10px 5px 15px 20px;</code><br>上外边距是 10px;<br>右外边距是 5px;<br>下外边距是 15px;<br>左外边距是 20px;</p>\n</li>\n<li><p>例子 2: <code>margin:10px 5px 15px;</code><br>上外边距是 10px;<br>右外边距和左外边距是 5px;<br>下外边距是 15px;</p>\n</li>\n<li><p>例子 3:<code>margin:10px 5px;</code><br>上外边距和下外边距是 10px;<br>右外边距和左外边距是 5px;</p>\n</li>\n<li><p>例子 4:<code>margin:10px;</code><br>所有 4 个外边距都是 10px</p>\n</li>\n</ul>\n<h3 id=\"media用法\"><a href=\"#media用法\" class=\"headerlink\" title=\"@media用法\"></a><code>@media</code>用法</h3><ul>\n<li><a href=\"http://www.runoob.com/cssref/css3-pr-mediaquery.html\" target=\"_blank\" rel=\"noopener\">用法详解</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新与2018.7.9</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<ul>\n<li><p>CSS全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。</p>\n</li>\n<li><p><strong>在CSS代码中不要随便加空格</strong></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/57ba5da7f9f6\" target=\"_blank\" rel=\"noopener\">CSS3动画效果</a></p>\n</li>\n</ul>\n<h2 id=\"CSS代码语法\"><a href=\"#CSS代码语法\" class=\"headerlink\" title=\"CSS代码语法\"></a>CSS代码语法</h2><hr>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><blockquote>\n<p>注意各个语句之间以分号间隔</p>\n</blockquote>\n<ul>\n<li><p>css 样式由选择符和声明组成，而声明又由属性和值组成，例如：<code>p{color:blue}</code></p>\n</li>\n<li><p>其中，<code>p</code>为 <strong>选择符</strong>，<code>{..}</code>为 <strong>声明</strong>，<code>color</code>为 <strong>属性</strong>，<code>blue</code>为 <strong>值</strong>。</p>\n</li>\n<li><p>选择符：又称选择器，<strong>指明网页中要应用样式规则的元素</strong>，如本例中是网页中所有的段（p）的文字将变成蓝色，而其他的元素（如ol）不会受到影响。</p>\n</li>\n<li><p>声明：在英文大括号<code>｛ ｝</code>中的的就是声明，属性和值之间用英文冒号<code>：</code>分隔。当有多条声明时，中间可以英文分号<code>；</code>分隔，如：<code>p{font-size:12px;color:red;}</code></p>\n</li>\n<li><p>最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号</p>\n</li>\n<li><p>为了使用样式更加容易阅读，可以将每条代码写在一个新行内，所以上面的应该写为：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p&#123;</span><br><span class=\"line\">  font-size:12px;</span><br><span class=\"line\">  color:red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CSS中的注释\"><a href=\"#CSS中的注释\" class=\"headerlink\" title=\"CSS中的注释\"></a>CSS中的注释</h3><ul>\n<li>格式：<code>/*注释语句*/</code></li>\n</ul>\n<h2 id=\"三种CSS样式\"><a href=\"#三种CSS样式\" class=\"headerlink\" title=\"三种CSS样式\"></a>三种CSS样式</h2><hr>\n<ul>\n<li>从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式、嵌入式和外部式三种。</li>\n</ul>\n<h3 id=\"内联式css样式，直接写在现有的HTML标签中\"><a href=\"#内联式css样式，直接写在现有的HTML标签中\" class=\"headerlink\" title=\"内联式css样式，直接写在现有的HTML标签中\"></a>内联式css样式，直接写在现有的HTML标签中</h3><ul>\n<li>内联式css样式表就是把css代码直接写在现有的HTML标签中，如下面代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p style=&quot;color:red&quot;&gt;这里文字是红色&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意要写在元素的开始标签里</p>\n</blockquote>\n<ul>\n<li>并且css样式代码要写在<code>style=&quot;&quot;</code>双引号中，如果有多条css样式代码设置可以写在一起，中间用分号隔开。如下代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p style=&quot;color:red;font-size:12px&quot;&gt;这里文字是红色&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌入式css样式，写在当前的文件中\"><a href=\"#嵌入式css样式，写在当前的文件中\" class=\"headerlink\" title=\"嵌入式css样式，写在当前的文件中\"></a>嵌入式css样式，写在当前的文件中</h3><ul>\n<li>嵌入式css样式，就是可以把css样式代码写在<code>&lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt;</code>标签之间。如下面代码实现把三个<code>&lt;span&gt;</code>标签中的文字设置为红色：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">span&#123;</span><br><span class=\"line\">color:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>嵌入式css样式必须写在<code>&lt;style&gt; &lt;/style&gt;</code>之间，并且一般情况下嵌入式css样式写在<code>&lt;head&gt; &lt;/head&gt;</code>之间</li>\n</ul>\n<h3 id=\"外部式css样式，写在单独的一个文件中\"><a href=\"#外部式css样式，写在单独的一个文件中\" class=\"headerlink\" title=\"外部式css样式，写在单独的一个文件中\"></a>外部式css样式，写在单独的一个文件中</h3><ul>\n<li>外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以<code>.css</code>为扩展名，在<code>&lt;head&gt;</code>内（不是在<code>&lt;style&gt;</code>标签内）使用<code>&lt;link&gt;</code>标签将css样式文件链接到HTML文件内，如下面代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>css样式文件名称以有意义的英文字母命名，如 main.css。</p>\n</li>\n<li><p><code>rel=&quot;stylesheet&quot; type=&quot;text/css&quot;</code> 是 <strong>固定写法</strong> 不可修改。</p>\n</li>\n<li><p><code>&lt;link&gt;</code>标签位置一般写在<code>&lt;head&gt;</code>标签之内。</p>\n</li>\n</ul>\n<h3 id=\"三种方法的优先级\"><a href=\"#三种方法的优先级\" class=\"headerlink\" title=\"三种方法的优先级\"></a>三种方法的优先级</h3><ul>\n<li><p>前提：在相同的权值的情况下。</p>\n</li>\n<li><p>优先级：<code>内联式 &gt; 嵌入式 &gt; 外部式</code></p>\n</li>\n<li><p>总而言之，就是就近原则（离被设置元素越近优先级别越高）。</p>\n</li>\n</ul>\n<h2 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h2><hr>\n<ul>\n<li>每一条css样式声明（定义）由两部分组成，形式如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">选择器&#123;</span><br><span class=\"line\">    样式;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>{}</code>之前的部分就是“选择器”，“选择器”指明了<code>{}</code>中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素。</p>\n<ul>\n<li>例：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;选择器&lt;/title&gt;</span><br><span class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">body&#123;</span><br><span class=\"line\">    font-size:12px;</span><br><span class=\"line\">    color:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">XXXXXXXX</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>其中<code>body{..}</code>就是一个选择器（标签选择器），他作用于<code>&lt;body&gt;</code>部分</p>\n<h3 id=\"标签选择器\"><a href=\"#标签选择器\" class=\"headerlink\" title=\"标签选择器\"></a>标签选择器</h3><ul>\n<li><p>标签选择器其实就是html代码中的标签。</p>\n</li>\n<li><p>例：<code>p{font-size:12px;line-height:1.6em;}</code>这个就为p标签（<code>&lt;p&gt;</code>标签是段落部分）设置12px字号，行间距设置1.6em的样式。</p>\n</li>\n</ul>\n<h3 id=\"类选择器\"><a href=\"#类选择器\" class=\"headerlink\" title=\"类选择器\"></a><strong>类选择器</strong></h3><ul>\n<li><p>语法：<code>.类选器名称{css样式代码;}</code></p>\n</li>\n<li><p>注意：以英文圆点开头。类选择器可以任意起名字。</p>\n</li>\n<li><p>用法：</p>\n</li>\n</ul>\n<ol>\n<li><p>使用合适的标签把要修饰的内容标记起来，如：<code>&lt;span&gt;胆小如鼠&lt;/span&gt;</code></p>\n</li>\n<li><p>使用<code>class=&quot;类选择器名称&quot;</code>为标签设置一个类，如：<code>&lt;span class=&quot;stress&quot;&gt;胆小如鼠&lt;/span&gt;</code></p>\n</li>\n<li><p>设置类选器css样式，如：<code>.stress{color:red;} /*类前面要加入一个英文圆点*/</code></p>\n</li>\n</ol>\n<ul>\n<li>类选择器使得我们可以灵活地自定义不同的部分的格式。</li>\n</ul>\n<h3 id=\"ID选择器\"><a href=\"#ID选择器\" class=\"headerlink\" title=\"ID选择器\"></a><strong>ID选择器</strong></h3><ul>\n<li>在很多方面，ID选择器都类似于类选择符，但也有一些重要的区别：</li>\n</ul>\n<ol>\n<li><p><strong>为标签设置<code>id=&quot;ID名称&quot;</code>，而不是<code>class=&quot;类名称&quot;</code>。</strong></p>\n</li>\n<li><p>ID选择符的前面是井号（#），而不是英文圆点（.）</p>\n</li>\n</ol>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#test&#123;</span><br><span class=\"line\">  color:blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">XXX&lt;span id=&quot;test&quot;&gt;...&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"id选择器和类选择器的区别与联系\"><a href=\"#id选择器和类选择器的区别与联系\" class=\"headerlink\" title=\"id选择器和类选择器的区别与联系\"></a>id选择器和类选择器的区别与联系</h3><h4 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h4><ul>\n<li>可以应用于任何元素</li>\n</ul>\n<h4 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h4><ul>\n<li><p><strong>ID选择器只能在文档中使用一次</strong>。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而<strong>类选择器可以使用多次</strong>。</p>\n</li>\n<li><p><strong>这里只能使用一次是指同一个id选择器只能修饰一个地方，而类选择器可以同时修饰多个地方。当然我们可以定义多个id选择器来修饰不同的地方</strong></p>\n</li>\n<li><p>可以使用类选择器词列表方法为一个元素<strong>同时设置多个样式</strong>。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（不能使用 ID 词列表）。</p>\n</li>\n<li><p><strong>正确示例</strong>：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.stress&#123;</span><br><span class=\"line\">    color:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.bigsize&#123;</span><br><span class=\"line\">    font-size:25px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">到了&lt;span class=&quot;stress bigsize&quot;&gt;三年级&lt;/span&gt;下学期时，我们班上了一节公开课...</span><br><span class=\"line\">&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>以上代码在<code>&lt;span&gt;</code>里定义两个类来修饰，这样的语法是可以的。上面代码的作用是为“三年级”三个文字设置文本颜色为红色并且字号为25px。</p>\n<ul>\n<li>错误的例子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#stressid&#123;</span><br><span class=\"line\">    color:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#bigsizeid&#123;</span><br><span class=\"line\">    font-size:25px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">到了&lt;span id=&quot;stressid bigsizeid&quot;&gt;三年级&lt;/span&gt;下学期时，我们班上了一节公开课...</span><br><span class=\"line\">&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>以上代码是错误的，一个地方只能用一个id选择器来修饰。以上代码不能起到修饰的作用。</p>\n<h3 id=\"子选择器\"><a href=\"#子选择器\" class=\"headerlink\" title=\"子选择器\"></a>子选择器</h3><ul>\n<li><p>还有一个比较有用的选择器子选择器，即大于符号(&gt;),用于选择指定标签元素的<strong>第一代子元素</strong>。</p>\n</li>\n<li><p>例如：(以下代码会使class名为food下的子元素 li 加入红色实线边框。)</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">.food&gt;li&#123;border:1px solid red;&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;h1&gt;食物&lt;/h1&gt;</span><br><span class=\"line\">&lt;ul class=&quot;food&quot;&gt;</span><br><span class=\"line\">    &lt;li&gt;水果</span><br><span class=\"line\">        &lt;ul&gt;</span><br><span class=\"line\">        \t&lt;li&gt;香蕉&lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;苹果&lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;梨&lt;/li&gt;</span><br><span class=\"line\">        &lt;/ul&gt;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;蔬菜</span><br><span class=\"line\">    \t&lt;ul&gt;</span><br><span class=\"line\">        \t&lt;li&gt;白菜&lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;油菜&lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;卷心菜&lt;/li&gt;</span><br><span class=\"line\">        &lt;/ul&gt;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"包含-后代-选择器\"><a href=\"#包含-后代-选择器\" class=\"headerlink\" title=\"包含(后代)选择器\"></a>包含(后代)选择器</h3><ul>\n<li><p>包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。如：<code>.first  span{color:red;}</code></p>\n</li>\n<li><p>请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的<strong>直接后代</strong>，或者你可以理解为作用于子元素的<strong>第一代后代</strong>。而后代选择器是作用于<strong>所有子后代元素</strong>。后代选择器通过<strong>空格</strong>来进行选择，而子选择器是通过<code>&gt;</code>进行选择。</p>\n</li>\n<li><p>总而言之就是，空格选择所有后代元素，<code>&gt;</code>只选择第一代后代。</p>\n</li>\n</ul>\n<h3 id=\"通用选择器\"><a href=\"#通用选择器\" class=\"headerlink\" title=\"通用选择器\"></a><strong>通用选择器</strong></h3><ul>\n<li>通用选择器是功能最强大的选择器，它使用一个<code>*</code>号指定，它的作用是匹配html中所有标签元素，如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色：<code>* {color:red;}</code></li>\n</ul>\n<h3 id=\"伪类选择符\"><a href=\"#伪类选择符\" class=\"headerlink\" title=\"伪类选择符\"></a>伪类选择符</h3><ul>\n<li><p>它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：<code>a:hover{color:red;}</code><br>这句代码就实现了<code>&lt;a&gt;</code>(超链接)鼠标划过的特效，当鼠标划过超链接时，超链接的字体颜色会变成红色。</p>\n</li>\n<li><p>一般<code>:hover</code>都是用来控制鼠标滑过的效果</p>\n</li>\n<li><p>其实 <code>:hover</code> 可以放在任意的标签上，比如说 <code>p:hover</code>，但是它们的兼容性也是很不好的，所以一般用在<code>a:hover</code>的组合。(<strong>现在也可以用在其他的地方</strong>)</p>\n</li>\n</ul>\n<h3 id=\"分组选择符\"><a href=\"#分组选择符\" class=\"headerlink\" title=\"分组选择符\"></a><strong>分组选择符</strong></h3><ul>\n<li><p>当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（，），如下代码将<code>&lt;h1&gt;</code>、<code>&lt;span&gt;</code>标签同时设置字体颜色为红色：<code>h1,span{color:red;}</code></p>\n</li>\n<li><p>以上代码相当于下面两行代码：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h1&#123;color:red;&#125;</span><br><span class=\"line\">span&#123;color:red;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><ul>\n<li>CSS的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。就是对某一些标签的样式的修改会对其子代也产生影响。</li>\n</ul>\n<p>###　权值</p>\n<ul>\n<li><p>如果对同一个标签设置了不同的样式，浏览器是根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。</p>\n</li>\n<li><p>权值的规则：<strong>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。</strong></p>\n</li>\n<li><p>例如：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p&#123;color:red;&#125; /*权值为1*/</span><br><span class=\"line\">p span&#123;color:green;&#125; /*权值为1+1=2*/</span><br><span class=\"line\">.warning&#123;color:white;&#125; /*权值为10*/</span><br><span class=\"line\">p span.warning&#123;color:purple;&#125; /*权值为1+1+10=12*/</span><br><span class=\"line\">#footer .note p&#123;color:yellow;&#125; /*权值为100+10+1=111*/</span><br></pre></td></tr></table></figure>\n<p>注意：还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。</p>\n<ul>\n<li>使用<code>!important</code>来使样式获得最高权值：<code>p{color:red!important;}</code><blockquote>\n<p>注意：!important要写在分号的前面,中间不需要空格。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"层叠\"><a href=\"#层叠\" class=\"headerlink\" title=\"层叠\"></a>层叠</h3><ul>\n<li><p>如果在html文件中对于同一个元素可以有多个css样式存在并且这多个css样式具有相同权重值怎么办？这时候我们就会用到层叠。</p>\n</li>\n<li><p>层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于<strong>最后面的css样式</strong>会被应用。</p>\n</li>\n<li><p>简单来说，就是，就是后面的样式会覆盖前面的样式。</p>\n</li>\n<li><p>所以之前的内外优先级关系：<code>内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</code> 也就很好理解了。</p>\n</li>\n</ul>\n<h2 id=\"文字排版\"><a href=\"#文字排版\" class=\"headerlink\" title=\"文字排版\"></a>文字排版</h2><hr>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><ul>\n<li><p>例：为网页设置字体 <code>body{font-family:&quot;Microsoft Yahei&quot;;}</code> //字体为微软雅黑</p>\n</li>\n<li><p>注意：这里设置的字体能否显示，取决于用户本地有没有安装这个字体。</p>\n</li>\n</ul>\n<h3 id=\"字号颜色\"><a href=\"#字号颜色\" class=\"headerlink\" title=\"字号颜色\"></a>字号颜色</h3><ul>\n<li><p>设置网页中文字的字号为12像素，并把字体颜色设置为#666(灰色)：<code>body{font-size:12px;color:#666}</code></p>\n</li>\n<li><p><code>font-size</code>:字体大小</p>\n</li>\n<li><p><code>color</code>：颜色(一般以<code>#</code>加数字来表示颜色，以增加颜色的多样化)</p>\n</li>\n</ul>\n<h3 id=\"一些字体样式：粗体、斜体等\"><a href=\"#一些字体样式：粗体、斜体等\" class=\"headerlink\" title=\"一些字体样式：粗体、斜体等\"></a>一些字体样式：粗体、斜体等</h3><ul>\n<li><p><code>font-weight</code>:字体粗细</p>\n</li>\n<li><p>例：<code>span{font-weight:bold;}</code>  //粗体</p>\n</li>\n<li><p><code>font-style</code>:字体特点</p>\n</li>\n<li><p>例：<code>span{font-style:italic;}</code>  //斜体(意大利体)</p>\n</li>\n<li><p><code>text-decoration</code>:文字修饰</p>\n</li>\n<li><p>例：<code>a{text-decoration:underline;}</code>  //下划线</p>\n</li>\n<li><p>例：<code>.oldPrice{text-decoration:line-through;}</code>    //删除线(将文字划去)</p>\n</li>\n</ul>\n<h3 id=\"段落排版\"><a href=\"#段落排版\" class=\"headerlink\" title=\"段落排版\"></a>段落排版</h3><h4 id=\"首行缩进\"><a href=\"#首行缩进\" class=\"headerlink\" title=\"首行缩进\"></a>首行缩进</h4><ul>\n<li><p>设置段落缩进两个字宽：<code>p{text-indent:2em;}</code></p>\n</li>\n<li><p><code>2em</code>的意思就是文字的2倍大小。</p>\n</li>\n</ul>\n<h4 id=\"行间距\"><a href=\"#行间距\" class=\"headerlink\" title=\"行间距\"></a>行间距</h4><ul>\n<li>例：<code>p{line-height:1.5em;}</code></li>\n</ul>\n<h4 id=\"中文字间距、字母间距\"><a href=\"#中文字间距、字母间距\" class=\"headerlink\" title=\"中文字间距、字母间距\"></a>中文字间距、字母间距</h4><ul>\n<li><p>如果想在网页排版中设置<strong>文字间隔</strong>或者<strong>字母间隔</strong>就可以使用<code>letter-spacing</code>来实现。</p>\n</li>\n<li><p>例：<code>h1{letter-spacing:10px;}</code></p>\n</li>\n<li><p>注意：这个样式使用在英文单词时，是设置<strong>字母与字母之间</strong>的间距。</p>\n</li>\n<li><p>如果我想设置英文单词之间的间距，可以使用 <code>word-spacing</code> 来实现。</p>\n</li>\n<li><p>例：<code>h1{word-spacing:20px;}</code></p>\n</li>\n</ul>\n<h4 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h4><ul>\n<li><p>为块状元素中的文本、图片设置居中样式，可以使用<code>text-align</code>样式代码。</p>\n</li>\n<li><p>例：<code>h1{text-align:center/left/right;}</code>  //居中/左对齐/右对齐</p>\n</li>\n</ul>\n<h2 id=\"元素分类\"><a href=\"#元素分类\" class=\"headerlink\" title=\"元素分类\"></a>元素分类</h2><hr>\n<ul>\n<li><p>在CSS中，html中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。</p>\n</li>\n<li><p>常用的块状元素有：<code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</code></p>\n</li>\n<li><p>常用的内联元素有：<code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</code></p>\n</li>\n<li><p>常用的内联块状元素有：<code>&lt;img&gt;、&lt;input&gt;</code></p>\n</li>\n</ul>\n<h3 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h3><ul>\n<li><p>设置<code>display:block</code>就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点：<code>a{display:block;}</code></p>\n</li>\n<li><p>块级元素特点：</p>\n</li>\n</ul>\n<ol>\n<li><p>每个块级元素都从新的一行开始，并且其后的元素也另起一行。</p>\n</li>\n<li><p>元素的高度、宽度、行高以及顶和底边距都可设置。</p>\n</li>\n<li><p>元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</p>\n</li>\n</ol>\n<h3 id=\"内联元素\"><a href=\"#内联元素\" class=\"headerlink\" title=\"内联元素\"></a>内联元素</h3><ul>\n<li><p>块状元素也可以通过代码<code>display:inline</code>将元素设置为内联元素。</p>\n</li>\n<li><p>如下代码就是将块状元素div转换为内联元素，从而使 div 元素具有内联元素特点：<code>div{display:inline;}</code></p>\n</li>\n<li><p>内联元素特点：</p>\n</li>\n</ul>\n<ol>\n<li><p>和其他元素都在一行上</p>\n</li>\n<li><p>元素的高度、宽度及顶部和底部边距不可设置</p>\n</li>\n<li><p>元素的宽度就是它包含的文字或图片的宽度，不可改变</p>\n</li>\n</ol>\n<h3 id=\"内联块状元素\"><a href=\"#内联块状元素\" class=\"headerlink\" title=\"内联块状元素\"></a>内联块状元素</h3><ul>\n<li><p>内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码<code>display:inline-block</code>就是将元素设置为内联块状元素。</p>\n</li>\n<li><p>inline-block 元素特点：</p>\n</li>\n</ul>\n<ol>\n<li><p>和其他元素都在一行上</p>\n</li>\n<li><p>元素的高度、宽度、行高以及顶和底边距都可设置</p>\n</li>\n</ol>\n<h2 id=\"颜色值\"><a href=\"#颜色值\" class=\"headerlink\" title=\"颜色值\"></a>颜色值</h2><hr>\n<ul>\n<li><p>英文命令颜色：<code>p{color:red;}</code></p>\n</li>\n<li><p>RGB颜色：这个与 photoshop 中的 RGB 颜色是一致的，由 R(red)、G(green)、B(blue) 三种颜色的比例来配色。</p>\n</li>\n<li><p>例：<code>p{color:rgb(133,45,200);}</code> 每一项的值可以是 0~255 之间的整数，也可以是 0%~100% 的百分数，例如：<code>p{color:rgb(20%,33%,25%);}</code></p>\n</li>\n<li><p><strong>十六进制颜色</strong>：这种颜色设置方法是现在比较普遍使用的方法，其原理其实也是 RGB 设置，但是其每一项的值由 0-255 变成了十六进制 00-ff。</p>\n</li>\n<li><p>例：<code>p{color:#00ffff;}</code>  //以<code>#</code>开头</p>\n</li>\n</ul>\n<p><img src=\"/images/CSS/color.jpg\" alt=\"\"></p>\n<p><img src=\"/images/CSS/color_list.jpg\" alt=\"\"></p>\n<h2 id=\"长度值\"><a href=\"#长度值\" class=\"headerlink\" title=\"长度值\"></a>长度值</h2><hr>\n<ul>\n<li>目前比较常用到px（像素）、em、% 百分比。(但是这三种单位都是相对值)</li>\n</ul>\n<h3 id=\"像素\"><a href=\"#像素\" class=\"headerlink\" title=\"像素\"></a>像素</h3><ul>\n<li>像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS规范中假设“90像素=1英寸”）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。</li>\n</ul>\n<h3 id=\"em\"><a href=\"#em\" class=\"headerlink\" title=\"em\"></a>em</h3><ul>\n<li>就是本元素给定字体的 font-size 值，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。如下代码：<code>p{font-size:12px;text-indent:2em;}</code>就是可以实现段落首行缩进 24px（也就是两个字体大小的距离）。</li>\n</ul>\n<h3 id=\"百分比\"><a href=\"#百分比\" class=\"headerlink\" title=\"百分比\"></a>百分比</h3><ul>\n<li><code>p{font-size:12px;line-height:130%}</code> 设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。</li>\n</ul>\n<h2 id=\"一些补充\"><a href=\"#一些补充\" class=\"headerlink\" title=\"一些补充\"></a>一些补充</h2><hr>\n<h3 id=\"元素宽度相关\"><a href=\"#元素宽度相关\" class=\"headerlink\" title=\"元素宽度相关\"></a>元素宽度相关</h3><ul>\n<li><p><code>calc()</code>用法：<a href=\"https://www.w3cplus.com/css3/how-to-use-css3-calc-function.html\" target=\"_blank\" rel=\"noopener\">详解</a></p>\n</li>\n<li><p>如果你的元素宽度是100%时，只要你在元素中添加了border,padding,margin任何一值，都将会把元素盒子撑破（标准模式下，除IE怪异模式）。</p>\n</li>\n</ul>\n<h4 id=\"opacity属性\"><a href=\"#opacity属性\" class=\"headerlink\" title=\"opacity属性\"></a>opacity属性</h4><ul>\n<li><p>设置div元素的不透明级别</p>\n</li>\n<li><p>语法：<code>opacity: value|inherit;</code></p>\n</li>\n<li><p>值： value: 规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）; inherit: 应该从父元素继承 opacity 属性的值。</p>\n</li>\n</ul>\n<h4 id=\"data-toggle属性\"><a href=\"#data-toggle属性\" class=\"headerlink\" title=\"data-toggle属性\"></a>data-toggle属性</h4><ul>\n<li>data-toggle一般是a元素(即链接)的属性。data-toggle指以什么事件触发。<a href=\"https://blog.csdn.net/d295968572/article/details/56667863\" target=\"_blank\" rel=\"noopener\">详细的介绍</a></li>\n</ul>\n<h4 id=\"webkit-tap-highlight-color属性\"><a href=\"#webkit-tap-highlight-color属性\" class=\"headerlink\" title=\"-webkit-tap-highlight-color属性\"></a>-webkit-tap-highlight-color属性</h4><ul>\n<li><code>-webkit-tap-highlight-color</code> 是一个没有标准化的属性，能够设置点击链接的时候出现的高亮颜色。显示给用户的高光是他们成功点击的标识，以及暗示了他们点击的元素。</li>\n</ul>\n<h3 id=\"media-用法\"><a href=\"#media-用法\" class=\"headerlink\" title=\"@media 用法\"></a><code>@media</code> 用法</h3><ul>\n<li><p><code>@media</code>可以让你根据不同的屏幕大小而使用不同的样式，这可以使得不需要js代码就能实现响应式布局。(即根据不同大小的页面重新排版)</p>\n</li>\n<li><p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media mediatype and|not|only (media feature) &#123;</span><br><span class=\"line\">    CSS-Code;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>其中mediatype就是媒体类型，可以包括好多种，最常用的就是screen，其他多数已经作废。</p>\n</li>\n<li><p>media feature就定义了这个media设备的一些特征，简单的说就是媒体满足什么条件，常用的就是max-width，min-width。</p>\n</li>\n<li><p><a href=\"http://blog.51cto.com/cnn237111/1602797\" target=\"_blank\" rel=\"noopener\">具体的例子</a></p>\n</li>\n</ul>\n<h3 id=\"margin属性\"><a href=\"#margin属性\" class=\"headerlink\" title=\"margin属性\"></a>margin属性</h3><ul>\n<li><p>定义和用法：margin 简写属性在一个声明中设置所有外边距属性。该属性可以有 1 到 4 个值。</p>\n</li>\n<li><p>块级元素的垂直相邻外边距会合并，而行内元素实际上不占上下外边距。行内元素的的左右外边距不会合并。同样地，浮动元素的外边距也不会合并。允许指定负的外边距值，不过使用时要小心。</p>\n</li>\n</ul>\n<blockquote>\n<p>注释：允许使用负值。</p>\n</blockquote>\n<ul>\n<li><p>例子 1：<code>margin:10px 5px 15px 20px;</code><br>上外边距是 10px;<br>右外边距是 5px;<br>下外边距是 15px;<br>左外边距是 20px;</p>\n</li>\n<li><p>例子 2: <code>margin:10px 5px 15px;</code><br>上外边距是 10px;<br>右外边距和左外边距是 5px;<br>下外边距是 15px;</p>\n</li>\n<li><p>例子 3:<code>margin:10px 5px;</code><br>上外边距和下外边距是 10px;<br>右外边距和左外边距是 5px;</p>\n</li>\n<li><p>例子 4:<code>margin:10px;</code><br>所有 4 个外边距都是 10px</p>\n</li>\n</ul>\n<h3 id=\"media用法\"><a href=\"#media用法\" class=\"headerlink\" title=\"@media用法\"></a><code>@media</code>用法</h3><ul>\n<li><a href=\"http://www.runoob.com/cssref/css3-pr-mediaquery.html\" target=\"_blank\" rel=\"noopener\">用法详解</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新与2018.7.9</p>\n</blockquote>\n"},{"layout":"post","title":"前端学习——HTML","date":"2018-06-17T03:46:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n## HTML基础\n---\n\n- 学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。(网页三件套大礼包～)\n\n### 概念解析\n\n-  HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。\n\n-  CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。\n\n- JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。\n\n### 一个html网页的基本结构\n\n```\n<html>\n<head>\n...\n</head>\n<body>\n<h1>\n...\n</h1>\n<p>\n...\n</p>\n<img src=\"...\">\n...\n</body>\n</html>\n```\n#### 标签语法\n\n- 标签由英文尖括号`<`和`>`括起来，如`<html>`就是一个标签。\n\n- 每组标签都是一一对应的，且后一个标签以 `/`(正斜杠)开头，标志着这一个部分的结束。\n\n- 标签与标签之间是可以嵌套的，但先后顺序必须保持一致，如：<div>里嵌套<p>，那么</p>必须放在</div>的前面。`<div> <p> ... </p> </div>`\n\n- HTML标签不区分大小写，`<h1>`和`<H1>`是一样的，但建议小写，因为大部分程序员都以小写为准\n\n### 代码注释\n\n- html代码注释的语法如： `<!--注释文字-->`\n\n## 标签详解\n\n- `<html></html>`称为根标签，所有的网页标签都在`<html></html>`中。\n\n- `<head>` 标签用于定义文档的头部，它是所有头部元素的容器。头部元素有`<title>、<script>、 <style>、<link>、 <meta>`等标签\n\n- 在`<body>`和`</body>`标签之间的内容是网页的主要内容，如`<h1>、<p>、<a>、<img>`等网页内容标签，在这里的标签中的内容会在浏览器中显示出来。\n\n- 其中，`<h1>`就是标题标签\n\n- `<p>`就是段落标签，段落内容就写在`<p>`与`<\\p>`之间\n\n- `<img src= \"..\">`表示图片，src中填写图片保存的路径\n\n### `<head>`标签\n\n- 文档的头部描述了文档的各种属性和信息，包括文档的标题等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。\n\n- 下面这些标签可以用在`<head>部分`：\n\n```\n<head>\n    <title>...</title>\n    <meta>\n    <link>\n    <style>...</style>\n    <script>...</script>\n</head>\n```\n\n- `<title>`标签：在`<title>`和`</title>`标签之间的文字内容是网页的标题信息，**它会出现在浏览器的标题栏中**。网页的title标签用于告诉用户和搜索引擎这个网页的主要内容是什么，搜索引擎可以通过网页标题，迅速的判断出网页的主题。每个网页的内容都是不同的，每个网页都应该有一个独一无二的title。\n\n### `<p>`标签\n\n- 每一对`<p></p>`标签表示一个段落，所以网页上每一段文字都要放在一对单独的`<p></p>`中。\n\n### `<hx>`标签\n\n- 上面的`<p>`标签是用来表示文章的段落的，那么文章的标题可以用`<hx>`来表示，**其中`x`为1-6的整数**，数字越小，代表越重要，字体也就越大。(这一点与markdown的用#号个数来表示几级标题是一致的)\n\n### 文本修饰：`<strong>`,`<em>`和`<span>`标签\n\n- `<em>`表示强调，`<strong>`表示更强烈的强调。并且在浏览器中`<em>`默认用 *斜体* 表示，`<strong>` 用 **粗体** 表示。\n\n- `<span>`标签是没有语义的，它的作用就是为了设置单独的样式用的。\n\n- 例子：\n\n```\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<title>了不起的盖茨比</title>\n<style>\nspan{\n    color:blue;\n}\n</style>\n</head>\n<body>\n    <p>\n    1922年的春天，一个想要成名名叫尼克•卡拉威（托比•马奎尔Tobey Maguire 饰）的作家，离开了美国中西部，来到了纽约。那是一个道德感渐失，爵士乐流行，走私为王，股票飞涨的时代。为了追寻他的<span>美国梦</span>，他搬入纽约附近一海湾居住。\n    </p>\n    <p>\n    菲茨杰拉德，二十世纪美国文学巨擘之一，兼具作家和编剧双重身份。他以诗人的敏感和戏剧家的想象为\"爵士乐时代\"吟唱华丽挽歌，其诗人和梦想家的气质亦为那个奢靡年代的不二注解。\n    </p>\n</body>\n</html>\n```\n其中第一段中的“美国梦”被`<span>`标签标记，在`<style>`标签中，我们定义了`<span>`标签修饰的文本的格式为蓝色。\n\n### `<q>标签`\n\n- `<q></q>`标签表示引用，注意要引用的文本不用加双引号，浏览器会对q标签自动添加双引号。\n\n- `<q></q>`适合一句话的引用。\n\n### `<blockquote>`标签\n\n- 相对于`<q></q>`，`<blockquote>...</blockquote>`适合用来引用一段长文字。\n\n### 换行与空格\n\n- 在 html 中是**忽略回车和空格**的，你输入的再多回车和空格也是显示不出来的\n\n- 换行标签语法：\n\n```\nxhtml1.0写法： <br />\nhtml4.01写法： <br>\n```\n现在一般用html4的写法\n\n-  与以前我们学过的标签不一样，`<br />`标签是一个 **空标签** 。没有HTML内容的标签就是空标签，**空标签只需要写一个开始标签**，这样的标签有`<br />`、`<hr />`和`<img />`。\n\n- 空格表示方法：`&nbsp;`。\n\n### 水平分割线\n\n- 在信息展示时，有时会需要加一些用于分隔的横线，这样会使文章看起来整齐些。效果如下\n<hr>\n\n- 语法：\n\n```\nhtml4.01版本 <hr>\nxhtml1.0版本 <hr />\n```\n现在一般用html4的写法\n\n- `<hr />`标签和`<br />`标签一样也是一个空标签，所以只有一个开始标签，没有结束标签。\n\n- `<hr />`标签的在浏览器中的默认样式线条比较粗，颜色为灰色，可能有些人觉得这种样式不美观，没有关系，这些外在样式在我们以后学习了css样式表之后，都可以对其修改。\n\n### `<address>`标签：为网页加入地址信息\n\n- `<address></address>`标签默认为斜体。这个也可以通过CSS修改。\n\n### `<code>`和`<pre>`标签\n\n- 在网页上`<code></code>`标签用来标注一行代码。\n\n- 如果是多行代码，可以使用`<pre>`标签。语法：`<pre>语言代码段</pre>`\n\n- `<pre>` 标签的主要作用:预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。\n\n- 注意：`<pre>` 标签不只是为显示计算机的源代码时用的，在你需要在网页中预显示格式时都可以使用它，只是`<pre>`标签的一个常见应用就是用来展示计算机的源代码。\n\n### `ul-li`标签\n\n- 实例：\n\n```\n<ul>\n  <li>精彩少年</li>\n  <li>美丽突然出现</li>\n  <li>触动心灵的旋律</li>\n</ul>\n```\n\n- `ul-li`在网页中显示的默认样式一般为：每项`li`前都自带一个圆点：\n![](/images/HTML/ul-li.png)\n\n### `ol-li`标签\n\n- 与`ul-li`标签类似，只是前面的圆点变成了从1开始的序号\n\n### `<div>`标签\n\n- 在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个`<div>`标签中，这个`<div>`标签的作用就相当于一个容器。\n\n- 逻辑部分是页面上相互关联的一组元素。如网页中的独立的栏目版块，就是一个典型的逻辑部分。\n\n- 一般一个网页都要用很多个`<div></div>`来划分成不同的逻辑部分。\n\n### `<div>`标签的命名\n\n- 为了使逻辑更加清晰，我们可以为这一个独立的逻辑部分设置一个名称，用`id`属性来为`<div>`提供唯一的名称，这个就像我们每个人都有一个身份证号，这个身份证号是唯一标识我们的身份的，也是必须唯一的。\n\n- 语法：`<div  id=\"版块名称\">...</div>`(只需要在开始的部分添加，结尾不变)\n\n### `<table>`标签\n\n- 创建表格的四个元素：table、tbody、tr、th、td\n\n- 整个表格以`<table>`标记开始、`</table>`标记结束。\n\n- 如果不加`<thead><tbody><tfooter>` , table表格加载完后才显示。加上这些表格结构， `tbody`包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用`tbody`分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。）\n\n- `<tr>...</tr>`：表格的一行，所以有几对tr 表格就有几行。\n\n- `<td>...</td>`：表格的一个单元格，一行中包含几对`<td>...</td>`，说明一行中就有几列。\n\n- `<th>…</th>`：表格的头部的一个单元格，表格表头。\n\n- 表格中列的个数，取决于一行中数据单元格的个数。\n\n- table表格在没有添加css样式之前，在浏览器中显示是没有表格线的\n\n### `<a>`标签\n\n- `<a>`标签实现了超链接。\n\n- 语法：`<a  href=\"http://...(网址)\"  title=\"鼠标滑过显示的文本\">链接显示的文本</a>`\n\n- 设置链接在新建窗口中打开：`<a href=\"目标网址\" target=\"_blank\">链接显示的文本</a>`\n\n### `<img>`标签\n\n- 语法：`<img src=\"图片地址\" [alt=\"下载失败时的替换文本\"](一般可以不写) title = \"提示文本\">`\n\n- src：标识图像的位置\n\n- alt：指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本\n\n- title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)\n\n### 表单标签\n\n- 表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。\n\n- 语法：`<form   method=\"传送方式\"   action=\"服务器文件\">`\n\n- <form> ：<form>标签是成对出现的，以<form>开始，以</form>结束。\n\n- action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。\n\n- method ： 数据传送的方式（get/post）。\n\n- 例：\n\n```\n<form    method=\"post\"   action=\"save.php\">\n        <label for=\"username\">用户名:</label>\n        <input type=\"text\" name=\"username\" />\n        <label for=\"pass\">密码:</label>\n        <input type=\"password\" name=\"pass\" />\n</form>\n```\n\n- 所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 <form></form> 标签之间，否则用户的数据可能提交不上。\n\n- method : post/get 的区别这一部分内容属于后端程序员考虑的问题。\n\n### 文本输入框、密码输入框\n\n- 文本输入框可以转化为密码输入框。\n\n- 语法：\n\n```\n<form>\n   <input type=\"text/password\" name=\"名称\" value=\"文本\" />\n</form>\n```\n\n- type：当type=\"text\"时，输入框为文本输入框; 当type=\"password\"时, 输入框为密码输入框。\n\n- name：为文本框命名，以备后台程序ASP 、PHP使用。\n\n- value：为文本输入框设置默认值。(一般起到提示作用)\n\n### 文本域\n\n- 语法：`<textarea  rows=\"行数\" cols=\"列数\">文本</textarea>`\n\n- cols ：多行输入域的列数。\n\n- rows ：多行输入域的行数。\n\n- 注意这两个属性可用css样式的width和height来代替：col用width、row用height来代替。\n\n- 在`<textarea></textarea>`标签之间可以输入默认值。\n\n## Html5新元素一览\n---\n\n- [Html5新元素](http://www.runoob.com/html/html5-new-element.html)\n\n\n<br>\n> 最后更新于2018.6.17\n","source":"_posts/2018-06-17-FrontEnd-HTML.md","raw":"---\nlayout:     post\ntitle:      \"前端学习——HTML\"\ndate:       2018-06-17 11:46:00\ncategories: FrontEnd\ntags:   [๑FrontEnd, ๑Html]\n---\n\n> 不适合人类阅读的学习笔记\n\n## HTML基础\n---\n\n- 学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。(网页三件套大礼包～)\n\n### 概念解析\n\n-  HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。\n\n-  CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。\n\n- JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。\n\n### 一个html网页的基本结构\n\n```\n<html>\n<head>\n...\n</head>\n<body>\n<h1>\n...\n</h1>\n<p>\n...\n</p>\n<img src=\"...\">\n...\n</body>\n</html>\n```\n#### 标签语法\n\n- 标签由英文尖括号`<`和`>`括起来，如`<html>`就是一个标签。\n\n- 每组标签都是一一对应的，且后一个标签以 `/`(正斜杠)开头，标志着这一个部分的结束。\n\n- 标签与标签之间是可以嵌套的，但先后顺序必须保持一致，如：<div>里嵌套<p>，那么</p>必须放在</div>的前面。`<div> <p> ... </p> </div>`\n\n- HTML标签不区分大小写，`<h1>`和`<H1>`是一样的，但建议小写，因为大部分程序员都以小写为准\n\n### 代码注释\n\n- html代码注释的语法如： `<!--注释文字-->`\n\n## 标签详解\n\n- `<html></html>`称为根标签，所有的网页标签都在`<html></html>`中。\n\n- `<head>` 标签用于定义文档的头部，它是所有头部元素的容器。头部元素有`<title>、<script>、 <style>、<link>、 <meta>`等标签\n\n- 在`<body>`和`</body>`标签之间的内容是网页的主要内容，如`<h1>、<p>、<a>、<img>`等网页内容标签，在这里的标签中的内容会在浏览器中显示出来。\n\n- 其中，`<h1>`就是标题标签\n\n- `<p>`就是段落标签，段落内容就写在`<p>`与`<\\p>`之间\n\n- `<img src= \"..\">`表示图片，src中填写图片保存的路径\n\n### `<head>`标签\n\n- 文档的头部描述了文档的各种属性和信息，包括文档的标题等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。\n\n- 下面这些标签可以用在`<head>部分`：\n\n```\n<head>\n    <title>...</title>\n    <meta>\n    <link>\n    <style>...</style>\n    <script>...</script>\n</head>\n```\n\n- `<title>`标签：在`<title>`和`</title>`标签之间的文字内容是网页的标题信息，**它会出现在浏览器的标题栏中**。网页的title标签用于告诉用户和搜索引擎这个网页的主要内容是什么，搜索引擎可以通过网页标题，迅速的判断出网页的主题。每个网页的内容都是不同的，每个网页都应该有一个独一无二的title。\n\n### `<p>`标签\n\n- 每一对`<p></p>`标签表示一个段落，所以网页上每一段文字都要放在一对单独的`<p></p>`中。\n\n### `<hx>`标签\n\n- 上面的`<p>`标签是用来表示文章的段落的，那么文章的标题可以用`<hx>`来表示，**其中`x`为1-6的整数**，数字越小，代表越重要，字体也就越大。(这一点与markdown的用#号个数来表示几级标题是一致的)\n\n### 文本修饰：`<strong>`,`<em>`和`<span>`标签\n\n- `<em>`表示强调，`<strong>`表示更强烈的强调。并且在浏览器中`<em>`默认用 *斜体* 表示，`<strong>` 用 **粗体** 表示。\n\n- `<span>`标签是没有语义的，它的作用就是为了设置单独的样式用的。\n\n- 例子：\n\n```\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<title>了不起的盖茨比</title>\n<style>\nspan{\n    color:blue;\n}\n</style>\n</head>\n<body>\n    <p>\n    1922年的春天，一个想要成名名叫尼克•卡拉威（托比•马奎尔Tobey Maguire 饰）的作家，离开了美国中西部，来到了纽约。那是一个道德感渐失，爵士乐流行，走私为王，股票飞涨的时代。为了追寻他的<span>美国梦</span>，他搬入纽约附近一海湾居住。\n    </p>\n    <p>\n    菲茨杰拉德，二十世纪美国文学巨擘之一，兼具作家和编剧双重身份。他以诗人的敏感和戏剧家的想象为\"爵士乐时代\"吟唱华丽挽歌，其诗人和梦想家的气质亦为那个奢靡年代的不二注解。\n    </p>\n</body>\n</html>\n```\n其中第一段中的“美国梦”被`<span>`标签标记，在`<style>`标签中，我们定义了`<span>`标签修饰的文本的格式为蓝色。\n\n### `<q>标签`\n\n- `<q></q>`标签表示引用，注意要引用的文本不用加双引号，浏览器会对q标签自动添加双引号。\n\n- `<q></q>`适合一句话的引用。\n\n### `<blockquote>`标签\n\n- 相对于`<q></q>`，`<blockquote>...</blockquote>`适合用来引用一段长文字。\n\n### 换行与空格\n\n- 在 html 中是**忽略回车和空格**的，你输入的再多回车和空格也是显示不出来的\n\n- 换行标签语法：\n\n```\nxhtml1.0写法： <br />\nhtml4.01写法： <br>\n```\n现在一般用html4的写法\n\n-  与以前我们学过的标签不一样，`<br />`标签是一个 **空标签** 。没有HTML内容的标签就是空标签，**空标签只需要写一个开始标签**，这样的标签有`<br />`、`<hr />`和`<img />`。\n\n- 空格表示方法：`&nbsp;`。\n\n### 水平分割线\n\n- 在信息展示时，有时会需要加一些用于分隔的横线，这样会使文章看起来整齐些。效果如下\n<hr>\n\n- 语法：\n\n```\nhtml4.01版本 <hr>\nxhtml1.0版本 <hr />\n```\n现在一般用html4的写法\n\n- `<hr />`标签和`<br />`标签一样也是一个空标签，所以只有一个开始标签，没有结束标签。\n\n- `<hr />`标签的在浏览器中的默认样式线条比较粗，颜色为灰色，可能有些人觉得这种样式不美观，没有关系，这些外在样式在我们以后学习了css样式表之后，都可以对其修改。\n\n### `<address>`标签：为网页加入地址信息\n\n- `<address></address>`标签默认为斜体。这个也可以通过CSS修改。\n\n### `<code>`和`<pre>`标签\n\n- 在网页上`<code></code>`标签用来标注一行代码。\n\n- 如果是多行代码，可以使用`<pre>`标签。语法：`<pre>语言代码段</pre>`\n\n- `<pre>` 标签的主要作用:预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。\n\n- 注意：`<pre>` 标签不只是为显示计算机的源代码时用的，在你需要在网页中预显示格式时都可以使用它，只是`<pre>`标签的一个常见应用就是用来展示计算机的源代码。\n\n### `ul-li`标签\n\n- 实例：\n\n```\n<ul>\n  <li>精彩少年</li>\n  <li>美丽突然出现</li>\n  <li>触动心灵的旋律</li>\n</ul>\n```\n\n- `ul-li`在网页中显示的默认样式一般为：每项`li`前都自带一个圆点：\n![](/images/HTML/ul-li.png)\n\n### `ol-li`标签\n\n- 与`ul-li`标签类似，只是前面的圆点变成了从1开始的序号\n\n### `<div>`标签\n\n- 在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个`<div>`标签中，这个`<div>`标签的作用就相当于一个容器。\n\n- 逻辑部分是页面上相互关联的一组元素。如网页中的独立的栏目版块，就是一个典型的逻辑部分。\n\n- 一般一个网页都要用很多个`<div></div>`来划分成不同的逻辑部分。\n\n### `<div>`标签的命名\n\n- 为了使逻辑更加清晰，我们可以为这一个独立的逻辑部分设置一个名称，用`id`属性来为`<div>`提供唯一的名称，这个就像我们每个人都有一个身份证号，这个身份证号是唯一标识我们的身份的，也是必须唯一的。\n\n- 语法：`<div  id=\"版块名称\">...</div>`(只需要在开始的部分添加，结尾不变)\n\n### `<table>`标签\n\n- 创建表格的四个元素：table、tbody、tr、th、td\n\n- 整个表格以`<table>`标记开始、`</table>`标记结束。\n\n- 如果不加`<thead><tbody><tfooter>` , table表格加载完后才显示。加上这些表格结构， `tbody`包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用`tbody`分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。）\n\n- `<tr>...</tr>`：表格的一行，所以有几对tr 表格就有几行。\n\n- `<td>...</td>`：表格的一个单元格，一行中包含几对`<td>...</td>`，说明一行中就有几列。\n\n- `<th>…</th>`：表格的头部的一个单元格，表格表头。\n\n- 表格中列的个数，取决于一行中数据单元格的个数。\n\n- table表格在没有添加css样式之前，在浏览器中显示是没有表格线的\n\n### `<a>`标签\n\n- `<a>`标签实现了超链接。\n\n- 语法：`<a  href=\"http://...(网址)\"  title=\"鼠标滑过显示的文本\">链接显示的文本</a>`\n\n- 设置链接在新建窗口中打开：`<a href=\"目标网址\" target=\"_blank\">链接显示的文本</a>`\n\n### `<img>`标签\n\n- 语法：`<img src=\"图片地址\" [alt=\"下载失败时的替换文本\"](一般可以不写) title = \"提示文本\">`\n\n- src：标识图像的位置\n\n- alt：指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本\n\n- title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)\n\n### 表单标签\n\n- 表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。\n\n- 语法：`<form   method=\"传送方式\"   action=\"服务器文件\">`\n\n- <form> ：<form>标签是成对出现的，以<form>开始，以</form>结束。\n\n- action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。\n\n- method ： 数据传送的方式（get/post）。\n\n- 例：\n\n```\n<form    method=\"post\"   action=\"save.php\">\n        <label for=\"username\">用户名:</label>\n        <input type=\"text\" name=\"username\" />\n        <label for=\"pass\">密码:</label>\n        <input type=\"password\" name=\"pass\" />\n</form>\n```\n\n- 所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 <form></form> 标签之间，否则用户的数据可能提交不上。\n\n- method : post/get 的区别这一部分内容属于后端程序员考虑的问题。\n\n### 文本输入框、密码输入框\n\n- 文本输入框可以转化为密码输入框。\n\n- 语法：\n\n```\n<form>\n   <input type=\"text/password\" name=\"名称\" value=\"文本\" />\n</form>\n```\n\n- type：当type=\"text\"时，输入框为文本输入框; 当type=\"password\"时, 输入框为密码输入框。\n\n- name：为文本框命名，以备后台程序ASP 、PHP使用。\n\n- value：为文本输入框设置默认值。(一般起到提示作用)\n\n### 文本域\n\n- 语法：`<textarea  rows=\"行数\" cols=\"列数\">文本</textarea>`\n\n- cols ：多行输入域的列数。\n\n- rows ：多行输入域的行数。\n\n- 注意这两个属性可用css样式的width和height来代替：col用width、row用height来代替。\n\n- 在`<textarea></textarea>`标签之间可以输入默认值。\n\n## Html5新元素一览\n---\n\n- [Html5新元素](http://www.runoob.com/html/html5-new-element.html)\n\n\n<br>\n> 最后更新于2018.6.17\n","slug":"2018-06-17-FrontEnd-HTML","published":1,"updated":"2018-09-03T13:14:06.827Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j52002i1m0o9i2osr1i","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"HTML基础\"><a href=\"#HTML基础\" class=\"headerlink\" title=\"HTML基础\"></a>HTML基础</h2><hr>\n<ul>\n<li>学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。(网页三件套大礼包～)</li>\n</ul>\n<h3 id=\"概念解析\"><a href=\"#概念解析\" class=\"headerlink\" title=\"概念解析\"></a>概念解析</h3><ul>\n<li><p>HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。</p>\n</li>\n<li><p>CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。</p>\n</li>\n<li><p>JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。</p>\n</li>\n</ul>\n<h3 id=\"一个html网页的基本结构\"><a href=\"#一个html网页的基本结构\" class=\"headerlink\" title=\"一个html网页的基本结构\"></a>一个html网页的基本结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h1&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/h1&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;img src=&quot;...&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"标签语法\"><a href=\"#标签语法\" class=\"headerlink\" title=\"标签语法\"></a>标签语法</h4><ul>\n<li><p>标签由英文尖括号<code>&lt;</code>和<code>&gt;</code>括起来，如<code>&lt;html&gt;</code>就是一个标签。</p>\n</li>\n<li><p>每组标签都是一一对应的，且后一个标签以 <code>/</code>(正斜杠)开头，标志着这一个部分的结束。</p>\n</li>\n<li><p>标签与标签之间是可以嵌套的，但先后顺序必须保持一致，如：<div>里嵌套<p>，那么</p>必须放在</div>的前面。<code>&lt;div&gt; &lt;p&gt; ... &lt;/p&gt; &lt;/div&gt;</code></p>\n</li>\n<li><p>HTML标签不区分大小写，<code>&lt;h1&gt;</code>和<code>&lt;H1&gt;</code>是一样的，但建议小写，因为大部分程序员都以小写为准</p>\n</li>\n</ul>\n<h3 id=\"代码注释\"><a href=\"#代码注释\" class=\"headerlink\" title=\"代码注释\"></a>代码注释</h3><ul>\n<li>html代码注释的语法如： <code>&lt;!--注释文字--&gt;</code></li>\n</ul>\n<h2 id=\"标签详解\"><a href=\"#标签详解\" class=\"headerlink\" title=\"标签详解\"></a>标签详解</h2><ul>\n<li><p><code>&lt;html&gt;&lt;/html&gt;</code>称为根标签，所有的网页标签都在<code>&lt;html&gt;&lt;/html&gt;</code>中。</p>\n</li>\n<li><p><code>&lt;head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器。头部元素有<code>&lt;title&gt;、&lt;script&gt;、 &lt;style&gt;、&lt;link&gt;、 &lt;meta&gt;</code>等标签</p>\n</li>\n<li><p>在<code>&lt;body&gt;</code>和<code>&lt;/body&gt;</code>标签之间的内容是网页的主要内容，如<code>&lt;h1&gt;、&lt;p&gt;、&lt;a&gt;、&lt;img&gt;</code>等网页内容标签，在这里的标签中的内容会在浏览器中显示出来。</p>\n</li>\n<li><p>其中，<code>&lt;h1&gt;</code>就是标题标签</p>\n</li>\n<li><p><code>&lt;p&gt;</code>就是段落标签，段落内容就写在<code>&lt;p&gt;</code>与<code>&lt;\\p&gt;</code>之间</p>\n</li>\n<li><p><code>&lt;img src= &quot;..&quot;&gt;</code>表示图片，src中填写图片保存的路径</p>\n</li>\n</ul>\n<h3 id=\"lt-head-gt-标签\"><a href=\"#lt-head-gt-标签\" class=\"headerlink\" title=\"&lt;head&gt;标签\"></a><code>&lt;head&gt;</code>标签</h3><ul>\n<li><p>文档的头部描述了文档的各种属性和信息，包括文档的标题等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>\n</li>\n<li><p>下面这些标签可以用在<code>&lt;head&gt;部分</code>：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;...&lt;/title&gt;</span><br><span class=\"line\">    &lt;meta&gt;</span><br><span class=\"line\">    &lt;link&gt;</span><br><span class=\"line\">    &lt;style&gt;...&lt;/style&gt;</span><br><span class=\"line\">    &lt;script&gt;...&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>&lt;title&gt;</code>标签：在<code>&lt;title&gt;</code>和<code>&lt;/title&gt;</code>标签之间的文字内容是网页的标题信息，<strong>它会出现在浏览器的标题栏中</strong>。网页的title标签用于告诉用户和搜索引擎这个网页的主要内容是什么，搜索引擎可以通过网页标题，迅速的判断出网页的主题。每个网页的内容都是不同的，每个网页都应该有一个独一无二的title。</li>\n</ul>\n<h3 id=\"lt-p-gt-标签\"><a href=\"#lt-p-gt-标签\" class=\"headerlink\" title=\"&lt;p&gt;标签\"></a><code>&lt;p&gt;</code>标签</h3><ul>\n<li>每一对<code>&lt;p&gt;&lt;/p&gt;</code>标签表示一个段落，所以网页上每一段文字都要放在一对单独的<code>&lt;p&gt;&lt;/p&gt;</code>中。</li>\n</ul>\n<h3 id=\"lt-hx-gt-标签\"><a href=\"#lt-hx-gt-标签\" class=\"headerlink\" title=\"&lt;hx&gt;标签\"></a><code>&lt;hx&gt;</code>标签</h3><ul>\n<li>上面的<code>&lt;p&gt;</code>标签是用来表示文章的段落的，那么文章的标题可以用<code>&lt;hx&gt;</code>来表示，<strong>其中<code>x</code>为1-6的整数</strong>，数字越小，代表越重要，字体也就越大。(这一点与markdown的用#号个数来表示几级标题是一致的)</li>\n</ul>\n<h3 id=\"文本修饰：-lt-strong-gt-lt-em-gt-和-lt-span-gt-标签\"><a href=\"#文本修饰：-lt-strong-gt-lt-em-gt-和-lt-span-gt-标签\" class=\"headerlink\" title=\"文本修饰：&lt;strong&gt;,&lt;em&gt;和&lt;span&gt;标签\"></a>文本修饰：<code>&lt;strong&gt;</code>,<code>&lt;em&gt;</code>和<code>&lt;span&gt;</code>标签</h3><ul>\n<li><p><code>&lt;em&gt;</code>表示强调，<code>&lt;strong&gt;</code>表示更强烈的强调。并且在浏览器中<code>&lt;em&gt;</code>默认用 <em>斜体</em> 表示，<code>&lt;strong&gt;</code> 用 <strong>粗体</strong> 表示。</p>\n</li>\n<li><p><code>&lt;span&gt;</code>标签是没有语义的，它的作用就是为了设置单独的样式用的。</p>\n</li>\n<li><p>例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;了不起的盖茨比&lt;/title&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">span&#123;</span><br><span class=\"line\">    color:blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;p&gt;</span><br><span class=\"line\">    1922年的春天，一个想要成名名叫尼克•卡拉威（托比•马奎尔Tobey Maguire 饰）的作家，离开了美国中西部，来到了纽约。那是一个道德感渐失，爵士乐流行，走私为王，股票飞涨的时代。为了追寻他的&lt;span&gt;美国梦&lt;/span&gt;，他搬入纽约附近一海湾居住。</span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;</span><br><span class=\"line\">    菲茨杰拉德，二十世纪美国文学巨擘之一，兼具作家和编剧双重身份。他以诗人的敏感和戏剧家的想象为&quot;爵士乐时代&quot;吟唱华丽挽歌，其诗人和梦想家的气质亦为那个奢靡年代的不二注解。</span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>其中第一段中的“美国梦”被<code>&lt;span&gt;</code>标签标记，在<code>&lt;style&gt;</code>标签中，我们定义了<code>&lt;span&gt;</code>标签修饰的文本的格式为蓝色。</p>\n<h3 id=\"lt-q-gt-标签\"><a href=\"#lt-q-gt-标签\" class=\"headerlink\" title=\"&lt;q&gt;标签\"></a><code>&lt;q&gt;标签</code></h3><ul>\n<li><p><code>&lt;q&gt;&lt;/q&gt;</code>标签表示引用，注意要引用的文本不用加双引号，浏览器会对q标签自动添加双引号。</p>\n</li>\n<li><p><code>&lt;q&gt;&lt;/q&gt;</code>适合一句话的引用。</p>\n</li>\n</ul>\n<h3 id=\"lt-blockquote-gt-标签\"><a href=\"#lt-blockquote-gt-标签\" class=\"headerlink\" title=\"&lt;blockquote&gt;标签\"></a><code>&lt;blockquote&gt;</code>标签</h3><ul>\n<li>相对于<code>&lt;q&gt;&lt;/q&gt;</code>，<code>&lt;blockquote&gt;...&lt;/blockquote&gt;</code>适合用来引用一段长文字。</li>\n</ul>\n<h3 id=\"换行与空格\"><a href=\"#换行与空格\" class=\"headerlink\" title=\"换行与空格\"></a>换行与空格</h3><ul>\n<li><p>在 html 中是<strong>忽略回车和空格</strong>的，你输入的再多回车和空格也是显示不出来的</p>\n</li>\n<li><p>换行标签语法：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhtml1.0写法： &lt;br /&gt;</span><br><span class=\"line\">html4.01写法： &lt;br&gt;</span><br></pre></td></tr></table></figure>\n<p>现在一般用html4的写法</p>\n<ul>\n<li><p>与以前我们学过的标签不一样，<code>&lt;br /&gt;</code>标签是一个 <strong>空标签</strong> 。没有HTML内容的标签就是空标签，<strong>空标签只需要写一个开始标签</strong>，这样的标签有<code>&lt;br /&gt;</code>、<code>&lt;hr /&gt;</code>和<code>&lt;img /&gt;</code>。</p>\n</li>\n<li><p>空格表示方法：<code>&amp;nbsp;</code>。</p>\n</li>\n</ul>\n<h3 id=\"水平分割线\"><a href=\"#水平分割线\" class=\"headerlink\" title=\"水平分割线\"></a>水平分割线</h3><ul>\n<li><p>在信息展示时，有时会需要加一些用于分隔的横线，这样会使文章看起来整齐些。效果如下</p>\n<hr>\n</li>\n<li><p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html4.01版本 &lt;hr&gt;</span><br><span class=\"line\">xhtml1.0版本 &lt;hr /&gt;</span><br></pre></td></tr></table></figure>\n<p>现在一般用html4的写法</p>\n<ul>\n<li><p><code>&lt;hr /&gt;</code>标签和<code>&lt;br /&gt;</code>标签一样也是一个空标签，所以只有一个开始标签，没有结束标签。</p>\n</li>\n<li><p><code>&lt;hr /&gt;</code>标签的在浏览器中的默认样式线条比较粗，颜色为灰色，可能有些人觉得这种样式不美观，没有关系，这些外在样式在我们以后学习了css样式表之后，都可以对其修改。</p>\n</li>\n</ul>\n<h3 id=\"lt-address-gt-标签：为网页加入地址信息\"><a href=\"#lt-address-gt-标签：为网页加入地址信息\" class=\"headerlink\" title=\"&lt;address&gt;标签：为网页加入地址信息\"></a><code>&lt;address&gt;</code>标签：为网页加入地址信息</h3><ul>\n<li><code>&lt;address&gt;&lt;/address&gt;</code>标签默认为斜体。这个也可以通过CSS修改。</li>\n</ul>\n<h3 id=\"lt-code-gt-和-lt-pre-gt-标签\"><a href=\"#lt-code-gt-和-lt-pre-gt-标签\" class=\"headerlink\" title=\"&lt;code&gt;和&lt;pre&gt;标签\"></a><code>&lt;code&gt;</code>和<code>&lt;pre&gt;</code>标签</h3><ul>\n<li><p>在网页上<code>&lt;code&gt;&lt;/code&gt;</code>标签用来标注一行代码。</p>\n</li>\n<li><p>如果是多行代码，可以使用<code>&lt;pre&gt;</code>标签。语法：<code>&lt;pre&gt;语言代码段&lt;/pre&gt;</code></p>\n</li>\n<li><p><code>&lt;pre&gt;</code> 标签的主要作用:预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。</p>\n</li>\n<li><p>注意：<code>&lt;pre&gt;</code> 标签不只是为显示计算机的源代码时用的，在你需要在网页中预显示格式时都可以使用它，只是<code>&lt;pre&gt;</code>标签的一个常见应用就是用来展示计算机的源代码。</p>\n</li>\n</ul>\n<h3 id=\"ul-li标签\"><a href=\"#ul-li标签\" class=\"headerlink\" title=\"ul-li标签\"></a><code>ul-li</code>标签</h3><ul>\n<li>实例：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li&gt;精彩少年&lt;/li&gt;</span><br><span class=\"line\">  &lt;li&gt;美丽突然出现&lt;/li&gt;</span><br><span class=\"line\">  &lt;li&gt;触动心灵的旋律&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>ul-li</code>在网页中显示的默认样式一般为：每项<code>li</code>前都自带一个圆点：<br><img src=\"/images/HTML/ul-li.png\" alt=\"\"></li>\n</ul>\n<h3 id=\"ol-li标签\"><a href=\"#ol-li标签\" class=\"headerlink\" title=\"ol-li标签\"></a><code>ol-li</code>标签</h3><ul>\n<li>与<code>ul-li</code>标签类似，只是前面的圆点变成了从1开始的序号</li>\n</ul>\n<h3 id=\"lt-div-gt-标签\"><a href=\"#lt-div-gt-标签\" class=\"headerlink\" title=\"&lt;div&gt;标签\"></a><code>&lt;div&gt;</code>标签</h3><ul>\n<li><p>在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个<code>&lt;div&gt;</code>标签中，这个<code>&lt;div&gt;</code>标签的作用就相当于一个容器。</p>\n</li>\n<li><p>逻辑部分是页面上相互关联的一组元素。如网页中的独立的栏目版块，就是一个典型的逻辑部分。</p>\n</li>\n<li><p>一般一个网页都要用很多个<code>&lt;div&gt;&lt;/div&gt;</code>来划分成不同的逻辑部分。</p>\n</li>\n</ul>\n<h3 id=\"lt-div-gt-标签的命名\"><a href=\"#lt-div-gt-标签的命名\" class=\"headerlink\" title=\"&lt;div&gt;标签的命名\"></a><code>&lt;div&gt;</code>标签的命名</h3><ul>\n<li><p>为了使逻辑更加清晰，我们可以为这一个独立的逻辑部分设置一个名称，用<code>id</code>属性来为<code>&lt;div&gt;</code>提供唯一的名称，这个就像我们每个人都有一个身份证号，这个身份证号是唯一标识我们的身份的，也是必须唯一的。</p>\n</li>\n<li><p>语法：<code>&lt;div  id=&quot;版块名称&quot;&gt;...&lt;/div&gt;</code>(只需要在开始的部分添加，结尾不变)</p>\n</li>\n</ul>\n<h3 id=\"lt-table-gt-标签\"><a href=\"#lt-table-gt-标签\" class=\"headerlink\" title=\"&lt;table&gt;标签\"></a><code>&lt;table&gt;</code>标签</h3><ul>\n<li><p>创建表格的四个元素：table、tbody、tr、th、td</p>\n</li>\n<li><p>整个表格以<code>&lt;table&gt;</code>标记开始、<code>&lt;/table&gt;</code>标记结束。</p>\n</li>\n<li><p>如果不加<code>&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt;</code> , table表格加载完后才显示。加上这些表格结构， <code>tbody</code>包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用<code>tbody</code>分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。）</p>\n</li>\n<li><p><code>&lt;tr&gt;...&lt;/tr&gt;</code>：表格的一行，所以有几对tr 表格就有几行。</p>\n</li>\n<li><p><code>&lt;td&gt;...&lt;/td&gt;</code>：表格的一个单元格，一行中包含几对<code>&lt;td&gt;...&lt;/td&gt;</code>，说明一行中就有几列。</p>\n</li>\n<li><p><code>&lt;th&gt;…&lt;/th&gt;</code>：表格的头部的一个单元格，表格表头。</p>\n</li>\n<li><p>表格中列的个数，取决于一行中数据单元格的个数。</p>\n</li>\n<li><p>table表格在没有添加css样式之前，在浏览器中显示是没有表格线的</p>\n</li>\n</ul>\n<h3 id=\"lt-a-gt-标签\"><a href=\"#lt-a-gt-标签\" class=\"headerlink\" title=\"&lt;a&gt;标签\"></a><code>&lt;a&gt;</code>标签</h3><ul>\n<li><p><code>&lt;a&gt;</code>标签实现了超链接。</p>\n</li>\n<li><p>语法：<code>&lt;a  href=&quot;http://...(网址)&quot;  title=&quot;鼠标滑过显示的文本&quot;&gt;链接显示的文本&lt;/a&gt;</code></p>\n</li>\n<li><p>设置链接在新建窗口中打开：<code>&lt;a href=&quot;目标网址&quot; target=&quot;_blank&quot;&gt;链接显示的文本&lt;/a&gt;</code></p>\n</li>\n</ul>\n<h3 id=\"lt-img-gt-标签\"><a href=\"#lt-img-gt-标签\" class=\"headerlink\" title=\"&lt;img&gt;标签\"></a><code>&lt;img&gt;</code>标签</h3><ul>\n<li><p>语法：<code>&lt;img src=&quot;图片地址&quot; [alt=&quot;下载失败时的替换文本&quot;](一般可以不写) title = &quot;提示文本&quot;&gt;</code></p>\n</li>\n<li><p>src：标识图像的位置</p>\n</li>\n<li><p>alt：指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本</p>\n</li>\n<li><p>title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)</p>\n</li>\n</ul>\n<h3 id=\"表单标签\"><a href=\"#表单标签\" class=\"headerlink\" title=\"表单标签\"></a>表单标签</h3><ul>\n<li><p>表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。</p>\n</li>\n<li><p>语法：<code>&lt;form   method=&quot;传送方式&quot;   action=&quot;服务器文件&quot;&gt;</code></p>\n</li>\n<li><p><form> ：<form>标签是成对出现的，以<form>开始，以</form>结束。</form></form></p>\n</li>\n<li><p>action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。</p>\n</li>\n<li><p>method ： 数据传送的方式（get/post）。</p>\n</li>\n<li><p>例：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form    method=&quot;post&quot;   action=&quot;save.php&quot;&gt;</span><br><span class=\"line\">        &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class=\"line\">        &lt;label for=&quot;pass&quot;&gt;密码:&lt;/label&gt;</span><br><span class=\"line\">        &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 <form></form> 标签之间，否则用户的数据可能提交不上。</p>\n</li>\n<li><p>method : post/get 的区别这一部分内容属于后端程序员考虑的问题。</p>\n</li>\n</ul>\n<h3 id=\"文本输入框、密码输入框\"><a href=\"#文本输入框、密码输入框\" class=\"headerlink\" title=\"文本输入框、密码输入框\"></a>文本输入框、密码输入框</h3><ul>\n<li><p>文本输入框可以转化为密码输入框。</p>\n</li>\n<li><p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form&gt;</span><br><span class=\"line\">   &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>type：当type=”text”时，输入框为文本输入框; 当type=”password”时, 输入框为密码输入框。</p>\n</li>\n<li><p>name：为文本框命名，以备后台程序ASP 、PHP使用。</p>\n</li>\n<li><p>value：为文本输入框设置默认值。(一般起到提示作用)</p>\n</li>\n</ul>\n<h3 id=\"文本域\"><a href=\"#文本域\" class=\"headerlink\" title=\"文本域\"></a>文本域</h3><ul>\n<li><p>语法：<code>&lt;textarea  rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt;</code></p>\n</li>\n<li><p>cols ：多行输入域的列数。</p>\n</li>\n<li><p>rows ：多行输入域的行数。</p>\n</li>\n<li><p>注意这两个属性可用css样式的width和height来代替：col用width、row用height来代替。</p>\n</li>\n<li><p>在<code>&lt;textarea&gt;&lt;/textarea&gt;</code>标签之间可以输入默认值。</p>\n</li>\n</ul>\n<h2 id=\"Html5新元素一览\"><a href=\"#Html5新元素一览\" class=\"headerlink\" title=\"Html5新元素一览\"></a>Html5新元素一览</h2><hr>\n<ul>\n<li><a href=\"http://www.runoob.com/html/html5-new-element.html\" target=\"_blank\" rel=\"noopener\">Html5新元素</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.6.17</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"HTML基础\"><a href=\"#HTML基础\" class=\"headerlink\" title=\"HTML基础\"></a>HTML基础</h2><hr>\n<ul>\n<li>学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。(网页三件套大礼包～)</li>\n</ul>\n<h3 id=\"概念解析\"><a href=\"#概念解析\" class=\"headerlink\" title=\"概念解析\"></a>概念解析</h3><ul>\n<li><p>HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。</p>\n</li>\n<li><p>CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。</p>\n</li>\n<li><p>JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。</p>\n</li>\n</ul>\n<h3 id=\"一个html网页的基本结构\"><a href=\"#一个html网页的基本结构\" class=\"headerlink\" title=\"一个html网页的基本结构\"></a>一个html网页的基本结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h1&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/h1&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/p&gt;</span><br><span class=\"line\">&lt;img src=&quot;...&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"标签语法\"><a href=\"#标签语法\" class=\"headerlink\" title=\"标签语法\"></a>标签语法</h4><ul>\n<li><p>标签由英文尖括号<code>&lt;</code>和<code>&gt;</code>括起来，如<code>&lt;html&gt;</code>就是一个标签。</p>\n</li>\n<li><p>每组标签都是一一对应的，且后一个标签以 <code>/</code>(正斜杠)开头，标志着这一个部分的结束。</p>\n</li>\n<li><p>标签与标签之间是可以嵌套的，但先后顺序必须保持一致，如：<div>里嵌套<p>，那么</p>必须放在</div>的前面。<code>&lt;div&gt; &lt;p&gt; ... &lt;/p&gt; &lt;/div&gt;</code></p>\n</li>\n<li><p>HTML标签不区分大小写，<code>&lt;h1&gt;</code>和<code>&lt;H1&gt;</code>是一样的，但建议小写，因为大部分程序员都以小写为准</p>\n</li>\n</ul>\n<h3 id=\"代码注释\"><a href=\"#代码注释\" class=\"headerlink\" title=\"代码注释\"></a>代码注释</h3><ul>\n<li>html代码注释的语法如： <code>&lt;!--注释文字--&gt;</code></li>\n</ul>\n<h2 id=\"标签详解\"><a href=\"#标签详解\" class=\"headerlink\" title=\"标签详解\"></a>标签详解</h2><ul>\n<li><p><code>&lt;html&gt;&lt;/html&gt;</code>称为根标签，所有的网页标签都在<code>&lt;html&gt;&lt;/html&gt;</code>中。</p>\n</li>\n<li><p><code>&lt;head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器。头部元素有<code>&lt;title&gt;、&lt;script&gt;、 &lt;style&gt;、&lt;link&gt;、 &lt;meta&gt;</code>等标签</p>\n</li>\n<li><p>在<code>&lt;body&gt;</code>和<code>&lt;/body&gt;</code>标签之间的内容是网页的主要内容，如<code>&lt;h1&gt;、&lt;p&gt;、&lt;a&gt;、&lt;img&gt;</code>等网页内容标签，在这里的标签中的内容会在浏览器中显示出来。</p>\n</li>\n<li><p>其中，<code>&lt;h1&gt;</code>就是标题标签</p>\n</li>\n<li><p><code>&lt;p&gt;</code>就是段落标签，段落内容就写在<code>&lt;p&gt;</code>与<code>&lt;\\p&gt;</code>之间</p>\n</li>\n<li><p><code>&lt;img src= &quot;..&quot;&gt;</code>表示图片，src中填写图片保存的路径</p>\n</li>\n</ul>\n<h3 id=\"lt-head-gt-标签\"><a href=\"#lt-head-gt-标签\" class=\"headerlink\" title=\"&lt;head&gt;标签\"></a><code>&lt;head&gt;</code>标签</h3><ul>\n<li><p>文档的头部描述了文档的各种属性和信息，包括文档的标题等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>\n</li>\n<li><p>下面这些标签可以用在<code>&lt;head&gt;部分</code>：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;...&lt;/title&gt;</span><br><span class=\"line\">    &lt;meta&gt;</span><br><span class=\"line\">    &lt;link&gt;</span><br><span class=\"line\">    &lt;style&gt;...&lt;/style&gt;</span><br><span class=\"line\">    &lt;script&gt;...&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>&lt;title&gt;</code>标签：在<code>&lt;title&gt;</code>和<code>&lt;/title&gt;</code>标签之间的文字内容是网页的标题信息，<strong>它会出现在浏览器的标题栏中</strong>。网页的title标签用于告诉用户和搜索引擎这个网页的主要内容是什么，搜索引擎可以通过网页标题，迅速的判断出网页的主题。每个网页的内容都是不同的，每个网页都应该有一个独一无二的title。</li>\n</ul>\n<h3 id=\"lt-p-gt-标签\"><a href=\"#lt-p-gt-标签\" class=\"headerlink\" title=\"&lt;p&gt;标签\"></a><code>&lt;p&gt;</code>标签</h3><ul>\n<li>每一对<code>&lt;p&gt;&lt;/p&gt;</code>标签表示一个段落，所以网页上每一段文字都要放在一对单独的<code>&lt;p&gt;&lt;/p&gt;</code>中。</li>\n</ul>\n<h3 id=\"lt-hx-gt-标签\"><a href=\"#lt-hx-gt-标签\" class=\"headerlink\" title=\"&lt;hx&gt;标签\"></a><code>&lt;hx&gt;</code>标签</h3><ul>\n<li>上面的<code>&lt;p&gt;</code>标签是用来表示文章的段落的，那么文章的标题可以用<code>&lt;hx&gt;</code>来表示，<strong>其中<code>x</code>为1-6的整数</strong>，数字越小，代表越重要，字体也就越大。(这一点与markdown的用#号个数来表示几级标题是一致的)</li>\n</ul>\n<h3 id=\"文本修饰：-lt-strong-gt-lt-em-gt-和-lt-span-gt-标签\"><a href=\"#文本修饰：-lt-strong-gt-lt-em-gt-和-lt-span-gt-标签\" class=\"headerlink\" title=\"文本修饰：&lt;strong&gt;,&lt;em&gt;和&lt;span&gt;标签\"></a>文本修饰：<code>&lt;strong&gt;</code>,<code>&lt;em&gt;</code>和<code>&lt;span&gt;</code>标签</h3><ul>\n<li><p><code>&lt;em&gt;</code>表示强调，<code>&lt;strong&gt;</code>表示更强烈的强调。并且在浏览器中<code>&lt;em&gt;</code>默认用 <em>斜体</em> 表示，<code>&lt;strong&gt;</code> 用 <strong>粗体</strong> 表示。</p>\n</li>\n<li><p><code>&lt;span&gt;</code>标签是没有语义的，它的作用就是为了设置单独的样式用的。</p>\n</li>\n<li><p>例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;了不起的盖茨比&lt;/title&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">span&#123;</span><br><span class=\"line\">    color:blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;p&gt;</span><br><span class=\"line\">    1922年的春天，一个想要成名名叫尼克•卡拉威（托比•马奎尔Tobey Maguire 饰）的作家，离开了美国中西部，来到了纽约。那是一个道德感渐失，爵士乐流行，走私为王，股票飞涨的时代。为了追寻他的&lt;span&gt;美国梦&lt;/span&gt;，他搬入纽约附近一海湾居住。</span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;</span><br><span class=\"line\">    菲茨杰拉德，二十世纪美国文学巨擘之一，兼具作家和编剧双重身份。他以诗人的敏感和戏剧家的想象为&quot;爵士乐时代&quot;吟唱华丽挽歌，其诗人和梦想家的气质亦为那个奢靡年代的不二注解。</span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>其中第一段中的“美国梦”被<code>&lt;span&gt;</code>标签标记，在<code>&lt;style&gt;</code>标签中，我们定义了<code>&lt;span&gt;</code>标签修饰的文本的格式为蓝色。</p>\n<h3 id=\"lt-q-gt-标签\"><a href=\"#lt-q-gt-标签\" class=\"headerlink\" title=\"&lt;q&gt;标签\"></a><code>&lt;q&gt;标签</code></h3><ul>\n<li><p><code>&lt;q&gt;&lt;/q&gt;</code>标签表示引用，注意要引用的文本不用加双引号，浏览器会对q标签自动添加双引号。</p>\n</li>\n<li><p><code>&lt;q&gt;&lt;/q&gt;</code>适合一句话的引用。</p>\n</li>\n</ul>\n<h3 id=\"lt-blockquote-gt-标签\"><a href=\"#lt-blockquote-gt-标签\" class=\"headerlink\" title=\"&lt;blockquote&gt;标签\"></a><code>&lt;blockquote&gt;</code>标签</h3><ul>\n<li>相对于<code>&lt;q&gt;&lt;/q&gt;</code>，<code>&lt;blockquote&gt;...&lt;/blockquote&gt;</code>适合用来引用一段长文字。</li>\n</ul>\n<h3 id=\"换行与空格\"><a href=\"#换行与空格\" class=\"headerlink\" title=\"换行与空格\"></a>换行与空格</h3><ul>\n<li><p>在 html 中是<strong>忽略回车和空格</strong>的，你输入的再多回车和空格也是显示不出来的</p>\n</li>\n<li><p>换行标签语法：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhtml1.0写法： &lt;br /&gt;</span><br><span class=\"line\">html4.01写法： &lt;br&gt;</span><br></pre></td></tr></table></figure>\n<p>现在一般用html4的写法</p>\n<ul>\n<li><p>与以前我们学过的标签不一样，<code>&lt;br /&gt;</code>标签是一个 <strong>空标签</strong> 。没有HTML内容的标签就是空标签，<strong>空标签只需要写一个开始标签</strong>，这样的标签有<code>&lt;br /&gt;</code>、<code>&lt;hr /&gt;</code>和<code>&lt;img /&gt;</code>。</p>\n</li>\n<li><p>空格表示方法：<code>&amp;nbsp;</code>。</p>\n</li>\n</ul>\n<h3 id=\"水平分割线\"><a href=\"#水平分割线\" class=\"headerlink\" title=\"水平分割线\"></a>水平分割线</h3><ul>\n<li><p>在信息展示时，有时会需要加一些用于分隔的横线，这样会使文章看起来整齐些。效果如下</p>\n<hr>\n</li>\n<li><p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html4.01版本 &lt;hr&gt;</span><br><span class=\"line\">xhtml1.0版本 &lt;hr /&gt;</span><br></pre></td></tr></table></figure>\n<p>现在一般用html4的写法</p>\n<ul>\n<li><p><code>&lt;hr /&gt;</code>标签和<code>&lt;br /&gt;</code>标签一样也是一个空标签，所以只有一个开始标签，没有结束标签。</p>\n</li>\n<li><p><code>&lt;hr /&gt;</code>标签的在浏览器中的默认样式线条比较粗，颜色为灰色，可能有些人觉得这种样式不美观，没有关系，这些外在样式在我们以后学习了css样式表之后，都可以对其修改。</p>\n</li>\n</ul>\n<h3 id=\"lt-address-gt-标签：为网页加入地址信息\"><a href=\"#lt-address-gt-标签：为网页加入地址信息\" class=\"headerlink\" title=\"&lt;address&gt;标签：为网页加入地址信息\"></a><code>&lt;address&gt;</code>标签：为网页加入地址信息</h3><ul>\n<li><code>&lt;address&gt;&lt;/address&gt;</code>标签默认为斜体。这个也可以通过CSS修改。</li>\n</ul>\n<h3 id=\"lt-code-gt-和-lt-pre-gt-标签\"><a href=\"#lt-code-gt-和-lt-pre-gt-标签\" class=\"headerlink\" title=\"&lt;code&gt;和&lt;pre&gt;标签\"></a><code>&lt;code&gt;</code>和<code>&lt;pre&gt;</code>标签</h3><ul>\n<li><p>在网页上<code>&lt;code&gt;&lt;/code&gt;</code>标签用来标注一行代码。</p>\n</li>\n<li><p>如果是多行代码，可以使用<code>&lt;pre&gt;</code>标签。语法：<code>&lt;pre&gt;语言代码段&lt;/pre&gt;</code></p>\n</li>\n<li><p><code>&lt;pre&gt;</code> 标签的主要作用:预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。</p>\n</li>\n<li><p>注意：<code>&lt;pre&gt;</code> 标签不只是为显示计算机的源代码时用的，在你需要在网页中预显示格式时都可以使用它，只是<code>&lt;pre&gt;</code>标签的一个常见应用就是用来展示计算机的源代码。</p>\n</li>\n</ul>\n<h3 id=\"ul-li标签\"><a href=\"#ul-li标签\" class=\"headerlink\" title=\"ul-li标签\"></a><code>ul-li</code>标签</h3><ul>\n<li>实例：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li&gt;精彩少年&lt;/li&gt;</span><br><span class=\"line\">  &lt;li&gt;美丽突然出现&lt;/li&gt;</span><br><span class=\"line\">  &lt;li&gt;触动心灵的旋律&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>ul-li</code>在网页中显示的默认样式一般为：每项<code>li</code>前都自带一个圆点：<br><img src=\"/images/HTML/ul-li.png\" alt=\"\"></li>\n</ul>\n<h3 id=\"ol-li标签\"><a href=\"#ol-li标签\" class=\"headerlink\" title=\"ol-li标签\"></a><code>ol-li</code>标签</h3><ul>\n<li>与<code>ul-li</code>标签类似，只是前面的圆点变成了从1开始的序号</li>\n</ul>\n<h3 id=\"lt-div-gt-标签\"><a href=\"#lt-div-gt-标签\" class=\"headerlink\" title=\"&lt;div&gt;标签\"></a><code>&lt;div&gt;</code>标签</h3><ul>\n<li><p>在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个<code>&lt;div&gt;</code>标签中，这个<code>&lt;div&gt;</code>标签的作用就相当于一个容器。</p>\n</li>\n<li><p>逻辑部分是页面上相互关联的一组元素。如网页中的独立的栏目版块，就是一个典型的逻辑部分。</p>\n</li>\n<li><p>一般一个网页都要用很多个<code>&lt;div&gt;&lt;/div&gt;</code>来划分成不同的逻辑部分。</p>\n</li>\n</ul>\n<h3 id=\"lt-div-gt-标签的命名\"><a href=\"#lt-div-gt-标签的命名\" class=\"headerlink\" title=\"&lt;div&gt;标签的命名\"></a><code>&lt;div&gt;</code>标签的命名</h3><ul>\n<li><p>为了使逻辑更加清晰，我们可以为这一个独立的逻辑部分设置一个名称，用<code>id</code>属性来为<code>&lt;div&gt;</code>提供唯一的名称，这个就像我们每个人都有一个身份证号，这个身份证号是唯一标识我们的身份的，也是必须唯一的。</p>\n</li>\n<li><p>语法：<code>&lt;div  id=&quot;版块名称&quot;&gt;...&lt;/div&gt;</code>(只需要在开始的部分添加，结尾不变)</p>\n</li>\n</ul>\n<h3 id=\"lt-table-gt-标签\"><a href=\"#lt-table-gt-标签\" class=\"headerlink\" title=\"&lt;table&gt;标签\"></a><code>&lt;table&gt;</code>标签</h3><ul>\n<li><p>创建表格的四个元素：table、tbody、tr、th、td</p>\n</li>\n<li><p>整个表格以<code>&lt;table&gt;</code>标记开始、<code>&lt;/table&gt;</code>标记结束。</p>\n</li>\n<li><p>如果不加<code>&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt;</code> , table表格加载完后才显示。加上这些表格结构， <code>tbody</code>包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用<code>tbody</code>分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。）</p>\n</li>\n<li><p><code>&lt;tr&gt;...&lt;/tr&gt;</code>：表格的一行，所以有几对tr 表格就有几行。</p>\n</li>\n<li><p><code>&lt;td&gt;...&lt;/td&gt;</code>：表格的一个单元格，一行中包含几对<code>&lt;td&gt;...&lt;/td&gt;</code>，说明一行中就有几列。</p>\n</li>\n<li><p><code>&lt;th&gt;…&lt;/th&gt;</code>：表格的头部的一个单元格，表格表头。</p>\n</li>\n<li><p>表格中列的个数，取决于一行中数据单元格的个数。</p>\n</li>\n<li><p>table表格在没有添加css样式之前，在浏览器中显示是没有表格线的</p>\n</li>\n</ul>\n<h3 id=\"lt-a-gt-标签\"><a href=\"#lt-a-gt-标签\" class=\"headerlink\" title=\"&lt;a&gt;标签\"></a><code>&lt;a&gt;</code>标签</h3><ul>\n<li><p><code>&lt;a&gt;</code>标签实现了超链接。</p>\n</li>\n<li><p>语法：<code>&lt;a  href=&quot;http://...(网址)&quot;  title=&quot;鼠标滑过显示的文本&quot;&gt;链接显示的文本&lt;/a&gt;</code></p>\n</li>\n<li><p>设置链接在新建窗口中打开：<code>&lt;a href=&quot;目标网址&quot; target=&quot;_blank&quot;&gt;链接显示的文本&lt;/a&gt;</code></p>\n</li>\n</ul>\n<h3 id=\"lt-img-gt-标签\"><a href=\"#lt-img-gt-标签\" class=\"headerlink\" title=\"&lt;img&gt;标签\"></a><code>&lt;img&gt;</code>标签</h3><ul>\n<li><p>语法：<code>&lt;img src=&quot;图片地址&quot; [alt=&quot;下载失败时的替换文本&quot;](一般可以不写) title = &quot;提示文本&quot;&gt;</code></p>\n</li>\n<li><p>src：标识图像的位置</p>\n</li>\n<li><p>alt：指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本</p>\n</li>\n<li><p>title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)</p>\n</li>\n</ul>\n<h3 id=\"表单标签\"><a href=\"#表单标签\" class=\"headerlink\" title=\"表单标签\"></a>表单标签</h3><ul>\n<li><p>表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。</p>\n</li>\n<li><p>语法：<code>&lt;form   method=&quot;传送方式&quot;   action=&quot;服务器文件&quot;&gt;</code></p>\n</li>\n<li><p><form> ：<form>标签是成对出现的，以<form>开始，以</form>结束。</form></form></p>\n</li>\n<li><p>action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。</p>\n</li>\n<li><p>method ： 数据传送的方式（get/post）。</p>\n</li>\n<li><p>例：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form    method=&quot;post&quot;   action=&quot;save.php&quot;&gt;</span><br><span class=\"line\">        &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class=\"line\">        &lt;label for=&quot;pass&quot;&gt;密码:&lt;/label&gt;</span><br><span class=\"line\">        &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 <form></form> 标签之间，否则用户的数据可能提交不上。</p>\n</li>\n<li><p>method : post/get 的区别这一部分内容属于后端程序员考虑的问题。</p>\n</li>\n</ul>\n<h3 id=\"文本输入框、密码输入框\"><a href=\"#文本输入框、密码输入框\" class=\"headerlink\" title=\"文本输入框、密码输入框\"></a>文本输入框、密码输入框</h3><ul>\n<li><p>文本输入框可以转化为密码输入框。</p>\n</li>\n<li><p>语法：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form&gt;</span><br><span class=\"line\">   &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>type：当type=”text”时，输入框为文本输入框; 当type=”password”时, 输入框为密码输入框。</p>\n</li>\n<li><p>name：为文本框命名，以备后台程序ASP 、PHP使用。</p>\n</li>\n<li><p>value：为文本输入框设置默认值。(一般起到提示作用)</p>\n</li>\n</ul>\n<h3 id=\"文本域\"><a href=\"#文本域\" class=\"headerlink\" title=\"文本域\"></a>文本域</h3><ul>\n<li><p>语法：<code>&lt;textarea  rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt;</code></p>\n</li>\n<li><p>cols ：多行输入域的列数。</p>\n</li>\n<li><p>rows ：多行输入域的行数。</p>\n</li>\n<li><p>注意这两个属性可用css样式的width和height来代替：col用width、row用height来代替。</p>\n</li>\n<li><p>在<code>&lt;textarea&gt;&lt;/textarea&gt;</code>标签之间可以输入默认值。</p>\n</li>\n</ul>\n<h2 id=\"Html5新元素一览\"><a href=\"#Html5新元素一览\" class=\"headerlink\" title=\"Html5新元素一览\"></a>Html5新元素一览</h2><hr>\n<ul>\n<li><a href=\"http://www.runoob.com/html/html5-new-element.html\" target=\"_blank\" rel=\"noopener\">Html5新元素</a></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.6.17</p>\n</blockquote>\n"},{"layout":"post","title":"前端学习——JavaScript","date":"2018-07-07T03:26:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n\n## 基础\n---\n\n>建议把javascript脚本放在 `<body> `部分的底部。\n>这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。\n\n- [Js是放在head还是body解析](https://blog.csdn.net/w405722907/article/details/78517757)\n\n### 嵌入html的javascript写法\n\n- JavaScript代码写在`<script>`和`</script>`标签之前。\n![](/images/JavaScript/001.png)\n- 其中`<script type =\"text/javascript\">`表示在`<script></script>`之间的是文本类型`(text)`,javascript是为了告诉浏览器里面的文本是属于JavaScript语言。\n\n### 单独写成文件\n\n- JavaScript代码只能写在HTML文件中吗?当然不是，我们可以把HTML文件和JS代码分开,并单独创建一个JavaScript文件(简称JS文件),其文件后缀通常为.js，然后将JS代码直接写在JS文件中。\n\n- **注意:在JS文件中，不需要`<script>`标签,直接编写JavaScript代码就可以了。**\n\n- 单独写成文件的javascript文件不能单独运行，比如一个叫“script.js”的文件，我们需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中：`<script src=\"script.js\"></script>`\n\n#### 位置\n\n- 我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。\n\n##### 放在`<head>`部分\n\n- 最常用的方式是在页面中head部分放置`<script>`元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。\n\n##### 放在`<body>`部分\n\n- JavaScript代码在网页读取到该语句的时候就会执行。\n\n- **注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。**\n\n## 语法\n---\n\n- 一个JavaScript语句以`;`结尾（虽然也可以不写）\n\n- 注释：单行注释：`//`，多行注释`/*...*/`\n\n### 变量\n\n- 定义变量使用关键字`var 变量名`\n\n- 注意JS中变量无需声明类型\n\n### 判断语句\n\n- 语法：\n```\nif(条件)\n{ 条件成立时执行的代码 }\nelse\n{ 条件不成立时执行的代码 }\n```\n\n- 例子：\n\n```\n<script type=\"text/javascript\">\n   var myage = 18;\n   if(myage>=18)  //myage>=18是判断条件\n   { document.write(\"你是成年人。\");}\n   else  //否则年龄小于18\n   { document.write(\"未满18岁，你不是成年人。\");}\n</script>\n```\n\n### 判断函数\n\n- 语法：\n```\nfunction 函数名()\n{\n     函数代码;\n}\n```\n\n- 例子：\n![](/images/JavaScript/002.png)\n\n#### 输出内容(document.write)\n\n- 输出内容可以是双引号括起来的，也可以是变量，多个输出项之间以`+`连接\n\n- 例子：\n\n```\n<script type=\"text/javascript\">\n  var mystr=\"hello\";\n  document.write(mystr+\"I love JavaScript\"); //多项内容之间用+号连接\n</script>\n```\n\n##### javascript警告(消息对话框)\n\n- 语法：`alert(字符串或变量)`\n\n> 注意：alert弹出一个消息对话框，只有一个确定按钮，多个对话框之间按顺序弹出。\n\n##### 确认(confirm对话框)\n\n- 语法：`confirm(str);`\n\n- 参数说明：\n1. str：在消息对话框中要显示的文本\n2. 返回值: Boolean值\n\n- 返回值：\n当用户点击\"确定\"按钮时，返回true ；当用户点击\"取消\"按钮时，返回false\n\n##### 打开新窗口(window.open)\n\n- 语法：`window.open([URL], [窗口名称], [参数字符串])`\n\n- 参数说明：\n```\nURL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。\n窗口名称：可选参数，被打开窗口的名称。\n    1.该名称由字母、数字和下划线字符组成。\n    2.\"_top\"、\"_blank\"、\"_self\"具有特殊意义的名称。\n       _blank：在新窗口显示目标网页\n       _self：在当前窗口显示目标网页\n       _top：框架网页中在上部窗口中显示目标网页\n    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。\n   4.name 不能包含有空格。\n参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。\n```\n![](/images/JavaScript/003.png)\n\n> 注意：所有的参数都要写在一个参数字符串中，中间以逗号间隔，例如 'height=100.width=100' 这样。\n\n- 可以将窗口对象存储在变量test中：`var test = window.open(...);`\n\n- 关闭窗口：\n\n1. `window.close();`:关闭本窗口\n\n2. `<窗口对象>.close();`:关闭指定窗口\n\n## 控制权(DOM操作)\n---\n\n- 文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。\n\n- 将HTML代码分解为DOM节点层次图:\n![](/images/JavaScript/004.png)\n\n### HTML文档可以说由节点构成的集合，三种常见的DOM节点:\n\n- 元素节点：上图中`<html>`、`<body>`、`<p>`等都是元素节点，即标签。\n\n- 文本节点:向用户展示的内容，如`<li>...</li>`中的JavaScript、DOM、CSS等文本。\n\n- 属性节点:元素属性，如`<a>`标签的链接属性`href=\"http://www.imooc.com\"`。\n\n- 例子：`<a href=\"http://www.imooc.com\">JavaScript DOM</a>`\n![](/images/JavaScript/005.png)\n\n### 通过ID获取元素\n\n- 网页由标签将信息组织起来，而标签的id属性值是唯一的，就像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通过id先找到标签，然后进行操作。\n\n- 语法：`document.getElementById(“id”) `\n\n- 例子：\n\n```\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta http-wquiv=\"Content-Type\" content=\"text/html; charest=gb2312\" />\n<title>获取元素</title>\n  <script type=\"text/javascript\">\n    var mye = document.getElementById(\"con\");    //获取元素变量存储在变量mye中\n    document.write(mye);                    //输出变量\n  </script>\n</head>\n<body>\n    <h3>Hello</h3>\n    <p id=\"con\">I love JavaScript</p>\n</body>\n</html>\n```\n### innerHTML属性\n\n- innerHTML 属性用于获取或替换 HTML 元素的内容。\n\n- 语法：`Object.innerHTML`\n\n- 例子：\n\n```\n<!DOCTYPE HTML>\n<html>\n<head>\n<title>innerHTML</title>\n</head>\n<body>\n  <p id=\"con\">Hello World!</p>\n  <script>\n    var mycon = document.getElementById(\"con\");\n    document.write(\"P标签原始内容：\" + mycon.innerHTML + “<br>”);\n    //输入想要修改的元素内容\n    mycon.innerHTML = \"New test!\";          //修改P元素内容\n    document.write(\"P标签修改后的内容：\" + mycon.innerHTML);\n  </script>\n</body>\n</html>\n```\n\n### 改变HTML样式\n\n- HTML DOM 允许 JavaScript 改变 HTML 元素的样式。\n\n- 语法：`Object.style.property=new style;`\n\n- 注意:Object是获取的元素对象，如通过`document.getElementById(\"id\")`获取的元素。\n\n- 基本属性表：\n\n| 属性 | 描述 |\n|---|---|\n|backgroundColor|设置元素背景颜色 |\n|height|设置元素高度|\n|width|设置元素宽度|\n|color|设置文本颜色|\n|font|在一行设置所有的字体属性|\n|fontFamily|设置元素的字体系列|\n|fontSize|设置元素的字体大小|\n|...|...|\n\n- CSS的其他的一些样式也可以通过该方法修改\n\n- 例子：改变`<p>`元素的样式，将颜色改为红色，字号改为20,背景颜色改为蓝：\n\n```\n<p id=\"pcon\">Hello World!</p>\n<script>\n   var mychar = document.getElementById(\"pcon\");\n   mychar.style.color=\"red\";\n   mychar.style.fontSize=\"20\";\n   mychar.style.backgroundColor =\"blue\";\n</script>\n```\n\n### 显示和隐藏\n\n- 网页中经常会看到显示和隐藏的效果，可通过display属性来设置。\n\n- 语法：`Object.style.display = value`\n\n> 注意这里的Object也是元素对象，可通过document.getElementById(\"id\")来获取\n\n- value取值：\n\n1. none：此元素讲不会被显示(即隐藏)\n2. block：此元素将显示为块级元素\n\n例子：\n![](/images/JavaScript/006.png)\n\n### 控制类名\n\n- className 属性设置或返回元素的class 属性。\n\n- 语法：`object.className = classname`\n\n- 作用：\n1. 获取元素的class属性\n2. 为网页内某个元素指定一个CSS样式来更改该元素的外观\n\n- 例子：\n\n```\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\">\n<title>className属性</title>\n<style type=\"text/css\">\n  input{\n    font-size:10px;\n  }\n  .one{\n    width:200px;\n    background-color:#CCC; //灰色\n  }\n  .two{\n    font-size:18px;\n    color:#F00\n  }\n</style>\n</head>\n<body>\n  <p id=\"con\" class=\"one\">JavaScript</p>\n  <form>\n    <input type=\"button\" value=\"点击更改\" onclick=\"modifyclass()\"/>\n  </form>\n  <script type=\"text/javascript\">\n    var mychar=document.getElementById(\"con\");\n    document.write(\"p元素的Class值为：\" + mychar.className + \"<br>\"); //输出P元素的class属性\n    function modifyclass(){\n      mychar.className=\"two\"; //改变className,即更换用来修饰的class\n    }\n    </script>\n</body>\n</html>\n```\n- 结果：\n\n![](/images/JavaScript/007.png)\n\n## 进阶\n---\n\n- 循环、分支、判断等语法与C++一致\n\n### 事件响应\n\n- JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。\n\n|事件|说明|\n|---|---|\n|onclick|鼠标单击事件|\n|onmouseover|鼠标经过事件|\n|onmouseout|鼠标移开事件|\n|onchange|文本框内容改变事件|\n|onselect|文本框内容被选中事件|\n|onfocus|光标聚集|\n|onblur|光标移开|\n|onload|网页导入|\n|onunload|关闭网页|\n\n#### 鼠标单击事件\n\n- onclick是鼠标单击事件，当在网页上单击鼠标时，就会发生该事件。同时onclick事件调用的程序块就会被执行，通常与按钮一起使用。\n\n- 例如：单击按钮时出发onclick事件，调用add2()函数\n\n```\n<form>\n     <input name=\"button\" type=\"button\" value=\"点击提交\" onclick=\"add2()\" />  //注意最后的斜杠\n  </form>\n```\n\n#### 鼠标经过事件\n\n- 与鼠标单击事件调用方法一致\n\n#### 其他的事件\n\n- 除了onload与onunload的使用有一点区别，别的都一致。\n\n### 对象\n\n- JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。\n\n- 创建对象使用`new`关键字\n\n#### 日期对象\n\n- 日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000 秒）\n\n- 定义一个时间对象：`var Udate = new Date();`\n> 这是默认定义，初始值为当前电脑时间\n\n- 如果要自定义值，使用以下方法：`var DATE = new Date(2018,10,4); //2018年10月4日`\n\n#### 浏览器对象\n\n#### window对象\n\n- window对象是BOM的核心，window对象指当前的浏览器窗口。\n\n- window对象方法：\n\n|方法|描述|\n|---|---|\n|alert()|显示带有一段消息和一个确认按钮的警告框|\n|prompt()|显示可提示用户输入的对话框|\n|confirm()|显示带有一段消息以及确认按钮和取消按钮的对话框|\n|open()|打开一个新的浏览器窗口或者查找一个已经命名的窗口|\n|close()|关闭浏览器窗口|\n|print()|打印当前窗口的内容|\n|focus()|把键盘焦点给予一个窗口|\n|blur()|把键盘焦点从顶层窗口移开|\n|moveBy()|可相对窗口的当前坐标把它移动指定的像素|\n|moveTo()|把窗口的左上角移动到一个指定的坐标|\n|resizeBy()|按照|\n|resizeTo()|把窗口的大小调整到指定的宽度和高度|\n|scrollBy()|按照指定的像素值来滚动内容|\n|scrollTo()|把内容滚动到指定的坐标|\n|setInterval()|每隔指定的时间执行代码|\n|setTimeout()|在指定的延迟时间后来执行代码|\n|clearInterval()|取消setInterval()的设置|\n|clearTimeout()|取消setTimeout()的设置|\n\n- 调用这些方法格式：`window.方法名(参数名);`\n\n例子：\n\n```\nfunction myFunction()\n{\n    alert(\"欢迎\")\n    window.open('http://www.imooc.com','_blank','width=600 height=400')\n    //第一个参数表示要打开的网页，'_blank'参数表示打开一个新网页，后面的参数设置新窗口的初始大小\n}\n```\n\n#### JavaScript计时器\n\n- 在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。\n\n- 计时器类型：\n\n  1. 一次性计时器：仅在指定的延迟时间之后触发一次。(setTimeout())\n\n  2. 间隔性触发计时器：每隔一定的时间间隔就触发一次。(setInterval())\n\n- setInterval()方法格式：`setInterval(代码，交互时间)`\n>参数中，代码就是要执行的函数挥着代码串，交互时间就是执行的时间间隔，以毫秒为单位\n\n- setInterval的返回值可以传递给clearInterval从而取消对代码的周期性执行。\n\n- 假设有一个clock()函数，则调用格式为：\n\n```\nsetInterval(\"clock()\",1000)\n或者\nsetInterval(clock,1000)\n```\n\n## DOM对象\n---\n\n### getElementsByName方法\n\n- 返回带有指定名称的节点对象的集合\n\n- 语法：`document.getElementsByName(name)`\n>其中name参数是标签上设置的name属性，和设置id属性格式一样，但是不同的标签可以设置同一个name属性，而id属性必须唯一\n\n- 与getElementById()不同的是，通过元素的name属性查询元素而不是通过id属性\n\n- 注意：因为文档中的name属性可能不唯一，所有的getElementByName()方法的返回值是元素的数组，而不是一个元素\n\n- 和数组类似的也有length属性，可以和访问数组一样的方法来访问，从0开始\n\n\n## 一些报错以及解决\n---\n\n### jQuery报错：Uncaught ReferenceError: $ is not defined\n\n- 出现这个报错的原因：\n\n1. jQuery库文件的路径不对，检查文件路径是否正确一般就能解决该错误。\n\n2. 如果库文件的路径是正确的，那么可能在html中加载jQuery库文件顺序有误，如果将jQuery库文件加载放到最开始位置，即可以解决该错误\n\n3. 检查传值错误，或者某些值不存在。\n\n\n\n<br>\n> 最后更新于2018.7.18\n","source":"_posts/2018-07-07-JavaScript.md","raw":"---\nlayout:     post\ntitle:      \"前端学习——JavaScript\"\ndate:       2018-07-07 11:26:00\ncategories: FrontEnd\ntags:   [๑FrontEnd, ๑JavaScrpt]\n---\n\n> 不适合人类阅读的学习笔记\n\n\n## 基础\n---\n\n>建议把javascript脚本放在 `<body> `部分的底部。\n>这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。\n\n- [Js是放在head还是body解析](https://blog.csdn.net/w405722907/article/details/78517757)\n\n### 嵌入html的javascript写法\n\n- JavaScript代码写在`<script>`和`</script>`标签之前。\n![](/images/JavaScript/001.png)\n- 其中`<script type =\"text/javascript\">`表示在`<script></script>`之间的是文本类型`(text)`,javascript是为了告诉浏览器里面的文本是属于JavaScript语言。\n\n### 单独写成文件\n\n- JavaScript代码只能写在HTML文件中吗?当然不是，我们可以把HTML文件和JS代码分开,并单独创建一个JavaScript文件(简称JS文件),其文件后缀通常为.js，然后将JS代码直接写在JS文件中。\n\n- **注意:在JS文件中，不需要`<script>`标签,直接编写JavaScript代码就可以了。**\n\n- 单独写成文件的javascript文件不能单独运行，比如一个叫“script.js”的文件，我们需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中：`<script src=\"script.js\"></script>`\n\n#### 位置\n\n- 我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。\n\n##### 放在`<head>`部分\n\n- 最常用的方式是在页面中head部分放置`<script>`元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。\n\n##### 放在`<body>`部分\n\n- JavaScript代码在网页读取到该语句的时候就会执行。\n\n- **注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。**\n\n## 语法\n---\n\n- 一个JavaScript语句以`;`结尾（虽然也可以不写）\n\n- 注释：单行注释：`//`，多行注释`/*...*/`\n\n### 变量\n\n- 定义变量使用关键字`var 变量名`\n\n- 注意JS中变量无需声明类型\n\n### 判断语句\n\n- 语法：\n```\nif(条件)\n{ 条件成立时执行的代码 }\nelse\n{ 条件不成立时执行的代码 }\n```\n\n- 例子：\n\n```\n<script type=\"text/javascript\">\n   var myage = 18;\n   if(myage>=18)  //myage>=18是判断条件\n   { document.write(\"你是成年人。\");}\n   else  //否则年龄小于18\n   { document.write(\"未满18岁，你不是成年人。\");}\n</script>\n```\n\n### 判断函数\n\n- 语法：\n```\nfunction 函数名()\n{\n     函数代码;\n}\n```\n\n- 例子：\n![](/images/JavaScript/002.png)\n\n#### 输出内容(document.write)\n\n- 输出内容可以是双引号括起来的，也可以是变量，多个输出项之间以`+`连接\n\n- 例子：\n\n```\n<script type=\"text/javascript\">\n  var mystr=\"hello\";\n  document.write(mystr+\"I love JavaScript\"); //多项内容之间用+号连接\n</script>\n```\n\n##### javascript警告(消息对话框)\n\n- 语法：`alert(字符串或变量)`\n\n> 注意：alert弹出一个消息对话框，只有一个确定按钮，多个对话框之间按顺序弹出。\n\n##### 确认(confirm对话框)\n\n- 语法：`confirm(str);`\n\n- 参数说明：\n1. str：在消息对话框中要显示的文本\n2. 返回值: Boolean值\n\n- 返回值：\n当用户点击\"确定\"按钮时，返回true ；当用户点击\"取消\"按钮时，返回false\n\n##### 打开新窗口(window.open)\n\n- 语法：`window.open([URL], [窗口名称], [参数字符串])`\n\n- 参数说明：\n```\nURL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。\n窗口名称：可选参数，被打开窗口的名称。\n    1.该名称由字母、数字和下划线字符组成。\n    2.\"_top\"、\"_blank\"、\"_self\"具有特殊意义的名称。\n       _blank：在新窗口显示目标网页\n       _self：在当前窗口显示目标网页\n       _top：框架网页中在上部窗口中显示目标网页\n    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。\n   4.name 不能包含有空格。\n参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。\n```\n![](/images/JavaScript/003.png)\n\n> 注意：所有的参数都要写在一个参数字符串中，中间以逗号间隔，例如 'height=100.width=100' 这样。\n\n- 可以将窗口对象存储在变量test中：`var test = window.open(...);`\n\n- 关闭窗口：\n\n1. `window.close();`:关闭本窗口\n\n2. `<窗口对象>.close();`:关闭指定窗口\n\n## 控制权(DOM操作)\n---\n\n- 文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。\n\n- 将HTML代码分解为DOM节点层次图:\n![](/images/JavaScript/004.png)\n\n### HTML文档可以说由节点构成的集合，三种常见的DOM节点:\n\n- 元素节点：上图中`<html>`、`<body>`、`<p>`等都是元素节点，即标签。\n\n- 文本节点:向用户展示的内容，如`<li>...</li>`中的JavaScript、DOM、CSS等文本。\n\n- 属性节点:元素属性，如`<a>`标签的链接属性`href=\"http://www.imooc.com\"`。\n\n- 例子：`<a href=\"http://www.imooc.com\">JavaScript DOM</a>`\n![](/images/JavaScript/005.png)\n\n### 通过ID获取元素\n\n- 网页由标签将信息组织起来，而标签的id属性值是唯一的，就像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通过id先找到标签，然后进行操作。\n\n- 语法：`document.getElementById(“id”) `\n\n- 例子：\n\n```\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta http-wquiv=\"Content-Type\" content=\"text/html; charest=gb2312\" />\n<title>获取元素</title>\n  <script type=\"text/javascript\">\n    var mye = document.getElementById(\"con\");    //获取元素变量存储在变量mye中\n    document.write(mye);                    //输出变量\n  </script>\n</head>\n<body>\n    <h3>Hello</h3>\n    <p id=\"con\">I love JavaScript</p>\n</body>\n</html>\n```\n### innerHTML属性\n\n- innerHTML 属性用于获取或替换 HTML 元素的内容。\n\n- 语法：`Object.innerHTML`\n\n- 例子：\n\n```\n<!DOCTYPE HTML>\n<html>\n<head>\n<title>innerHTML</title>\n</head>\n<body>\n  <p id=\"con\">Hello World!</p>\n  <script>\n    var mycon = document.getElementById(\"con\");\n    document.write(\"P标签原始内容：\" + mycon.innerHTML + “<br>”);\n    //输入想要修改的元素内容\n    mycon.innerHTML = \"New test!\";          //修改P元素内容\n    document.write(\"P标签修改后的内容：\" + mycon.innerHTML);\n  </script>\n</body>\n</html>\n```\n\n### 改变HTML样式\n\n- HTML DOM 允许 JavaScript 改变 HTML 元素的样式。\n\n- 语法：`Object.style.property=new style;`\n\n- 注意:Object是获取的元素对象，如通过`document.getElementById(\"id\")`获取的元素。\n\n- 基本属性表：\n\n| 属性 | 描述 |\n|---|---|\n|backgroundColor|设置元素背景颜色 |\n|height|设置元素高度|\n|width|设置元素宽度|\n|color|设置文本颜色|\n|font|在一行设置所有的字体属性|\n|fontFamily|设置元素的字体系列|\n|fontSize|设置元素的字体大小|\n|...|...|\n\n- CSS的其他的一些样式也可以通过该方法修改\n\n- 例子：改变`<p>`元素的样式，将颜色改为红色，字号改为20,背景颜色改为蓝：\n\n```\n<p id=\"pcon\">Hello World!</p>\n<script>\n   var mychar = document.getElementById(\"pcon\");\n   mychar.style.color=\"red\";\n   mychar.style.fontSize=\"20\";\n   mychar.style.backgroundColor =\"blue\";\n</script>\n```\n\n### 显示和隐藏\n\n- 网页中经常会看到显示和隐藏的效果，可通过display属性来设置。\n\n- 语法：`Object.style.display = value`\n\n> 注意这里的Object也是元素对象，可通过document.getElementById(\"id\")来获取\n\n- value取值：\n\n1. none：此元素讲不会被显示(即隐藏)\n2. block：此元素将显示为块级元素\n\n例子：\n![](/images/JavaScript/006.png)\n\n### 控制类名\n\n- className 属性设置或返回元素的class 属性。\n\n- 语法：`object.className = classname`\n\n- 作用：\n1. 获取元素的class属性\n2. 为网页内某个元素指定一个CSS样式来更改该元素的外观\n\n- 例子：\n\n```\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\">\n<title>className属性</title>\n<style type=\"text/css\">\n  input{\n    font-size:10px;\n  }\n  .one{\n    width:200px;\n    background-color:#CCC; //灰色\n  }\n  .two{\n    font-size:18px;\n    color:#F00\n  }\n</style>\n</head>\n<body>\n  <p id=\"con\" class=\"one\">JavaScript</p>\n  <form>\n    <input type=\"button\" value=\"点击更改\" onclick=\"modifyclass()\"/>\n  </form>\n  <script type=\"text/javascript\">\n    var mychar=document.getElementById(\"con\");\n    document.write(\"p元素的Class值为：\" + mychar.className + \"<br>\"); //输出P元素的class属性\n    function modifyclass(){\n      mychar.className=\"two\"; //改变className,即更换用来修饰的class\n    }\n    </script>\n</body>\n</html>\n```\n- 结果：\n\n![](/images/JavaScript/007.png)\n\n## 进阶\n---\n\n- 循环、分支、判断等语法与C++一致\n\n### 事件响应\n\n- JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。\n\n|事件|说明|\n|---|---|\n|onclick|鼠标单击事件|\n|onmouseover|鼠标经过事件|\n|onmouseout|鼠标移开事件|\n|onchange|文本框内容改变事件|\n|onselect|文本框内容被选中事件|\n|onfocus|光标聚集|\n|onblur|光标移开|\n|onload|网页导入|\n|onunload|关闭网页|\n\n#### 鼠标单击事件\n\n- onclick是鼠标单击事件，当在网页上单击鼠标时，就会发生该事件。同时onclick事件调用的程序块就会被执行，通常与按钮一起使用。\n\n- 例如：单击按钮时出发onclick事件，调用add2()函数\n\n```\n<form>\n     <input name=\"button\" type=\"button\" value=\"点击提交\" onclick=\"add2()\" />  //注意最后的斜杠\n  </form>\n```\n\n#### 鼠标经过事件\n\n- 与鼠标单击事件调用方法一致\n\n#### 其他的事件\n\n- 除了onload与onunload的使用有一点区别，别的都一致。\n\n### 对象\n\n- JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。\n\n- 创建对象使用`new`关键字\n\n#### 日期对象\n\n- 日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000 秒）\n\n- 定义一个时间对象：`var Udate = new Date();`\n> 这是默认定义，初始值为当前电脑时间\n\n- 如果要自定义值，使用以下方法：`var DATE = new Date(2018,10,4); //2018年10月4日`\n\n#### 浏览器对象\n\n#### window对象\n\n- window对象是BOM的核心，window对象指当前的浏览器窗口。\n\n- window对象方法：\n\n|方法|描述|\n|---|---|\n|alert()|显示带有一段消息和一个确认按钮的警告框|\n|prompt()|显示可提示用户输入的对话框|\n|confirm()|显示带有一段消息以及确认按钮和取消按钮的对话框|\n|open()|打开一个新的浏览器窗口或者查找一个已经命名的窗口|\n|close()|关闭浏览器窗口|\n|print()|打印当前窗口的内容|\n|focus()|把键盘焦点给予一个窗口|\n|blur()|把键盘焦点从顶层窗口移开|\n|moveBy()|可相对窗口的当前坐标把它移动指定的像素|\n|moveTo()|把窗口的左上角移动到一个指定的坐标|\n|resizeBy()|按照|\n|resizeTo()|把窗口的大小调整到指定的宽度和高度|\n|scrollBy()|按照指定的像素值来滚动内容|\n|scrollTo()|把内容滚动到指定的坐标|\n|setInterval()|每隔指定的时间执行代码|\n|setTimeout()|在指定的延迟时间后来执行代码|\n|clearInterval()|取消setInterval()的设置|\n|clearTimeout()|取消setTimeout()的设置|\n\n- 调用这些方法格式：`window.方法名(参数名);`\n\n例子：\n\n```\nfunction myFunction()\n{\n    alert(\"欢迎\")\n    window.open('http://www.imooc.com','_blank','width=600 height=400')\n    //第一个参数表示要打开的网页，'_blank'参数表示打开一个新网页，后面的参数设置新窗口的初始大小\n}\n```\n\n#### JavaScript计时器\n\n- 在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。\n\n- 计时器类型：\n\n  1. 一次性计时器：仅在指定的延迟时间之后触发一次。(setTimeout())\n\n  2. 间隔性触发计时器：每隔一定的时间间隔就触发一次。(setInterval())\n\n- setInterval()方法格式：`setInterval(代码，交互时间)`\n>参数中，代码就是要执行的函数挥着代码串，交互时间就是执行的时间间隔，以毫秒为单位\n\n- setInterval的返回值可以传递给clearInterval从而取消对代码的周期性执行。\n\n- 假设有一个clock()函数，则调用格式为：\n\n```\nsetInterval(\"clock()\",1000)\n或者\nsetInterval(clock,1000)\n```\n\n## DOM对象\n---\n\n### getElementsByName方法\n\n- 返回带有指定名称的节点对象的集合\n\n- 语法：`document.getElementsByName(name)`\n>其中name参数是标签上设置的name属性，和设置id属性格式一样，但是不同的标签可以设置同一个name属性，而id属性必须唯一\n\n- 与getElementById()不同的是，通过元素的name属性查询元素而不是通过id属性\n\n- 注意：因为文档中的name属性可能不唯一，所有的getElementByName()方法的返回值是元素的数组，而不是一个元素\n\n- 和数组类似的也有length属性，可以和访问数组一样的方法来访问，从0开始\n\n\n## 一些报错以及解决\n---\n\n### jQuery报错：Uncaught ReferenceError: $ is not defined\n\n- 出现这个报错的原因：\n\n1. jQuery库文件的路径不对，检查文件路径是否正确一般就能解决该错误。\n\n2. 如果库文件的路径是正确的，那么可能在html中加载jQuery库文件顺序有误，如果将jQuery库文件加载放到最开始位置，即可以解决该错误\n\n3. 检查传值错误，或者某些值不存在。\n\n\n\n<br>\n> 最后更新于2018.7.18\n","slug":"2018-07-07-JavaScript","published":1,"updated":"2018-09-03T13:13:08.670Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j55002m1m0o7dvqsb33","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><hr>\n<blockquote>\n<p>建议把javascript脚本放在 <code>&lt;body&gt;</code>部分的底部。<br>这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/w405722907/article/details/78517757\" target=\"_blank\" rel=\"noopener\">Js是放在head还是body解析</a></li>\n</ul>\n<h3 id=\"嵌入html的javascript写法\"><a href=\"#嵌入html的javascript写法\" class=\"headerlink\" title=\"嵌入html的javascript写法\"></a>嵌入html的javascript写法</h3><ul>\n<li>JavaScript代码写在<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签之前。<br><img src=\"/images/JavaScript/001.png\" alt=\"\"></li>\n<li>其中<code>&lt;script type =&quot;text/javascript&quot;&gt;</code>表示在<code>&lt;script&gt;&lt;/script&gt;</code>之间的是文本类型<code>(text)</code>,javascript是为了告诉浏览器里面的文本是属于JavaScript语言。</li>\n</ul>\n<h3 id=\"单独写成文件\"><a href=\"#单独写成文件\" class=\"headerlink\" title=\"单独写成文件\"></a>单独写成文件</h3><ul>\n<li><p>JavaScript代码只能写在HTML文件中吗?当然不是，我们可以把HTML文件和JS代码分开,并单独创建一个JavaScript文件(简称JS文件),其文件后缀通常为.js，然后将JS代码直接写在JS文件中。</p>\n</li>\n<li><p><strong>注意:在JS文件中，不需要<code>&lt;script&gt;</code>标签,直接编写JavaScript代码就可以了。</strong></p>\n</li>\n<li><p>单独写成文件的javascript文件不能单独运行，比如一个叫“script.js”的文件，我们需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中：<code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></p>\n</li>\n</ul>\n<h4 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h4><ul>\n<li>我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。</li>\n</ul>\n<h5 id=\"放在-lt-head-gt-部分\"><a href=\"#放在-lt-head-gt-部分\" class=\"headerlink\" title=\"放在&lt;head&gt;部分\"></a>放在<code>&lt;head&gt;</code>部分</h5><ul>\n<li>最常用的方式是在页面中head部分放置<code>&lt;script&gt;</code>元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。</li>\n</ul>\n<h5 id=\"放在-lt-body-gt-部分\"><a href=\"#放在-lt-body-gt-部分\" class=\"headerlink\" title=\"放在&lt;body&gt;部分\"></a>放在<code>&lt;body&gt;</code>部分</h5><ul>\n<li><p>JavaScript代码在网页读取到该语句的时候就会执行。</p>\n</li>\n<li><p><strong>注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。</strong></p>\n</li>\n</ul>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><hr>\n<ul>\n<li><p>一个JavaScript语句以<code>;</code>结尾（虽然也可以不写）</p>\n</li>\n<li><p>注释：单行注释：<code>//</code>，多行注释<code>/*...*/</code></p>\n</li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ul>\n<li><p>定义变量使用关键字<code>var 变量名</code></p>\n</li>\n<li><p>注意JS中变量无需声明类型</p>\n</li>\n</ul>\n<h3 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h3><ul>\n<li><p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(条件)</span><br><span class=\"line\">&#123; 条件成立时执行的代码 &#125;</span><br><span class=\"line\">else</span><br><span class=\"line\">&#123; 条件不成立时执行的代码 &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">   var myage = 18;</span><br><span class=\"line\">   if(myage&gt;=18)  //myage&gt;=18是判断条件</span><br><span class=\"line\">   &#123; document.write(&quot;你是成年人。&quot;);&#125;</span><br><span class=\"line\">   else  //否则年龄小于18</span><br><span class=\"line\">   &#123; document.write(&quot;未满18岁，你不是成年人。&quot;);&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"判断函数\"><a href=\"#判断函数\" class=\"headerlink\" title=\"判断函数\"></a>判断函数</h3><ul>\n<li><p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function 函数名()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     函数代码;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例子：<br><img src=\"/images/JavaScript/002.png\" alt=\"\"></p>\n</li>\n</ul>\n<h4 id=\"输出内容-document-write\"><a href=\"#输出内容-document-write\" class=\"headerlink\" title=\"输出内容(document.write)\"></a>输出内容(document.write)</h4><ul>\n<li><p>输出内容可以是双引号括起来的，也可以是变量，多个输出项之间以<code>+</code>连接</p>\n</li>\n<li><p>例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">  var mystr=&quot;hello&quot;;</span><br><span class=\"line\">  document.write(mystr+&quot;I love JavaScript&quot;); //多项内容之间用+号连接</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"javascript警告-消息对话框\"><a href=\"#javascript警告-消息对话框\" class=\"headerlink\" title=\"javascript警告(消息对话框)\"></a>javascript警告(消息对话框)</h5><ul>\n<li>语法：<code>alert(字符串或变量)</code></li>\n</ul>\n<blockquote>\n<p>注意：alert弹出一个消息对话框，只有一个确定按钮，多个对话框之间按顺序弹出。</p>\n</blockquote>\n<h5 id=\"确认-confirm对话框\"><a href=\"#确认-confirm对话框\" class=\"headerlink\" title=\"确认(confirm对话框)\"></a>确认(confirm对话框)</h5><ul>\n<li><p>语法：<code>confirm(str);</code></p>\n</li>\n<li><p>参数说明：</p>\n</li>\n</ul>\n<ol>\n<li>str：在消息对话框中要显示的文本</li>\n<li>返回值: Boolean值</li>\n</ol>\n<ul>\n<li>返回值：<br>当用户点击”确定”按钮时，返回true ；当用户点击”取消”按钮时，返回false</li>\n</ul>\n<h5 id=\"打开新窗口-window-open\"><a href=\"#打开新窗口-window-open\" class=\"headerlink\" title=\"打开新窗口(window.open)\"></a>打开新窗口(window.open)</h5><ul>\n<li><p>语法：<code>window.open([URL], [窗口名称], [参数字符串])</code></p>\n</li>\n<li><p>参数说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。</span><br><span class=\"line\">窗口名称：可选参数，被打开窗口的名称。</span><br><span class=\"line\">    1.该名称由字母、数字和下划线字符组成。</span><br><span class=\"line\">    2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。</span><br><span class=\"line\">       _blank：在新窗口显示目标网页</span><br><span class=\"line\">       _self：在当前窗口显示目标网页</span><br><span class=\"line\">       _top：框架网页中在上部窗口中显示目标网页</span><br><span class=\"line\">    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。</span><br><span class=\"line\">   4.name 不能包含有空格。</span><br><span class=\"line\">参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"/images/JavaScript/003.png\" alt=\"\"></p>\n<blockquote>\n<p>注意：所有的参数都要写在一个参数字符串中，中间以逗号间隔，例如 ‘height=100.width=100’ 这样。</p>\n</blockquote>\n<ul>\n<li><p>可以将窗口对象存储在变量test中：<code>var test = window.open(...);</code></p>\n</li>\n<li><p>关闭窗口：</p>\n</li>\n</ul>\n<ol>\n<li><p><code>window.close();</code>:关闭本窗口</p>\n</li>\n<li><p><code>&lt;窗口对象&gt;.close();</code>:关闭指定窗口</p>\n</li>\n</ol>\n<h2 id=\"控制权-DOM操作\"><a href=\"#控制权-DOM操作\" class=\"headerlink\" title=\"控制权(DOM操作)\"></a>控制权(DOM操作)</h2><hr>\n<ul>\n<li><p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p>\n</li>\n<li><p>将HTML代码分解为DOM节点层次图:<br><img src=\"/images/JavaScript/004.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"HTML文档可以说由节点构成的集合，三种常见的DOM节点\"><a href=\"#HTML文档可以说由节点构成的集合，三种常见的DOM节点\" class=\"headerlink\" title=\"HTML文档可以说由节点构成的集合，三种常见的DOM节点:\"></a>HTML文档可以说由节点构成的集合，三种常见的DOM节点:</h3><ul>\n<li><p>元素节点：上图中<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>、<code>&lt;p&gt;</code>等都是元素节点，即标签。</p>\n</li>\n<li><p>文本节点:向用户展示的内容，如<code>&lt;li&gt;...&lt;/li&gt;</code>中的JavaScript、DOM、CSS等文本。</p>\n</li>\n<li><p>属性节点:元素属性，如<code>&lt;a&gt;</code>标签的链接属性<code>href=&quot;http://www.imooc.com&quot;</code>。</p>\n</li>\n<li><p>例子：<code>&lt;a href=&quot;http://www.imooc.com&quot;&gt;JavaScript DOM&lt;/a&gt;</code><br><img src=\"/images/JavaScript/005.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"通过ID获取元素\"><a href=\"#通过ID获取元素\" class=\"headerlink\" title=\"通过ID获取元素\"></a>通过ID获取元素</h3><ul>\n<li><p>网页由标签将信息组织起来，而标签的id属性值是唯一的，就像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通过id先找到标签，然后进行操作。</p>\n</li>\n<li><p>语法：<code>document.getElementById(“id”)</code></p>\n</li>\n<li><p>例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta http-wquiv=&quot;Content-Type&quot; content=&quot;text/html; charest=gb2312&quot; /&gt;</span><br><span class=\"line\">&lt;title&gt;获取元素&lt;/title&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    var mye = document.getElementById(&quot;con&quot;);    //获取元素变量存储在变量mye中</span><br><span class=\"line\">    document.write(mye);                    //输出变量</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;h3&gt;Hello&lt;/h3&gt;</span><br><span class=\"line\">    &lt;p id=&quot;con&quot;&gt;I love JavaScript&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"innerHTML属性\"><a href=\"#innerHTML属性\" class=\"headerlink\" title=\"innerHTML属性\"></a>innerHTML属性</h3><ul>\n<li><p>innerHTML 属性用于获取或替换 HTML 元素的内容。</p>\n</li>\n<li><p>语法：<code>Object.innerHTML</code></p>\n</li>\n<li><p>例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;innerHTML&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;p id=&quot;con&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    var mycon = document.getElementById(&quot;con&quot;);</span><br><span class=\"line\">    document.write(&quot;P标签原始内容：&quot; + mycon.innerHTML + “&lt;br&gt;”);</span><br><span class=\"line\">    //输入想要修改的元素内容</span><br><span class=\"line\">    mycon.innerHTML = &quot;New test!&quot;;          //修改P元素内容</span><br><span class=\"line\">    document.write(&quot;P标签修改后的内容：&quot; + mycon.innerHTML);</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"改变HTML样式\"><a href=\"#改变HTML样式\" class=\"headerlink\" title=\"改变HTML样式\"></a>改变HTML样式</h3><ul>\n<li><p>HTML DOM 允许 JavaScript 改变 HTML 元素的样式。</p>\n</li>\n<li><p>语法：<code>Object.style.property=new style;</code></p>\n</li>\n<li><p>注意:Object是获取的元素对象，如通过<code>document.getElementById(&quot;id&quot;)</code>获取的元素。</p>\n</li>\n<li><p>基本属性表：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>backgroundColor</td>\n<td>设置元素背景颜色</td>\n</tr>\n<tr>\n<td>height</td>\n<td>设置元素高度</td>\n</tr>\n<tr>\n<td>width</td>\n<td>设置元素宽度</td>\n</tr>\n<tr>\n<td>color</td>\n<td>设置文本颜色</td>\n</tr>\n<tr>\n<td>font</td>\n<td>在一行设置所有的字体属性</td>\n</tr>\n<tr>\n<td>fontFamily</td>\n<td>设置元素的字体系列</td>\n</tr>\n<tr>\n<td>fontSize</td>\n<td>设置元素的字体大小</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>CSS的其他的一些样式也可以通过该方法修改</p>\n</li>\n<li><p>例子：改变<code>&lt;p&gt;</code>元素的样式，将颜色改为红色，字号改为20,背景颜色改为蓝：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p id=&quot;pcon&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">   var mychar = document.getElementById(&quot;pcon&quot;);</span><br><span class=\"line\">   mychar.style.color=&quot;red&quot;;</span><br><span class=\"line\">   mychar.style.fontSize=&quot;20&quot;;</span><br><span class=\"line\">   mychar.style.backgroundColor =&quot;blue&quot;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"显示和隐藏\"><a href=\"#显示和隐藏\" class=\"headerlink\" title=\"显示和隐藏\"></a>显示和隐藏</h3><ul>\n<li><p>网页中经常会看到显示和隐藏的效果，可通过display属性来设置。</p>\n</li>\n<li><p>语法：<code>Object.style.display = value</code></p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里的Object也是元素对象，可通过document.getElementById(“id”)来获取</p>\n</blockquote>\n<ul>\n<li>value取值：</li>\n</ul>\n<ol>\n<li>none：此元素讲不会被显示(即隐藏)</li>\n<li>block：此元素将显示为块级元素</li>\n</ol>\n<p>例子：<br><img src=\"/images/JavaScript/006.png\" alt=\"\"></p>\n<h3 id=\"控制类名\"><a href=\"#控制类名\" class=\"headerlink\" title=\"控制类名\"></a>控制类名</h3><ul>\n<li><p>className 属性设置或返回元素的class 属性。</p>\n</li>\n<li><p>语法：<code>object.className = classname</code></p>\n</li>\n<li><p>作用：</p>\n</li>\n</ul>\n<ol>\n<li>获取元素的class属性</li>\n<li>为网页内某个元素指定一个CSS样式来更改该元素的外观</li>\n</ol>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=gb2312&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;className属性&lt;/title&gt;</span><br><span class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">  input&#123;</span><br><span class=\"line\">    font-size:10px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .one&#123;</span><br><span class=\"line\">    width:200px;</span><br><span class=\"line\">    background-color:#CCC; //灰色</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .two&#123;</span><br><span class=\"line\">    font-size:18px;</span><br><span class=\"line\">    color:#F00</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;p id=&quot;con&quot; class=&quot;one&quot;&gt;JavaScript&lt;/p&gt;</span><br><span class=\"line\">  &lt;form&gt;</span><br><span class=\"line\">    &lt;input type=&quot;button&quot; value=&quot;点击更改&quot; onclick=&quot;modifyclass()&quot;/&gt;</span><br><span class=\"line\">  &lt;/form&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    var mychar=document.getElementById(&quot;con&quot;);</span><br><span class=\"line\">    document.write(&quot;p元素的Class值为：&quot; + mychar.className + &quot;&lt;br&gt;&quot;); //输出P元素的class属性</span><br><span class=\"line\">    function modifyclass()&#123;</span><br><span class=\"line\">      mychar.className=&quot;two&quot;; //改变className,即更换用来修饰的class</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>结果：</li>\n</ul>\n<p><img src=\"/images/JavaScript/007.png\" alt=\"\"></p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><hr>\n<ul>\n<li>循环、分支、判断等语法与C++一致</li>\n</ul>\n<h3 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h3><ul>\n<li>JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onclick</td>\n<td>鼠标单击事件</td>\n</tr>\n<tr>\n<td>onmouseover</td>\n<td>鼠标经过事件</td>\n</tr>\n<tr>\n<td>onmouseout</td>\n<td>鼠标移开事件</td>\n</tr>\n<tr>\n<td>onchange</td>\n<td>文本框内容改变事件</td>\n</tr>\n<tr>\n<td>onselect</td>\n<td>文本框内容被选中事件</td>\n</tr>\n<tr>\n<td>onfocus</td>\n<td>光标聚集</td>\n</tr>\n<tr>\n<td>onblur</td>\n<td>光标移开</td>\n</tr>\n<tr>\n<td>onload</td>\n<td>网页导入</td>\n</tr>\n<tr>\n<td>onunload</td>\n<td>关闭网页</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"鼠标单击事件\"><a href=\"#鼠标单击事件\" class=\"headerlink\" title=\"鼠标单击事件\"></a>鼠标单击事件</h4><ul>\n<li><p>onclick是鼠标单击事件，当在网页上单击鼠标时，就会发生该事件。同时onclick事件调用的程序块就会被执行，通常与按钮一起使用。</p>\n</li>\n<li><p>例如：单击按钮时出发onclick事件，调用add2()函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form&gt;</span><br><span class=\"line\">     &lt;input name=&quot;button&quot; type=&quot;button&quot; value=&quot;点击提交&quot; onclick=&quot;add2()&quot; /&gt;  //注意最后的斜杠</span><br><span class=\"line\">  &lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"鼠标经过事件\"><a href=\"#鼠标经过事件\" class=\"headerlink\" title=\"鼠标经过事件\"></a>鼠标经过事件</h4><ul>\n<li>与鼠标单击事件调用方法一致</li>\n</ul>\n<h4 id=\"其他的事件\"><a href=\"#其他的事件\" class=\"headerlink\" title=\"其他的事件\"></a>其他的事件</h4><ul>\n<li>除了onload与onunload的使用有一点区别，别的都一致。</li>\n</ul>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><ul>\n<li><p>JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。</p>\n</li>\n<li><p>创建对象使用<code>new</code>关键字</p>\n</li>\n</ul>\n<h4 id=\"日期对象\"><a href=\"#日期对象\" class=\"headerlink\" title=\"日期对象\"></a>日期对象</h4><ul>\n<li><p>日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000 秒）</p>\n</li>\n<li><p>定义一个时间对象：<code>var Udate = new Date();</code></p>\n<blockquote>\n<p>这是默认定义，初始值为当前电脑时间</p>\n</blockquote>\n</li>\n<li><p>如果要自定义值，使用以下方法：<code>var DATE = new Date(2018,10,4); //2018年10月4日</code></p>\n</li>\n</ul>\n<h4 id=\"浏览器对象\"><a href=\"#浏览器对象\" class=\"headerlink\" title=\"浏览器对象\"></a>浏览器对象</h4><h4 id=\"window对象\"><a href=\"#window对象\" class=\"headerlink\" title=\"window对象\"></a>window对象</h4><ul>\n<li><p>window对象是BOM的核心，window对象指当前的浏览器窗口。</p>\n</li>\n<li><p>window对象方法：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alert()</td>\n<td>显示带有一段消息和一个确认按钮的警告框</td>\n</tr>\n<tr>\n<td>prompt()</td>\n<td>显示可提示用户输入的对话框</td>\n</tr>\n<tr>\n<td>confirm()</td>\n<td>显示带有一段消息以及确认按钮和取消按钮的对话框</td>\n</tr>\n<tr>\n<td>open()</td>\n<td>打开一个新的浏览器窗口或者查找一个已经命名的窗口</td>\n</tr>\n<tr>\n<td>close()</td>\n<td>关闭浏览器窗口</td>\n</tr>\n<tr>\n<td>print()</td>\n<td>打印当前窗口的内容</td>\n</tr>\n<tr>\n<td>focus()</td>\n<td>把键盘焦点给予一个窗口</td>\n</tr>\n<tr>\n<td>blur()</td>\n<td>把键盘焦点从顶层窗口移开</td>\n</tr>\n<tr>\n<td>moveBy()</td>\n<td>可相对窗口的当前坐标把它移动指定的像素</td>\n</tr>\n<tr>\n<td>moveTo()</td>\n<td>把窗口的左上角移动到一个指定的坐标</td>\n</tr>\n<tr>\n<td>resizeBy()</td>\n<td>按照</td>\n</tr>\n<tr>\n<td>resizeTo()</td>\n<td>把窗口的大小调整到指定的宽度和高度</td>\n</tr>\n<tr>\n<td>scrollBy()</td>\n<td>按照指定的像素值来滚动内容</td>\n</tr>\n<tr>\n<td>scrollTo()</td>\n<td>把内容滚动到指定的坐标</td>\n</tr>\n<tr>\n<td>setInterval()</td>\n<td>每隔指定的时间执行代码</td>\n</tr>\n<tr>\n<td>setTimeout()</td>\n<td>在指定的延迟时间后来执行代码</td>\n</tr>\n<tr>\n<td>clearInterval()</td>\n<td>取消setInterval()的设置</td>\n</tr>\n<tr>\n<td>clearTimeout()</td>\n<td>取消setTimeout()的设置</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>调用这些方法格式：<code>window.方法名(参数名);</code></li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function myFunction()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    alert(&quot;欢迎&quot;)</span><br><span class=\"line\">    window.open(&apos;http://www.imooc.com&apos;,&apos;_blank&apos;,&apos;width=600 height=400&apos;)</span><br><span class=\"line\">    //第一个参数表示要打开的网页，&apos;_blank&apos;参数表示打开一个新网页，后面的参数设置新窗口的初始大小</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"JavaScript计时器\"><a href=\"#JavaScript计时器\" class=\"headerlink\" title=\"JavaScript计时器\"></a>JavaScript计时器</h4><ul>\n<li><p>在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。</p>\n</li>\n<li><p>计时器类型：</p>\n<ol>\n<li><p>一次性计时器：仅在指定的延迟时间之后触发一次。(setTimeout())</p>\n</li>\n<li><p>间隔性触发计时器：每隔一定的时间间隔就触发一次。(setInterval())</p>\n</li>\n</ol>\n</li>\n<li><p>setInterval()方法格式：<code>setInterval(代码，交互时间)</code></p>\n<blockquote>\n<p>参数中，代码就是要执行的函数挥着代码串，交互时间就是执行的时间间隔，以毫秒为单位</p>\n</blockquote>\n</li>\n<li><p>setInterval的返回值可以传递给clearInterval从而取消对代码的周期性执行。</p>\n</li>\n<li><p>假设有一个clock()函数，则调用格式为：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(&quot;clock()&quot;,1000)</span><br><span class=\"line\">或者</span><br><span class=\"line\">setInterval(clock,1000)</span><br></pre></td></tr></table></figure>\n<h2 id=\"DOM对象\"><a href=\"#DOM对象\" class=\"headerlink\" title=\"DOM对象\"></a>DOM对象</h2><hr>\n<h3 id=\"getElementsByName方法\"><a href=\"#getElementsByName方法\" class=\"headerlink\" title=\"getElementsByName方法\"></a>getElementsByName方法</h3><ul>\n<li><p>返回带有指定名称的节点对象的集合</p>\n</li>\n<li><p>语法：<code>document.getElementsByName(name)</code></p>\n<blockquote>\n<p>其中name参数是标签上设置的name属性，和设置id属性格式一样，但是不同的标签可以设置同一个name属性，而id属性必须唯一</p>\n</blockquote>\n</li>\n<li><p>与getElementById()不同的是，通过元素的name属性查询元素而不是通过id属性</p>\n</li>\n<li><p>注意：因为文档中的name属性可能不唯一，所有的getElementByName()方法的返回值是元素的数组，而不是一个元素</p>\n</li>\n<li><p>和数组类似的也有length属性，可以和访问数组一样的方法来访问，从0开始</p>\n</li>\n</ul>\n<h2 id=\"一些报错以及解决\"><a href=\"#一些报错以及解决\" class=\"headerlink\" title=\"一些报错以及解决\"></a>一些报错以及解决</h2><hr>\n<h3 id=\"jQuery报错：Uncaught-ReferenceError-is-not-defined\"><a href=\"#jQuery报错：Uncaught-ReferenceError-is-not-defined\" class=\"headerlink\" title=\"jQuery报错：Uncaught ReferenceError: $ is not defined\"></a>jQuery报错：Uncaught ReferenceError: $ is not defined</h3><ul>\n<li>出现这个报错的原因：</li>\n</ul>\n<ol>\n<li><p>jQuery库文件的路径不对，检查文件路径是否正确一般就能解决该错误。</p>\n</li>\n<li><p>如果库文件的路径是正确的，那么可能在html中加载jQuery库文件顺序有误，如果将jQuery库文件加载放到最开始位置，即可以解决该错误</p>\n</li>\n<li><p>检查传值错误，或者某些值不存在。</p>\n</li>\n</ol>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.18</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><hr>\n<blockquote>\n<p>建议把javascript脚本放在 <code>&lt;body&gt;</code>部分的底部。<br>这会提高网页加载速度，因为 HTML 加载不受制于脚本加载。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/w405722907/article/details/78517757\" target=\"_blank\" rel=\"noopener\">Js是放在head还是body解析</a></li>\n</ul>\n<h3 id=\"嵌入html的javascript写法\"><a href=\"#嵌入html的javascript写法\" class=\"headerlink\" title=\"嵌入html的javascript写法\"></a>嵌入html的javascript写法</h3><ul>\n<li>JavaScript代码写在<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签之前。<br><img src=\"/images/JavaScript/001.png\" alt=\"\"></li>\n<li>其中<code>&lt;script type =&quot;text/javascript&quot;&gt;</code>表示在<code>&lt;script&gt;&lt;/script&gt;</code>之间的是文本类型<code>(text)</code>,javascript是为了告诉浏览器里面的文本是属于JavaScript语言。</li>\n</ul>\n<h3 id=\"单独写成文件\"><a href=\"#单独写成文件\" class=\"headerlink\" title=\"单独写成文件\"></a>单独写成文件</h3><ul>\n<li><p>JavaScript代码只能写在HTML文件中吗?当然不是，我们可以把HTML文件和JS代码分开,并单独创建一个JavaScript文件(简称JS文件),其文件后缀通常为.js，然后将JS代码直接写在JS文件中。</p>\n</li>\n<li><p><strong>注意:在JS文件中，不需要<code>&lt;script&gt;</code>标签,直接编写JavaScript代码就可以了。</strong></p>\n</li>\n<li><p>单独写成文件的javascript文件不能单独运行，比如一个叫“script.js”的文件，我们需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中：<code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></p>\n</li>\n</ul>\n<h4 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h4><ul>\n<li>我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。</li>\n</ul>\n<h5 id=\"放在-lt-head-gt-部分\"><a href=\"#放在-lt-head-gt-部分\" class=\"headerlink\" title=\"放在&lt;head&gt;部分\"></a>放在<code>&lt;head&gt;</code>部分</h5><ul>\n<li>最常用的方式是在页面中head部分放置<code>&lt;script&gt;</code>元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。</li>\n</ul>\n<h5 id=\"放在-lt-body-gt-部分\"><a href=\"#放在-lt-body-gt-部分\" class=\"headerlink\" title=\"放在&lt;body&gt;部分\"></a>放在<code>&lt;body&gt;</code>部分</h5><ul>\n<li><p>JavaScript代码在网页读取到该语句的时候就会执行。</p>\n</li>\n<li><p><strong>注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。</strong></p>\n</li>\n</ul>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><hr>\n<ul>\n<li><p>一个JavaScript语句以<code>;</code>结尾（虽然也可以不写）</p>\n</li>\n<li><p>注释：单行注释：<code>//</code>，多行注释<code>/*...*/</code></p>\n</li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ul>\n<li><p>定义变量使用关键字<code>var 变量名</code></p>\n</li>\n<li><p>注意JS中变量无需声明类型</p>\n</li>\n</ul>\n<h3 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h3><ul>\n<li><p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(条件)</span><br><span class=\"line\">&#123; 条件成立时执行的代码 &#125;</span><br><span class=\"line\">else</span><br><span class=\"line\">&#123; 条件不成立时执行的代码 &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">   var myage = 18;</span><br><span class=\"line\">   if(myage&gt;=18)  //myage&gt;=18是判断条件</span><br><span class=\"line\">   &#123; document.write(&quot;你是成年人。&quot;);&#125;</span><br><span class=\"line\">   else  //否则年龄小于18</span><br><span class=\"line\">   &#123; document.write(&quot;未满18岁，你不是成年人。&quot;);&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"判断函数\"><a href=\"#判断函数\" class=\"headerlink\" title=\"判断函数\"></a>判断函数</h3><ul>\n<li><p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function 函数名()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     函数代码;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例子：<br><img src=\"/images/JavaScript/002.png\" alt=\"\"></p>\n</li>\n</ul>\n<h4 id=\"输出内容-document-write\"><a href=\"#输出内容-document-write\" class=\"headerlink\" title=\"输出内容(document.write)\"></a>输出内容(document.write)</h4><ul>\n<li><p>输出内容可以是双引号括起来的，也可以是变量，多个输出项之间以<code>+</code>连接</p>\n</li>\n<li><p>例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">  var mystr=&quot;hello&quot;;</span><br><span class=\"line\">  document.write(mystr+&quot;I love JavaScript&quot;); //多项内容之间用+号连接</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"javascript警告-消息对话框\"><a href=\"#javascript警告-消息对话框\" class=\"headerlink\" title=\"javascript警告(消息对话框)\"></a>javascript警告(消息对话框)</h5><ul>\n<li>语法：<code>alert(字符串或变量)</code></li>\n</ul>\n<blockquote>\n<p>注意：alert弹出一个消息对话框，只有一个确定按钮，多个对话框之间按顺序弹出。</p>\n</blockquote>\n<h5 id=\"确认-confirm对话框\"><a href=\"#确认-confirm对话框\" class=\"headerlink\" title=\"确认(confirm对话框)\"></a>确认(confirm对话框)</h5><ul>\n<li><p>语法：<code>confirm(str);</code></p>\n</li>\n<li><p>参数说明：</p>\n</li>\n</ul>\n<ol>\n<li>str：在消息对话框中要显示的文本</li>\n<li>返回值: Boolean值</li>\n</ol>\n<ul>\n<li>返回值：<br>当用户点击”确定”按钮时，返回true ；当用户点击”取消”按钮时，返回false</li>\n</ul>\n<h5 id=\"打开新窗口-window-open\"><a href=\"#打开新窗口-window-open\" class=\"headerlink\" title=\"打开新窗口(window.open)\"></a>打开新窗口(window.open)</h5><ul>\n<li><p>语法：<code>window.open([URL], [窗口名称], [参数字符串])</code></p>\n</li>\n<li><p>参数说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。</span><br><span class=\"line\">窗口名称：可选参数，被打开窗口的名称。</span><br><span class=\"line\">    1.该名称由字母、数字和下划线字符组成。</span><br><span class=\"line\">    2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。</span><br><span class=\"line\">       _blank：在新窗口显示目标网页</span><br><span class=\"line\">       _self：在当前窗口显示目标网页</span><br><span class=\"line\">       _top：框架网页中在上部窗口中显示目标网页</span><br><span class=\"line\">    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。</span><br><span class=\"line\">   4.name 不能包含有空格。</span><br><span class=\"line\">参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"/images/JavaScript/003.png\" alt=\"\"></p>\n<blockquote>\n<p>注意：所有的参数都要写在一个参数字符串中，中间以逗号间隔，例如 ‘height=100.width=100’ 这样。</p>\n</blockquote>\n<ul>\n<li><p>可以将窗口对象存储在变量test中：<code>var test = window.open(...);</code></p>\n</li>\n<li><p>关闭窗口：</p>\n</li>\n</ul>\n<ol>\n<li><p><code>window.close();</code>:关闭本窗口</p>\n</li>\n<li><p><code>&lt;窗口对象&gt;.close();</code>:关闭指定窗口</p>\n</li>\n</ol>\n<h2 id=\"控制权-DOM操作\"><a href=\"#控制权-DOM操作\" class=\"headerlink\" title=\"控制权(DOM操作)\"></a>控制权(DOM操作)</h2><hr>\n<ul>\n<li><p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p>\n</li>\n<li><p>将HTML代码分解为DOM节点层次图:<br><img src=\"/images/JavaScript/004.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"HTML文档可以说由节点构成的集合，三种常见的DOM节点\"><a href=\"#HTML文档可以说由节点构成的集合，三种常见的DOM节点\" class=\"headerlink\" title=\"HTML文档可以说由节点构成的集合，三种常见的DOM节点:\"></a>HTML文档可以说由节点构成的集合，三种常见的DOM节点:</h3><ul>\n<li><p>元素节点：上图中<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>、<code>&lt;p&gt;</code>等都是元素节点，即标签。</p>\n</li>\n<li><p>文本节点:向用户展示的内容，如<code>&lt;li&gt;...&lt;/li&gt;</code>中的JavaScript、DOM、CSS等文本。</p>\n</li>\n<li><p>属性节点:元素属性，如<code>&lt;a&gt;</code>标签的链接属性<code>href=&quot;http://www.imooc.com&quot;</code>。</p>\n</li>\n<li><p>例子：<code>&lt;a href=&quot;http://www.imooc.com&quot;&gt;JavaScript DOM&lt;/a&gt;</code><br><img src=\"/images/JavaScript/005.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"通过ID获取元素\"><a href=\"#通过ID获取元素\" class=\"headerlink\" title=\"通过ID获取元素\"></a>通过ID获取元素</h3><ul>\n<li><p>网页由标签将信息组织起来，而标签的id属性值是唯一的，就像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通过id先找到标签，然后进行操作。</p>\n</li>\n<li><p>语法：<code>document.getElementById(“id”)</code></p>\n</li>\n<li><p>例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta http-wquiv=&quot;Content-Type&quot; content=&quot;text/html; charest=gb2312&quot; /&gt;</span><br><span class=\"line\">&lt;title&gt;获取元素&lt;/title&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    var mye = document.getElementById(&quot;con&quot;);    //获取元素变量存储在变量mye中</span><br><span class=\"line\">    document.write(mye);                    //输出变量</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;h3&gt;Hello&lt;/h3&gt;</span><br><span class=\"line\">    &lt;p id=&quot;con&quot;&gt;I love JavaScript&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"innerHTML属性\"><a href=\"#innerHTML属性\" class=\"headerlink\" title=\"innerHTML属性\"></a>innerHTML属性</h3><ul>\n<li><p>innerHTML 属性用于获取或替换 HTML 元素的内容。</p>\n</li>\n<li><p>语法：<code>Object.innerHTML</code></p>\n</li>\n<li><p>例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;innerHTML&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;p id=&quot;con&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    var mycon = document.getElementById(&quot;con&quot;);</span><br><span class=\"line\">    document.write(&quot;P标签原始内容：&quot; + mycon.innerHTML + “&lt;br&gt;”);</span><br><span class=\"line\">    //输入想要修改的元素内容</span><br><span class=\"line\">    mycon.innerHTML = &quot;New test!&quot;;          //修改P元素内容</span><br><span class=\"line\">    document.write(&quot;P标签修改后的内容：&quot; + mycon.innerHTML);</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"改变HTML样式\"><a href=\"#改变HTML样式\" class=\"headerlink\" title=\"改变HTML样式\"></a>改变HTML样式</h3><ul>\n<li><p>HTML DOM 允许 JavaScript 改变 HTML 元素的样式。</p>\n</li>\n<li><p>语法：<code>Object.style.property=new style;</code></p>\n</li>\n<li><p>注意:Object是获取的元素对象，如通过<code>document.getElementById(&quot;id&quot;)</code>获取的元素。</p>\n</li>\n<li><p>基本属性表：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>backgroundColor</td>\n<td>设置元素背景颜色</td>\n</tr>\n<tr>\n<td>height</td>\n<td>设置元素高度</td>\n</tr>\n<tr>\n<td>width</td>\n<td>设置元素宽度</td>\n</tr>\n<tr>\n<td>color</td>\n<td>设置文本颜色</td>\n</tr>\n<tr>\n<td>font</td>\n<td>在一行设置所有的字体属性</td>\n</tr>\n<tr>\n<td>fontFamily</td>\n<td>设置元素的字体系列</td>\n</tr>\n<tr>\n<td>fontSize</td>\n<td>设置元素的字体大小</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>CSS的其他的一些样式也可以通过该方法修改</p>\n</li>\n<li><p>例子：改变<code>&lt;p&gt;</code>元素的样式，将颜色改为红色，字号改为20,背景颜色改为蓝：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p id=&quot;pcon&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">   var mychar = document.getElementById(&quot;pcon&quot;);</span><br><span class=\"line\">   mychar.style.color=&quot;red&quot;;</span><br><span class=\"line\">   mychar.style.fontSize=&quot;20&quot;;</span><br><span class=\"line\">   mychar.style.backgroundColor =&quot;blue&quot;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"显示和隐藏\"><a href=\"#显示和隐藏\" class=\"headerlink\" title=\"显示和隐藏\"></a>显示和隐藏</h3><ul>\n<li><p>网页中经常会看到显示和隐藏的效果，可通过display属性来设置。</p>\n</li>\n<li><p>语法：<code>Object.style.display = value</code></p>\n</li>\n</ul>\n<blockquote>\n<p>注意这里的Object也是元素对象，可通过document.getElementById(“id”)来获取</p>\n</blockquote>\n<ul>\n<li>value取值：</li>\n</ul>\n<ol>\n<li>none：此元素讲不会被显示(即隐藏)</li>\n<li>block：此元素将显示为块级元素</li>\n</ol>\n<p>例子：<br><img src=\"/images/JavaScript/006.png\" alt=\"\"></p>\n<h3 id=\"控制类名\"><a href=\"#控制类名\" class=\"headerlink\" title=\"控制类名\"></a>控制类名</h3><ul>\n<li><p>className 属性设置或返回元素的class 属性。</p>\n</li>\n<li><p>语法：<code>object.className = classname</code></p>\n</li>\n<li><p>作用：</p>\n</li>\n</ul>\n<ol>\n<li>获取元素的class属性</li>\n<li>为网页内某个元素指定一个CSS样式来更改该元素的外观</li>\n</ol>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=gb2312&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;className属性&lt;/title&gt;</span><br><span class=\"line\">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">  input&#123;</span><br><span class=\"line\">    font-size:10px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .one&#123;</span><br><span class=\"line\">    width:200px;</span><br><span class=\"line\">    background-color:#CCC; //灰色</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .two&#123;</span><br><span class=\"line\">    font-size:18px;</span><br><span class=\"line\">    color:#F00</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;p id=&quot;con&quot; class=&quot;one&quot;&gt;JavaScript&lt;/p&gt;</span><br><span class=\"line\">  &lt;form&gt;</span><br><span class=\"line\">    &lt;input type=&quot;button&quot; value=&quot;点击更改&quot; onclick=&quot;modifyclass()&quot;/&gt;</span><br><span class=\"line\">  &lt;/form&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    var mychar=document.getElementById(&quot;con&quot;);</span><br><span class=\"line\">    document.write(&quot;p元素的Class值为：&quot; + mychar.className + &quot;&lt;br&gt;&quot;); //输出P元素的class属性</span><br><span class=\"line\">    function modifyclass()&#123;</span><br><span class=\"line\">      mychar.className=&quot;two&quot;; //改变className,即更换用来修饰的class</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>结果：</li>\n</ul>\n<p><img src=\"/images/JavaScript/007.png\" alt=\"\"></p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><hr>\n<ul>\n<li>循环、分支、判断等语法与C++一致</li>\n</ul>\n<h3 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h3><ul>\n<li>JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onclick</td>\n<td>鼠标单击事件</td>\n</tr>\n<tr>\n<td>onmouseover</td>\n<td>鼠标经过事件</td>\n</tr>\n<tr>\n<td>onmouseout</td>\n<td>鼠标移开事件</td>\n</tr>\n<tr>\n<td>onchange</td>\n<td>文本框内容改变事件</td>\n</tr>\n<tr>\n<td>onselect</td>\n<td>文本框内容被选中事件</td>\n</tr>\n<tr>\n<td>onfocus</td>\n<td>光标聚集</td>\n</tr>\n<tr>\n<td>onblur</td>\n<td>光标移开</td>\n</tr>\n<tr>\n<td>onload</td>\n<td>网页导入</td>\n</tr>\n<tr>\n<td>onunload</td>\n<td>关闭网页</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"鼠标单击事件\"><a href=\"#鼠标单击事件\" class=\"headerlink\" title=\"鼠标单击事件\"></a>鼠标单击事件</h4><ul>\n<li><p>onclick是鼠标单击事件，当在网页上单击鼠标时，就会发生该事件。同时onclick事件调用的程序块就会被执行，通常与按钮一起使用。</p>\n</li>\n<li><p>例如：单击按钮时出发onclick事件，调用add2()函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form&gt;</span><br><span class=\"line\">     &lt;input name=&quot;button&quot; type=&quot;button&quot; value=&quot;点击提交&quot; onclick=&quot;add2()&quot; /&gt;  //注意最后的斜杠</span><br><span class=\"line\">  &lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"鼠标经过事件\"><a href=\"#鼠标经过事件\" class=\"headerlink\" title=\"鼠标经过事件\"></a>鼠标经过事件</h4><ul>\n<li>与鼠标单击事件调用方法一致</li>\n</ul>\n<h4 id=\"其他的事件\"><a href=\"#其他的事件\" class=\"headerlink\" title=\"其他的事件\"></a>其他的事件</h4><ul>\n<li>除了onload与onunload的使用有一点区别，别的都一致。</li>\n</ul>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><ul>\n<li><p>JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。</p>\n</li>\n<li><p>创建对象使用<code>new</code>关键字</p>\n</li>\n</ul>\n<h4 id=\"日期对象\"><a href=\"#日期对象\" class=\"headerlink\" title=\"日期对象\"></a>日期对象</h4><ul>\n<li><p>日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000 秒）</p>\n</li>\n<li><p>定义一个时间对象：<code>var Udate = new Date();</code></p>\n<blockquote>\n<p>这是默认定义，初始值为当前电脑时间</p>\n</blockquote>\n</li>\n<li><p>如果要自定义值，使用以下方法：<code>var DATE = new Date(2018,10,4); //2018年10月4日</code></p>\n</li>\n</ul>\n<h4 id=\"浏览器对象\"><a href=\"#浏览器对象\" class=\"headerlink\" title=\"浏览器对象\"></a>浏览器对象</h4><h4 id=\"window对象\"><a href=\"#window对象\" class=\"headerlink\" title=\"window对象\"></a>window对象</h4><ul>\n<li><p>window对象是BOM的核心，window对象指当前的浏览器窗口。</p>\n</li>\n<li><p>window对象方法：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alert()</td>\n<td>显示带有一段消息和一个确认按钮的警告框</td>\n</tr>\n<tr>\n<td>prompt()</td>\n<td>显示可提示用户输入的对话框</td>\n</tr>\n<tr>\n<td>confirm()</td>\n<td>显示带有一段消息以及确认按钮和取消按钮的对话框</td>\n</tr>\n<tr>\n<td>open()</td>\n<td>打开一个新的浏览器窗口或者查找一个已经命名的窗口</td>\n</tr>\n<tr>\n<td>close()</td>\n<td>关闭浏览器窗口</td>\n</tr>\n<tr>\n<td>print()</td>\n<td>打印当前窗口的内容</td>\n</tr>\n<tr>\n<td>focus()</td>\n<td>把键盘焦点给予一个窗口</td>\n</tr>\n<tr>\n<td>blur()</td>\n<td>把键盘焦点从顶层窗口移开</td>\n</tr>\n<tr>\n<td>moveBy()</td>\n<td>可相对窗口的当前坐标把它移动指定的像素</td>\n</tr>\n<tr>\n<td>moveTo()</td>\n<td>把窗口的左上角移动到一个指定的坐标</td>\n</tr>\n<tr>\n<td>resizeBy()</td>\n<td>按照</td>\n</tr>\n<tr>\n<td>resizeTo()</td>\n<td>把窗口的大小调整到指定的宽度和高度</td>\n</tr>\n<tr>\n<td>scrollBy()</td>\n<td>按照指定的像素值来滚动内容</td>\n</tr>\n<tr>\n<td>scrollTo()</td>\n<td>把内容滚动到指定的坐标</td>\n</tr>\n<tr>\n<td>setInterval()</td>\n<td>每隔指定的时间执行代码</td>\n</tr>\n<tr>\n<td>setTimeout()</td>\n<td>在指定的延迟时间后来执行代码</td>\n</tr>\n<tr>\n<td>clearInterval()</td>\n<td>取消setInterval()的设置</td>\n</tr>\n<tr>\n<td>clearTimeout()</td>\n<td>取消setTimeout()的设置</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>调用这些方法格式：<code>window.方法名(参数名);</code></li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function myFunction()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    alert(&quot;欢迎&quot;)</span><br><span class=\"line\">    window.open(&apos;http://www.imooc.com&apos;,&apos;_blank&apos;,&apos;width=600 height=400&apos;)</span><br><span class=\"line\">    //第一个参数表示要打开的网页，&apos;_blank&apos;参数表示打开一个新网页，后面的参数设置新窗口的初始大小</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"JavaScript计时器\"><a href=\"#JavaScript计时器\" class=\"headerlink\" title=\"JavaScript计时器\"></a>JavaScript计时器</h4><ul>\n<li><p>在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。</p>\n</li>\n<li><p>计时器类型：</p>\n<ol>\n<li><p>一次性计时器：仅在指定的延迟时间之后触发一次。(setTimeout())</p>\n</li>\n<li><p>间隔性触发计时器：每隔一定的时间间隔就触发一次。(setInterval())</p>\n</li>\n</ol>\n</li>\n<li><p>setInterval()方法格式：<code>setInterval(代码，交互时间)</code></p>\n<blockquote>\n<p>参数中，代码就是要执行的函数挥着代码串，交互时间就是执行的时间间隔，以毫秒为单位</p>\n</blockquote>\n</li>\n<li><p>setInterval的返回值可以传递给clearInterval从而取消对代码的周期性执行。</p>\n</li>\n<li><p>假设有一个clock()函数，则调用格式为：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setInterval(&quot;clock()&quot;,1000)</span><br><span class=\"line\">或者</span><br><span class=\"line\">setInterval(clock,1000)</span><br></pre></td></tr></table></figure>\n<h2 id=\"DOM对象\"><a href=\"#DOM对象\" class=\"headerlink\" title=\"DOM对象\"></a>DOM对象</h2><hr>\n<h3 id=\"getElementsByName方法\"><a href=\"#getElementsByName方法\" class=\"headerlink\" title=\"getElementsByName方法\"></a>getElementsByName方法</h3><ul>\n<li><p>返回带有指定名称的节点对象的集合</p>\n</li>\n<li><p>语法：<code>document.getElementsByName(name)</code></p>\n<blockquote>\n<p>其中name参数是标签上设置的name属性，和设置id属性格式一样，但是不同的标签可以设置同一个name属性，而id属性必须唯一</p>\n</blockquote>\n</li>\n<li><p>与getElementById()不同的是，通过元素的name属性查询元素而不是通过id属性</p>\n</li>\n<li><p>注意：因为文档中的name属性可能不唯一，所有的getElementByName()方法的返回值是元素的数组，而不是一个元素</p>\n</li>\n<li><p>和数组类似的也有length属性，可以和访问数组一样的方法来访问，从0开始</p>\n</li>\n</ul>\n<h2 id=\"一些报错以及解决\"><a href=\"#一些报错以及解决\" class=\"headerlink\" title=\"一些报错以及解决\"></a>一些报错以及解决</h2><hr>\n<h3 id=\"jQuery报错：Uncaught-ReferenceError-is-not-defined\"><a href=\"#jQuery报错：Uncaught-ReferenceError-is-not-defined\" class=\"headerlink\" title=\"jQuery报错：Uncaught ReferenceError: $ is not defined\"></a>jQuery报错：Uncaught ReferenceError: $ is not defined</h3><ul>\n<li>出现这个报错的原因：</li>\n</ul>\n<ol>\n<li><p>jQuery库文件的路径不对，检查文件路径是否正确一般就能解决该错误。</p>\n</li>\n<li><p>如果库文件的路径是正确的，那么可能在html中加载jQuery库文件顺序有误，如果将jQuery库文件加载放到最开始位置，即可以解决该错误</p>\n</li>\n<li><p>检查传值错误，或者某些值不存在。</p>\n</li>\n</ol>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.18</p>\n</blockquote>\n"},{"layout":"post","title":"Ubuntu下使用jekyll预览博客","date":"2018-07-08T14:40:00.000Z","_content":"\n\n## 环境安装\n---\n\n确保下面环境的齐全：\n```\nbrew install ruby\n//\ngem install jekyll\n//\ngem install bundler\n//\ngem install jekyll-paginate\n//\ngem install jekyll-gist\n```\n\n- 如果执行命令的过程中有提示什么什么未安装，按照提示的命令来安装即可。\n\n- 然后将终端切换到你博客所在的根目录，执行：`jekyll serve --watch`即可\n\n- 终端中会告诉你博客使用了本地4000端口，在网页中输入：`http://127.0.0.1:4000/\n`即可预览博客的效果\n\n- 更新本地内容保存后更新网页即可看到效果\n\n\n<br>\n> 最后更新于2018.7.14\n","source":"_posts/2018-07-08-Jekyll-usage.md","raw":"---\nlayout:     post\ntitle:      \"Ubuntu下使用jekyll预览博客\"\ndate:       2018-07-08 22:40:00\ncategories: Personal Blog\ntags:   ๑Blog\n---\n\n\n## 环境安装\n---\n\n确保下面环境的齐全：\n```\nbrew install ruby\n//\ngem install jekyll\n//\ngem install bundler\n//\ngem install jekyll-paginate\n//\ngem install jekyll-gist\n```\n\n- 如果执行命令的过程中有提示什么什么未安装，按照提示的命令来安装即可。\n\n- 然后将终端切换到你博客所在的根目录，执行：`jekyll serve --watch`即可\n\n- 终端中会告诉你博客使用了本地4000端口，在网页中输入：`http://127.0.0.1:4000/\n`即可预览博客的效果\n\n- 更新本地内容保存后更新网页即可看到效果\n\n\n<br>\n> 最后更新于2018.7.14\n","slug":"2018-07-08-Jekyll-usage","published":1,"updated":"2018-09-03T08:50:12.010Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j56002q1m0osla929td","content":"<h2 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h2><hr>\n<p>确保下面环境的齐全：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install ruby</span><br><span class=\"line\">//</span><br><span class=\"line\">gem install jekyll</span><br><span class=\"line\">//</span><br><span class=\"line\">gem install bundler</span><br><span class=\"line\">//</span><br><span class=\"line\">gem install jekyll-paginate</span><br><span class=\"line\">//</span><br><span class=\"line\">gem install jekyll-gist</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>如果执行命令的过程中有提示什么什么未安装，按照提示的命令来安装即可。</p>\n</li>\n<li><p>然后将终端切换到你博客所在的根目录，执行：<code>jekyll serve --watch</code>即可</p>\n</li>\n<li><p>终端中会告诉你博客使用了本地4000端口，在网页中输入：<code>http://127.0.0.1:4000/</code>即可预览博客的效果</p>\n</li>\n<li><p>更新本地内容保存后更新网页即可看到效果</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.14</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h2><hr>\n<p>确保下面环境的齐全：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install ruby</span><br><span class=\"line\">//</span><br><span class=\"line\">gem install jekyll</span><br><span class=\"line\">//</span><br><span class=\"line\">gem install bundler</span><br><span class=\"line\">//</span><br><span class=\"line\">gem install jekyll-paginate</span><br><span class=\"line\">//</span><br><span class=\"line\">gem install jekyll-gist</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>如果执行命令的过程中有提示什么什么未安装，按照提示的命令来安装即可。</p>\n</li>\n<li><p>然后将终端切换到你博客所在的根目录，执行：<code>jekyll serve --watch</code>即可</p>\n</li>\n<li><p>终端中会告诉你博客使用了本地4000端口，在网页中输入：<code>http://127.0.0.1:4000/</code>即可预览博客的效果</p>\n</li>\n<li><p>更新本地内容保存后更新网页即可看到效果</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.14</p>\n</blockquote>\n"},{"layout":"post","title":"Scala方法查询记录","date":"2018-07-12T08:40:00.000Z","_content":"\n> 仅供查询，禁止转载\n\n- 一般的Int类型的都可以通过`.max`和`.min`获取最大最小元素\n\n## List的一些方法和用途\n\n|方法|用途|\n|---|---|\n|List()或者Nil|表示空列表|\n|List(\"Cool\",\"Tools\")|创建一个新的List[String],包含两个值:\"Cool\",\"Tools\"|\n|val thrill = \"Will\"::\"Fill\"::Nil|创建一个新的List[String]包含两个值：\"Will\"和\"Fill\"|\n|List(\"a\",\"b\"):::List(\"c\",\"d\")|将两个列表拼接起来(返回一个新的列表List(\"a\",\"b\",\"c\",\"d\"))|\n|thrill(2)|返回列表thrill下标为2(从0开始计数)|\n|thrill.count(s => s.length == 4)|对thrill中长度为4的字符串进行计数|\n|thrill.drop(2)|返回去掉了thrill的头两个元素的列表|\n|thrill.dropRight(2)|返回去掉了thrill后两个元素的列表|\n|thrill.exists(s => s==\"until\")|判断thrill中是否有字符串元素的值为\"until\"，返回值为Boolean|\n|thrill.filter(s => s.length == 4)|按顺序返回列表thrill中所有长度为4的元素列表|\n|thrill.forall(s => s.endsWith(\"1\"))|表示列表中是否所有元素都以字母\"1\"结尾|\n|thrill.foreach(s => println(s)) / thrill.foreach(println)|遍历列表执行打印|\n|thrill.head|返回列表的首个元素|\n|thrill.init|返回列表thrill除最后一个元素之外其他元素组成的列表|\n|thrill.isEmpty|判断列表是否为空|\n|thrill.last|返回thrill的最后一个元素|\n|thrill.length|返回列表的元素个数|\n|thrill.map(s => s + \"y\")|返回一个对列表thrill所有字符串元素末尾添加\"y\"的新字符串列表|\n|thrill.makeString\", \"|返回用列表thrill的所有元素组合成的字符串，以\", \"连接各个元素|\n|thrill.filterNot(s => s.length == 4)|按顺序返回列表中所有长度不为4的元素列表|\n|thrill.reverse|返回包含列表thrill的逆序列表|\n|thrill.sort( (s,t) => s.charAt(0).toLower < t.charAt(0).toLower)|返回包含thrill的所有元素，按照首字母小写顺序排序的列表|\n|thrill.tail|返回列表thrill除首个元素之外其他元素组成的列表|\n\n## 常用的集操作\n\n|操作|效果|\n|---|---|\n|val nums = Set(1,2,3)|创建一个不可变集(nums.toString返回Set(1,2,3))|\n|nums + 5|添加一个元素(返回Set(1,2,3,5))|\n|nums - 3|移除一个元素(返回Set(1,2))|\n|nums ++ List(5,6)|添加多个元素(返回Set(1,2,3,5,6))|\n|nums -- List(1,2)|移除多个元素(返回Set(3))|\n|nums & Set(1,3,5,7)|获取两个集的交集(返回Set(1,3))|\n|nums.size|返回集的大小(返回3)|\n|nums.contains(3)|检查是否包含(此处返回true)|\n|import scala.collection.mutable|让可变集易于访问|\n|val words = mutable.Set.empty[String]|创建一个空的可变集(words.toString将返回Set())|\n|words += \"the\"|添加一个元素(words.toString将返回Set(the))|\n|words -= \"the\"|移除一个元素，如果这个元素存在(words.toString将返回Set())|\n|words ++= List(\"do\",\"re\",\"mi\")|添加多个元素(words.toString将返回Set(do,re,mi))|\n|words --= List(\"do\",\"re\")|移除多个元素(words.toString将返回Set(mi))|\n|words.clear|移除所有元素(words.toString将返回Set())|\n\n- [更详细的链接](https://docs.scala-lang.org/zh-cn/overviews/collections/sets.html)\n\n## 常用的映射操作\n\n|操作|效果|\n|---|---|\n|val nums = Map(\"i\" -> 1, \"ii\" -> 2)|创建一个不可变映射(nums.toString返回Map(i -> 1, ii -> 2))|\n|nums + (\"vi\" -> 6)|添加一个条目(返回Map(i -> 1, ii -> 2, vi -> 6))|\n|nums - \"ii\"|移除一个条目(返回Map(i -> 1))|\n|nums ++ List(\"iii\" -> 3, \"v\" -> 5)|添加多个条目(返回Map(i -> 1, ii -> 2, iii -> 3, v -> 5))|\n|nums -- List(\"i\",\"ii\")|移除多个条目(返回Map())|\n|nums.size|返回映射的大小(返回2)|\n|nums.contains(\"ii\")|检查是否包含(返回true)|\n|nums(\"ii\")|获取指定键的值(返回2)|\n|nums.keys|返回所有键(返回字符串\"i\"和\"ii\"的Iterable)|\n|nums.keySet|以集的形式返回所有的键(返回Set(i,ii))|\n|nums.values|返回所有的值(返回整数1和2的Iterable)|\n|nums.isEmpty|表示映射是否为空|\n|import scala.collection.mutable|让可变集合易于访问|\n|val words = mutable.Map.empty[String,Int]|创建一个空的可变映射|\n|words += (\"one\" -> 1, \"two\" -> 2, \"three\" -> 3)|添加一个从\"one\"到1的映射条目|\n|words -= \"one\"|移除一个映射条目，如果存在|\n|words ++= List(\"one\" -> 1, \"two\" -> 2, \"three\" -> 3)|添加多个条目|\n|words --= List(\"one\",\"two\")|移除多个条目|\n\n- [更详细的链接](https://docs.scala-lang.org/zh-cn/overviews/collections/maps.html)\n\n## 序列\n\n|操作|说明|\n|---|---|\n|索引和长度的操作 apply、isDefinedAt、length、indices，及lengthCompare|序列的apply操作用于索引访问；因此，Seq[T]类型的序列也是一个以单个Int（索引下标）为参数、返回值类型为T的偏函数。换言之，Seq[T]继承自Partial Function[Int, T]。序列各元素的索引下标从0开始计数，最大索引下标为序列长度减一。序列的length方法是collection的size方法的别名。lengthCompare方法可以比较两个序列的长度，即便其中一个序列长度无限也可以处理。|\n|索引检索操作（indexOf、lastIndexOf、indexofSlice、lastIndexOfSlice、indexWhere、lastIndexWhere、segmentLength、prefixLength）|用于返回等于给定值或满足某个谓词的元素的索引。|\n|加法运算（+:，:+，padTo）|用于在序列的前面或者后面添加一个元素并作为新序列返回。|\n|更新操作（updated，patch）|用于替换原序列的某些元素并作为一个新序列返回。|\n|排序操作（sorted, sortWith, sortBy）|根据不同的条件对序列元素进行排序。|\n|反转操作（reverse, reverseIterator, reverseMap）|用于将序列中的元素以相反的顺序排列。|\n|比较（startsWith, endsWith, contains, containsSlice, corresponds）|用于对两个序列进行比较，或者在序列中查找某个元素。|\n|多集操作（intersect, diff, union, distinct）|用于对两个序列中的元素进行类似集合的操作，或者删除重复元素。|\n\n## Seq类的操作\n\n|WHAT IT IS|WHAT IT DOES|\n|---|---|\n|索引和长度|-----------------------------------|\n|xs(i)|\t(或者写作xs apply i)。xs的第i个元素|\n|xs isDefinedAt i|\t测试xs.indices中是否包含i。|\n|xs.length|序列的长度（同size）。|\n|xs.lengthCompare ys|如果xs的长度小于ys的长度，则返回-1。如果xs的长度大于ys的长度，则返回+1，如果它们长度相等，则返回0。即使其中一个序列是无限的，也可以使用此方法。|\n|xs.indices|xs的索引范围，从0到xs.length - 1。|\n|索引搜索|-----------------------------------|\n|xs indexOf x|返回序列xs中等于x的第一个元素的索引（存在多种变体）。|\n|xs lastIndexOf x|返回序列xs中等于x的最后一个元素的索引（存在多种变体）。|\n|xs indexOfSlice ys|查找子序列ys，返回xs中匹配的第一个索引。|\n|xs indexOfSlice ys|查找子序列ys，返回xs中匹配的倒数一个索引。|\n|xs indexWhere p|xs序列中满足p的第一个元素。（有多种形式）|\n|xs segmentLength (p, i)|xs中，从xs(i)开始并满足条件p的元素的最长连续片段的长度。|\n|xs prefixLength p|xs序列中满足p条件的先头元素的最大个数。|\n|加法|-----------------------------------|\n|x +: xs|由序列xs的前方添加x所得的新序列。|\n|xs :+ x|由序列xs的后方追加x所得的新序列。|\n|xs padTo (len, x)|在xs后方追加x，直到长度达到len后得到的序列。|\n|更新|-----------------------------------|\n|xs patch (i, ys, r)|将xs中第i个元素开始的r个元素，替换为ys所得的序列。|\n|xs updated (i, x)|将xs中第i个元素替换为x后所得的xs的副本。|\n|xs(i) = x|（或写作 xs.update(i, x)，仅适用于可变序列）将xs序列中第i个元素修改为x。|\n|排序|-----------------------------------|\n|xs.sorted|通过使用xs中元素类型的标准顺序，将xs元素进行排序后得到的新序列。|\n|xs sortWith lt|将lt作为比较操作，并以此将xs中的元素进行排序后得到的新序列。|\n|xs sortBy f|将序列xs的元素进行排序后得到的新序列。参与比较的两个元素各自经f函数映射后得到一个结果，通过比较它们的结果来进行排序。|\n|反转|-----------------------------------|\n|xs.reverse|与xs序列元素顺序相反的一个新序列。|\n|xs.reverseIterator|产生序列xs中元素的反序迭代器。|\n|xs reverseMap f|以xs的相反顺序，通过f映射xs序列中的元素得到的新序列。|\n|比较|-----------------------------------|\n|xs startsWith ys|测试序列xs是否以序列ys开头（存在多种形式）。|\n|xs endsWith ys|测试序列xs是否以序列ys结束（存在多种形式）。|\n|xs contains x|测试xs序列中是否存在一个与x相等的元素。|\n|xs containsSlice ys|\t测试xs序列中是否存在一个与ys相同的连续子序列。|\n|(xs corresponds ys)(p)|测试序列xs与序列ys中对应的元素是否满足二元的判断式p。|\n|多集操作|-----------------------------------|\n|xs intersect ys|序列xs和ys的交集，并保留序列xs中的顺序。|\n|xs diff ys|序列xs和ys的差集，并保留序列xs中的顺序。|\n|xs union ys|并集；同xs ++ ys。|\n|xs.distinct|不含重复元素的xs的子序列。|\n\n## Buffer类的操作\n\n|WHAT IT IS|WHAT IT DOES|\n|---|---|\n|加法：|-----------------------------------|\n|buf += x|将元素x追加到buffer，并将buf自身作为结果返回。|\n|buf += (x, y, z)|将给定的元素追加到buffer。|\n|buf ++= xs|将xs中的所有元素追加到buffer。|\n|x +=: buf|将元素x添加到buffer的前方。|\n|xs ++=: buf|将xs中的所有元素都添加到buffer的前方。|\n|buf insert (i, x)|将元素x插入到buffer中索引为i的位置。|\n|buf insertAll (i, xs)|将xs的所有元素都插入到buffer中索引为i的位置。|\n|移除：|-----------------------------------|\n|buf -= x|将元素x从buffer中移除。|\n|buf remove i|将buffer中索引为i的元素移除。|\n|buf remove (i, n)|将buffer中从索引i开始的n个元素移除。|\n|buf trimStart n|移除buffer中的前n个元素。|\n|buf trimEnd n|移除buffer中的后n个元素。|\n|buf.clear()|移除buffer中的所有元素。|\n|克隆：|-----------------------------------|\n|buf.clone|与buf具有相同元素的新buffer。|\n\n## Traversable对象的操作\n\n|WHAT IT IS\t|WHAT IT DOES|\n|---|---|\n|抽象方法：|\t |\n|xs foreach f\t|对xs中的每一个元素执行函数f|\n|加运算（Addition）：|\t |\n|xs ++ ys\t|生成一个由xs和ys中的元素组成容器。ys是一个TraversableOnce容器，即Taversable类型或迭代器。|\n|Maps:\t ||\n|xs map f\t|通过函数xs中的每一个元素调用函数f来生成一个容器。|\n|xs flatMap f\t|通过对容器xs中的每一个元素调用作为容器的值函数f，在把所得的结果连接起来作为一个新的容器。|\n|xs collect f\t|通过对每个xs中的符合定义的元素调用偏函数f，并把结果收集起来生成一个集合。|\n|转换（Conversions）：\t ||\n|xs.toArray\t|把容器转换为一个数组|\n|xs.toList|\t把容器转换为一个list|\n|xs.toIterable|\t把容器转换为一个迭代器。|\n|xs.toSeq\t|把容器转换为一个序列|\n|xs.toIndexedSeq|\t把容器转换为一个索引序列|\n|xs.toStream|\t把容器转换为一个延迟计算的流。|\n|xs.toSet\t|把容器转换为一个集合（Set）。|\n|xs.toMap\t|把由键/值对组成的容器转换为一个映射表（map）。如果该容器并不是以键/值对作为元素的，那么调用这个操作将会导致一个静态类型的错误。|\n|拷贝（Copying）：\t ||\n|xs copyToBuffer buf\t|把容器的所有元素拷贝到buf缓冲区。|\n|xs copyToArray(arr, s, n)|\t拷贝最多n个元素到数组arr的坐标s处。参数s，n是可选项。|\n|大小判断（Size info）：\t ||\n|xs.isEmpty\t|测试容器是否为空。|\n|xs.nonEmpty\t|测试容器是否包含元素。|\n|xs.size\t|计算容器内元素的个数。|\n|xs.hasDefiniteSize\t|如果xs的大小是有限的，则为true。|\n|元素检索（Element Retrieval）：\t ||\n|xs.head\t|返回容器内第一个元素（或其他元素，若当前的容器无序）。|\n|xs.headOption|\txs选项值中的第一个元素，若xs为空则为None。|\n|xs.last\t|返回容器的最后一个元素（或某个元素，如果当前的容器无序的话）。|\n|xs.lastOption\t|xs选项值中的最后一个元素，如果xs为空则为None。|\n|xs find p|\t查找xs中满足p条件的元素，若存在则返回第一个元素；若不存在，则为空。|\n|子容器（Subcollection）：\t||\n|xs.tail|\t返回由除了xs.head外的其余部分。|\n|xs.init|\t返回除xs.last外的其余部分。|\n|xs slice (from, to)|\t返回由xs的一个片段索引中的元素组成的容器（从from到to，但不包括to）。|\n|xs take n\t|由xs的第一个到第n个元素（或当xs无序时任意的n个元素）组成的容器。|\n|xs drop n\t|由除了xs take n以外的元素组成的容器。|\n|xs takeWhile p\t|容器xs中最长能够满足断言p的前缀。|\n|xs dropWhile p\t|容器xs中除了xs takeWhile p以外的全部元素。|\n|xs filter p|\t由xs中满足条件p的元素组成的容器。|\n|xs withFilter p|\t这个容器是一个不太严格的过滤器。子容器调用map，flatMap，foreach和withFilter只适用于xs中那些的满足条件p的元素。|\n|xs filterNot p\t|由xs中不满足条件p的元素组成的容器。|\n|拆分（Subdivision）：\t ||\n|xs splitAt n\t|把xs从指定位置的拆分成两个容器（xs take n和xs drop n）。|\n|xs span p|\t根据一个断言p将xs拆分为两个容器（xs takeWhile p, xs.dropWhile p）。|\n|xs partition p\t|把xs分割为两个容器，符合断言p的元素赋给一个容器，其余的赋给另一个(xs filter p, xs.filterNot p)。|\n|xs groupBy f\t|根据判别函数f把xs拆分一个到容器（collection）的map中。|\n|条件元素（Element Conditions）：\t ||\n|xs forall p|\t返回一个布尔值表示用于表示断言p是否适用xs中的所有元素。|\n|xs exists p\t|返回一个布尔值判断xs中是否有部分元素满足断言p。|\n|xs count p\t|返回xs中符合断言p条件的元素个数。|\n|折叠（Fold）：||\t \n|(z /: xs)(op)|\t在xs中，对由z开始从左到右的连续元素应用二进制运算op。|\n|(xs :\\ z)(op)\t|在xs中，对由z开始从右到左的连续元素应用二进制运算op|\n|xs.foldLeft(z)(op)|\t与(z /: xs)(op)相同。|\n|xs.foldRight(z)(op)|\t与 (xs :\\ z)(op)相同。|\n|xs reduceLeft op\t|非空容器xs中的连续元素从左至右调用二进制运算op。|\n|xs reduceRight op|\t非空容器xs中的连续元素从右至左调用二进制运算op。|\n|特殊折叠（Specific Fold）：\t ||\n|xs.sum\t|返回容器xs中数字元素的和。|\n|xs.product\t|xs返回容器xs中数字元素的积。|\n|xs.min|\t容器xs中有序元素值中的最小值。|\n|xs.max\t|容器xs中有序元素值中的最大值。|\n|字符串（String）：\t||\n|xs addString (b, start, sep, end)|\t把一个字符串加到StringBuilder对象b中，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。|\n|xs mkString (start, sep, end)\t|把容器xs转换为一个字符串，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。|\n|xs.stringPrefix|\t返回一个字符串，该字符串是以容器名开头的xs.toString。|\n|视图（View）：\t ||\n|xs.view|\t通过容器xs生成一个视图。|\n|xs view (from, to)\t|生成一个表示在指定索引范围内的xs元素的视图。|\n\n## Trait Iterable操作\n\n|WHAT IT IS\t|WHAT IT DOES|\n|---|---|\n|抽象方法：\t ||\n|xs.iterator\txs|迭代器生成的每一个元素，以相同的顺序就像foreach一样遍历元素。|\n|其他迭代器：\t ||\n|xs grouped size|\t一个迭代器生成一个固定大小的容器（collection）块。||\n|xs sliding size\t|一个迭代器生成一个固定大小的滑动窗口作为容器（collection）的元素。|\n|子容器（Subcollection）：||\t \n|xs takeRight n\t|一个容器（collection）由xs的最后n个元素组成（或，若定义的元素是无序，则由任意的n个元素组成）。|\n|xs dropRight n\t|一个容器（collection）由除了xs 被取走的（执行过takeRight （）方法）n个元素外的其余元素组成。|\n|拉链方法（Zippers）：\t||\n|xs zip ys|\t把一对容器 xs和ys的包含的元素合成到一个iterabale。|\n|xs zipAll (ys, x, y)\t|一对容器 xs 和ys的相应的元素合并到一个iterable ，实现方式是通过附加的元素x或y，把短的序列被延展到相对更长的一个上。|\n|xs.zip WithIndex\t|把一对容器xs和它的序列，所包含的元素组成一个iterable 。|\n|比对：\t ||\n|xs sameElements ys\t|测试 xs 和 ys 是否以相同的顺序包含相同的元素。|\n\n<br>\n> 最后更新于2018.7.26\n","source":"_posts/2018-07-12-Scala-infos.md","raw":"---\nlayout:     post\ntitle:      \"Scala方法查询记录\"\ndate:       2018-07-12 16:40:00\ncategories: Computer Programes\ntags:   ๑Scala\n---\n\n> 仅供查询，禁止转载\n\n- 一般的Int类型的都可以通过`.max`和`.min`获取最大最小元素\n\n## List的一些方法和用途\n\n|方法|用途|\n|---|---|\n|List()或者Nil|表示空列表|\n|List(\"Cool\",\"Tools\")|创建一个新的List[String],包含两个值:\"Cool\",\"Tools\"|\n|val thrill = \"Will\"::\"Fill\"::Nil|创建一个新的List[String]包含两个值：\"Will\"和\"Fill\"|\n|List(\"a\",\"b\"):::List(\"c\",\"d\")|将两个列表拼接起来(返回一个新的列表List(\"a\",\"b\",\"c\",\"d\"))|\n|thrill(2)|返回列表thrill下标为2(从0开始计数)|\n|thrill.count(s => s.length == 4)|对thrill中长度为4的字符串进行计数|\n|thrill.drop(2)|返回去掉了thrill的头两个元素的列表|\n|thrill.dropRight(2)|返回去掉了thrill后两个元素的列表|\n|thrill.exists(s => s==\"until\")|判断thrill中是否有字符串元素的值为\"until\"，返回值为Boolean|\n|thrill.filter(s => s.length == 4)|按顺序返回列表thrill中所有长度为4的元素列表|\n|thrill.forall(s => s.endsWith(\"1\"))|表示列表中是否所有元素都以字母\"1\"结尾|\n|thrill.foreach(s => println(s)) / thrill.foreach(println)|遍历列表执行打印|\n|thrill.head|返回列表的首个元素|\n|thrill.init|返回列表thrill除最后一个元素之外其他元素组成的列表|\n|thrill.isEmpty|判断列表是否为空|\n|thrill.last|返回thrill的最后一个元素|\n|thrill.length|返回列表的元素个数|\n|thrill.map(s => s + \"y\")|返回一个对列表thrill所有字符串元素末尾添加\"y\"的新字符串列表|\n|thrill.makeString\", \"|返回用列表thrill的所有元素组合成的字符串，以\", \"连接各个元素|\n|thrill.filterNot(s => s.length == 4)|按顺序返回列表中所有长度不为4的元素列表|\n|thrill.reverse|返回包含列表thrill的逆序列表|\n|thrill.sort( (s,t) => s.charAt(0).toLower < t.charAt(0).toLower)|返回包含thrill的所有元素，按照首字母小写顺序排序的列表|\n|thrill.tail|返回列表thrill除首个元素之外其他元素组成的列表|\n\n## 常用的集操作\n\n|操作|效果|\n|---|---|\n|val nums = Set(1,2,3)|创建一个不可变集(nums.toString返回Set(1,2,3))|\n|nums + 5|添加一个元素(返回Set(1,2,3,5))|\n|nums - 3|移除一个元素(返回Set(1,2))|\n|nums ++ List(5,6)|添加多个元素(返回Set(1,2,3,5,6))|\n|nums -- List(1,2)|移除多个元素(返回Set(3))|\n|nums & Set(1,3,5,7)|获取两个集的交集(返回Set(1,3))|\n|nums.size|返回集的大小(返回3)|\n|nums.contains(3)|检查是否包含(此处返回true)|\n|import scala.collection.mutable|让可变集易于访问|\n|val words = mutable.Set.empty[String]|创建一个空的可变集(words.toString将返回Set())|\n|words += \"the\"|添加一个元素(words.toString将返回Set(the))|\n|words -= \"the\"|移除一个元素，如果这个元素存在(words.toString将返回Set())|\n|words ++= List(\"do\",\"re\",\"mi\")|添加多个元素(words.toString将返回Set(do,re,mi))|\n|words --= List(\"do\",\"re\")|移除多个元素(words.toString将返回Set(mi))|\n|words.clear|移除所有元素(words.toString将返回Set())|\n\n- [更详细的链接](https://docs.scala-lang.org/zh-cn/overviews/collections/sets.html)\n\n## 常用的映射操作\n\n|操作|效果|\n|---|---|\n|val nums = Map(\"i\" -> 1, \"ii\" -> 2)|创建一个不可变映射(nums.toString返回Map(i -> 1, ii -> 2))|\n|nums + (\"vi\" -> 6)|添加一个条目(返回Map(i -> 1, ii -> 2, vi -> 6))|\n|nums - \"ii\"|移除一个条目(返回Map(i -> 1))|\n|nums ++ List(\"iii\" -> 3, \"v\" -> 5)|添加多个条目(返回Map(i -> 1, ii -> 2, iii -> 3, v -> 5))|\n|nums -- List(\"i\",\"ii\")|移除多个条目(返回Map())|\n|nums.size|返回映射的大小(返回2)|\n|nums.contains(\"ii\")|检查是否包含(返回true)|\n|nums(\"ii\")|获取指定键的值(返回2)|\n|nums.keys|返回所有键(返回字符串\"i\"和\"ii\"的Iterable)|\n|nums.keySet|以集的形式返回所有的键(返回Set(i,ii))|\n|nums.values|返回所有的值(返回整数1和2的Iterable)|\n|nums.isEmpty|表示映射是否为空|\n|import scala.collection.mutable|让可变集合易于访问|\n|val words = mutable.Map.empty[String,Int]|创建一个空的可变映射|\n|words += (\"one\" -> 1, \"two\" -> 2, \"three\" -> 3)|添加一个从\"one\"到1的映射条目|\n|words -= \"one\"|移除一个映射条目，如果存在|\n|words ++= List(\"one\" -> 1, \"two\" -> 2, \"three\" -> 3)|添加多个条目|\n|words --= List(\"one\",\"two\")|移除多个条目|\n\n- [更详细的链接](https://docs.scala-lang.org/zh-cn/overviews/collections/maps.html)\n\n## 序列\n\n|操作|说明|\n|---|---|\n|索引和长度的操作 apply、isDefinedAt、length、indices，及lengthCompare|序列的apply操作用于索引访问；因此，Seq[T]类型的序列也是一个以单个Int（索引下标）为参数、返回值类型为T的偏函数。换言之，Seq[T]继承自Partial Function[Int, T]。序列各元素的索引下标从0开始计数，最大索引下标为序列长度减一。序列的length方法是collection的size方法的别名。lengthCompare方法可以比较两个序列的长度，即便其中一个序列长度无限也可以处理。|\n|索引检索操作（indexOf、lastIndexOf、indexofSlice、lastIndexOfSlice、indexWhere、lastIndexWhere、segmentLength、prefixLength）|用于返回等于给定值或满足某个谓词的元素的索引。|\n|加法运算（+:，:+，padTo）|用于在序列的前面或者后面添加一个元素并作为新序列返回。|\n|更新操作（updated，patch）|用于替换原序列的某些元素并作为一个新序列返回。|\n|排序操作（sorted, sortWith, sortBy）|根据不同的条件对序列元素进行排序。|\n|反转操作（reverse, reverseIterator, reverseMap）|用于将序列中的元素以相反的顺序排列。|\n|比较（startsWith, endsWith, contains, containsSlice, corresponds）|用于对两个序列进行比较，或者在序列中查找某个元素。|\n|多集操作（intersect, diff, union, distinct）|用于对两个序列中的元素进行类似集合的操作，或者删除重复元素。|\n\n## Seq类的操作\n\n|WHAT IT IS|WHAT IT DOES|\n|---|---|\n|索引和长度|-----------------------------------|\n|xs(i)|\t(或者写作xs apply i)。xs的第i个元素|\n|xs isDefinedAt i|\t测试xs.indices中是否包含i。|\n|xs.length|序列的长度（同size）。|\n|xs.lengthCompare ys|如果xs的长度小于ys的长度，则返回-1。如果xs的长度大于ys的长度，则返回+1，如果它们长度相等，则返回0。即使其中一个序列是无限的，也可以使用此方法。|\n|xs.indices|xs的索引范围，从0到xs.length - 1。|\n|索引搜索|-----------------------------------|\n|xs indexOf x|返回序列xs中等于x的第一个元素的索引（存在多种变体）。|\n|xs lastIndexOf x|返回序列xs中等于x的最后一个元素的索引（存在多种变体）。|\n|xs indexOfSlice ys|查找子序列ys，返回xs中匹配的第一个索引。|\n|xs indexOfSlice ys|查找子序列ys，返回xs中匹配的倒数一个索引。|\n|xs indexWhere p|xs序列中满足p的第一个元素。（有多种形式）|\n|xs segmentLength (p, i)|xs中，从xs(i)开始并满足条件p的元素的最长连续片段的长度。|\n|xs prefixLength p|xs序列中满足p条件的先头元素的最大个数。|\n|加法|-----------------------------------|\n|x +: xs|由序列xs的前方添加x所得的新序列。|\n|xs :+ x|由序列xs的后方追加x所得的新序列。|\n|xs padTo (len, x)|在xs后方追加x，直到长度达到len后得到的序列。|\n|更新|-----------------------------------|\n|xs patch (i, ys, r)|将xs中第i个元素开始的r个元素，替换为ys所得的序列。|\n|xs updated (i, x)|将xs中第i个元素替换为x后所得的xs的副本。|\n|xs(i) = x|（或写作 xs.update(i, x)，仅适用于可变序列）将xs序列中第i个元素修改为x。|\n|排序|-----------------------------------|\n|xs.sorted|通过使用xs中元素类型的标准顺序，将xs元素进行排序后得到的新序列。|\n|xs sortWith lt|将lt作为比较操作，并以此将xs中的元素进行排序后得到的新序列。|\n|xs sortBy f|将序列xs的元素进行排序后得到的新序列。参与比较的两个元素各自经f函数映射后得到一个结果，通过比较它们的结果来进行排序。|\n|反转|-----------------------------------|\n|xs.reverse|与xs序列元素顺序相反的一个新序列。|\n|xs.reverseIterator|产生序列xs中元素的反序迭代器。|\n|xs reverseMap f|以xs的相反顺序，通过f映射xs序列中的元素得到的新序列。|\n|比较|-----------------------------------|\n|xs startsWith ys|测试序列xs是否以序列ys开头（存在多种形式）。|\n|xs endsWith ys|测试序列xs是否以序列ys结束（存在多种形式）。|\n|xs contains x|测试xs序列中是否存在一个与x相等的元素。|\n|xs containsSlice ys|\t测试xs序列中是否存在一个与ys相同的连续子序列。|\n|(xs corresponds ys)(p)|测试序列xs与序列ys中对应的元素是否满足二元的判断式p。|\n|多集操作|-----------------------------------|\n|xs intersect ys|序列xs和ys的交集，并保留序列xs中的顺序。|\n|xs diff ys|序列xs和ys的差集，并保留序列xs中的顺序。|\n|xs union ys|并集；同xs ++ ys。|\n|xs.distinct|不含重复元素的xs的子序列。|\n\n## Buffer类的操作\n\n|WHAT IT IS|WHAT IT DOES|\n|---|---|\n|加法：|-----------------------------------|\n|buf += x|将元素x追加到buffer，并将buf自身作为结果返回。|\n|buf += (x, y, z)|将给定的元素追加到buffer。|\n|buf ++= xs|将xs中的所有元素追加到buffer。|\n|x +=: buf|将元素x添加到buffer的前方。|\n|xs ++=: buf|将xs中的所有元素都添加到buffer的前方。|\n|buf insert (i, x)|将元素x插入到buffer中索引为i的位置。|\n|buf insertAll (i, xs)|将xs的所有元素都插入到buffer中索引为i的位置。|\n|移除：|-----------------------------------|\n|buf -= x|将元素x从buffer中移除。|\n|buf remove i|将buffer中索引为i的元素移除。|\n|buf remove (i, n)|将buffer中从索引i开始的n个元素移除。|\n|buf trimStart n|移除buffer中的前n个元素。|\n|buf trimEnd n|移除buffer中的后n个元素。|\n|buf.clear()|移除buffer中的所有元素。|\n|克隆：|-----------------------------------|\n|buf.clone|与buf具有相同元素的新buffer。|\n\n## Traversable对象的操作\n\n|WHAT IT IS\t|WHAT IT DOES|\n|---|---|\n|抽象方法：|\t |\n|xs foreach f\t|对xs中的每一个元素执行函数f|\n|加运算（Addition）：|\t |\n|xs ++ ys\t|生成一个由xs和ys中的元素组成容器。ys是一个TraversableOnce容器，即Taversable类型或迭代器。|\n|Maps:\t ||\n|xs map f\t|通过函数xs中的每一个元素调用函数f来生成一个容器。|\n|xs flatMap f\t|通过对容器xs中的每一个元素调用作为容器的值函数f，在把所得的结果连接起来作为一个新的容器。|\n|xs collect f\t|通过对每个xs中的符合定义的元素调用偏函数f，并把结果收集起来生成一个集合。|\n|转换（Conversions）：\t ||\n|xs.toArray\t|把容器转换为一个数组|\n|xs.toList|\t把容器转换为一个list|\n|xs.toIterable|\t把容器转换为一个迭代器。|\n|xs.toSeq\t|把容器转换为一个序列|\n|xs.toIndexedSeq|\t把容器转换为一个索引序列|\n|xs.toStream|\t把容器转换为一个延迟计算的流。|\n|xs.toSet\t|把容器转换为一个集合（Set）。|\n|xs.toMap\t|把由键/值对组成的容器转换为一个映射表（map）。如果该容器并不是以键/值对作为元素的，那么调用这个操作将会导致一个静态类型的错误。|\n|拷贝（Copying）：\t ||\n|xs copyToBuffer buf\t|把容器的所有元素拷贝到buf缓冲区。|\n|xs copyToArray(arr, s, n)|\t拷贝最多n个元素到数组arr的坐标s处。参数s，n是可选项。|\n|大小判断（Size info）：\t ||\n|xs.isEmpty\t|测试容器是否为空。|\n|xs.nonEmpty\t|测试容器是否包含元素。|\n|xs.size\t|计算容器内元素的个数。|\n|xs.hasDefiniteSize\t|如果xs的大小是有限的，则为true。|\n|元素检索（Element Retrieval）：\t ||\n|xs.head\t|返回容器内第一个元素（或其他元素，若当前的容器无序）。|\n|xs.headOption|\txs选项值中的第一个元素，若xs为空则为None。|\n|xs.last\t|返回容器的最后一个元素（或某个元素，如果当前的容器无序的话）。|\n|xs.lastOption\t|xs选项值中的最后一个元素，如果xs为空则为None。|\n|xs find p|\t查找xs中满足p条件的元素，若存在则返回第一个元素；若不存在，则为空。|\n|子容器（Subcollection）：\t||\n|xs.tail|\t返回由除了xs.head外的其余部分。|\n|xs.init|\t返回除xs.last外的其余部分。|\n|xs slice (from, to)|\t返回由xs的一个片段索引中的元素组成的容器（从from到to，但不包括to）。|\n|xs take n\t|由xs的第一个到第n个元素（或当xs无序时任意的n个元素）组成的容器。|\n|xs drop n\t|由除了xs take n以外的元素组成的容器。|\n|xs takeWhile p\t|容器xs中最长能够满足断言p的前缀。|\n|xs dropWhile p\t|容器xs中除了xs takeWhile p以外的全部元素。|\n|xs filter p|\t由xs中满足条件p的元素组成的容器。|\n|xs withFilter p|\t这个容器是一个不太严格的过滤器。子容器调用map，flatMap，foreach和withFilter只适用于xs中那些的满足条件p的元素。|\n|xs filterNot p\t|由xs中不满足条件p的元素组成的容器。|\n|拆分（Subdivision）：\t ||\n|xs splitAt n\t|把xs从指定位置的拆分成两个容器（xs take n和xs drop n）。|\n|xs span p|\t根据一个断言p将xs拆分为两个容器（xs takeWhile p, xs.dropWhile p）。|\n|xs partition p\t|把xs分割为两个容器，符合断言p的元素赋给一个容器，其余的赋给另一个(xs filter p, xs.filterNot p)。|\n|xs groupBy f\t|根据判别函数f把xs拆分一个到容器（collection）的map中。|\n|条件元素（Element Conditions）：\t ||\n|xs forall p|\t返回一个布尔值表示用于表示断言p是否适用xs中的所有元素。|\n|xs exists p\t|返回一个布尔值判断xs中是否有部分元素满足断言p。|\n|xs count p\t|返回xs中符合断言p条件的元素个数。|\n|折叠（Fold）：||\t \n|(z /: xs)(op)|\t在xs中，对由z开始从左到右的连续元素应用二进制运算op。|\n|(xs :\\ z)(op)\t|在xs中，对由z开始从右到左的连续元素应用二进制运算op|\n|xs.foldLeft(z)(op)|\t与(z /: xs)(op)相同。|\n|xs.foldRight(z)(op)|\t与 (xs :\\ z)(op)相同。|\n|xs reduceLeft op\t|非空容器xs中的连续元素从左至右调用二进制运算op。|\n|xs reduceRight op|\t非空容器xs中的连续元素从右至左调用二进制运算op。|\n|特殊折叠（Specific Fold）：\t ||\n|xs.sum\t|返回容器xs中数字元素的和。|\n|xs.product\t|xs返回容器xs中数字元素的积。|\n|xs.min|\t容器xs中有序元素值中的最小值。|\n|xs.max\t|容器xs中有序元素值中的最大值。|\n|字符串（String）：\t||\n|xs addString (b, start, sep, end)|\t把一个字符串加到StringBuilder对象b中，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。|\n|xs mkString (start, sep, end)\t|把容器xs转换为一个字符串，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。|\n|xs.stringPrefix|\t返回一个字符串，该字符串是以容器名开头的xs.toString。|\n|视图（View）：\t ||\n|xs.view|\t通过容器xs生成一个视图。|\n|xs view (from, to)\t|生成一个表示在指定索引范围内的xs元素的视图。|\n\n## Trait Iterable操作\n\n|WHAT IT IS\t|WHAT IT DOES|\n|---|---|\n|抽象方法：\t ||\n|xs.iterator\txs|迭代器生成的每一个元素，以相同的顺序就像foreach一样遍历元素。|\n|其他迭代器：\t ||\n|xs grouped size|\t一个迭代器生成一个固定大小的容器（collection）块。||\n|xs sliding size\t|一个迭代器生成一个固定大小的滑动窗口作为容器（collection）的元素。|\n|子容器（Subcollection）：||\t \n|xs takeRight n\t|一个容器（collection）由xs的最后n个元素组成（或，若定义的元素是无序，则由任意的n个元素组成）。|\n|xs dropRight n\t|一个容器（collection）由除了xs 被取走的（执行过takeRight （）方法）n个元素外的其余元素组成。|\n|拉链方法（Zippers）：\t||\n|xs zip ys|\t把一对容器 xs和ys的包含的元素合成到一个iterabale。|\n|xs zipAll (ys, x, y)\t|一对容器 xs 和ys的相应的元素合并到一个iterable ，实现方式是通过附加的元素x或y，把短的序列被延展到相对更长的一个上。|\n|xs.zip WithIndex\t|把一对容器xs和它的序列，所包含的元素组成一个iterable 。|\n|比对：\t ||\n|xs sameElements ys\t|测试 xs 和 ys 是否以相同的顺序包含相同的元素。|\n\n<br>\n> 最后更新于2018.7.26\n","slug":"2018-07-12-Scala-infos","published":1,"updated":"2018-09-03T13:11:49.120Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j57002s1m0oslzl5qcn","content":"<blockquote>\n<p>仅供查询，禁止转载</p>\n</blockquote>\n<ul>\n<li>一般的Int类型的都可以通过<code>.max</code>和<code>.min</code>获取最大最小元素</li>\n</ul>\n<h2 id=\"List的一些方法和用途\"><a href=\"#List的一些方法和用途\" class=\"headerlink\" title=\"List的一些方法和用途\"></a>List的一些方法和用途</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>List()或者Nil</td>\n<td>表示空列表</td>\n</tr>\n<tr>\n<td>List(“Cool”,”Tools”)</td>\n<td>创建一个新的List[String],包含两个值:”Cool”,”Tools”</td>\n</tr>\n<tr>\n<td>val thrill = “Will”::”Fill”::Nil</td>\n<td>创建一个新的List[String]包含两个值：”Will”和”Fill”</td>\n</tr>\n<tr>\n<td>List(“a”,”b”):::List(“c”,”d”)</td>\n<td>将两个列表拼接起来(返回一个新的列表List(“a”,”b”,”c”,”d”))</td>\n</tr>\n<tr>\n<td>thrill(2)</td>\n<td>返回列表thrill下标为2(从0开始计数)</td>\n</tr>\n<tr>\n<td>thrill.count(s =&gt; s.length == 4)</td>\n<td>对thrill中长度为4的字符串进行计数</td>\n</tr>\n<tr>\n<td>thrill.drop(2)</td>\n<td>返回去掉了thrill的头两个元素的列表</td>\n</tr>\n<tr>\n<td>thrill.dropRight(2)</td>\n<td>返回去掉了thrill后两个元素的列表</td>\n</tr>\n<tr>\n<td>thrill.exists(s =&gt; s==”until”)</td>\n<td>判断thrill中是否有字符串元素的值为”until”，返回值为Boolean</td>\n</tr>\n<tr>\n<td>thrill.filter(s =&gt; s.length == 4)</td>\n<td>按顺序返回列表thrill中所有长度为4的元素列表</td>\n</tr>\n<tr>\n<td>thrill.forall(s =&gt; s.endsWith(“1”))</td>\n<td>表示列表中是否所有元素都以字母”1”结尾</td>\n</tr>\n<tr>\n<td>thrill.foreach(s =&gt; println(s)) / thrill.foreach(println)</td>\n<td>遍历列表执行打印</td>\n</tr>\n<tr>\n<td>thrill.head</td>\n<td>返回列表的首个元素</td>\n</tr>\n<tr>\n<td>thrill.init</td>\n<td>返回列表thrill除最后一个元素之外其他元素组成的列表</td>\n</tr>\n<tr>\n<td>thrill.isEmpty</td>\n<td>判断列表是否为空</td>\n</tr>\n<tr>\n<td>thrill.last</td>\n<td>返回thrill的最后一个元素</td>\n</tr>\n<tr>\n<td>thrill.length</td>\n<td>返回列表的元素个数</td>\n</tr>\n<tr>\n<td>thrill.map(s =&gt; s + “y”)</td>\n<td>返回一个对列表thrill所有字符串元素末尾添加”y”的新字符串列表</td>\n</tr>\n<tr>\n<td>thrill.makeString”, “</td>\n<td>返回用列表thrill的所有元素组合成的字符串，以”, “连接各个元素</td>\n</tr>\n<tr>\n<td>thrill.filterNot(s =&gt; s.length == 4)</td>\n<td>按顺序返回列表中所有长度不为4的元素列表</td>\n</tr>\n<tr>\n<td>thrill.reverse</td>\n<td>返回包含列表thrill的逆序列表</td>\n</tr>\n<tr>\n<td>thrill.sort( (s,t) =&gt; s.charAt(0).toLower &lt; t.charAt(0).toLower)</td>\n<td>返回包含thrill的所有元素，按照首字母小写顺序排序的列表</td>\n</tr>\n<tr>\n<td>thrill.tail</td>\n<td>返回列表thrill除首个元素之外其他元素组成的列表</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"常用的集操作\"><a href=\"#常用的集操作\" class=\"headerlink\" title=\"常用的集操作\"></a>常用的集操作</h2><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>val nums = Set(1,2,3)</td>\n<td>创建一个不可变集(nums.toString返回Set(1,2,3))</td>\n</tr>\n<tr>\n<td>nums + 5</td>\n<td>添加一个元素(返回Set(1,2,3,5))</td>\n</tr>\n<tr>\n<td>nums - 3</td>\n<td>移除一个元素(返回Set(1,2))</td>\n</tr>\n<tr>\n<td>nums ++ List(5,6)</td>\n<td>添加多个元素(返回Set(1,2,3,5,6))</td>\n</tr>\n<tr>\n<td>nums – List(1,2)</td>\n<td>移除多个元素(返回Set(3))</td>\n</tr>\n<tr>\n<td>nums &amp; Set(1,3,5,7)</td>\n<td>获取两个集的交集(返回Set(1,3))</td>\n</tr>\n<tr>\n<td>nums.size</td>\n<td>返回集的大小(返回3)</td>\n</tr>\n<tr>\n<td>nums.contains(3)</td>\n<td>检查是否包含(此处返回true)</td>\n</tr>\n<tr>\n<td>import scala.collection.mutable</td>\n<td>让可变集易于访问</td>\n</tr>\n<tr>\n<td>val words = mutable.Set.empty[String]</td>\n<td>创建一个空的可变集(words.toString将返回Set())</td>\n</tr>\n<tr>\n<td>words += “the”</td>\n<td>添加一个元素(words.toString将返回Set(the))</td>\n</tr>\n<tr>\n<td>words -= “the”</td>\n<td>移除一个元素，如果这个元素存在(words.toString将返回Set())</td>\n</tr>\n<tr>\n<td>words ++= List(“do”,”re”,”mi”)</td>\n<td>添加多个元素(words.toString将返回Set(do,re,mi))</td>\n</tr>\n<tr>\n<td>words –= List(“do”,”re”)</td>\n<td>移除多个元素(words.toString将返回Set(mi))</td>\n</tr>\n<tr>\n<td>words.clear</td>\n<td>移除所有元素(words.toString将返回Set())</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><a href=\"https://docs.scala-lang.org/zh-cn/overviews/collections/sets.html\" target=\"_blank\" rel=\"noopener\">更详细的链接</a></li>\n</ul>\n<h2 id=\"常用的映射操作\"><a href=\"#常用的映射操作\" class=\"headerlink\" title=\"常用的映射操作\"></a>常用的映射操作</h2><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>val nums = Map(“i” -&gt; 1, “ii” -&gt; 2)</td>\n<td>创建一个不可变映射(nums.toString返回Map(i -&gt; 1, ii -&gt; 2))</td>\n</tr>\n<tr>\n<td>nums + (“vi” -&gt; 6)</td>\n<td>添加一个条目(返回Map(i -&gt; 1, ii -&gt; 2, vi -&gt; 6))</td>\n</tr>\n<tr>\n<td>nums - “ii”</td>\n<td>移除一个条目(返回Map(i -&gt; 1))</td>\n</tr>\n<tr>\n<td>nums ++ List(“iii” -&gt; 3, “v” -&gt; 5)</td>\n<td>添加多个条目(返回Map(i -&gt; 1, ii -&gt; 2, iii -&gt; 3, v -&gt; 5))</td>\n</tr>\n<tr>\n<td>nums – List(“i”,”ii”)</td>\n<td>移除多个条目(返回Map())</td>\n</tr>\n<tr>\n<td>nums.size</td>\n<td>返回映射的大小(返回2)</td>\n</tr>\n<tr>\n<td>nums.contains(“ii”)</td>\n<td>检查是否包含(返回true)</td>\n</tr>\n<tr>\n<td>nums(“ii”)</td>\n<td>获取指定键的值(返回2)</td>\n</tr>\n<tr>\n<td>nums.keys</td>\n<td>返回所有键(返回字符串”i”和”ii”的Iterable)</td>\n</tr>\n<tr>\n<td>nums.keySet</td>\n<td>以集的形式返回所有的键(返回Set(i,ii))</td>\n</tr>\n<tr>\n<td>nums.values</td>\n<td>返回所有的值(返回整数1和2的Iterable)</td>\n</tr>\n<tr>\n<td>nums.isEmpty</td>\n<td>表示映射是否为空</td>\n</tr>\n<tr>\n<td>import scala.collection.mutable</td>\n<td>让可变集合易于访问</td>\n</tr>\n<tr>\n<td>val words = mutable.Map.empty[String,Int]</td>\n<td>创建一个空的可变映射</td>\n</tr>\n<tr>\n<td>words += (“one” -&gt; 1, “two” -&gt; 2, “three” -&gt; 3)</td>\n<td>添加一个从”one”到1的映射条目</td>\n</tr>\n<tr>\n<td>words -= “one”</td>\n<td>移除一个映射条目，如果存在</td>\n</tr>\n<tr>\n<td>words ++= List(“one” -&gt; 1, “two” -&gt; 2, “three” -&gt; 3)</td>\n<td>添加多个条目</td>\n</tr>\n<tr>\n<td>words –= List(“one”,”two”)</td>\n<td>移除多个条目</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><a href=\"https://docs.scala-lang.org/zh-cn/overviews/collections/maps.html\" target=\"_blank\" rel=\"noopener\">更详细的链接</a></li>\n</ul>\n<h2 id=\"序列\"><a href=\"#序列\" class=\"headerlink\" title=\"序列\"></a>序列</h2><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>索引和长度的操作 apply、isDefinedAt、length、indices，及lengthCompare</td>\n<td>序列的apply操作用于索引访问；因此，Seq[T]类型的序列也是一个以单个Int（索引下标）为参数、返回值类型为T的偏函数。换言之，Seq[T]继承自Partial Function[Int, T]。序列各元素的索引下标从0开始计数，最大索引下标为序列长度减一。序列的length方法是collection的size方法的别名。lengthCompare方法可以比较两个序列的长度，即便其中一个序列长度无限也可以处理。</td>\n</tr>\n<tr>\n<td>索引检索操作（indexOf、lastIndexOf、indexofSlice、lastIndexOfSlice、indexWhere、lastIndexWhere、segmentLength、prefixLength）</td>\n<td>用于返回等于给定值或满足某个谓词的元素的索引。</td>\n</tr>\n<tr>\n<td>加法运算（+:，:+，padTo）</td>\n<td>用于在序列的前面或者后面添加一个元素并作为新序列返回。</td>\n</tr>\n<tr>\n<td>更新操作（updated，patch）</td>\n<td>用于替换原序列的某些元素并作为一个新序列返回。</td>\n</tr>\n<tr>\n<td>排序操作（sorted, sortWith, sortBy）</td>\n<td>根据不同的条件对序列元素进行排序。</td>\n</tr>\n<tr>\n<td>反转操作（reverse, reverseIterator, reverseMap）</td>\n<td>用于将序列中的元素以相反的顺序排列。</td>\n</tr>\n<tr>\n<td>比较（startsWith, endsWith, contains, containsSlice, corresponds）</td>\n<td>用于对两个序列进行比较，或者在序列中查找某个元素。</td>\n</tr>\n<tr>\n<td>多集操作（intersect, diff, union, distinct）</td>\n<td>用于对两个序列中的元素进行类似集合的操作，或者删除重复元素。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Seq类的操作\"><a href=\"#Seq类的操作\" class=\"headerlink\" title=\"Seq类的操作\"></a>Seq类的操作</h2><table>\n<thead>\n<tr>\n<th>WHAT IT IS</th>\n<th>WHAT IT DOES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>索引和长度</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs(i)</td>\n<td>(或者写作xs apply i)。xs的第i个元素</td>\n</tr>\n<tr>\n<td>xs isDefinedAt i</td>\n<td>测试xs.indices中是否包含i。</td>\n</tr>\n<tr>\n<td>xs.length</td>\n<td>序列的长度（同size）。</td>\n</tr>\n<tr>\n<td>xs.lengthCompare ys</td>\n<td>如果xs的长度小于ys的长度，则返回-1。如果xs的长度大于ys的长度，则返回+1，如果它们长度相等，则返回0。即使其中一个序列是无限的，也可以使用此方法。</td>\n</tr>\n<tr>\n<td>xs.indices</td>\n<td>xs的索引范围，从0到xs.length - 1。</td>\n</tr>\n<tr>\n<td>索引搜索</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs indexOf x</td>\n<td>返回序列xs中等于x的第一个元素的索引（存在多种变体）。</td>\n</tr>\n<tr>\n<td>xs lastIndexOf x</td>\n<td>返回序列xs中等于x的最后一个元素的索引（存在多种变体）。</td>\n</tr>\n<tr>\n<td>xs indexOfSlice ys</td>\n<td>查找子序列ys，返回xs中匹配的第一个索引。</td>\n</tr>\n<tr>\n<td>xs indexOfSlice ys</td>\n<td>查找子序列ys，返回xs中匹配的倒数一个索引。</td>\n</tr>\n<tr>\n<td>xs indexWhere p</td>\n<td>xs序列中满足p的第一个元素。（有多种形式）</td>\n</tr>\n<tr>\n<td>xs segmentLength (p, i)</td>\n<td>xs中，从xs(i)开始并满足条件p的元素的最长连续片段的长度。</td>\n</tr>\n<tr>\n<td>xs prefixLength p</td>\n<td>xs序列中满足p条件的先头元素的最大个数。</td>\n</tr>\n<tr>\n<td>加法</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>x +: xs</td>\n<td>由序列xs的前方添加x所得的新序列。</td>\n</tr>\n<tr>\n<td>xs :+ x</td>\n<td>由序列xs的后方追加x所得的新序列。</td>\n</tr>\n<tr>\n<td>xs padTo (len, x)</td>\n<td>在xs后方追加x，直到长度达到len后得到的序列。</td>\n</tr>\n<tr>\n<td>更新</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs patch (i, ys, r)</td>\n<td>将xs中第i个元素开始的r个元素，替换为ys所得的序列。</td>\n</tr>\n<tr>\n<td>xs updated (i, x)</td>\n<td>将xs中第i个元素替换为x后所得的xs的副本。</td>\n</tr>\n<tr>\n<td>xs(i) = x</td>\n<td>（或写作 xs.update(i, x)，仅适用于可变序列）将xs序列中第i个元素修改为x。</td>\n</tr>\n<tr>\n<td>排序</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs.sorted</td>\n<td>通过使用xs中元素类型的标准顺序，将xs元素进行排序后得到的新序列。</td>\n</tr>\n<tr>\n<td>xs sortWith lt</td>\n<td>将lt作为比较操作，并以此将xs中的元素进行排序后得到的新序列。</td>\n</tr>\n<tr>\n<td>xs sortBy f</td>\n<td>将序列xs的元素进行排序后得到的新序列。参与比较的两个元素各自经f函数映射后得到一个结果，通过比较它们的结果来进行排序。</td>\n</tr>\n<tr>\n<td>反转</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs.reverse</td>\n<td>与xs序列元素顺序相反的一个新序列。</td>\n</tr>\n<tr>\n<td>xs.reverseIterator</td>\n<td>产生序列xs中元素的反序迭代器。</td>\n</tr>\n<tr>\n<td>xs reverseMap f</td>\n<td>以xs的相反顺序，通过f映射xs序列中的元素得到的新序列。</td>\n</tr>\n<tr>\n<td>比较</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs startsWith ys</td>\n<td>测试序列xs是否以序列ys开头（存在多种形式）。</td>\n</tr>\n<tr>\n<td>xs endsWith ys</td>\n<td>测试序列xs是否以序列ys结束（存在多种形式）。</td>\n</tr>\n<tr>\n<td>xs contains x</td>\n<td>测试xs序列中是否存在一个与x相等的元素。</td>\n</tr>\n<tr>\n<td>xs containsSlice ys</td>\n<td>测试xs序列中是否存在一个与ys相同的连续子序列。</td>\n</tr>\n<tr>\n<td>(xs corresponds ys)(p)</td>\n<td>测试序列xs与序列ys中对应的元素是否满足二元的判断式p。</td>\n</tr>\n<tr>\n<td>多集操作</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs intersect ys</td>\n<td>序列xs和ys的交集，并保留序列xs中的顺序。</td>\n</tr>\n<tr>\n<td>xs diff ys</td>\n<td>序列xs和ys的差集，并保留序列xs中的顺序。</td>\n</tr>\n<tr>\n<td>xs union ys</td>\n<td>并集；同xs ++ ys。</td>\n</tr>\n<tr>\n<td>xs.distinct</td>\n<td>不含重复元素的xs的子序列。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Buffer类的操作\"><a href=\"#Buffer类的操作\" class=\"headerlink\" title=\"Buffer类的操作\"></a>Buffer类的操作</h2><table>\n<thead>\n<tr>\n<th>WHAT IT IS</th>\n<th>WHAT IT DOES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>加法：</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>buf += x</td>\n<td>将元素x追加到buffer，并将buf自身作为结果返回。</td>\n</tr>\n<tr>\n<td>buf += (x, y, z)</td>\n<td>将给定的元素追加到buffer。</td>\n</tr>\n<tr>\n<td>buf ++= xs</td>\n<td>将xs中的所有元素追加到buffer。</td>\n</tr>\n<tr>\n<td>x +=: buf</td>\n<td>将元素x添加到buffer的前方。</td>\n</tr>\n<tr>\n<td>xs ++=: buf</td>\n<td>将xs中的所有元素都添加到buffer的前方。</td>\n</tr>\n<tr>\n<td>buf insert (i, x)</td>\n<td>将元素x插入到buffer中索引为i的位置。</td>\n</tr>\n<tr>\n<td>buf insertAll (i, xs)</td>\n<td>将xs的所有元素都插入到buffer中索引为i的位置。</td>\n</tr>\n<tr>\n<td>移除：</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>buf -= x</td>\n<td>将元素x从buffer中移除。</td>\n</tr>\n<tr>\n<td>buf remove i</td>\n<td>将buffer中索引为i的元素移除。</td>\n</tr>\n<tr>\n<td>buf remove (i, n)</td>\n<td>将buffer中从索引i开始的n个元素移除。</td>\n</tr>\n<tr>\n<td>buf trimStart n</td>\n<td>移除buffer中的前n个元素。</td>\n</tr>\n<tr>\n<td>buf trimEnd n</td>\n<td>移除buffer中的后n个元素。</td>\n</tr>\n<tr>\n<td>buf.clear()</td>\n<td>移除buffer中的所有元素。</td>\n</tr>\n<tr>\n<td>克隆：</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>buf.clone</td>\n<td>与buf具有相同元素的新buffer。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Traversable对象的操作\"><a href=\"#Traversable对象的操作\" class=\"headerlink\" title=\"Traversable对象的操作\"></a>Traversable对象的操作</h2><table>\n<thead>\n<tr>\n<th>WHAT IT IS</th>\n<th>WHAT IT DOES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>抽象方法：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs foreach f</td>\n<td>对xs中的每一个元素执行函数f</td>\n</tr>\n<tr>\n<td>加运算（Addition）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs ++ ys</td>\n<td>生成一个由xs和ys中的元素组成容器。ys是一个TraversableOnce容器，即Taversable类型或迭代器。</td>\n</tr>\n<tr>\n<td>Maps:</td>\n<td></td>\n</tr>\n<tr>\n<td>xs map f</td>\n<td>通过函数xs中的每一个元素调用函数f来生成一个容器。</td>\n</tr>\n<tr>\n<td>xs flatMap f</td>\n<td>通过对容器xs中的每一个元素调用作为容器的值函数f，在把所得的结果连接起来作为一个新的容器。</td>\n</tr>\n<tr>\n<td>xs collect f</td>\n<td>通过对每个xs中的符合定义的元素调用偏函数f，并把结果收集起来生成一个集合。</td>\n</tr>\n<tr>\n<td>转换（Conversions）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.toArray</td>\n<td>把容器转换为一个数组</td>\n</tr>\n<tr>\n<td>xs.toList</td>\n<td>把容器转换为一个list</td>\n</tr>\n<tr>\n<td>xs.toIterable</td>\n<td>把容器转换为一个迭代器。</td>\n</tr>\n<tr>\n<td>xs.toSeq</td>\n<td>把容器转换为一个序列</td>\n</tr>\n<tr>\n<td>xs.toIndexedSeq</td>\n<td>把容器转换为一个索引序列</td>\n</tr>\n<tr>\n<td>xs.toStream</td>\n<td>把容器转换为一个延迟计算的流。</td>\n</tr>\n<tr>\n<td>xs.toSet</td>\n<td>把容器转换为一个集合（Set）。</td>\n</tr>\n<tr>\n<td>xs.toMap</td>\n<td>把由键/值对组成的容器转换为一个映射表（map）。如果该容器并不是以键/值对作为元素的，那么调用这个操作将会导致一个静态类型的错误。</td>\n</tr>\n<tr>\n<td>拷贝（Copying）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs copyToBuffer buf</td>\n<td>把容器的所有元素拷贝到buf缓冲区。</td>\n</tr>\n<tr>\n<td>xs copyToArray(arr, s, n)</td>\n<td>拷贝最多n个元素到数组arr的坐标s处。参数s，n是可选项。</td>\n</tr>\n<tr>\n<td>大小判断（Size info）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.isEmpty</td>\n<td>测试容器是否为空。</td>\n</tr>\n<tr>\n<td>xs.nonEmpty</td>\n<td>测试容器是否包含元素。</td>\n</tr>\n<tr>\n<td>xs.size</td>\n<td>计算容器内元素的个数。</td>\n</tr>\n<tr>\n<td>xs.hasDefiniteSize</td>\n<td>如果xs的大小是有限的，则为true。</td>\n</tr>\n<tr>\n<td>元素检索（Element Retrieval）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.head</td>\n<td>返回容器内第一个元素（或其他元素，若当前的容器无序）。</td>\n</tr>\n<tr>\n<td>xs.headOption</td>\n<td>xs选项值中的第一个元素，若xs为空则为None。</td>\n</tr>\n<tr>\n<td>xs.last</td>\n<td>返回容器的最后一个元素（或某个元素，如果当前的容器无序的话）。</td>\n</tr>\n<tr>\n<td>xs.lastOption</td>\n<td>xs选项值中的最后一个元素，如果xs为空则为None。</td>\n</tr>\n<tr>\n<td>xs find p</td>\n<td>查找xs中满足p条件的元素，若存在则返回第一个元素；若不存在，则为空。</td>\n</tr>\n<tr>\n<td>子容器（Subcollection）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.tail</td>\n<td>返回由除了xs.head外的其余部分。</td>\n</tr>\n<tr>\n<td>xs.init</td>\n<td>返回除xs.last外的其余部分。</td>\n</tr>\n<tr>\n<td>xs slice (from, to)</td>\n<td>返回由xs的一个片段索引中的元素组成的容器（从from到to，但不包括to）。</td>\n</tr>\n<tr>\n<td>xs take n</td>\n<td>由xs的第一个到第n个元素（或当xs无序时任意的n个元素）组成的容器。</td>\n</tr>\n<tr>\n<td>xs drop n</td>\n<td>由除了xs take n以外的元素组成的容器。</td>\n</tr>\n<tr>\n<td>xs takeWhile p</td>\n<td>容器xs中最长能够满足断言p的前缀。</td>\n</tr>\n<tr>\n<td>xs dropWhile p</td>\n<td>容器xs中除了xs takeWhile p以外的全部元素。</td>\n</tr>\n<tr>\n<td>xs filter p</td>\n<td>由xs中满足条件p的元素组成的容器。</td>\n</tr>\n<tr>\n<td>xs withFilter p</td>\n<td>这个容器是一个不太严格的过滤器。子容器调用map，flatMap，foreach和withFilter只适用于xs中那些的满足条件p的元素。</td>\n</tr>\n<tr>\n<td>xs filterNot p</td>\n<td>由xs中不满足条件p的元素组成的容器。</td>\n</tr>\n<tr>\n<td>拆分（Subdivision）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs splitAt n</td>\n<td>把xs从指定位置的拆分成两个容器（xs take n和xs drop n）。</td>\n</tr>\n<tr>\n<td>xs span p</td>\n<td>根据一个断言p将xs拆分为两个容器（xs takeWhile p, xs.dropWhile p）。</td>\n</tr>\n<tr>\n<td>xs partition p</td>\n<td>把xs分割为两个容器，符合断言p的元素赋给一个容器，其余的赋给另一个(xs filter p, xs.filterNot p)。</td>\n</tr>\n<tr>\n<td>xs groupBy f</td>\n<td>根据判别函数f把xs拆分一个到容器（collection）的map中。</td>\n</tr>\n<tr>\n<td>条件元素（Element Conditions）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs forall p</td>\n<td>返回一个布尔值表示用于表示断言p是否适用xs中的所有元素。</td>\n</tr>\n<tr>\n<td>xs exists p</td>\n<td>返回一个布尔值判断xs中是否有部分元素满足断言p。</td>\n</tr>\n<tr>\n<td>xs count p</td>\n<td>返回xs中符合断言p条件的元素个数。</td>\n</tr>\n<tr>\n<td>折叠（Fold）：</td>\n<td></td>\n</tr>\n<tr>\n<td>(z /: xs)(op)</td>\n<td>在xs中，对由z开始从左到右的连续元素应用二进制运算op。</td>\n</tr>\n<tr>\n<td>(xs :\\ z)(op)</td>\n<td>在xs中，对由z开始从右到左的连续元素应用二进制运算op</td>\n</tr>\n<tr>\n<td>xs.foldLeft(z)(op)</td>\n<td>与(z /: xs)(op)相同。</td>\n</tr>\n<tr>\n<td>xs.foldRight(z)(op)</td>\n<td>与 (xs :\\ z)(op)相同。</td>\n</tr>\n<tr>\n<td>xs reduceLeft op</td>\n<td>非空容器xs中的连续元素从左至右调用二进制运算op。</td>\n</tr>\n<tr>\n<td>xs reduceRight op</td>\n<td>非空容器xs中的连续元素从右至左调用二进制运算op。</td>\n</tr>\n<tr>\n<td>特殊折叠（Specific Fold）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.sum</td>\n<td>返回容器xs中数字元素的和。</td>\n</tr>\n<tr>\n<td>xs.product</td>\n<td>xs返回容器xs中数字元素的积。</td>\n</tr>\n<tr>\n<td>xs.min</td>\n<td>容器xs中有序元素值中的最小值。</td>\n</tr>\n<tr>\n<td>xs.max</td>\n<td>容器xs中有序元素值中的最大值。</td>\n</tr>\n<tr>\n<td>字符串（String）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs addString (b, start, sep, end)</td>\n<td>把一个字符串加到StringBuilder对象b中，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。</td>\n</tr>\n<tr>\n<td>xs mkString (start, sep, end)</td>\n<td>把容器xs转换为一个字符串，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。</td>\n</tr>\n<tr>\n<td>xs.stringPrefix</td>\n<td>返回一个字符串，该字符串是以容器名开头的xs.toString。</td>\n</tr>\n<tr>\n<td>视图（View）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.view</td>\n<td>通过容器xs生成一个视图。</td>\n</tr>\n<tr>\n<td>xs view (from, to)</td>\n<td>生成一个表示在指定索引范围内的xs元素的视图。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Trait-Iterable操作\"><a href=\"#Trait-Iterable操作\" class=\"headerlink\" title=\"Trait Iterable操作\"></a>Trait Iterable操作</h2><table>\n<thead>\n<tr>\n<th>WHAT IT IS</th>\n<th>WHAT IT DOES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>抽象方法：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.iterator    xs</td>\n<td>迭代器生成的每一个元素，以相同的顺序就像foreach一样遍历元素。</td>\n</tr>\n<tr>\n<td>其他迭代器：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs grouped size</td>\n<td>一个迭代器生成一个固定大小的容器（collection）块。</td>\n<td></td>\n</tr>\n<tr>\n<td>xs sliding size</td>\n<td>一个迭代器生成一个固定大小的滑动窗口作为容器（collection）的元素。</td>\n</tr>\n<tr>\n<td>子容器（Subcollection）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs takeRight n</td>\n<td>一个容器（collection）由xs的最后n个元素组成（或，若定义的元素是无序，则由任意的n个元素组成）。</td>\n</tr>\n<tr>\n<td>xs dropRight n</td>\n<td>一个容器（collection）由除了xs 被取走的（执行过takeRight （）方法）n个元素外的其余元素组成。</td>\n</tr>\n<tr>\n<td>拉链方法（Zippers）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs zip ys</td>\n<td>把一对容器 xs和ys的包含的元素合成到一个iterabale。</td>\n</tr>\n<tr>\n<td>xs zipAll (ys, x, y)</td>\n<td>一对容器 xs 和ys的相应的元素合并到一个iterable ，实现方式是通过附加的元素x或y，把短的序列被延展到相对更长的一个上。</td>\n</tr>\n<tr>\n<td>xs.zip WithIndex</td>\n<td>把一对容器xs和它的序列，所包含的元素组成一个iterable 。</td>\n</tr>\n<tr>\n<td>比对：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs sameElements ys</td>\n<td>测试 xs 和 ys 是否以相同的顺序包含相同的元素。</td>\n</tr>\n</tbody>\n</table>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.26</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>仅供查询，禁止转载</p>\n</blockquote>\n<ul>\n<li>一般的Int类型的都可以通过<code>.max</code>和<code>.min</code>获取最大最小元素</li>\n</ul>\n<h2 id=\"List的一些方法和用途\"><a href=\"#List的一些方法和用途\" class=\"headerlink\" title=\"List的一些方法和用途\"></a>List的一些方法和用途</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>List()或者Nil</td>\n<td>表示空列表</td>\n</tr>\n<tr>\n<td>List(“Cool”,”Tools”)</td>\n<td>创建一个新的List[String],包含两个值:”Cool”,”Tools”</td>\n</tr>\n<tr>\n<td>val thrill = “Will”::”Fill”::Nil</td>\n<td>创建一个新的List[String]包含两个值：”Will”和”Fill”</td>\n</tr>\n<tr>\n<td>List(“a”,”b”):::List(“c”,”d”)</td>\n<td>将两个列表拼接起来(返回一个新的列表List(“a”,”b”,”c”,”d”))</td>\n</tr>\n<tr>\n<td>thrill(2)</td>\n<td>返回列表thrill下标为2(从0开始计数)</td>\n</tr>\n<tr>\n<td>thrill.count(s =&gt; s.length == 4)</td>\n<td>对thrill中长度为4的字符串进行计数</td>\n</tr>\n<tr>\n<td>thrill.drop(2)</td>\n<td>返回去掉了thrill的头两个元素的列表</td>\n</tr>\n<tr>\n<td>thrill.dropRight(2)</td>\n<td>返回去掉了thrill后两个元素的列表</td>\n</tr>\n<tr>\n<td>thrill.exists(s =&gt; s==”until”)</td>\n<td>判断thrill中是否有字符串元素的值为”until”，返回值为Boolean</td>\n</tr>\n<tr>\n<td>thrill.filter(s =&gt; s.length == 4)</td>\n<td>按顺序返回列表thrill中所有长度为4的元素列表</td>\n</tr>\n<tr>\n<td>thrill.forall(s =&gt; s.endsWith(“1”))</td>\n<td>表示列表中是否所有元素都以字母”1”结尾</td>\n</tr>\n<tr>\n<td>thrill.foreach(s =&gt; println(s)) / thrill.foreach(println)</td>\n<td>遍历列表执行打印</td>\n</tr>\n<tr>\n<td>thrill.head</td>\n<td>返回列表的首个元素</td>\n</tr>\n<tr>\n<td>thrill.init</td>\n<td>返回列表thrill除最后一个元素之外其他元素组成的列表</td>\n</tr>\n<tr>\n<td>thrill.isEmpty</td>\n<td>判断列表是否为空</td>\n</tr>\n<tr>\n<td>thrill.last</td>\n<td>返回thrill的最后一个元素</td>\n</tr>\n<tr>\n<td>thrill.length</td>\n<td>返回列表的元素个数</td>\n</tr>\n<tr>\n<td>thrill.map(s =&gt; s + “y”)</td>\n<td>返回一个对列表thrill所有字符串元素末尾添加”y”的新字符串列表</td>\n</tr>\n<tr>\n<td>thrill.makeString”, “</td>\n<td>返回用列表thrill的所有元素组合成的字符串，以”, “连接各个元素</td>\n</tr>\n<tr>\n<td>thrill.filterNot(s =&gt; s.length == 4)</td>\n<td>按顺序返回列表中所有长度不为4的元素列表</td>\n</tr>\n<tr>\n<td>thrill.reverse</td>\n<td>返回包含列表thrill的逆序列表</td>\n</tr>\n<tr>\n<td>thrill.sort( (s,t) =&gt; s.charAt(0).toLower &lt; t.charAt(0).toLower)</td>\n<td>返回包含thrill的所有元素，按照首字母小写顺序排序的列表</td>\n</tr>\n<tr>\n<td>thrill.tail</td>\n<td>返回列表thrill除首个元素之外其他元素组成的列表</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"常用的集操作\"><a href=\"#常用的集操作\" class=\"headerlink\" title=\"常用的集操作\"></a>常用的集操作</h2><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>val nums = Set(1,2,3)</td>\n<td>创建一个不可变集(nums.toString返回Set(1,2,3))</td>\n</tr>\n<tr>\n<td>nums + 5</td>\n<td>添加一个元素(返回Set(1,2,3,5))</td>\n</tr>\n<tr>\n<td>nums - 3</td>\n<td>移除一个元素(返回Set(1,2))</td>\n</tr>\n<tr>\n<td>nums ++ List(5,6)</td>\n<td>添加多个元素(返回Set(1,2,3,5,6))</td>\n</tr>\n<tr>\n<td>nums – List(1,2)</td>\n<td>移除多个元素(返回Set(3))</td>\n</tr>\n<tr>\n<td>nums &amp; Set(1,3,5,7)</td>\n<td>获取两个集的交集(返回Set(1,3))</td>\n</tr>\n<tr>\n<td>nums.size</td>\n<td>返回集的大小(返回3)</td>\n</tr>\n<tr>\n<td>nums.contains(3)</td>\n<td>检查是否包含(此处返回true)</td>\n</tr>\n<tr>\n<td>import scala.collection.mutable</td>\n<td>让可变集易于访问</td>\n</tr>\n<tr>\n<td>val words = mutable.Set.empty[String]</td>\n<td>创建一个空的可变集(words.toString将返回Set())</td>\n</tr>\n<tr>\n<td>words += “the”</td>\n<td>添加一个元素(words.toString将返回Set(the))</td>\n</tr>\n<tr>\n<td>words -= “the”</td>\n<td>移除一个元素，如果这个元素存在(words.toString将返回Set())</td>\n</tr>\n<tr>\n<td>words ++= List(“do”,”re”,”mi”)</td>\n<td>添加多个元素(words.toString将返回Set(do,re,mi))</td>\n</tr>\n<tr>\n<td>words –= List(“do”,”re”)</td>\n<td>移除多个元素(words.toString将返回Set(mi))</td>\n</tr>\n<tr>\n<td>words.clear</td>\n<td>移除所有元素(words.toString将返回Set())</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><a href=\"https://docs.scala-lang.org/zh-cn/overviews/collections/sets.html\" target=\"_blank\" rel=\"noopener\">更详细的链接</a></li>\n</ul>\n<h2 id=\"常用的映射操作\"><a href=\"#常用的映射操作\" class=\"headerlink\" title=\"常用的映射操作\"></a>常用的映射操作</h2><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>val nums = Map(“i” -&gt; 1, “ii” -&gt; 2)</td>\n<td>创建一个不可变映射(nums.toString返回Map(i -&gt; 1, ii -&gt; 2))</td>\n</tr>\n<tr>\n<td>nums + (“vi” -&gt; 6)</td>\n<td>添加一个条目(返回Map(i -&gt; 1, ii -&gt; 2, vi -&gt; 6))</td>\n</tr>\n<tr>\n<td>nums - “ii”</td>\n<td>移除一个条目(返回Map(i -&gt; 1))</td>\n</tr>\n<tr>\n<td>nums ++ List(“iii” -&gt; 3, “v” -&gt; 5)</td>\n<td>添加多个条目(返回Map(i -&gt; 1, ii -&gt; 2, iii -&gt; 3, v -&gt; 5))</td>\n</tr>\n<tr>\n<td>nums – List(“i”,”ii”)</td>\n<td>移除多个条目(返回Map())</td>\n</tr>\n<tr>\n<td>nums.size</td>\n<td>返回映射的大小(返回2)</td>\n</tr>\n<tr>\n<td>nums.contains(“ii”)</td>\n<td>检查是否包含(返回true)</td>\n</tr>\n<tr>\n<td>nums(“ii”)</td>\n<td>获取指定键的值(返回2)</td>\n</tr>\n<tr>\n<td>nums.keys</td>\n<td>返回所有键(返回字符串”i”和”ii”的Iterable)</td>\n</tr>\n<tr>\n<td>nums.keySet</td>\n<td>以集的形式返回所有的键(返回Set(i,ii))</td>\n</tr>\n<tr>\n<td>nums.values</td>\n<td>返回所有的值(返回整数1和2的Iterable)</td>\n</tr>\n<tr>\n<td>nums.isEmpty</td>\n<td>表示映射是否为空</td>\n</tr>\n<tr>\n<td>import scala.collection.mutable</td>\n<td>让可变集合易于访问</td>\n</tr>\n<tr>\n<td>val words = mutable.Map.empty[String,Int]</td>\n<td>创建一个空的可变映射</td>\n</tr>\n<tr>\n<td>words += (“one” -&gt; 1, “two” -&gt; 2, “three” -&gt; 3)</td>\n<td>添加一个从”one”到1的映射条目</td>\n</tr>\n<tr>\n<td>words -= “one”</td>\n<td>移除一个映射条目，如果存在</td>\n</tr>\n<tr>\n<td>words ++= List(“one” -&gt; 1, “two” -&gt; 2, “three” -&gt; 3)</td>\n<td>添加多个条目</td>\n</tr>\n<tr>\n<td>words –= List(“one”,”two”)</td>\n<td>移除多个条目</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><a href=\"https://docs.scala-lang.org/zh-cn/overviews/collections/maps.html\" target=\"_blank\" rel=\"noopener\">更详细的链接</a></li>\n</ul>\n<h2 id=\"序列\"><a href=\"#序列\" class=\"headerlink\" title=\"序列\"></a>序列</h2><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>索引和长度的操作 apply、isDefinedAt、length、indices，及lengthCompare</td>\n<td>序列的apply操作用于索引访问；因此，Seq[T]类型的序列也是一个以单个Int（索引下标）为参数、返回值类型为T的偏函数。换言之，Seq[T]继承自Partial Function[Int, T]。序列各元素的索引下标从0开始计数，最大索引下标为序列长度减一。序列的length方法是collection的size方法的别名。lengthCompare方法可以比较两个序列的长度，即便其中一个序列长度无限也可以处理。</td>\n</tr>\n<tr>\n<td>索引检索操作（indexOf、lastIndexOf、indexofSlice、lastIndexOfSlice、indexWhere、lastIndexWhere、segmentLength、prefixLength）</td>\n<td>用于返回等于给定值或满足某个谓词的元素的索引。</td>\n</tr>\n<tr>\n<td>加法运算（+:，:+，padTo）</td>\n<td>用于在序列的前面或者后面添加一个元素并作为新序列返回。</td>\n</tr>\n<tr>\n<td>更新操作（updated，patch）</td>\n<td>用于替换原序列的某些元素并作为一个新序列返回。</td>\n</tr>\n<tr>\n<td>排序操作（sorted, sortWith, sortBy）</td>\n<td>根据不同的条件对序列元素进行排序。</td>\n</tr>\n<tr>\n<td>反转操作（reverse, reverseIterator, reverseMap）</td>\n<td>用于将序列中的元素以相反的顺序排列。</td>\n</tr>\n<tr>\n<td>比较（startsWith, endsWith, contains, containsSlice, corresponds）</td>\n<td>用于对两个序列进行比较，或者在序列中查找某个元素。</td>\n</tr>\n<tr>\n<td>多集操作（intersect, diff, union, distinct）</td>\n<td>用于对两个序列中的元素进行类似集合的操作，或者删除重复元素。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Seq类的操作\"><a href=\"#Seq类的操作\" class=\"headerlink\" title=\"Seq类的操作\"></a>Seq类的操作</h2><table>\n<thead>\n<tr>\n<th>WHAT IT IS</th>\n<th>WHAT IT DOES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>索引和长度</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs(i)</td>\n<td>(或者写作xs apply i)。xs的第i个元素</td>\n</tr>\n<tr>\n<td>xs isDefinedAt i</td>\n<td>测试xs.indices中是否包含i。</td>\n</tr>\n<tr>\n<td>xs.length</td>\n<td>序列的长度（同size）。</td>\n</tr>\n<tr>\n<td>xs.lengthCompare ys</td>\n<td>如果xs的长度小于ys的长度，则返回-1。如果xs的长度大于ys的长度，则返回+1，如果它们长度相等，则返回0。即使其中一个序列是无限的，也可以使用此方法。</td>\n</tr>\n<tr>\n<td>xs.indices</td>\n<td>xs的索引范围，从0到xs.length - 1。</td>\n</tr>\n<tr>\n<td>索引搜索</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs indexOf x</td>\n<td>返回序列xs中等于x的第一个元素的索引（存在多种变体）。</td>\n</tr>\n<tr>\n<td>xs lastIndexOf x</td>\n<td>返回序列xs中等于x的最后一个元素的索引（存在多种变体）。</td>\n</tr>\n<tr>\n<td>xs indexOfSlice ys</td>\n<td>查找子序列ys，返回xs中匹配的第一个索引。</td>\n</tr>\n<tr>\n<td>xs indexOfSlice ys</td>\n<td>查找子序列ys，返回xs中匹配的倒数一个索引。</td>\n</tr>\n<tr>\n<td>xs indexWhere p</td>\n<td>xs序列中满足p的第一个元素。（有多种形式）</td>\n</tr>\n<tr>\n<td>xs segmentLength (p, i)</td>\n<td>xs中，从xs(i)开始并满足条件p的元素的最长连续片段的长度。</td>\n</tr>\n<tr>\n<td>xs prefixLength p</td>\n<td>xs序列中满足p条件的先头元素的最大个数。</td>\n</tr>\n<tr>\n<td>加法</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>x +: xs</td>\n<td>由序列xs的前方添加x所得的新序列。</td>\n</tr>\n<tr>\n<td>xs :+ x</td>\n<td>由序列xs的后方追加x所得的新序列。</td>\n</tr>\n<tr>\n<td>xs padTo (len, x)</td>\n<td>在xs后方追加x，直到长度达到len后得到的序列。</td>\n</tr>\n<tr>\n<td>更新</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs patch (i, ys, r)</td>\n<td>将xs中第i个元素开始的r个元素，替换为ys所得的序列。</td>\n</tr>\n<tr>\n<td>xs updated (i, x)</td>\n<td>将xs中第i个元素替换为x后所得的xs的副本。</td>\n</tr>\n<tr>\n<td>xs(i) = x</td>\n<td>（或写作 xs.update(i, x)，仅适用于可变序列）将xs序列中第i个元素修改为x。</td>\n</tr>\n<tr>\n<td>排序</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs.sorted</td>\n<td>通过使用xs中元素类型的标准顺序，将xs元素进行排序后得到的新序列。</td>\n</tr>\n<tr>\n<td>xs sortWith lt</td>\n<td>将lt作为比较操作，并以此将xs中的元素进行排序后得到的新序列。</td>\n</tr>\n<tr>\n<td>xs sortBy f</td>\n<td>将序列xs的元素进行排序后得到的新序列。参与比较的两个元素各自经f函数映射后得到一个结果，通过比较它们的结果来进行排序。</td>\n</tr>\n<tr>\n<td>反转</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs.reverse</td>\n<td>与xs序列元素顺序相反的一个新序列。</td>\n</tr>\n<tr>\n<td>xs.reverseIterator</td>\n<td>产生序列xs中元素的反序迭代器。</td>\n</tr>\n<tr>\n<td>xs reverseMap f</td>\n<td>以xs的相反顺序，通过f映射xs序列中的元素得到的新序列。</td>\n</tr>\n<tr>\n<td>比较</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs startsWith ys</td>\n<td>测试序列xs是否以序列ys开头（存在多种形式）。</td>\n</tr>\n<tr>\n<td>xs endsWith ys</td>\n<td>测试序列xs是否以序列ys结束（存在多种形式）。</td>\n</tr>\n<tr>\n<td>xs contains x</td>\n<td>测试xs序列中是否存在一个与x相等的元素。</td>\n</tr>\n<tr>\n<td>xs containsSlice ys</td>\n<td>测试xs序列中是否存在一个与ys相同的连续子序列。</td>\n</tr>\n<tr>\n<td>(xs corresponds ys)(p)</td>\n<td>测试序列xs与序列ys中对应的元素是否满足二元的判断式p。</td>\n</tr>\n<tr>\n<td>多集操作</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>xs intersect ys</td>\n<td>序列xs和ys的交集，并保留序列xs中的顺序。</td>\n</tr>\n<tr>\n<td>xs diff ys</td>\n<td>序列xs和ys的差集，并保留序列xs中的顺序。</td>\n</tr>\n<tr>\n<td>xs union ys</td>\n<td>并集；同xs ++ ys。</td>\n</tr>\n<tr>\n<td>xs.distinct</td>\n<td>不含重复元素的xs的子序列。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Buffer类的操作\"><a href=\"#Buffer类的操作\" class=\"headerlink\" title=\"Buffer类的操作\"></a>Buffer类的操作</h2><table>\n<thead>\n<tr>\n<th>WHAT IT IS</th>\n<th>WHAT IT DOES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>加法：</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>buf += x</td>\n<td>将元素x追加到buffer，并将buf自身作为结果返回。</td>\n</tr>\n<tr>\n<td>buf += (x, y, z)</td>\n<td>将给定的元素追加到buffer。</td>\n</tr>\n<tr>\n<td>buf ++= xs</td>\n<td>将xs中的所有元素追加到buffer。</td>\n</tr>\n<tr>\n<td>x +=: buf</td>\n<td>将元素x添加到buffer的前方。</td>\n</tr>\n<tr>\n<td>xs ++=: buf</td>\n<td>将xs中的所有元素都添加到buffer的前方。</td>\n</tr>\n<tr>\n<td>buf insert (i, x)</td>\n<td>将元素x插入到buffer中索引为i的位置。</td>\n</tr>\n<tr>\n<td>buf insertAll (i, xs)</td>\n<td>将xs的所有元素都插入到buffer中索引为i的位置。</td>\n</tr>\n<tr>\n<td>移除：</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>buf -= x</td>\n<td>将元素x从buffer中移除。</td>\n</tr>\n<tr>\n<td>buf remove i</td>\n<td>将buffer中索引为i的元素移除。</td>\n</tr>\n<tr>\n<td>buf remove (i, n)</td>\n<td>将buffer中从索引i开始的n个元素移除。</td>\n</tr>\n<tr>\n<td>buf trimStart n</td>\n<td>移除buffer中的前n个元素。</td>\n</tr>\n<tr>\n<td>buf trimEnd n</td>\n<td>移除buffer中的后n个元素。</td>\n</tr>\n<tr>\n<td>buf.clear()</td>\n<td>移除buffer中的所有元素。</td>\n</tr>\n<tr>\n<td>克隆：</td>\n<td>———————————–</td>\n</tr>\n<tr>\n<td>buf.clone</td>\n<td>与buf具有相同元素的新buffer。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Traversable对象的操作\"><a href=\"#Traversable对象的操作\" class=\"headerlink\" title=\"Traversable对象的操作\"></a>Traversable对象的操作</h2><table>\n<thead>\n<tr>\n<th>WHAT IT IS</th>\n<th>WHAT IT DOES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>抽象方法：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs foreach f</td>\n<td>对xs中的每一个元素执行函数f</td>\n</tr>\n<tr>\n<td>加运算（Addition）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs ++ ys</td>\n<td>生成一个由xs和ys中的元素组成容器。ys是一个TraversableOnce容器，即Taversable类型或迭代器。</td>\n</tr>\n<tr>\n<td>Maps:</td>\n<td></td>\n</tr>\n<tr>\n<td>xs map f</td>\n<td>通过函数xs中的每一个元素调用函数f来生成一个容器。</td>\n</tr>\n<tr>\n<td>xs flatMap f</td>\n<td>通过对容器xs中的每一个元素调用作为容器的值函数f，在把所得的结果连接起来作为一个新的容器。</td>\n</tr>\n<tr>\n<td>xs collect f</td>\n<td>通过对每个xs中的符合定义的元素调用偏函数f，并把结果收集起来生成一个集合。</td>\n</tr>\n<tr>\n<td>转换（Conversions）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.toArray</td>\n<td>把容器转换为一个数组</td>\n</tr>\n<tr>\n<td>xs.toList</td>\n<td>把容器转换为一个list</td>\n</tr>\n<tr>\n<td>xs.toIterable</td>\n<td>把容器转换为一个迭代器。</td>\n</tr>\n<tr>\n<td>xs.toSeq</td>\n<td>把容器转换为一个序列</td>\n</tr>\n<tr>\n<td>xs.toIndexedSeq</td>\n<td>把容器转换为一个索引序列</td>\n</tr>\n<tr>\n<td>xs.toStream</td>\n<td>把容器转换为一个延迟计算的流。</td>\n</tr>\n<tr>\n<td>xs.toSet</td>\n<td>把容器转换为一个集合（Set）。</td>\n</tr>\n<tr>\n<td>xs.toMap</td>\n<td>把由键/值对组成的容器转换为一个映射表（map）。如果该容器并不是以键/值对作为元素的，那么调用这个操作将会导致一个静态类型的错误。</td>\n</tr>\n<tr>\n<td>拷贝（Copying）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs copyToBuffer buf</td>\n<td>把容器的所有元素拷贝到buf缓冲区。</td>\n</tr>\n<tr>\n<td>xs copyToArray(arr, s, n)</td>\n<td>拷贝最多n个元素到数组arr的坐标s处。参数s，n是可选项。</td>\n</tr>\n<tr>\n<td>大小判断（Size info）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.isEmpty</td>\n<td>测试容器是否为空。</td>\n</tr>\n<tr>\n<td>xs.nonEmpty</td>\n<td>测试容器是否包含元素。</td>\n</tr>\n<tr>\n<td>xs.size</td>\n<td>计算容器内元素的个数。</td>\n</tr>\n<tr>\n<td>xs.hasDefiniteSize</td>\n<td>如果xs的大小是有限的，则为true。</td>\n</tr>\n<tr>\n<td>元素检索（Element Retrieval）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.head</td>\n<td>返回容器内第一个元素（或其他元素，若当前的容器无序）。</td>\n</tr>\n<tr>\n<td>xs.headOption</td>\n<td>xs选项值中的第一个元素，若xs为空则为None。</td>\n</tr>\n<tr>\n<td>xs.last</td>\n<td>返回容器的最后一个元素（或某个元素，如果当前的容器无序的话）。</td>\n</tr>\n<tr>\n<td>xs.lastOption</td>\n<td>xs选项值中的最后一个元素，如果xs为空则为None。</td>\n</tr>\n<tr>\n<td>xs find p</td>\n<td>查找xs中满足p条件的元素，若存在则返回第一个元素；若不存在，则为空。</td>\n</tr>\n<tr>\n<td>子容器（Subcollection）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.tail</td>\n<td>返回由除了xs.head外的其余部分。</td>\n</tr>\n<tr>\n<td>xs.init</td>\n<td>返回除xs.last外的其余部分。</td>\n</tr>\n<tr>\n<td>xs slice (from, to)</td>\n<td>返回由xs的一个片段索引中的元素组成的容器（从from到to，但不包括to）。</td>\n</tr>\n<tr>\n<td>xs take n</td>\n<td>由xs的第一个到第n个元素（或当xs无序时任意的n个元素）组成的容器。</td>\n</tr>\n<tr>\n<td>xs drop n</td>\n<td>由除了xs take n以外的元素组成的容器。</td>\n</tr>\n<tr>\n<td>xs takeWhile p</td>\n<td>容器xs中最长能够满足断言p的前缀。</td>\n</tr>\n<tr>\n<td>xs dropWhile p</td>\n<td>容器xs中除了xs takeWhile p以外的全部元素。</td>\n</tr>\n<tr>\n<td>xs filter p</td>\n<td>由xs中满足条件p的元素组成的容器。</td>\n</tr>\n<tr>\n<td>xs withFilter p</td>\n<td>这个容器是一个不太严格的过滤器。子容器调用map，flatMap，foreach和withFilter只适用于xs中那些的满足条件p的元素。</td>\n</tr>\n<tr>\n<td>xs filterNot p</td>\n<td>由xs中不满足条件p的元素组成的容器。</td>\n</tr>\n<tr>\n<td>拆分（Subdivision）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs splitAt n</td>\n<td>把xs从指定位置的拆分成两个容器（xs take n和xs drop n）。</td>\n</tr>\n<tr>\n<td>xs span p</td>\n<td>根据一个断言p将xs拆分为两个容器（xs takeWhile p, xs.dropWhile p）。</td>\n</tr>\n<tr>\n<td>xs partition p</td>\n<td>把xs分割为两个容器，符合断言p的元素赋给一个容器，其余的赋给另一个(xs filter p, xs.filterNot p)。</td>\n</tr>\n<tr>\n<td>xs groupBy f</td>\n<td>根据判别函数f把xs拆分一个到容器（collection）的map中。</td>\n</tr>\n<tr>\n<td>条件元素（Element Conditions）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs forall p</td>\n<td>返回一个布尔值表示用于表示断言p是否适用xs中的所有元素。</td>\n</tr>\n<tr>\n<td>xs exists p</td>\n<td>返回一个布尔值判断xs中是否有部分元素满足断言p。</td>\n</tr>\n<tr>\n<td>xs count p</td>\n<td>返回xs中符合断言p条件的元素个数。</td>\n</tr>\n<tr>\n<td>折叠（Fold）：</td>\n<td></td>\n</tr>\n<tr>\n<td>(z /: xs)(op)</td>\n<td>在xs中，对由z开始从左到右的连续元素应用二进制运算op。</td>\n</tr>\n<tr>\n<td>(xs :\\ z)(op)</td>\n<td>在xs中，对由z开始从右到左的连续元素应用二进制运算op</td>\n</tr>\n<tr>\n<td>xs.foldLeft(z)(op)</td>\n<td>与(z /: xs)(op)相同。</td>\n</tr>\n<tr>\n<td>xs.foldRight(z)(op)</td>\n<td>与 (xs :\\ z)(op)相同。</td>\n</tr>\n<tr>\n<td>xs reduceLeft op</td>\n<td>非空容器xs中的连续元素从左至右调用二进制运算op。</td>\n</tr>\n<tr>\n<td>xs reduceRight op</td>\n<td>非空容器xs中的连续元素从右至左调用二进制运算op。</td>\n</tr>\n<tr>\n<td>特殊折叠（Specific Fold）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.sum</td>\n<td>返回容器xs中数字元素的和。</td>\n</tr>\n<tr>\n<td>xs.product</td>\n<td>xs返回容器xs中数字元素的积。</td>\n</tr>\n<tr>\n<td>xs.min</td>\n<td>容器xs中有序元素值中的最小值。</td>\n</tr>\n<tr>\n<td>xs.max</td>\n<td>容器xs中有序元素值中的最大值。</td>\n</tr>\n<tr>\n<td>字符串（String）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs addString (b, start, sep, end)</td>\n<td>把一个字符串加到StringBuilder对象b中，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。</td>\n</tr>\n<tr>\n<td>xs mkString (start, sep, end)</td>\n<td>把容器xs转换为一个字符串，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。</td>\n</tr>\n<tr>\n<td>xs.stringPrefix</td>\n<td>返回一个字符串，该字符串是以容器名开头的xs.toString。</td>\n</tr>\n<tr>\n<td>视图（View）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.view</td>\n<td>通过容器xs生成一个视图。</td>\n</tr>\n<tr>\n<td>xs view (from, to)</td>\n<td>生成一个表示在指定索引范围内的xs元素的视图。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Trait-Iterable操作\"><a href=\"#Trait-Iterable操作\" class=\"headerlink\" title=\"Trait Iterable操作\"></a>Trait Iterable操作</h2><table>\n<thead>\n<tr>\n<th>WHAT IT IS</th>\n<th>WHAT IT DOES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>抽象方法：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs.iterator    xs</td>\n<td>迭代器生成的每一个元素，以相同的顺序就像foreach一样遍历元素。</td>\n</tr>\n<tr>\n<td>其他迭代器：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs grouped size</td>\n<td>一个迭代器生成一个固定大小的容器（collection）块。</td>\n<td></td>\n</tr>\n<tr>\n<td>xs sliding size</td>\n<td>一个迭代器生成一个固定大小的滑动窗口作为容器（collection）的元素。</td>\n</tr>\n<tr>\n<td>子容器（Subcollection）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs takeRight n</td>\n<td>一个容器（collection）由xs的最后n个元素组成（或，若定义的元素是无序，则由任意的n个元素组成）。</td>\n</tr>\n<tr>\n<td>xs dropRight n</td>\n<td>一个容器（collection）由除了xs 被取走的（执行过takeRight （）方法）n个元素外的其余元素组成。</td>\n</tr>\n<tr>\n<td>拉链方法（Zippers）：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs zip ys</td>\n<td>把一对容器 xs和ys的包含的元素合成到一个iterabale。</td>\n</tr>\n<tr>\n<td>xs zipAll (ys, x, y)</td>\n<td>一对容器 xs 和ys的相应的元素合并到一个iterable ，实现方式是通过附加的元素x或y，把短的序列被延展到相对更长的一个上。</td>\n</tr>\n<tr>\n<td>xs.zip WithIndex</td>\n<td>把一对容器xs和它的序列，所包含的元素组成一个iterable 。</td>\n</tr>\n<tr>\n<td>比对：</td>\n<td></td>\n</tr>\n<tr>\n<td>xs sameElements ys</td>\n<td>测试 xs 和 ys 是否以相同的顺序包含相同的元素。</td>\n</tr>\n</tbody>\n</table>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.26</p>\n</blockquote>\n"},{"layout":"post","title":"《Scala编程》阅读记录——入门部分","date":"2018-07-12T13:40:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n## 入门\n---\n\n- scala是一门函数式编程语言,同时也是面向对象的\n\n- 函数值就是对象\n\n- scala对面向对象的实现是纯的：每个值都是对象，每个操作都是方法调用\n\n- 例如，两个Int类型的相加（注意scala里所有的数据类型首字母都是大写，这说明了他们都是类），+实际上是调用了一个名为+的方法\n\n### 函数式编程以两大核心概念为指导：\n\n- (1)函数是一等的值：函数值可以作为参数传递给其他函数，可以作为返回值，可以保存在一个变量里。还可以在一个函数里定义另一个函数，就像在函数里定义一个整数一样。也可以在定义函数时不指定名字。\n\n- (2)程序中的操作应该将输入值映射成输出值，而不是当场修改数据。例如Java对String的修改就是生成了一个新的String对象而原先的String不变。这个理念的另一种表述就是函数不应该有副作用(sideeffect)。方法只能通过接受入参数和返回结果这两种方式与外部通信，即参数本身不会被修改，这样的方法被称为是“指称透明的”。\n函数式编程鼓励不可变的数据结构和指称透明的方法。\n\n- Scala可以选择使用指令式编程的方法，即使用可变数据和副作用编程。但是推荐使用函数式编程。\n\n- scala定义类的简便的写法： `class MyClass(index: Int, name:String)`这样scala编译器就会产生带有两个 **私有** 实例变量和一个接受这两个变量初始值的参数的构造方法类\n\n- 假设name是一个String 类型的变量\n`val IfHasUpperCase = name.exists(_.isUpper)`\n\n- 这段代码实现了判断name中是否存在大写字母，并赋值给IfHasUpperCase这个Boolean类型的变量(scala赋值时如果不明确写出变量类型，则编译器会自动判断)\n\n- scala代码将字符串当做更高级的字符序列(sequence) 来处理，用 前提(predicate) 来处理\n\n- 这里的 前提 `_.isUpper` 是scala的函数字面量(当函数字面量的结果类型是Boolean时，可以被称作前提)。它描述了一个接受 **字符** 作为 **入参(以下划线表示)**，判断该字符是否为大写字母的函数。\n\n- 布尔值不能和整数相加\n\n- scala几乎所有语法结构都支持嵌套\n\n- scala输出： `println(\"....\")`\n\n- 注意编译器不会推断函数参数的类型，因此函数中参数的数据类型要显式地写出\n\n- scala函数形式：\n```\ndef FuncName(x:Int, y:Int): Int = {\n\tif(...){..}\n\telse{..}\n\tx\n}\n```\n- 注意函数结果类型前面的冒号不能省（这里函数的格式实际山是与变量保持一致的，即类型跟在冒号后面）\n\n- scala的函数会将函数体里的最后一条语句的值作为函数的返回值（例子里的函数将x的值返回）\n\n- 大多数时候函数的结果类型不需要显式地给出。但是递归函数必须显式地给出结果类型\n\n\n- scala表达式`if(x>y) x else y`的行为，与Java里的`(x>y)? x:y`的含义一致\n\n- 编译scala脚本：`scala hello.scala`\n\n- 命令行参数可以通过名为args的scala数组来获取：`println(\"Hello \" + args(0) + \"!\")`\n\n- 然后执行： `$ scala hello.scala planet  //其中planet被当做参数传入`\n\n- 结果： `Hello planet!`\n\n- 尽量少用for 和 while 循环\n\n### foreach遍历\n\n- 打印每一个命令行参数的方式：args.foreach(arg => println(arg))\n这段代码中，对args执行foreach方法，传入一个函数。本例中传入的是一个函数字面量(function literal)\n\n- 这个(匿名)函数接受一个名为arg的参数(arg仅仅是参数名没有别的特殊含义)\n上面也可以指明类型名(这样需要将参数的部分包在圆括号里，这是函数字面量的常规语法)：`args.foreach((arg:String) => println(arg))`\n\n- scala函数字面量语法： `(x:Int, y: Int) => x + y`\n其中从左到右，括号中的是参数部分，然后是右箭头，最右边是函数体\n\n- scala对函数字面量还有一个特殊的简写规则：如果函数字面量只是一个接收单个参数的语句，可以不必给出参数名和参数本身。\n因此上例可以写为：`args.foreach(println)`\n\n\n- scala只支持指令式的for语句的函数式亲戚。*for表达式*\n- for表达式一个简单的例子：\n```\n\tfor(arg <- args)\n\t    println(arg)\n```\n\n- 其中，位于 `<-` 符号右边的，是args数组，在 `<-` 左边的是一个 val变量的名字，为arg。\n注意左边的这个变量一定是 val类型 的(即它不能在for表达式循环体里被重新赋值)，并且只能写为 `arg` 而不能写成 `val arg`\n\n### 用类型参数化数组\n\n- 在scala中，可以用new来实例化对象或类的实例，当实例化对象时，可以用值和类型来对其进行参数化(parameterize)\n\n- 参数化的意思是：在创建实例的时候对实例做\"配置\"，可以用值来参数化一个实例，做法是在构造方法的括号中传入对象参数。\n\n- 参数化创建数组：\n```\n\tval myArr = new Array[String](3)\n\tmyArr(0) = ...\n\tmyArr(1) = ...\n\tmyArr(2) = ...\n```\n\n- 另一种创建方法： `val numArr = Array(\"zero\",\"one\",\"two\")`\n\n- 这实际上是调用了一个名为apply的工厂方法，这个方法创建并返回了新的数组。这个apply方法接受一个变长的参数列表。\n\n\n- scala数组使用 **圆括号** 来访问元素而不是方括号，原因(原文)：\n\t>数组不过是类的实例，这一点跟其他scala的实例没有本质区别。当你用一组圆括号讲一个或多个值包起来，并将其应用(apply)到某个对象时，scala会将这段代码转换成对这个对象的一个名为apply的方法调用。因此myArray(i)实际上就是myArray.apply(i)。因此，在scala中访问一个数组的元素就是一个简单的方法调用。\n\n- scala将从数组到表达式的一切都当做带有方法的对象来处理，由此来实现概念是的简单化。不需要记住各种特例。同时，这种统一并不会带来显著的性能开销。因为scala在编译代码时，会尽可能使用Java数组、基本类型和原生的算术指令。\n\n### 使用列表\n- scala的列表(list)是不可变的(数组虽然不能更改长度，但是元素是可以改变的，因此是可变的)\n因此list的修改有点像Java的字符串，每次对其中元素的修改都会返回一个新的list对象。\n\n- 不需要写 `new List`，因为scala.List的伴生对象上定义了一个工厂方法`List.apply()`\n\n- 列表上用的最多的操作是 `::`，读作\"cons\"。它是在一个已有的列表最前面添加一个新元素，并返回这个新的列表。\n例：\n```\n\tval twoThree = List(2,3)\n\tval oneTwoThree = 1 :: twoThree\n\tprintln(onTwoThree)\n```\n结果： `List(1,2,3)`\n\n- 注意：在表达式`1::twoThree`中，`::`是它右操作元的方法。（一般用在操作符表示法的方法都是左结合的，例如 `a * b`相当于 `a.*(b)` ) 除非方法名是以 `:` 结尾的，那么这个方法的调用就会发生在他的右操作元上。 因此上例相当于： `twoThree.::(1)`，1是作为参数传入的。\n\n- 表示空列表的快捷方式是`Nil`，初始化一个新的列表的另一种方式是用`::`将元素串接起来，并将Nil作为最后一个元素。例如：\n```\nval oneTwoThree = 1 :: 2 :: 3 :: Nil\nprintln(oneTwoThree)\n```\n\n- `:::`连接两个List：\n```\nval a = List(1)\nval b = List(2,3)\nval c = a ::: b   //c: List(1,2,3)\n```\n\n- 列表也有从末尾增加元素的方法，但是应当尽力避免这种写法，因为末尾追加元素的操作所需时间随列表的大小线性增加，而使用`::`只需要常量级的时间。\n\n- 可以通过在头部添加元素的方法，最后调用reverse方法来实现末尾添加的效果\n\n- 也可以使用ListBuffer，这是个可变列表，支持追加操作，最后使用toList方法即可转换为List\n\n### 使用元祖\n\n- 元祖也是不可变的，但是元祖可以容纳不同类型的元素。\n\n- 当需要从方法返回多个对象时，元祖就非常有用\n\n- 实例化一个元祖非常简单，只要将对象放在圆括号当中，用逗号隔开即可\n\n- 一旦实例化好一个元祖，就可以用英文句点、下划线和 **从1开始** 的序号来访问每一个元素。\n\n- 例如：\n```\nval pair = (99,\"test\")\npritln(pair._1)\t\t//访问第一个元素\nprintln(pair._2)\t//访问第二个元素\n```\n\n- 元祖的实际类型取决于它的元素。例如：`(99,\"test\")`的类型为`Tuple2[Int,String]`,而元祖`('u','r',\"the\",1,4,\"me\")`的类型是`Tuple6[Char,Char,String,Int,Int,String]`\n\n- 元祖为什么不能像数组一样用圆括号来访问元素(原文)：\n> 你也许正好奇问什么不能像访问列表元素，也就是“pair(0)”那样访问元祖元素。背后的原因是列表的apply方法永远**只返回同一种类型**，但元祖里的元素可以是不同类型的：`_1`可能是一种类型，`_2`可能是另一种\n\n### 使用集和映射\n\n- scala的API包含了一个基础的特质(trait)来表示集，这里的特质跟Java的接口定义类似\n\n- scala提供了两个子特质：一个表示可变集，一个表示不可变集。(可变集与不可变集位于不同的包)\n\n- 创建一个集合的例子：\n```\nvar jetSet = Set(\"Boeing\",\"Airbus\")\njetSet += \"Lear\"\nprintln(jetSet.contains(\"Cessna\"))\n```\n- 第一行代码表示，可以像创建列表和数组那样创建集：通过调用Set伴生对象的apply工厂方法。\n\n- 在这个例子中，实际上调用了scala.collection.immutable.Set的伴生对象的apply方法，返回一个默认的、**不可变** 的Set对象，类型为`Set[String]`\n\n- 向集添加元素需要调用`+`方法。无论是可变集还是不可变集，`+`方法都会创建并返回一个新的集\n\n- 而本例中的`+=`方法，实际上不可变集并不提供这个方法，其本质上是`jetSet = jetSet + ”Lear\"`的简写。因此，**其本质上是将jetSet这个var重新赋值成了一个包含三个元素的新的集**\n\n- 最后一行是打印集中是否包含\"Cessna\"这个元素，结果应当是`false`\n\n### 可变集\n\n- 使用可变集需要一次引入，例：\n```\nimport scala.collection.mutable\nval movieSet = mutable.Set(\"Hitch\",\"Peter\")\nmovieSet += \"Shrek\"\nprintln(movieSet)\n```\n- 通过import语句，可以使用简短的`mutable.Set()`而不是`scala.colection.mutable.Set()`这样完整的句子\n\n- 这里的`+=`方法在可变集里是有定义的，因此这个可变集声明时用的是 `val`而不是 `var`(上面也提到了不可变集实际上是被重新赋值了，如果使用`val`会编译报错)\n\n- `HashSet`的用法与`Set`一致，只是`HashSet`的存储方式不同，因此一般在需要考虑性能的地方会用到`HashSet`\n\n### 映射(Map)\n\n- 与Set类似，Map也有可变与不可变的版本。\n\n- 例子：\n```\nimport scala.collection.mutable\nval treasureMap = mutable.Map[Int,String]()\ntreasureMap += (1 -> \"Go to island\")\ntreasureMap += (2 -> \"Find big X on ground\")\ntreasureMap += (3 -> \"Dig\")\nprintln(treasureMap(2))\n```\n\n- 上面的例子引入了可变Map(默认为不可变映射)，这里与上面可变集一样，定义为val类型。接下来，使用`->`来定义键值对。这里scala会将二元操作，比如`1 -> \"Go to island\"`转换为标准的方法调用，即`(1).->(\"Go to island\")`，这里`\"Go to island\"`是方法`->`的参数。\n\n- 可以对任何对象调用`->`方法，它将返回包含键和值两个元素的元组。\n\n- 若要获取Map里的某个键的值，如上面代码的最后一行`treasureMap(2)`将返回`2`这个键对应的值。\n\n### 函数式编程风格\n\n- 如果一段代码避免了使用`var`(也就是全是`val`类型的变量)，那么它很可能是函数式的。因此，向函数式风格的转化应该尽可能地避免使用`var`类型的变量。\n\n- 指令式编程的例子：\n```\ndef printArgs(args: Array[String]): Unit = {\n\tvar i = 0\n\twhile (i < args.length){\n\t\tprintln(args(i))\n\t\ti += 1\n\t}\n}\n```\n\n- 可以将这段代码转化为函数式的：\n\n1. 第一种：\n```\ndef printArgs(args: Array[String]): Unit = {\n\tfor (arg <- args)  //for表达式形式\n\t\tprintln(arg)\n}\n```\n\n2. 第二种：\n```\ndef printArgs(args: Array[String]): Unit = {\n\targs.foreach(println)\n}\n```\n\n- 另一方面，尽量避免使用带有副作用的函数。就比如上面修改之后的函数，它依旧不是“纯”的函数式代码，因为他有副作用(*本处的副作用是向标准输出流打印*)。带有副作用的函数的标志特征就是结果类型为`Unit`。(因为一个一个结果类型为`Unit`的函数，存在世上的唯一意义就是产生副作用)\n\n- 对于这一问题，函数式编程的做法就是定义一个将传入的`args`作为格式化(用于打印)的方法，但是只返回这个格式化的字符串。例如上例可以改成：`def formatArgs(args: Array[String]) = args.mkString(\"\\n\")`\n这个函数就满足了既没有`var`变量也没有副作用。\n\n- 这时我们就可以使用`println(formatArgs(args))`来实现与上面相同的打印的效果。\n\n### 从文件读取文本行\n\n- 例子：从文本读取文本行，并将它们打印出来，在每一行前面带上当前的字符数。\n```\nimport scala.io.Source\nif(args.length >0){\n\tfor (line <- Source.fromFile(args(0)).getLines())\n\t\tprintln(line.length + \" \" + filename)\n\telse\n\t\tConsole.err.println(\"Please enter filename\")\n}\n```\n\n- 这段脚本首先引入了scala.io名为Srouce的类，然后检查命令行是不是至少给出了一个参数。表达式`Source.fromFile(args(0))`尝试打开指定的文件并且返回一个Source对象。在这个对象上，继续调用`getLines`方法。\n\n- `getLines`方法返回一个`Iterator[String]`，每次迭代都给出一行内容，去掉了最后的换行符。for表达式遍历这些文本行。\n\n- 可以将文本行赋值给一个变量：`val lines = Source.fromFile(args(0)).getLines().toList`\n\n- 其中，最后的`toList`是必须的。因为`getLines`方法返回的是一个迭代器，一旦完成遍历，迭代器就会被消耗掉，通过`toList`方法将它转化为列表，就可以随便遍历这些文本行，多少次都可以(迭代器只能遍历一次)。但是代价就是要在内存中同时存储所有的行。因此`lines`指向了一个字符串列表。\n\n- **scala也可以使用`*`来重复一个字符串**，例：\n```\nscala> var s = \"a\" * 5\ns: String = aaaaa\n```\n\n\n<br>\n> 最后更新于2018.7.16\n","source":"_posts/2018-07-12-Scala-learning-01.md","raw":"---\nlayout:     post\ntitle:      \"《Scala编程》阅读记录——入门部分\"\ndate:       2018-07-12 21:40:00\ncategories: Computer Programes\ntags:   ๑Scala\n---\n\n> 不适合人类阅读的学习笔记\n\n## 入门\n---\n\n- scala是一门函数式编程语言,同时也是面向对象的\n\n- 函数值就是对象\n\n- scala对面向对象的实现是纯的：每个值都是对象，每个操作都是方法调用\n\n- 例如，两个Int类型的相加（注意scala里所有的数据类型首字母都是大写，这说明了他们都是类），+实际上是调用了一个名为+的方法\n\n### 函数式编程以两大核心概念为指导：\n\n- (1)函数是一等的值：函数值可以作为参数传递给其他函数，可以作为返回值，可以保存在一个变量里。还可以在一个函数里定义另一个函数，就像在函数里定义一个整数一样。也可以在定义函数时不指定名字。\n\n- (2)程序中的操作应该将输入值映射成输出值，而不是当场修改数据。例如Java对String的修改就是生成了一个新的String对象而原先的String不变。这个理念的另一种表述就是函数不应该有副作用(sideeffect)。方法只能通过接受入参数和返回结果这两种方式与外部通信，即参数本身不会被修改，这样的方法被称为是“指称透明的”。\n函数式编程鼓励不可变的数据结构和指称透明的方法。\n\n- Scala可以选择使用指令式编程的方法，即使用可变数据和副作用编程。但是推荐使用函数式编程。\n\n- scala定义类的简便的写法： `class MyClass(index: Int, name:String)`这样scala编译器就会产生带有两个 **私有** 实例变量和一个接受这两个变量初始值的参数的构造方法类\n\n- 假设name是一个String 类型的变量\n`val IfHasUpperCase = name.exists(_.isUpper)`\n\n- 这段代码实现了判断name中是否存在大写字母，并赋值给IfHasUpperCase这个Boolean类型的变量(scala赋值时如果不明确写出变量类型，则编译器会自动判断)\n\n- scala代码将字符串当做更高级的字符序列(sequence) 来处理，用 前提(predicate) 来处理\n\n- 这里的 前提 `_.isUpper` 是scala的函数字面量(当函数字面量的结果类型是Boolean时，可以被称作前提)。它描述了一个接受 **字符** 作为 **入参(以下划线表示)**，判断该字符是否为大写字母的函数。\n\n- 布尔值不能和整数相加\n\n- scala几乎所有语法结构都支持嵌套\n\n- scala输出： `println(\"....\")`\n\n- 注意编译器不会推断函数参数的类型，因此函数中参数的数据类型要显式地写出\n\n- scala函数形式：\n```\ndef FuncName(x:Int, y:Int): Int = {\n\tif(...){..}\n\telse{..}\n\tx\n}\n```\n- 注意函数结果类型前面的冒号不能省（这里函数的格式实际山是与变量保持一致的，即类型跟在冒号后面）\n\n- scala的函数会将函数体里的最后一条语句的值作为函数的返回值（例子里的函数将x的值返回）\n\n- 大多数时候函数的结果类型不需要显式地给出。但是递归函数必须显式地给出结果类型\n\n\n- scala表达式`if(x>y) x else y`的行为，与Java里的`(x>y)? x:y`的含义一致\n\n- 编译scala脚本：`scala hello.scala`\n\n- 命令行参数可以通过名为args的scala数组来获取：`println(\"Hello \" + args(0) + \"!\")`\n\n- 然后执行： `$ scala hello.scala planet  //其中planet被当做参数传入`\n\n- 结果： `Hello planet!`\n\n- 尽量少用for 和 while 循环\n\n### foreach遍历\n\n- 打印每一个命令行参数的方式：args.foreach(arg => println(arg))\n这段代码中，对args执行foreach方法，传入一个函数。本例中传入的是一个函数字面量(function literal)\n\n- 这个(匿名)函数接受一个名为arg的参数(arg仅仅是参数名没有别的特殊含义)\n上面也可以指明类型名(这样需要将参数的部分包在圆括号里，这是函数字面量的常规语法)：`args.foreach((arg:String) => println(arg))`\n\n- scala函数字面量语法： `(x:Int, y: Int) => x + y`\n其中从左到右，括号中的是参数部分，然后是右箭头，最右边是函数体\n\n- scala对函数字面量还有一个特殊的简写规则：如果函数字面量只是一个接收单个参数的语句，可以不必给出参数名和参数本身。\n因此上例可以写为：`args.foreach(println)`\n\n\n- scala只支持指令式的for语句的函数式亲戚。*for表达式*\n- for表达式一个简单的例子：\n```\n\tfor(arg <- args)\n\t    println(arg)\n```\n\n- 其中，位于 `<-` 符号右边的，是args数组，在 `<-` 左边的是一个 val变量的名字，为arg。\n注意左边的这个变量一定是 val类型 的(即它不能在for表达式循环体里被重新赋值)，并且只能写为 `arg` 而不能写成 `val arg`\n\n### 用类型参数化数组\n\n- 在scala中，可以用new来实例化对象或类的实例，当实例化对象时，可以用值和类型来对其进行参数化(parameterize)\n\n- 参数化的意思是：在创建实例的时候对实例做\"配置\"，可以用值来参数化一个实例，做法是在构造方法的括号中传入对象参数。\n\n- 参数化创建数组：\n```\n\tval myArr = new Array[String](3)\n\tmyArr(0) = ...\n\tmyArr(1) = ...\n\tmyArr(2) = ...\n```\n\n- 另一种创建方法： `val numArr = Array(\"zero\",\"one\",\"two\")`\n\n- 这实际上是调用了一个名为apply的工厂方法，这个方法创建并返回了新的数组。这个apply方法接受一个变长的参数列表。\n\n\n- scala数组使用 **圆括号** 来访问元素而不是方括号，原因(原文)：\n\t>数组不过是类的实例，这一点跟其他scala的实例没有本质区别。当你用一组圆括号讲一个或多个值包起来，并将其应用(apply)到某个对象时，scala会将这段代码转换成对这个对象的一个名为apply的方法调用。因此myArray(i)实际上就是myArray.apply(i)。因此，在scala中访问一个数组的元素就是一个简单的方法调用。\n\n- scala将从数组到表达式的一切都当做带有方法的对象来处理，由此来实现概念是的简单化。不需要记住各种特例。同时，这种统一并不会带来显著的性能开销。因为scala在编译代码时，会尽可能使用Java数组、基本类型和原生的算术指令。\n\n### 使用列表\n- scala的列表(list)是不可变的(数组虽然不能更改长度，但是元素是可以改变的，因此是可变的)\n因此list的修改有点像Java的字符串，每次对其中元素的修改都会返回一个新的list对象。\n\n- 不需要写 `new List`，因为scala.List的伴生对象上定义了一个工厂方法`List.apply()`\n\n- 列表上用的最多的操作是 `::`，读作\"cons\"。它是在一个已有的列表最前面添加一个新元素，并返回这个新的列表。\n例：\n```\n\tval twoThree = List(2,3)\n\tval oneTwoThree = 1 :: twoThree\n\tprintln(onTwoThree)\n```\n结果： `List(1,2,3)`\n\n- 注意：在表达式`1::twoThree`中，`::`是它右操作元的方法。（一般用在操作符表示法的方法都是左结合的，例如 `a * b`相当于 `a.*(b)` ) 除非方法名是以 `:` 结尾的，那么这个方法的调用就会发生在他的右操作元上。 因此上例相当于： `twoThree.::(1)`，1是作为参数传入的。\n\n- 表示空列表的快捷方式是`Nil`，初始化一个新的列表的另一种方式是用`::`将元素串接起来，并将Nil作为最后一个元素。例如：\n```\nval oneTwoThree = 1 :: 2 :: 3 :: Nil\nprintln(oneTwoThree)\n```\n\n- `:::`连接两个List：\n```\nval a = List(1)\nval b = List(2,3)\nval c = a ::: b   //c: List(1,2,3)\n```\n\n- 列表也有从末尾增加元素的方法，但是应当尽力避免这种写法，因为末尾追加元素的操作所需时间随列表的大小线性增加，而使用`::`只需要常量级的时间。\n\n- 可以通过在头部添加元素的方法，最后调用reverse方法来实现末尾添加的效果\n\n- 也可以使用ListBuffer，这是个可变列表，支持追加操作，最后使用toList方法即可转换为List\n\n### 使用元祖\n\n- 元祖也是不可变的，但是元祖可以容纳不同类型的元素。\n\n- 当需要从方法返回多个对象时，元祖就非常有用\n\n- 实例化一个元祖非常简单，只要将对象放在圆括号当中，用逗号隔开即可\n\n- 一旦实例化好一个元祖，就可以用英文句点、下划线和 **从1开始** 的序号来访问每一个元素。\n\n- 例如：\n```\nval pair = (99,\"test\")\npritln(pair._1)\t\t//访问第一个元素\nprintln(pair._2)\t//访问第二个元素\n```\n\n- 元祖的实际类型取决于它的元素。例如：`(99,\"test\")`的类型为`Tuple2[Int,String]`,而元祖`('u','r',\"the\",1,4,\"me\")`的类型是`Tuple6[Char,Char,String,Int,Int,String]`\n\n- 元祖为什么不能像数组一样用圆括号来访问元素(原文)：\n> 你也许正好奇问什么不能像访问列表元素，也就是“pair(0)”那样访问元祖元素。背后的原因是列表的apply方法永远**只返回同一种类型**，但元祖里的元素可以是不同类型的：`_1`可能是一种类型，`_2`可能是另一种\n\n### 使用集和映射\n\n- scala的API包含了一个基础的特质(trait)来表示集，这里的特质跟Java的接口定义类似\n\n- scala提供了两个子特质：一个表示可变集，一个表示不可变集。(可变集与不可变集位于不同的包)\n\n- 创建一个集合的例子：\n```\nvar jetSet = Set(\"Boeing\",\"Airbus\")\njetSet += \"Lear\"\nprintln(jetSet.contains(\"Cessna\"))\n```\n- 第一行代码表示，可以像创建列表和数组那样创建集：通过调用Set伴生对象的apply工厂方法。\n\n- 在这个例子中，实际上调用了scala.collection.immutable.Set的伴生对象的apply方法，返回一个默认的、**不可变** 的Set对象，类型为`Set[String]`\n\n- 向集添加元素需要调用`+`方法。无论是可变集还是不可变集，`+`方法都会创建并返回一个新的集\n\n- 而本例中的`+=`方法，实际上不可变集并不提供这个方法，其本质上是`jetSet = jetSet + ”Lear\"`的简写。因此，**其本质上是将jetSet这个var重新赋值成了一个包含三个元素的新的集**\n\n- 最后一行是打印集中是否包含\"Cessna\"这个元素，结果应当是`false`\n\n### 可变集\n\n- 使用可变集需要一次引入，例：\n```\nimport scala.collection.mutable\nval movieSet = mutable.Set(\"Hitch\",\"Peter\")\nmovieSet += \"Shrek\"\nprintln(movieSet)\n```\n- 通过import语句，可以使用简短的`mutable.Set()`而不是`scala.colection.mutable.Set()`这样完整的句子\n\n- 这里的`+=`方法在可变集里是有定义的，因此这个可变集声明时用的是 `val`而不是 `var`(上面也提到了不可变集实际上是被重新赋值了，如果使用`val`会编译报错)\n\n- `HashSet`的用法与`Set`一致，只是`HashSet`的存储方式不同，因此一般在需要考虑性能的地方会用到`HashSet`\n\n### 映射(Map)\n\n- 与Set类似，Map也有可变与不可变的版本。\n\n- 例子：\n```\nimport scala.collection.mutable\nval treasureMap = mutable.Map[Int,String]()\ntreasureMap += (1 -> \"Go to island\")\ntreasureMap += (2 -> \"Find big X on ground\")\ntreasureMap += (3 -> \"Dig\")\nprintln(treasureMap(2))\n```\n\n- 上面的例子引入了可变Map(默认为不可变映射)，这里与上面可变集一样，定义为val类型。接下来，使用`->`来定义键值对。这里scala会将二元操作，比如`1 -> \"Go to island\"`转换为标准的方法调用，即`(1).->(\"Go to island\")`，这里`\"Go to island\"`是方法`->`的参数。\n\n- 可以对任何对象调用`->`方法，它将返回包含键和值两个元素的元组。\n\n- 若要获取Map里的某个键的值，如上面代码的最后一行`treasureMap(2)`将返回`2`这个键对应的值。\n\n### 函数式编程风格\n\n- 如果一段代码避免了使用`var`(也就是全是`val`类型的变量)，那么它很可能是函数式的。因此，向函数式风格的转化应该尽可能地避免使用`var`类型的变量。\n\n- 指令式编程的例子：\n```\ndef printArgs(args: Array[String]): Unit = {\n\tvar i = 0\n\twhile (i < args.length){\n\t\tprintln(args(i))\n\t\ti += 1\n\t}\n}\n```\n\n- 可以将这段代码转化为函数式的：\n\n1. 第一种：\n```\ndef printArgs(args: Array[String]): Unit = {\n\tfor (arg <- args)  //for表达式形式\n\t\tprintln(arg)\n}\n```\n\n2. 第二种：\n```\ndef printArgs(args: Array[String]): Unit = {\n\targs.foreach(println)\n}\n```\n\n- 另一方面，尽量避免使用带有副作用的函数。就比如上面修改之后的函数，它依旧不是“纯”的函数式代码，因为他有副作用(*本处的副作用是向标准输出流打印*)。带有副作用的函数的标志特征就是结果类型为`Unit`。(因为一个一个结果类型为`Unit`的函数，存在世上的唯一意义就是产生副作用)\n\n- 对于这一问题，函数式编程的做法就是定义一个将传入的`args`作为格式化(用于打印)的方法，但是只返回这个格式化的字符串。例如上例可以改成：`def formatArgs(args: Array[String]) = args.mkString(\"\\n\")`\n这个函数就满足了既没有`var`变量也没有副作用。\n\n- 这时我们就可以使用`println(formatArgs(args))`来实现与上面相同的打印的效果。\n\n### 从文件读取文本行\n\n- 例子：从文本读取文本行，并将它们打印出来，在每一行前面带上当前的字符数。\n```\nimport scala.io.Source\nif(args.length >0){\n\tfor (line <- Source.fromFile(args(0)).getLines())\n\t\tprintln(line.length + \" \" + filename)\n\telse\n\t\tConsole.err.println(\"Please enter filename\")\n}\n```\n\n- 这段脚本首先引入了scala.io名为Srouce的类，然后检查命令行是不是至少给出了一个参数。表达式`Source.fromFile(args(0))`尝试打开指定的文件并且返回一个Source对象。在这个对象上，继续调用`getLines`方法。\n\n- `getLines`方法返回一个`Iterator[String]`，每次迭代都给出一行内容，去掉了最后的换行符。for表达式遍历这些文本行。\n\n- 可以将文本行赋值给一个变量：`val lines = Source.fromFile(args(0)).getLines().toList`\n\n- 其中，最后的`toList`是必须的。因为`getLines`方法返回的是一个迭代器，一旦完成遍历，迭代器就会被消耗掉，通过`toList`方法将它转化为列表，就可以随便遍历这些文本行，多少次都可以(迭代器只能遍历一次)。但是代价就是要在内存中同时存储所有的行。因此`lines`指向了一个字符串列表。\n\n- **scala也可以使用`*`来重复一个字符串**，例：\n```\nscala> var s = \"a\" * 5\ns: String = aaaaa\n```\n\n\n<br>\n> 最后更新于2018.7.16\n","slug":"2018-07-12-Scala-learning-01","published":1,"updated":"2018-09-03T13:11:18.654Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j58002x1m0o3htf7kdo","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><hr>\n<ul>\n<li><p>scala是一门函数式编程语言,同时也是面向对象的</p>\n</li>\n<li><p>函数值就是对象</p>\n</li>\n<li><p>scala对面向对象的实现是纯的：每个值都是对象，每个操作都是方法调用</p>\n</li>\n<li><p>例如，两个Int类型的相加（注意scala里所有的数据类型首字母都是大写，这说明了他们都是类），+实际上是调用了一个名为+的方法</p>\n</li>\n</ul>\n<h3 id=\"函数式编程以两大核心概念为指导：\"><a href=\"#函数式编程以两大核心概念为指导：\" class=\"headerlink\" title=\"函数式编程以两大核心概念为指导：\"></a>函数式编程以两大核心概念为指导：</h3><ul>\n<li><p>(1)函数是一等的值：函数值可以作为参数传递给其他函数，可以作为返回值，可以保存在一个变量里。还可以在一个函数里定义另一个函数，就像在函数里定义一个整数一样。也可以在定义函数时不指定名字。</p>\n</li>\n<li><p>(2)程序中的操作应该将输入值映射成输出值，而不是当场修改数据。例如Java对String的修改就是生成了一个新的String对象而原先的String不变。这个理念的另一种表述就是函数不应该有副作用(sideeffect)。方法只能通过接受入参数和返回结果这两种方式与外部通信，即参数本身不会被修改，这样的方法被称为是“指称透明的”。<br>函数式编程鼓励不可变的数据结构和指称透明的方法。</p>\n</li>\n<li><p>Scala可以选择使用指令式编程的方法，即使用可变数据和副作用编程。但是推荐使用函数式编程。</p>\n</li>\n<li><p>scala定义类的简便的写法： <code>class MyClass(index: Int, name:String)</code>这样scala编译器就会产生带有两个 <strong>私有</strong> 实例变量和一个接受这两个变量初始值的参数的构造方法类</p>\n</li>\n<li><p>假设name是一个String 类型的变量<br><code>val IfHasUpperCase = name.exists(_.isUpper)</code></p>\n</li>\n<li><p>这段代码实现了判断name中是否存在大写字母，并赋值给IfHasUpperCase这个Boolean类型的变量(scala赋值时如果不明确写出变量类型，则编译器会自动判断)</p>\n</li>\n<li><p>scala代码将字符串当做更高级的字符序列(sequence) 来处理，用 前提(predicate) 来处理</p>\n</li>\n<li><p>这里的 前提 <code>_.isUpper</code> 是scala的函数字面量(当函数字面量的结果类型是Boolean时，可以被称作前提)。它描述了一个接受 <strong>字符</strong> 作为 <strong>入参(以下划线表示)</strong>，判断该字符是否为大写字母的函数。</p>\n</li>\n<li><p>布尔值不能和整数相加</p>\n</li>\n<li><p>scala几乎所有语法结构都支持嵌套</p>\n</li>\n<li><p>scala输出： <code>println(&quot;....&quot;)</code></p>\n</li>\n<li><p>注意编译器不会推断函数参数的类型，因此函数中参数的数据类型要显式地写出</p>\n</li>\n<li><p>scala函数形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def FuncName(x:Int, y:Int): Int = &#123;</span><br><span class=\"line\">\tif(...)&#123;..&#125;</span><br><span class=\"line\">\telse&#123;..&#125;</span><br><span class=\"line\">\tx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意函数结果类型前面的冒号不能省（这里函数的格式实际山是与变量保持一致的，即类型跟在冒号后面）</p>\n</li>\n<li><p>scala的函数会将函数体里的最后一条语句的值作为函数的返回值（例子里的函数将x的值返回）</p>\n</li>\n<li><p>大多数时候函数的结果类型不需要显式地给出。但是递归函数必须显式地给出结果类型</p>\n</li>\n</ul>\n<ul>\n<li><p>scala表达式<code>if(x&gt;y) x else y</code>的行为，与Java里的<code>(x&gt;y)? x:y</code>的含义一致</p>\n</li>\n<li><p>编译scala脚本：<code>scala hello.scala</code></p>\n</li>\n<li><p>命令行参数可以通过名为args的scala数组来获取：<code>println(&quot;Hello &quot; + args(0) + &quot;!&quot;)</code></p>\n</li>\n<li><p>然后执行： <code>$ scala hello.scala planet  //其中planet被当做参数传入</code></p>\n</li>\n<li><p>结果： <code>Hello planet!</code></p>\n</li>\n<li><p>尽量少用for 和 while 循环</p>\n</li>\n</ul>\n<h3 id=\"foreach遍历\"><a href=\"#foreach遍历\" class=\"headerlink\" title=\"foreach遍历\"></a>foreach遍历</h3><ul>\n<li><p>打印每一个命令行参数的方式：args.foreach(arg =&gt; println(arg))<br>这段代码中，对args执行foreach方法，传入一个函数。本例中传入的是一个函数字面量(function literal)</p>\n</li>\n<li><p>这个(匿名)函数接受一个名为arg的参数(arg仅仅是参数名没有别的特殊含义)<br>上面也可以指明类型名(这样需要将参数的部分包在圆括号里，这是函数字面量的常规语法)：<code>args.foreach((arg:String) =&gt; println(arg))</code></p>\n</li>\n<li><p>scala函数字面量语法： <code>(x:Int, y: Int) =&gt; x + y</code><br>其中从左到右，括号中的是参数部分，然后是右箭头，最右边是函数体</p>\n</li>\n<li><p>scala对函数字面量还有一个特殊的简写规则：如果函数字面量只是一个接收单个参数的语句，可以不必给出参数名和参数本身。<br>因此上例可以写为：<code>args.foreach(println)</code></p>\n</li>\n</ul>\n<ul>\n<li>scala只支持指令式的for语句的函数式亲戚。<em>for表达式</em></li>\n<li><p>for表达式一个简单的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(arg &lt;- args)</span><br><span class=\"line\">    println(arg)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其中，位于 <code>&lt;-</code> 符号右边的，是args数组，在 <code>&lt;-</code> 左边的是一个 val变量的名字，为arg。<br>注意左边的这个变量一定是 val类型 的(即它不能在for表达式循环体里被重新赋值)，并且只能写为 <code>arg</code> 而不能写成 <code>val arg</code></p>\n</li>\n</ul>\n<h3 id=\"用类型参数化数组\"><a href=\"#用类型参数化数组\" class=\"headerlink\" title=\"用类型参数化数组\"></a>用类型参数化数组</h3><ul>\n<li><p>在scala中，可以用new来实例化对象或类的实例，当实例化对象时，可以用值和类型来对其进行参数化(parameterize)</p>\n</li>\n<li><p>参数化的意思是：在创建实例的时候对实例做”配置”，可以用值来参数化一个实例，做法是在构造方法的括号中传入对象参数。</p>\n</li>\n<li><p>参数化创建数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val myArr = new Array[String](3)</span><br><span class=\"line\">myArr(0) = ...</span><br><span class=\"line\">myArr(1) = ...</span><br><span class=\"line\">myArr(2) = ...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另一种创建方法： <code>val numArr = Array(&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;)</code></p>\n</li>\n<li><p>这实际上是调用了一个名为apply的工厂方法，这个方法创建并返回了新的数组。这个apply方法接受一个变长的参数列表。</p>\n</li>\n</ul>\n<ul>\n<li><p>scala数组使用 <strong>圆括号</strong> 来访问元素而不是方括号，原因(原文)：</p>\n<blockquote>\n<p>数组不过是类的实例，这一点跟其他scala的实例没有本质区别。当你用一组圆括号讲一个或多个值包起来，并将其应用(apply)到某个对象时，scala会将这段代码转换成对这个对象的一个名为apply的方法调用。因此myArray(i)实际上就是myArray.apply(i)。因此，在scala中访问一个数组的元素就是一个简单的方法调用。</p>\n</blockquote>\n</li>\n<li><p>scala将从数组到表达式的一切都当做带有方法的对象来处理，由此来实现概念是的简单化。不需要记住各种特例。同时，这种统一并不会带来显著的性能开销。因为scala在编译代码时，会尽可能使用Java数组、基本类型和原生的算术指令。</p>\n</li>\n</ul>\n<h3 id=\"使用列表\"><a href=\"#使用列表\" class=\"headerlink\" title=\"使用列表\"></a>使用列表</h3><ul>\n<li><p>scala的列表(list)是不可变的(数组虽然不能更改长度，但是元素是可以改变的，因此是可变的)<br>因此list的修改有点像Java的字符串，每次对其中元素的修改都会返回一个新的list对象。</p>\n</li>\n<li><p>不需要写 <code>new List</code>，因为scala.List的伴生对象上定义了一个工厂方法<code>List.apply()</code></p>\n</li>\n<li><p>列表上用的最多的操作是 <code>::</code>，读作”cons”。它是在一个已有的列表最前面添加一个新元素，并返回这个新的列表。<br>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val twoThree = List(2,3)</span><br><span class=\"line\">val oneTwoThree = 1 :: twoThree</span><br><span class=\"line\">println(onTwoThree)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>结果： <code>List(1,2,3)</code></p>\n<ul>\n<li><p>注意：在表达式<code>1::twoThree</code>中，<code>::</code>是它右操作元的方法。（一般用在操作符表示法的方法都是左结合的，例如 <code>a * b</code>相当于 <code>a.*(b)</code> ) 除非方法名是以 <code>:</code> 结尾的，那么这个方法的调用就会发生在他的右操作元上。 因此上例相当于： <code>twoThree.::(1)</code>，1是作为参数传入的。</p>\n</li>\n<li><p>表示空列表的快捷方式是<code>Nil</code>，初始化一个新的列表的另一种方式是用<code>::</code>将元素串接起来，并将Nil作为最后一个元素。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val oneTwoThree = 1 :: 2 :: 3 :: Nil</span><br><span class=\"line\">println(oneTwoThree)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>:::</code>连接两个List：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val a = List(1)</span><br><span class=\"line\">val b = List(2,3)</span><br><span class=\"line\">val c = a ::: b   //c: List(1,2,3)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>列表也有从末尾增加元素的方法，但是应当尽力避免这种写法，因为末尾追加元素的操作所需时间随列表的大小线性增加，而使用<code>::</code>只需要常量级的时间。</p>\n</li>\n<li><p>可以通过在头部添加元素的方法，最后调用reverse方法来实现末尾添加的效果</p>\n</li>\n<li><p>也可以使用ListBuffer，这是个可变列表，支持追加操作，最后使用toList方法即可转换为List</p>\n</li>\n</ul>\n<h3 id=\"使用元祖\"><a href=\"#使用元祖\" class=\"headerlink\" title=\"使用元祖\"></a>使用元祖</h3><ul>\n<li><p>元祖也是不可变的，但是元祖可以容纳不同类型的元素。</p>\n</li>\n<li><p>当需要从方法返回多个对象时，元祖就非常有用</p>\n</li>\n<li><p>实例化一个元祖非常简单，只要将对象放在圆括号当中，用逗号隔开即可</p>\n</li>\n<li><p>一旦实例化好一个元祖，就可以用英文句点、下划线和 <strong>从1开始</strong> 的序号来访问每一个元素。</p>\n</li>\n<li><p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val pair = (99,&quot;test&quot;)</span><br><span class=\"line\">pritln(pair._1)\t\t//访问第一个元素</span><br><span class=\"line\">println(pair._2)\t//访问第二个元素</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>元祖的实际类型取决于它的元素。例如：<code>(99,&quot;test&quot;)</code>的类型为<code>Tuple2[Int,String]</code>,而元祖<code>(&#39;u&#39;,&#39;r&#39;,&quot;the&quot;,1,4,&quot;me&quot;)</code>的类型是<code>Tuple6[Char,Char,String,Int,Int,String]</code></p>\n</li>\n<li><p>元祖为什么不能像数组一样用圆括号来访问元素(原文)：</p>\n<blockquote>\n<p>你也许正好奇问什么不能像访问列表元素，也就是“pair(0)”那样访问元祖元素。背后的原因是列表的apply方法永远<strong>只返回同一种类型</strong>，但元祖里的元素可以是不同类型的：<code>_1</code>可能是一种类型，<code>_2</code>可能是另一种</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"使用集和映射\"><a href=\"#使用集和映射\" class=\"headerlink\" title=\"使用集和映射\"></a>使用集和映射</h3><ul>\n<li><p>scala的API包含了一个基础的特质(trait)来表示集，这里的特质跟Java的接口定义类似</p>\n</li>\n<li><p>scala提供了两个子特质：一个表示可变集，一个表示不可变集。(可变集与不可变集位于不同的包)</p>\n</li>\n<li><p>创建一个集合的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var jetSet = Set(&quot;Boeing&quot;,&quot;Airbus&quot;)</span><br><span class=\"line\">jetSet += &quot;Lear&quot;</span><br><span class=\"line\">println(jetSet.contains(&quot;Cessna&quot;))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第一行代码表示，可以像创建列表和数组那样创建集：通过调用Set伴生对象的apply工厂方法。</p>\n</li>\n<li><p>在这个例子中，实际上调用了scala.collection.immutable.Set的伴生对象的apply方法，返回一个默认的、<strong>不可变</strong> 的Set对象，类型为<code>Set[String]</code></p>\n</li>\n<li><p>向集添加元素需要调用<code>+</code>方法。无论是可变集还是不可变集，<code>+</code>方法都会创建并返回一个新的集</p>\n</li>\n<li><p>而本例中的<code>+=</code>方法，实际上不可变集并不提供这个方法，其本质上是<code>jetSet = jetSet + ”Lear&quot;</code>的简写。因此，<strong>其本质上是将jetSet这个var重新赋值成了一个包含三个元素的新的集</strong></p>\n</li>\n<li><p>最后一行是打印集中是否包含”Cessna”这个元素，结果应当是<code>false</code></p>\n</li>\n</ul>\n<h3 id=\"可变集\"><a href=\"#可变集\" class=\"headerlink\" title=\"可变集\"></a>可变集</h3><ul>\n<li><p>使用可变集需要一次引入，例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import scala.collection.mutable</span><br><span class=\"line\">val movieSet = mutable.Set(&quot;Hitch&quot;,&quot;Peter&quot;)</span><br><span class=\"line\">movieSet += &quot;Shrek&quot;</span><br><span class=\"line\">println(movieSet)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过import语句，可以使用简短的<code>mutable.Set()</code>而不是<code>scala.colection.mutable.Set()</code>这样完整的句子</p>\n</li>\n<li><p>这里的<code>+=</code>方法在可变集里是有定义的，因此这个可变集声明时用的是 <code>val</code>而不是 <code>var</code>(上面也提到了不可变集实际上是被重新赋值了，如果使用<code>val</code>会编译报错)</p>\n</li>\n<li><p><code>HashSet</code>的用法与<code>Set</code>一致，只是<code>HashSet</code>的存储方式不同，因此一般在需要考虑性能的地方会用到<code>HashSet</code></p>\n</li>\n</ul>\n<h3 id=\"映射-Map\"><a href=\"#映射-Map\" class=\"headerlink\" title=\"映射(Map)\"></a>映射(Map)</h3><ul>\n<li><p>与Set类似，Map也有可变与不可变的版本。</p>\n</li>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import scala.collection.mutable</span><br><span class=\"line\">val treasureMap = mutable.Map[Int,String]()</span><br><span class=\"line\">treasureMap += (1 -&gt; &quot;Go to island&quot;)</span><br><span class=\"line\">treasureMap += (2 -&gt; &quot;Find big X on ground&quot;)</span><br><span class=\"line\">treasureMap += (3 -&gt; &quot;Dig&quot;)</span><br><span class=\"line\">println(treasureMap(2))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>上面的例子引入了可变Map(默认为不可变映射)，这里与上面可变集一样，定义为val类型。接下来，使用<code>-&gt;</code>来定义键值对。这里scala会将二元操作，比如<code>1 -&gt; &quot;Go to island&quot;</code>转换为标准的方法调用，即<code>(1).-&gt;(&quot;Go to island&quot;)</code>，这里<code>&quot;Go to island&quot;</code>是方法<code>-&gt;</code>的参数。</p>\n</li>\n<li><p>可以对任何对象调用<code>-&gt;</code>方法，它将返回包含键和值两个元素的元组。</p>\n</li>\n<li><p>若要获取Map里的某个键的值，如上面代码的最后一行<code>treasureMap(2)</code>将返回<code>2</code>这个键对应的值。</p>\n</li>\n</ul>\n<h3 id=\"函数式编程风格\"><a href=\"#函数式编程风格\" class=\"headerlink\" title=\"函数式编程风格\"></a>函数式编程风格</h3><ul>\n<li><p>如果一段代码避免了使用<code>var</code>(也就是全是<code>val</code>类型的变量)，那么它很可能是函数式的。因此，向函数式风格的转化应该尽可能地避免使用<code>var</code>类型的变量。</p>\n</li>\n<li><p>指令式编程的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printArgs(args: Array[String]): Unit = &#123;</span><br><span class=\"line\">\tvar i = 0</span><br><span class=\"line\">\twhile (i &lt; args.length)&#123;</span><br><span class=\"line\">\t\tprintln(args(i))</span><br><span class=\"line\">\t\ti += 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以将这段代码转化为函数式的：</p>\n</li>\n</ul>\n<ol>\n<li><p>第一种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printArgs(args: Array[String]): Unit = &#123;</span><br><span class=\"line\">\tfor (arg &lt;- args)  //for表达式形式</span><br><span class=\"line\">\t\tprintln(arg)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printArgs(args: Array[String]): Unit = &#123;</span><br><span class=\"line\">\targs.foreach(println)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><p>另一方面，尽量避免使用带有副作用的函数。就比如上面修改之后的函数，它依旧不是“纯”的函数式代码，因为他有副作用(<em>本处的副作用是向标准输出流打印</em>)。带有副作用的函数的标志特征就是结果类型为<code>Unit</code>。(因为一个一个结果类型为<code>Unit</code>的函数，存在世上的唯一意义就是产生副作用)</p>\n</li>\n<li><p>对于这一问题，函数式编程的做法就是定义一个将传入的<code>args</code>作为格式化(用于打印)的方法，但是只返回这个格式化的字符串。例如上例可以改成：<code>def formatArgs(args: Array[String]) = args.mkString(&quot;\\n&quot;)</code><br>这个函数就满足了既没有<code>var</code>变量也没有副作用。</p>\n</li>\n<li><p>这时我们就可以使用<code>println(formatArgs(args))</code>来实现与上面相同的打印的效果。</p>\n</li>\n</ul>\n<h3 id=\"从文件读取文本行\"><a href=\"#从文件读取文本行\" class=\"headerlink\" title=\"从文件读取文本行\"></a>从文件读取文本行</h3><ul>\n<li><p>例子：从文本读取文本行，并将它们打印出来，在每一行前面带上当前的字符数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import scala.io.Source</span><br><span class=\"line\">if(args.length &gt;0)&#123;</span><br><span class=\"line\">\tfor (line &lt;- Source.fromFile(args(0)).getLines())</span><br><span class=\"line\">\t\tprintln(line.length + &quot; &quot; + filename)</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tConsole.err.println(&quot;Please enter filename&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这段脚本首先引入了scala.io名为Srouce的类，然后检查命令行是不是至少给出了一个参数。表达式<code>Source.fromFile(args(0))</code>尝试打开指定的文件并且返回一个Source对象。在这个对象上，继续调用<code>getLines</code>方法。</p>\n</li>\n<li><p><code>getLines</code>方法返回一个<code>Iterator[String]</code>，每次迭代都给出一行内容，去掉了最后的换行符。for表达式遍历这些文本行。</p>\n</li>\n<li><p>可以将文本行赋值给一个变量：<code>val lines = Source.fromFile(args(0)).getLines().toList</code></p>\n</li>\n<li><p>其中，最后的<code>toList</code>是必须的。因为<code>getLines</code>方法返回的是一个迭代器，一旦完成遍历，迭代器就会被消耗掉，通过<code>toList</code>方法将它转化为列表，就可以随便遍历这些文本行，多少次都可以(迭代器只能遍历一次)。但是代价就是要在内存中同时存储所有的行。因此<code>lines</code>指向了一个字符串列表。</p>\n</li>\n<li><p><strong>scala也可以使用<code>*</code>来重复一个字符串</strong>，例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; var s = &quot;a&quot; * 5</span><br><span class=\"line\">s: String = aaaaa</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.16</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><hr>\n<ul>\n<li><p>scala是一门函数式编程语言,同时也是面向对象的</p>\n</li>\n<li><p>函数值就是对象</p>\n</li>\n<li><p>scala对面向对象的实现是纯的：每个值都是对象，每个操作都是方法调用</p>\n</li>\n<li><p>例如，两个Int类型的相加（注意scala里所有的数据类型首字母都是大写，这说明了他们都是类），+实际上是调用了一个名为+的方法</p>\n</li>\n</ul>\n<h3 id=\"函数式编程以两大核心概念为指导：\"><a href=\"#函数式编程以两大核心概念为指导：\" class=\"headerlink\" title=\"函数式编程以两大核心概念为指导：\"></a>函数式编程以两大核心概念为指导：</h3><ul>\n<li><p>(1)函数是一等的值：函数值可以作为参数传递给其他函数，可以作为返回值，可以保存在一个变量里。还可以在一个函数里定义另一个函数，就像在函数里定义一个整数一样。也可以在定义函数时不指定名字。</p>\n</li>\n<li><p>(2)程序中的操作应该将输入值映射成输出值，而不是当场修改数据。例如Java对String的修改就是生成了一个新的String对象而原先的String不变。这个理念的另一种表述就是函数不应该有副作用(sideeffect)。方法只能通过接受入参数和返回结果这两种方式与外部通信，即参数本身不会被修改，这样的方法被称为是“指称透明的”。<br>函数式编程鼓励不可变的数据结构和指称透明的方法。</p>\n</li>\n<li><p>Scala可以选择使用指令式编程的方法，即使用可变数据和副作用编程。但是推荐使用函数式编程。</p>\n</li>\n<li><p>scala定义类的简便的写法： <code>class MyClass(index: Int, name:String)</code>这样scala编译器就会产生带有两个 <strong>私有</strong> 实例变量和一个接受这两个变量初始值的参数的构造方法类</p>\n</li>\n<li><p>假设name是一个String 类型的变量<br><code>val IfHasUpperCase = name.exists(_.isUpper)</code></p>\n</li>\n<li><p>这段代码实现了判断name中是否存在大写字母，并赋值给IfHasUpperCase这个Boolean类型的变量(scala赋值时如果不明确写出变量类型，则编译器会自动判断)</p>\n</li>\n<li><p>scala代码将字符串当做更高级的字符序列(sequence) 来处理，用 前提(predicate) 来处理</p>\n</li>\n<li><p>这里的 前提 <code>_.isUpper</code> 是scala的函数字面量(当函数字面量的结果类型是Boolean时，可以被称作前提)。它描述了一个接受 <strong>字符</strong> 作为 <strong>入参(以下划线表示)</strong>，判断该字符是否为大写字母的函数。</p>\n</li>\n<li><p>布尔值不能和整数相加</p>\n</li>\n<li><p>scala几乎所有语法结构都支持嵌套</p>\n</li>\n<li><p>scala输出： <code>println(&quot;....&quot;)</code></p>\n</li>\n<li><p>注意编译器不会推断函数参数的类型，因此函数中参数的数据类型要显式地写出</p>\n</li>\n<li><p>scala函数形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def FuncName(x:Int, y:Int): Int = &#123;</span><br><span class=\"line\">\tif(...)&#123;..&#125;</span><br><span class=\"line\">\telse&#123;..&#125;</span><br><span class=\"line\">\tx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意函数结果类型前面的冒号不能省（这里函数的格式实际山是与变量保持一致的，即类型跟在冒号后面）</p>\n</li>\n<li><p>scala的函数会将函数体里的最后一条语句的值作为函数的返回值（例子里的函数将x的值返回）</p>\n</li>\n<li><p>大多数时候函数的结果类型不需要显式地给出。但是递归函数必须显式地给出结果类型</p>\n</li>\n</ul>\n<ul>\n<li><p>scala表达式<code>if(x&gt;y) x else y</code>的行为，与Java里的<code>(x&gt;y)? x:y</code>的含义一致</p>\n</li>\n<li><p>编译scala脚本：<code>scala hello.scala</code></p>\n</li>\n<li><p>命令行参数可以通过名为args的scala数组来获取：<code>println(&quot;Hello &quot; + args(0) + &quot;!&quot;)</code></p>\n</li>\n<li><p>然后执行： <code>$ scala hello.scala planet  //其中planet被当做参数传入</code></p>\n</li>\n<li><p>结果： <code>Hello planet!</code></p>\n</li>\n<li><p>尽量少用for 和 while 循环</p>\n</li>\n</ul>\n<h3 id=\"foreach遍历\"><a href=\"#foreach遍历\" class=\"headerlink\" title=\"foreach遍历\"></a>foreach遍历</h3><ul>\n<li><p>打印每一个命令行参数的方式：args.foreach(arg =&gt; println(arg))<br>这段代码中，对args执行foreach方法，传入一个函数。本例中传入的是一个函数字面量(function literal)</p>\n</li>\n<li><p>这个(匿名)函数接受一个名为arg的参数(arg仅仅是参数名没有别的特殊含义)<br>上面也可以指明类型名(这样需要将参数的部分包在圆括号里，这是函数字面量的常规语法)：<code>args.foreach((arg:String) =&gt; println(arg))</code></p>\n</li>\n<li><p>scala函数字面量语法： <code>(x:Int, y: Int) =&gt; x + y</code><br>其中从左到右，括号中的是参数部分，然后是右箭头，最右边是函数体</p>\n</li>\n<li><p>scala对函数字面量还有一个特殊的简写规则：如果函数字面量只是一个接收单个参数的语句，可以不必给出参数名和参数本身。<br>因此上例可以写为：<code>args.foreach(println)</code></p>\n</li>\n</ul>\n<ul>\n<li>scala只支持指令式的for语句的函数式亲戚。<em>for表达式</em></li>\n<li><p>for表达式一个简单的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(arg &lt;- args)</span><br><span class=\"line\">    println(arg)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其中，位于 <code>&lt;-</code> 符号右边的，是args数组，在 <code>&lt;-</code> 左边的是一个 val变量的名字，为arg。<br>注意左边的这个变量一定是 val类型 的(即它不能在for表达式循环体里被重新赋值)，并且只能写为 <code>arg</code> 而不能写成 <code>val arg</code></p>\n</li>\n</ul>\n<h3 id=\"用类型参数化数组\"><a href=\"#用类型参数化数组\" class=\"headerlink\" title=\"用类型参数化数组\"></a>用类型参数化数组</h3><ul>\n<li><p>在scala中，可以用new来实例化对象或类的实例，当实例化对象时，可以用值和类型来对其进行参数化(parameterize)</p>\n</li>\n<li><p>参数化的意思是：在创建实例的时候对实例做”配置”，可以用值来参数化一个实例，做法是在构造方法的括号中传入对象参数。</p>\n</li>\n<li><p>参数化创建数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val myArr = new Array[String](3)</span><br><span class=\"line\">myArr(0) = ...</span><br><span class=\"line\">myArr(1) = ...</span><br><span class=\"line\">myArr(2) = ...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另一种创建方法： <code>val numArr = Array(&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;)</code></p>\n</li>\n<li><p>这实际上是调用了一个名为apply的工厂方法，这个方法创建并返回了新的数组。这个apply方法接受一个变长的参数列表。</p>\n</li>\n</ul>\n<ul>\n<li><p>scala数组使用 <strong>圆括号</strong> 来访问元素而不是方括号，原因(原文)：</p>\n<blockquote>\n<p>数组不过是类的实例，这一点跟其他scala的实例没有本质区别。当你用一组圆括号讲一个或多个值包起来，并将其应用(apply)到某个对象时，scala会将这段代码转换成对这个对象的一个名为apply的方法调用。因此myArray(i)实际上就是myArray.apply(i)。因此，在scala中访问一个数组的元素就是一个简单的方法调用。</p>\n</blockquote>\n</li>\n<li><p>scala将从数组到表达式的一切都当做带有方法的对象来处理，由此来实现概念是的简单化。不需要记住各种特例。同时，这种统一并不会带来显著的性能开销。因为scala在编译代码时，会尽可能使用Java数组、基本类型和原生的算术指令。</p>\n</li>\n</ul>\n<h3 id=\"使用列表\"><a href=\"#使用列表\" class=\"headerlink\" title=\"使用列表\"></a>使用列表</h3><ul>\n<li><p>scala的列表(list)是不可变的(数组虽然不能更改长度，但是元素是可以改变的，因此是可变的)<br>因此list的修改有点像Java的字符串，每次对其中元素的修改都会返回一个新的list对象。</p>\n</li>\n<li><p>不需要写 <code>new List</code>，因为scala.List的伴生对象上定义了一个工厂方法<code>List.apply()</code></p>\n</li>\n<li><p>列表上用的最多的操作是 <code>::</code>，读作”cons”。它是在一个已有的列表最前面添加一个新元素，并返回这个新的列表。<br>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val twoThree = List(2,3)</span><br><span class=\"line\">val oneTwoThree = 1 :: twoThree</span><br><span class=\"line\">println(onTwoThree)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>结果： <code>List(1,2,3)</code></p>\n<ul>\n<li><p>注意：在表达式<code>1::twoThree</code>中，<code>::</code>是它右操作元的方法。（一般用在操作符表示法的方法都是左结合的，例如 <code>a * b</code>相当于 <code>a.*(b)</code> ) 除非方法名是以 <code>:</code> 结尾的，那么这个方法的调用就会发生在他的右操作元上。 因此上例相当于： <code>twoThree.::(1)</code>，1是作为参数传入的。</p>\n</li>\n<li><p>表示空列表的快捷方式是<code>Nil</code>，初始化一个新的列表的另一种方式是用<code>::</code>将元素串接起来，并将Nil作为最后一个元素。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val oneTwoThree = 1 :: 2 :: 3 :: Nil</span><br><span class=\"line\">println(oneTwoThree)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>:::</code>连接两个List：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val a = List(1)</span><br><span class=\"line\">val b = List(2,3)</span><br><span class=\"line\">val c = a ::: b   //c: List(1,2,3)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>列表也有从末尾增加元素的方法，但是应当尽力避免这种写法，因为末尾追加元素的操作所需时间随列表的大小线性增加，而使用<code>::</code>只需要常量级的时间。</p>\n</li>\n<li><p>可以通过在头部添加元素的方法，最后调用reverse方法来实现末尾添加的效果</p>\n</li>\n<li><p>也可以使用ListBuffer，这是个可变列表，支持追加操作，最后使用toList方法即可转换为List</p>\n</li>\n</ul>\n<h3 id=\"使用元祖\"><a href=\"#使用元祖\" class=\"headerlink\" title=\"使用元祖\"></a>使用元祖</h3><ul>\n<li><p>元祖也是不可变的，但是元祖可以容纳不同类型的元素。</p>\n</li>\n<li><p>当需要从方法返回多个对象时，元祖就非常有用</p>\n</li>\n<li><p>实例化一个元祖非常简单，只要将对象放在圆括号当中，用逗号隔开即可</p>\n</li>\n<li><p>一旦实例化好一个元祖，就可以用英文句点、下划线和 <strong>从1开始</strong> 的序号来访问每一个元素。</p>\n</li>\n<li><p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val pair = (99,&quot;test&quot;)</span><br><span class=\"line\">pritln(pair._1)\t\t//访问第一个元素</span><br><span class=\"line\">println(pair._2)\t//访问第二个元素</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>元祖的实际类型取决于它的元素。例如：<code>(99,&quot;test&quot;)</code>的类型为<code>Tuple2[Int,String]</code>,而元祖<code>(&#39;u&#39;,&#39;r&#39;,&quot;the&quot;,1,4,&quot;me&quot;)</code>的类型是<code>Tuple6[Char,Char,String,Int,Int,String]</code></p>\n</li>\n<li><p>元祖为什么不能像数组一样用圆括号来访问元素(原文)：</p>\n<blockquote>\n<p>你也许正好奇问什么不能像访问列表元素，也就是“pair(0)”那样访问元祖元素。背后的原因是列表的apply方法永远<strong>只返回同一种类型</strong>，但元祖里的元素可以是不同类型的：<code>_1</code>可能是一种类型，<code>_2</code>可能是另一种</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"使用集和映射\"><a href=\"#使用集和映射\" class=\"headerlink\" title=\"使用集和映射\"></a>使用集和映射</h3><ul>\n<li><p>scala的API包含了一个基础的特质(trait)来表示集，这里的特质跟Java的接口定义类似</p>\n</li>\n<li><p>scala提供了两个子特质：一个表示可变集，一个表示不可变集。(可变集与不可变集位于不同的包)</p>\n</li>\n<li><p>创建一个集合的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var jetSet = Set(&quot;Boeing&quot;,&quot;Airbus&quot;)</span><br><span class=\"line\">jetSet += &quot;Lear&quot;</span><br><span class=\"line\">println(jetSet.contains(&quot;Cessna&quot;))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第一行代码表示，可以像创建列表和数组那样创建集：通过调用Set伴生对象的apply工厂方法。</p>\n</li>\n<li><p>在这个例子中，实际上调用了scala.collection.immutable.Set的伴生对象的apply方法，返回一个默认的、<strong>不可变</strong> 的Set对象，类型为<code>Set[String]</code></p>\n</li>\n<li><p>向集添加元素需要调用<code>+</code>方法。无论是可变集还是不可变集，<code>+</code>方法都会创建并返回一个新的集</p>\n</li>\n<li><p>而本例中的<code>+=</code>方法，实际上不可变集并不提供这个方法，其本质上是<code>jetSet = jetSet + ”Lear&quot;</code>的简写。因此，<strong>其本质上是将jetSet这个var重新赋值成了一个包含三个元素的新的集</strong></p>\n</li>\n<li><p>最后一行是打印集中是否包含”Cessna”这个元素，结果应当是<code>false</code></p>\n</li>\n</ul>\n<h3 id=\"可变集\"><a href=\"#可变集\" class=\"headerlink\" title=\"可变集\"></a>可变集</h3><ul>\n<li><p>使用可变集需要一次引入，例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import scala.collection.mutable</span><br><span class=\"line\">val movieSet = mutable.Set(&quot;Hitch&quot;,&quot;Peter&quot;)</span><br><span class=\"line\">movieSet += &quot;Shrek&quot;</span><br><span class=\"line\">println(movieSet)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过import语句，可以使用简短的<code>mutable.Set()</code>而不是<code>scala.colection.mutable.Set()</code>这样完整的句子</p>\n</li>\n<li><p>这里的<code>+=</code>方法在可变集里是有定义的，因此这个可变集声明时用的是 <code>val</code>而不是 <code>var</code>(上面也提到了不可变集实际上是被重新赋值了，如果使用<code>val</code>会编译报错)</p>\n</li>\n<li><p><code>HashSet</code>的用法与<code>Set</code>一致，只是<code>HashSet</code>的存储方式不同，因此一般在需要考虑性能的地方会用到<code>HashSet</code></p>\n</li>\n</ul>\n<h3 id=\"映射-Map\"><a href=\"#映射-Map\" class=\"headerlink\" title=\"映射(Map)\"></a>映射(Map)</h3><ul>\n<li><p>与Set类似，Map也有可变与不可变的版本。</p>\n</li>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import scala.collection.mutable</span><br><span class=\"line\">val treasureMap = mutable.Map[Int,String]()</span><br><span class=\"line\">treasureMap += (1 -&gt; &quot;Go to island&quot;)</span><br><span class=\"line\">treasureMap += (2 -&gt; &quot;Find big X on ground&quot;)</span><br><span class=\"line\">treasureMap += (3 -&gt; &quot;Dig&quot;)</span><br><span class=\"line\">println(treasureMap(2))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>上面的例子引入了可变Map(默认为不可变映射)，这里与上面可变集一样，定义为val类型。接下来，使用<code>-&gt;</code>来定义键值对。这里scala会将二元操作，比如<code>1 -&gt; &quot;Go to island&quot;</code>转换为标准的方法调用，即<code>(1).-&gt;(&quot;Go to island&quot;)</code>，这里<code>&quot;Go to island&quot;</code>是方法<code>-&gt;</code>的参数。</p>\n</li>\n<li><p>可以对任何对象调用<code>-&gt;</code>方法，它将返回包含键和值两个元素的元组。</p>\n</li>\n<li><p>若要获取Map里的某个键的值，如上面代码的最后一行<code>treasureMap(2)</code>将返回<code>2</code>这个键对应的值。</p>\n</li>\n</ul>\n<h3 id=\"函数式编程风格\"><a href=\"#函数式编程风格\" class=\"headerlink\" title=\"函数式编程风格\"></a>函数式编程风格</h3><ul>\n<li><p>如果一段代码避免了使用<code>var</code>(也就是全是<code>val</code>类型的变量)，那么它很可能是函数式的。因此，向函数式风格的转化应该尽可能地避免使用<code>var</code>类型的变量。</p>\n</li>\n<li><p>指令式编程的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printArgs(args: Array[String]): Unit = &#123;</span><br><span class=\"line\">\tvar i = 0</span><br><span class=\"line\">\twhile (i &lt; args.length)&#123;</span><br><span class=\"line\">\t\tprintln(args(i))</span><br><span class=\"line\">\t\ti += 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以将这段代码转化为函数式的：</p>\n</li>\n</ul>\n<ol>\n<li><p>第一种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printArgs(args: Array[String]): Unit = &#123;</span><br><span class=\"line\">\tfor (arg &lt;- args)  //for表达式形式</span><br><span class=\"line\">\t\tprintln(arg)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printArgs(args: Array[String]): Unit = &#123;</span><br><span class=\"line\">\targs.foreach(println)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><p>另一方面，尽量避免使用带有副作用的函数。就比如上面修改之后的函数，它依旧不是“纯”的函数式代码，因为他有副作用(<em>本处的副作用是向标准输出流打印</em>)。带有副作用的函数的标志特征就是结果类型为<code>Unit</code>。(因为一个一个结果类型为<code>Unit</code>的函数，存在世上的唯一意义就是产生副作用)</p>\n</li>\n<li><p>对于这一问题，函数式编程的做法就是定义一个将传入的<code>args</code>作为格式化(用于打印)的方法，但是只返回这个格式化的字符串。例如上例可以改成：<code>def formatArgs(args: Array[String]) = args.mkString(&quot;\\n&quot;)</code><br>这个函数就满足了既没有<code>var</code>变量也没有副作用。</p>\n</li>\n<li><p>这时我们就可以使用<code>println(formatArgs(args))</code>来实现与上面相同的打印的效果。</p>\n</li>\n</ul>\n<h3 id=\"从文件读取文本行\"><a href=\"#从文件读取文本行\" class=\"headerlink\" title=\"从文件读取文本行\"></a>从文件读取文本行</h3><ul>\n<li><p>例子：从文本读取文本行，并将它们打印出来，在每一行前面带上当前的字符数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import scala.io.Source</span><br><span class=\"line\">if(args.length &gt;0)&#123;</span><br><span class=\"line\">\tfor (line &lt;- Source.fromFile(args(0)).getLines())</span><br><span class=\"line\">\t\tprintln(line.length + &quot; &quot; + filename)</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\tConsole.err.println(&quot;Please enter filename&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这段脚本首先引入了scala.io名为Srouce的类，然后检查命令行是不是至少给出了一个参数。表达式<code>Source.fromFile(args(0))</code>尝试打开指定的文件并且返回一个Source对象。在这个对象上，继续调用<code>getLines</code>方法。</p>\n</li>\n<li><p><code>getLines</code>方法返回一个<code>Iterator[String]</code>，每次迭代都给出一行内容，去掉了最后的换行符。for表达式遍历这些文本行。</p>\n</li>\n<li><p>可以将文本行赋值给一个变量：<code>val lines = Source.fromFile(args(0)).getLines().toList</code></p>\n</li>\n<li><p>其中，最后的<code>toList</code>是必须的。因为<code>getLines</code>方法返回的是一个迭代器，一旦完成遍历，迭代器就会被消耗掉，通过<code>toList</code>方法将它转化为列表，就可以随便遍历这些文本行，多少次都可以(迭代器只能遍历一次)。但是代价就是要在内存中同时存储所有的行。因此<code>lines</code>指向了一个字符串列表。</p>\n</li>\n<li><p><strong>scala也可以使用<code>*</code>来重复一个字符串</strong>，例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; var s = &quot;a&quot; * 5</span><br><span class=\"line\">s: String = aaaaa</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.16</p>\n</blockquote>\n"},{"layout":"post","title":"hadoop集群使用中的一些问题记录","date":"2018-07-20T02:40:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n#### 无法运行spark-shell\n\n- 一般出现这种情况是集群的内存满了\n\n- 使用`df -h`命令来查看存储情况\n\n#### Linux下/proc目录简介\n\n- [linux下proc目录的作用](https://blog.csdn.net/zdwzzu2006/article/details/7747977)\n\n##### 删除文件夹\n\n- 尽量使用`rmdir`来删除一个空目录，如果目录下存在多个文件，要一次性删除所有的使用`rm -rf`来实现。`-r`表示递归删除，`-f`表示强制执行。不过在删除之前一定要仔细确认，一旦删除无法撤销\n","source":"_posts/2018-07-20-cluster-usage.md","raw":"---\nlayout:     post\ntitle:      \"hadoop集群使用中的一些问题记录\"\ndate:       2018-07-20 10:40:00\ncategories: Hadoop CLuster\ntags:   [๑Hadoop, ๑Linux, ๑CLuster]\n---\n\n> 不适合人类阅读的学习笔记\n\n#### 无法运行spark-shell\n\n- 一般出现这种情况是集群的内存满了\n\n- 使用`df -h`命令来查看存储情况\n\n#### Linux下/proc目录简介\n\n- [linux下proc目录的作用](https://blog.csdn.net/zdwzzu2006/article/details/7747977)\n\n##### 删除文件夹\n\n- 尽量使用`rmdir`来删除一个空目录，如果目录下存在多个文件，要一次性删除所有的使用`rm -rf`来实现。`-r`表示递归删除，`-f`表示强制执行。不过在删除之前一定要仔细确认，一旦删除无法撤销\n","slug":"2018-07-20-cluster-usage","published":1,"updated":"2018-09-03T13:09:49.971Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j5900301m0ojqsav55x","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h4 id=\"无法运行spark-shell\"><a href=\"#无法运行spark-shell\" class=\"headerlink\" title=\"无法运行spark-shell\"></a>无法运行spark-shell</h4><ul>\n<li><p>一般出现这种情况是集群的内存满了</p>\n</li>\n<li><p>使用<code>df -h</code>命令来查看存储情况</p>\n</li>\n</ul>\n<h4 id=\"Linux下-proc目录简介\"><a href=\"#Linux下-proc目录简介\" class=\"headerlink\" title=\"Linux下/proc目录简介\"></a>Linux下/proc目录简介</h4><ul>\n<li><a href=\"https://blog.csdn.net/zdwzzu2006/article/details/7747977\" target=\"_blank\" rel=\"noopener\">linux下proc目录的作用</a></li>\n</ul>\n<h5 id=\"删除文件夹\"><a href=\"#删除文件夹\" class=\"headerlink\" title=\"删除文件夹\"></a>删除文件夹</h5><ul>\n<li>尽量使用<code>rmdir</code>来删除一个空目录，如果目录下存在多个文件，要一次性删除所有的使用<code>rm -rf</code>来实现。<code>-r</code>表示递归删除，<code>-f</code>表示强制执行。不过在删除之前一定要仔细确认，一旦删除无法撤销</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h4 id=\"无法运行spark-shell\"><a href=\"#无法运行spark-shell\" class=\"headerlink\" title=\"无法运行spark-shell\"></a>无法运行spark-shell</h4><ul>\n<li><p>一般出现这种情况是集群的内存满了</p>\n</li>\n<li><p>使用<code>df -h</code>命令来查看存储情况</p>\n</li>\n</ul>\n<h4 id=\"Linux下-proc目录简介\"><a href=\"#Linux下-proc目录简介\" class=\"headerlink\" title=\"Linux下/proc目录简介\"></a>Linux下/proc目录简介</h4><ul>\n<li><a href=\"https://blog.csdn.net/zdwzzu2006/article/details/7747977\" target=\"_blank\" rel=\"noopener\">linux下proc目录的作用</a></li>\n</ul>\n<h5 id=\"删除文件夹\"><a href=\"#删除文件夹\" class=\"headerlink\" title=\"删除文件夹\"></a>删除文件夹</h5><ul>\n<li>尽量使用<code>rmdir</code>来删除一个空目录，如果目录下存在多个文件，要一次性删除所有的使用<code>rm -rf</code>来实现。<code>-r</code>表示递归删除，<code>-f</code>表示强制执行。不过在删除之前一定要仔细确认，一旦删除无法撤销</li>\n</ul>\n"},{"layout":"post","title":"《Scala编程》阅读记录——进阶部分","date":"2018-07-19T02:40:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n## 概念\n---\n\n### 序列\n\n- Seq trait用于表示序列。所谓序列，指的是一类具有一定长度的可迭代访问的对象，其中每个元素均带有一个从0开始计数的固定索引位置。\n\n- 常用线性序列有 `scala.collection.immutable.List`和`scala.collection.immutable.Stream`。常用索引序列有 `scala.Array scala.collection.mutable.ArrayBuffer`。Vector 类提供一个在索引访问和线性访问之间有趣的折中。它同时具有高效的恒定时间的索引开销，和恒定时间的线性访问开销。正因为如此，对于混合访问模式，vector是一个很好的基础。\n\n### 缓冲器\n\n- Buffers是可变序列一个重要的种类。它们不仅允许更新现有的元素，而且允许元素的插入、移除和在buffer尾部高效地添加新元素。buffer 支持的主要新方法有：用于在尾部添加元素的`+=` 和 `++=`；用于在前方添加元素的`+=:` 和 `++=:` ；用于插入元素的 `insert`和`insertAll`；以及用于删除元素的 `remove` 和 `-=`。\n\n## 第四章\n---\n\n### 类和对象\n\n- 在类定义中，我们会填入字段(field)和方法(method)，这些统称为成员(member)\n\n- 保持健壮性，我们可以将字段声明为私有(在字段前面加上private修饰符)，访问和修改都通过方法来实现。\nscala的默认访问级别是public\n\n- scala方法参数有一个特征，就是 **它们都是`val`而不是`var`**\n\n- 一个类的例子：\n```\nclass test{\n\tprivate var sum = 0\n\tdef add(b: Byte): Unit = {\n\t\tsum += b\n\t}\n\tdef checksum(): Int = {\n\t\treturn ~(sum & 0xFF) + 1\n\t}\n}\n```\n\n- 在方法中，没有任何显式的return语句时，**scala返回的是该方法计算出的最后一个(表达式的)值** ,因此上面这个例子的return语句可以省略不写\n- 同时，另一种方法的简写方式是，当一个方法只会计算一个返回结果的表达式时，可以不写花括号。如果这个表达式很短，他甚至可以被放置在def的同一行。为了极致的精简，还可以省略掉结果类型。\n\n- 更改后的写法：\n```\nclass test{\n\tprivate var sum = 0\n\tdef add(b: Byte) = sum += b\n\tdef checksum() = ~(sum & 0xFF) + 1\n}\n```\n在这段代码中，scala能够正确地推断出add和checksum这两个方法的结果类型。但是最好的写法是显式地给出结果类型，这样便于代码的调试和维护\n\n- 本例中的add方法结果类型为Unit，执行它的目的就是产生副作用。对于那些仅仅为了其副作用而被执行的方法被称作*过程*。\n\n- 一般分号是没有必要加的，但是如果一行写多个语句，则用分号间隔\n\n### 单例对象\n\n- scala比Java更面向对象一点，是scala **不允许有静态成员**。\n因此，scala提供了*单例对象*，单例对象与普通的类很像，只是将`class`关键字换成了`object`\n\n- 当单例对象跟某个类共用同一个名字时，它被称作这个类的 **伴生对象(companion object)**\n\n- 必须在同一个源码文件中定义类和类的伴生对象，同时，类又叫做这个单例对象的 **伴生类(companion class)**\n\n- 类和它的伴生对象可以互相访问对方的私有成员\n\n- 单例对象当中的方法可以像Java中的静态方法一样直接通过类名来访问\n\n- 单例对象不仅仅用来存放静态方法，他是一等的对象，可以把单例对象想象成附加在对象身上的“名字标签”\n\n- 类和单例对象的区别是单例对象不能被实例化(即没法new一个单例对象，除非这个单例对象有伴生类)\n\n- 单例对象在有代码首次访问时才会被初始化\n\n- 没有同名的伴生类的单例对象称为 *孤立对象*(standalone object)，一般用来将工具方法归集在一起，或定义scala程序的入口。\n\n### scala应用程序\n\n- 要运行一个scala程序，必须提供一个孤立对象，这个孤立对象需要包含一个main方法，该方法接收一个Array[String]作为参数，结果类型为Unit,例如：\n```\nobject Test{\n\tdef main(args: Array[String]): Unit = {\n\t\t...\n\t}\n}\n```\n\n> 注意：scala在每一个源码文件都隐式地引入了java.lang和scala包的成员，以及名为Predef的单例对象的所有成员。例如使用的println和assert都是来自于Predef\n\n- 注意要运行这个程序，那么文件名需要与这个单例对象的名称相同。\n\n### App特质\n\n- scala提供了一个特质scala.App，我们可以不用编写main方法，而是将打算放在main方法里的代码直接写在单例对象的花括号里。不过首先要在单例对象名后加上`extends App`。例子：\n```\nobject AppTest extends App{\n\tfor(i <- 0 to 10){\n\t\tprintln(\"...\")\n\t}\n}\n```\n它可以像正常的scala程序一样运行\n\n## 第五章\n---\n\n### 基础类型和操作\n\n#### 一些基础类型\n\n- Byte、Short、Int、Long和Char类型统称为 *整数类型*，整数类型加上Float和Double类型统称为 *数值类型*\n\n- String是java.lang包的成员\n\n- 注意这些数据类型实际上都是封装好的类，所以首字母都是大写\n\n- Long类型以l或者L结尾\n\n- 字符串插值：\n```\nval name=\"reader\"\nprintln(s\"Hello, $name\")\n```\n\n- 这个的结果与`println(\"Hello\" + name)`是一样的\n\n- scala中raw可以屏蔽转义字符`/`，例如`println(raw\"abc\\n\\n\")`其中斜杠和n将被原样输出\n\n- scala中判断任意两个对象都可以用`==`方法，甚至可以是与null值进行比较而不会报错，并且总能返回正确的比较结果。scala的`==` **只比较值**，而Java的引用类型的==比较的是引用是否相同。\n\n- 赋值操作符`=`的优先级是最低的,而像`*=`这样的操作符也被当做赋值操作符，因此其优先级不如`+`操作符\n\n\n## 第六章 函数式对象\n---\n\n- 如果要在类中重新实现一个已经实现的方法，例如toString方法，要用到override关键字\n\n- 例如`override def toString = {...}`\n\n- 一个例子：创建一个有理数的类，这是个不可变的类并且要求分母不为零\n```\nclass Rational(n: Int, d:Int){\n\trequire(d!=0)\n\toverride def toString = n + \"/\" + d\n}\n```\nrequire方法接受一个boolean的参数。如果传入的参数为true，require将会正常返回。否则,require将会抛出IllegalArgumentException来阻止对象的构建。\n\n### 添加字段\n\n- 例如添加一个add方法：\n```\ndef add(that: Rational): Rational = new(\n\tnew Rational(n * that.d + that.n * d, d * that.d)\n)\n```\n这个方法是会报错的\n\n- 上面那个类如果要添加一个add方法，实现两个Rational类型的值的相加，此时add是不能直接调用this.n或者this.d的(虽然类参数n和d在add方法中是在作用域内的，但是编译器并不允许使用`that.n`和`that.d`，因为that并非指向调用add的那个对象，要访问that的d和n，需要将它做成字段(相当于成员变量))\n我们需要添加字段才行：\n```\nclass Rational(n: Int, d:Int){\n\trequire(d != 0)\n\tval numer: Int = n\n\tval denom: Int = d\n\toverride def toString = numer + \"/\" + denom\n\tdef add(that: Rational): Rational =\n\t\tnew Rational(\n\t\t\tnumer * that.denom + that.numer * denom,\n\t\t\tdenom * that.denom\t\t\n\t\t)\n}\n```\n\n- scala中 字段 默认的访问权限是public\n\n### 自引用\n\n- 使用关键字this，写法为`this.字段名`，也可以直接写字段名，用法与C++和Java一致\n\n- 辅助构造方法：\n`def this(...){...}`\n\n- 操作符也可以像方法一样定义，例如：\n```\ndef + (that: MyClass): MyClass ={...}\n```\n\n- scala支持方法重载，用法与C++和Java相同，通过定义多个参数不同的同名函数来实现重载\n\n\n## 第七章 内建的控制结构\n---\n\n- scala的控制语句都有返回值，可以直接拿来用\n\n- 例子：`println(if (!args.isEmoty) args(0) else \"default.txt\")`\n\n\n- 形如 `a <- b`的称为生成器语法\n\n- `1 to 4` 包含上界 4\n- `1 until 4` 不包含上界 4\n\n\n\n### 过滤\n\n- 有时候遍历集合的时候不想完整地遍历集合，而是先过滤成一个子集。这时可以给for表达式添加过滤器(filter)\n例：\n```\nval filesHere = (new java.io.File(\".\")).listDiles\nfor(file <- filesHere if file.getName.endsWith(\".scala\"))\n\tprintln(file)\n```\n- 过滤器就是for表达式圆括号中的一个if子句，并且可以随意添加更多的过滤器，直接添加if子句即可\n\n### 嵌套迭代\n\n- 如果添加多个`<-`子句，将得到嵌套的循环\n例：\n```\ndef fileLines(file: java.io.File) =\n\tscala.io.Source.fromFile(file).getLines().toList\ndef grep(pattern: String) =\n\tfor(\n\t\tfile <- filesHere\n\t\tif file.getName.endsWith(\".scala\");\n\t\ttrimed = line.trim\n\t\tline <- fileLines(file)\n\t\tif trimed.matches(pattern)\n\t)\n\tprintln(file + \": \" + line.trimed)\ngrep(\".*gcd.*\")\n```\n- 其中，外部循环遍历filesHere，内部循环遍历每个以.scala结尾的file的fileLines(file)\n- 其中trimed作为中途变量绑定，用来保存line.trim的值，避免line.trim被重复计算两次\n\n### match表达式\n\n- 例子：\n```\nval firstArg = if (args.length > 0) args(0) else \"\"\nval friend =\nfirstArg match {\n\tcase \"salt\" => println(\"pepper\")\n\tcase \"chips\" => println(\"salsa\")\n\tcase \"eggs\" => println(\"bacon\")\n\tcase _ =>println(\"huh?\")\n}\nprintln(friend)\n```\n- 这个例子中，match 表达式跟java的switch相比，有一些很重要的区别。其中一个区别是任何常量、字符串等都可以用作样例。另一个区别是，每个可选项后面没有break，因为scala中break是隐含的，不会出现某个可选项执行完又执行下一个的情况\n\n- match表达式会返回值，上例可以直接将匹配的结果打印出来\n\n- 一般不会用到continue和break\n\n- 例如一段java代码：\n```\nint i = 0;\nboolean foundIt = false;\nwhile (i < args.length){\n\tif(args[i].startsWith(\"-\")){\n\t\ti = i + 1;\n\t\tcontinue;\n\t}\n\tif(args[i].endsWith(\".scala\")){\n\t\tfoundIt = true;\n\t\tbreak;\n\t}\n\ti = i+ 1\n}\n```\n\n- scala可以写成：\n```\nvar i = 0\nvar foundIt : Boolean = false\nwhile (i < args.length && !foundIt){\n\tif(!args(i).startsWith(\"-\")){\n\t\tif(args(i).endsWith(\".scala\")\n\t\t\tfoundIt = true\n\t}\n\ti = i + 1\n}\n```\n\n- 或者用递归函数代替循环：\n```\ndef searchFrom(i: Int): Int = {\n\tif(i >= args.length) -1\t\t//未找到返回-1\n\telse if(args(i).startsWith(\"-\")) searchFrom(i + 1)\t//递归查找下一处\n\telse if(args(i).endsWith(\".scala\")) i\t//找到了就返回\n\telse searchFrom(i + 1)\n}\nval i = searchFrom(0)\n```\n- 这个递归去掉了循环，每一个continue都换成了一次以i+1为入参的递归调用\n\n## 第八章 函数和闭包\n---\n\n### 局部函数\n\n- 我们可以在某个函数内部定义函数，就像局部变量一样，这样局部函数只在包含他的代码块中可见，实现了与类中私有方法相同的效果。\n例：\n```\ndef processFile(filename: String, width: Int) = {\n\tdef processLine(line: String) = { //局部函数可以访问包含它们的函数的参数\n\t\tif(line.length > width)\n\t\t\tprintln(filename + \": \" + line.trim)\n\t}\n\tval source = Source.fromFile(filename) //从文件名创建一个名为source的Source对象\n\tfor (line <- source.getLines()){ //getLines()返回一个每次迭代从文件读取一行并去掉换行符的迭代器\n\t\tprocessLine(filename, width, line)\n\t}\n}\n```\n\n### 一等函数*\n\n- 函数字面量被编译成类，并在运行时实例化为函数值。因此，函数字面量和函数值的区别在于，函数字面量存在于，函数字面量存在于源码，而函数值以对象的形式存在于运行时\n\n- 一个函数字面量的简单示例：`(x: Int) => x + 1`\n\n- `=>`表示该函数将左侧的内容转换成右侧的内容，因此这是一个将任何整数x **映射** 成 (x + 1)的函数\n\n- 函数值是对象，所以还可以将他们存放在变量中。同时他们也是函数，也可以用常规的圆括号来调用他们：\n```\nvar increase = (x: Int) => x + 1 //可以将函数字面量赋值给变量\nval n = increase(10)  //可以像一般的函数一样调用\nincrease = (x: Int) => x + 999 //因为increase是var类型，还可以重新赋值\n```\n\n- 如果在函数字面量中有多于一条语句，可以将函数体用花括号括起来\n\n- 所有的集合类(List,Set,Array,Map)都提供了foreach方法，**它接受一个函数作为入参，并对它的每个元素调用这个函数**\n\n- 同时，集合类还有个filter方法。这个方法从集合中选出那些满足条件的元素。这个指定条件由函数表示,例如：`(x: Int) => x > 0`这个方法可以被用来过滤。 **这个函数将所有的正整数映射成true，所有其他的整数映射成false**\n\n### 函数字面量的简写形式\n\n- 一种更为简要的方法是省去参数类型声明：`someNumbers.filter((x) => x > 0)`\n\n- 同时圆括号也可以去掉，因为可以省略掉自动推断类型的参数的圆括号：`someNumbers.filter(x => x > 0)`\n\n### 占位符语法\n\n- 为了让函数字面量更加精简，还可以使用下划线作为占位符，用来表示一个或多个参数，只要满足每个参数只在函数字面量中出现一次即可。例如：`_ > 0` 是一个非常短的表示法，表示一个检查某个值是否大于0的函数\n\n- 例子：`someNumber.filter(_ > 0)`\n\n- 可以将下划线当成是表达式中需要被\"填\"的\"空\"。函数每次被调用，这个空都会被一个入参给填上\n\n- 如果someNumber被初始化为`List(11,10,9,8)`，那么filter方法首先把 `_ > 0`中的空替换成11，即 11 > 0，然后替换成10，以此类推，直到List末尾\n\n\n- 有时候当你用下划线作为参数占位时，编译器可能没有足够的信息来推断缺失的参数类型。\n\n- 例如：\n```\nscala> val f = _ + _\n<console> error: missing parameter type for expanded\nfunction ((x$1, x$2) => x$1.$plus(x$2))\n...\n```\n\n- 这种情况下，可以用冒号来给出类型，就像这样：\n```\nscala> val f = (_: Int) + (_: Int)\nf: (Int, Int) => Int = <function0>\nscala> f(5,10)\nres0: Int = 15\n```\n\n- 注意，`_ + _`将会展开成一个接收两个参数的函数字面量。这就是为什么只有当每个参数在函数字面量中出现不多不少正好一次的时候才能使用这样的精简写法。多个下划线意味着多个参数，而不是对单个参数的重复利用。\n\n### 部分应用的函数\n\n- 下划线还能替换掉整个参数列表，例如：\n```\nscala>def sum(a:Int, b:Int, c:Int) = a + b + c\nsum: (a:Int, b:Int, c:Int)Int\nscala>val a = sum _\na:(Int, Int, Int) => Int = <function3>\nscala> a(1,2,3)\nres0: Int = 6\n```\n\n- 后面的a 即是基于sum创建的一个部分应用函数\n\n\n### 特殊的函数调用形式\n\n#### 重复参数\n\n- scala允许你标示出的参数的最后一个参数可以被重复，这样我们可以对函数传入一个可变长度的参数列表。这样一个重复参数的表示，需要在参数的类型之后加上一个`*`号：\n```\nscala> def echo(args: String) =\n\tfor (arg <- args) println(arg)\necho: (args: String*)Unit\n```\n这样echo就可以接受任意多个String类型的参数(可以是0个)\n\n- 但是如果要将一个适合类型的数组以这种重复参数的形式传入的时候，需要写成如下形式：\n```\nscala> var arr = Array(\"a\",\"v\",\"gf\")\narr:Array[String] = Array(a,v,gf)\nscala> echo(arr: _*)\na\nv\ngf\n```\n这种表示法告诉编译器将arr的每个元素作为参数传给echo，而不是将所有元素放在一起作为单个实参传入\n\n#### 尾递归\n\n- 例子：\n```\ndef approximate(guess: Double): Double =\n\tif (isGoodEnough(guess)) guess\n\telse approximate(improve(guess))\n```\n在合适的isGoodEnough和improve函数的实现下，这个函数就是一个递归函数。而这个递归调用在最后一步的函数称为尾递归(tail recursive)函数\n\n- scala编译器对尾递归函数有特殊的优化，能够检测到尾递归并将他替换为跳转到函数的最开始，并在跳转之前更新参数的值\n\n- 也就是说，我们完全可以用尾递归的方法来代替循环而不用付出任何额外的开销\n\n- 尾递归不会在每次调用时构建一个新的栈，所有的调用都会在同一个栈中进行\n\n- 如下有个例子：\n```\ndef boom(x: Int): Int =\n\tif(x == 0) throw new Exception (\"boom!\")\n\telse boom(x - 1) + 1\n```\n这个函数不是一个尾递归的，因为 **它在递归调用之后还执行了一个递增操作**\n\n- 但是scala中尾递归是受限的，更高级形式的尾递归实现十分困难。scala只能对那些直接尾递归的函数做优化\n\n\n## 第九章 控制抽象\n---\n\n### 减少代码重复\n\n- 例子：\n```\ndef filesMatching(query: String,\n\tmatcher: (String, String) => Boolean) = {\n\tfor (file <- filesHere; if matcher(file.getName, query))\n\t\tyield file\n}\n```\n- 在这个方法中，if子句用matcher来检查文件名是否满足条件，这个检查具体做什么，取决于具体的matcher。matcher本身是一个函数，因此类型声明中有一个`=>`符号。这个函数接受两个字符串类型的参数(分别是文件名和查询条件)，返回一个布尔值，因此这个参数的类型为`(String, String) => Boolean`\n\n- 下面三个方法分别使用三种不同的参数matcher来实现不同的文件查找功能:\n```\ndef filesEnding(query: String) =\n\tfilesMatching(query, _.endsWith(_))\n```\n```\ndef filesContaning(query: String) =\n\tfilesMatching(query, _.contains(_))\n```\n```\ndef filesRegex(query: String) =\n\tfilesMatching(query, _.matches(_))\n```\n- 其中，`_.endsWith(_)`的含义与下面的代码是一样的`(fileName: String, query: String) => fileName.endsWith(query)` 两个下划线按顺序作为传入的两个参数的占位符\n\n\n\n\n\n\n\n\n\n<br>\n> 最后更新于2018.7.23\n","source":"_posts/2018-07-19-scala-learning-02.md","raw":"---\nlayout:     post\ntitle:      \"《Scala编程》阅读记录——进阶部分\"\ndate:       2018-07-19 10:40:00\ncategories: Computer Programes\ntags:   ๑Scala\n---\n\n> 不适合人类阅读的学习笔记\n\n## 概念\n---\n\n### 序列\n\n- Seq trait用于表示序列。所谓序列，指的是一类具有一定长度的可迭代访问的对象，其中每个元素均带有一个从0开始计数的固定索引位置。\n\n- 常用线性序列有 `scala.collection.immutable.List`和`scala.collection.immutable.Stream`。常用索引序列有 `scala.Array scala.collection.mutable.ArrayBuffer`。Vector 类提供一个在索引访问和线性访问之间有趣的折中。它同时具有高效的恒定时间的索引开销，和恒定时间的线性访问开销。正因为如此，对于混合访问模式，vector是一个很好的基础。\n\n### 缓冲器\n\n- Buffers是可变序列一个重要的种类。它们不仅允许更新现有的元素，而且允许元素的插入、移除和在buffer尾部高效地添加新元素。buffer 支持的主要新方法有：用于在尾部添加元素的`+=` 和 `++=`；用于在前方添加元素的`+=:` 和 `++=:` ；用于插入元素的 `insert`和`insertAll`；以及用于删除元素的 `remove` 和 `-=`。\n\n## 第四章\n---\n\n### 类和对象\n\n- 在类定义中，我们会填入字段(field)和方法(method)，这些统称为成员(member)\n\n- 保持健壮性，我们可以将字段声明为私有(在字段前面加上private修饰符)，访问和修改都通过方法来实现。\nscala的默认访问级别是public\n\n- scala方法参数有一个特征，就是 **它们都是`val`而不是`var`**\n\n- 一个类的例子：\n```\nclass test{\n\tprivate var sum = 0\n\tdef add(b: Byte): Unit = {\n\t\tsum += b\n\t}\n\tdef checksum(): Int = {\n\t\treturn ~(sum & 0xFF) + 1\n\t}\n}\n```\n\n- 在方法中，没有任何显式的return语句时，**scala返回的是该方法计算出的最后一个(表达式的)值** ,因此上面这个例子的return语句可以省略不写\n- 同时，另一种方法的简写方式是，当一个方法只会计算一个返回结果的表达式时，可以不写花括号。如果这个表达式很短，他甚至可以被放置在def的同一行。为了极致的精简，还可以省略掉结果类型。\n\n- 更改后的写法：\n```\nclass test{\n\tprivate var sum = 0\n\tdef add(b: Byte) = sum += b\n\tdef checksum() = ~(sum & 0xFF) + 1\n}\n```\n在这段代码中，scala能够正确地推断出add和checksum这两个方法的结果类型。但是最好的写法是显式地给出结果类型，这样便于代码的调试和维护\n\n- 本例中的add方法结果类型为Unit，执行它的目的就是产生副作用。对于那些仅仅为了其副作用而被执行的方法被称作*过程*。\n\n- 一般分号是没有必要加的，但是如果一行写多个语句，则用分号间隔\n\n### 单例对象\n\n- scala比Java更面向对象一点，是scala **不允许有静态成员**。\n因此，scala提供了*单例对象*，单例对象与普通的类很像，只是将`class`关键字换成了`object`\n\n- 当单例对象跟某个类共用同一个名字时，它被称作这个类的 **伴生对象(companion object)**\n\n- 必须在同一个源码文件中定义类和类的伴生对象，同时，类又叫做这个单例对象的 **伴生类(companion class)**\n\n- 类和它的伴生对象可以互相访问对方的私有成员\n\n- 单例对象当中的方法可以像Java中的静态方法一样直接通过类名来访问\n\n- 单例对象不仅仅用来存放静态方法，他是一等的对象，可以把单例对象想象成附加在对象身上的“名字标签”\n\n- 类和单例对象的区别是单例对象不能被实例化(即没法new一个单例对象，除非这个单例对象有伴生类)\n\n- 单例对象在有代码首次访问时才会被初始化\n\n- 没有同名的伴生类的单例对象称为 *孤立对象*(standalone object)，一般用来将工具方法归集在一起，或定义scala程序的入口。\n\n### scala应用程序\n\n- 要运行一个scala程序，必须提供一个孤立对象，这个孤立对象需要包含一个main方法，该方法接收一个Array[String]作为参数，结果类型为Unit,例如：\n```\nobject Test{\n\tdef main(args: Array[String]): Unit = {\n\t\t...\n\t}\n}\n```\n\n> 注意：scala在每一个源码文件都隐式地引入了java.lang和scala包的成员，以及名为Predef的单例对象的所有成员。例如使用的println和assert都是来自于Predef\n\n- 注意要运行这个程序，那么文件名需要与这个单例对象的名称相同。\n\n### App特质\n\n- scala提供了一个特质scala.App，我们可以不用编写main方法，而是将打算放在main方法里的代码直接写在单例对象的花括号里。不过首先要在单例对象名后加上`extends App`。例子：\n```\nobject AppTest extends App{\n\tfor(i <- 0 to 10){\n\t\tprintln(\"...\")\n\t}\n}\n```\n它可以像正常的scala程序一样运行\n\n## 第五章\n---\n\n### 基础类型和操作\n\n#### 一些基础类型\n\n- Byte、Short、Int、Long和Char类型统称为 *整数类型*，整数类型加上Float和Double类型统称为 *数值类型*\n\n- String是java.lang包的成员\n\n- 注意这些数据类型实际上都是封装好的类，所以首字母都是大写\n\n- Long类型以l或者L结尾\n\n- 字符串插值：\n```\nval name=\"reader\"\nprintln(s\"Hello, $name\")\n```\n\n- 这个的结果与`println(\"Hello\" + name)`是一样的\n\n- scala中raw可以屏蔽转义字符`/`，例如`println(raw\"abc\\n\\n\")`其中斜杠和n将被原样输出\n\n- scala中判断任意两个对象都可以用`==`方法，甚至可以是与null值进行比较而不会报错，并且总能返回正确的比较结果。scala的`==` **只比较值**，而Java的引用类型的==比较的是引用是否相同。\n\n- 赋值操作符`=`的优先级是最低的,而像`*=`这样的操作符也被当做赋值操作符，因此其优先级不如`+`操作符\n\n\n## 第六章 函数式对象\n---\n\n- 如果要在类中重新实现一个已经实现的方法，例如toString方法，要用到override关键字\n\n- 例如`override def toString = {...}`\n\n- 一个例子：创建一个有理数的类，这是个不可变的类并且要求分母不为零\n```\nclass Rational(n: Int, d:Int){\n\trequire(d!=0)\n\toverride def toString = n + \"/\" + d\n}\n```\nrequire方法接受一个boolean的参数。如果传入的参数为true，require将会正常返回。否则,require将会抛出IllegalArgumentException来阻止对象的构建。\n\n### 添加字段\n\n- 例如添加一个add方法：\n```\ndef add(that: Rational): Rational = new(\n\tnew Rational(n * that.d + that.n * d, d * that.d)\n)\n```\n这个方法是会报错的\n\n- 上面那个类如果要添加一个add方法，实现两个Rational类型的值的相加，此时add是不能直接调用this.n或者this.d的(虽然类参数n和d在add方法中是在作用域内的，但是编译器并不允许使用`that.n`和`that.d`，因为that并非指向调用add的那个对象，要访问that的d和n，需要将它做成字段(相当于成员变量))\n我们需要添加字段才行：\n```\nclass Rational(n: Int, d:Int){\n\trequire(d != 0)\n\tval numer: Int = n\n\tval denom: Int = d\n\toverride def toString = numer + \"/\" + denom\n\tdef add(that: Rational): Rational =\n\t\tnew Rational(\n\t\t\tnumer * that.denom + that.numer * denom,\n\t\t\tdenom * that.denom\t\t\n\t\t)\n}\n```\n\n- scala中 字段 默认的访问权限是public\n\n### 自引用\n\n- 使用关键字this，写法为`this.字段名`，也可以直接写字段名，用法与C++和Java一致\n\n- 辅助构造方法：\n`def this(...){...}`\n\n- 操作符也可以像方法一样定义，例如：\n```\ndef + (that: MyClass): MyClass ={...}\n```\n\n- scala支持方法重载，用法与C++和Java相同，通过定义多个参数不同的同名函数来实现重载\n\n\n## 第七章 内建的控制结构\n---\n\n- scala的控制语句都有返回值，可以直接拿来用\n\n- 例子：`println(if (!args.isEmoty) args(0) else \"default.txt\")`\n\n\n- 形如 `a <- b`的称为生成器语法\n\n- `1 to 4` 包含上界 4\n- `1 until 4` 不包含上界 4\n\n\n\n### 过滤\n\n- 有时候遍历集合的时候不想完整地遍历集合，而是先过滤成一个子集。这时可以给for表达式添加过滤器(filter)\n例：\n```\nval filesHere = (new java.io.File(\".\")).listDiles\nfor(file <- filesHere if file.getName.endsWith(\".scala\"))\n\tprintln(file)\n```\n- 过滤器就是for表达式圆括号中的一个if子句，并且可以随意添加更多的过滤器，直接添加if子句即可\n\n### 嵌套迭代\n\n- 如果添加多个`<-`子句，将得到嵌套的循环\n例：\n```\ndef fileLines(file: java.io.File) =\n\tscala.io.Source.fromFile(file).getLines().toList\ndef grep(pattern: String) =\n\tfor(\n\t\tfile <- filesHere\n\t\tif file.getName.endsWith(\".scala\");\n\t\ttrimed = line.trim\n\t\tline <- fileLines(file)\n\t\tif trimed.matches(pattern)\n\t)\n\tprintln(file + \": \" + line.trimed)\ngrep(\".*gcd.*\")\n```\n- 其中，外部循环遍历filesHere，内部循环遍历每个以.scala结尾的file的fileLines(file)\n- 其中trimed作为中途变量绑定，用来保存line.trim的值，避免line.trim被重复计算两次\n\n### match表达式\n\n- 例子：\n```\nval firstArg = if (args.length > 0) args(0) else \"\"\nval friend =\nfirstArg match {\n\tcase \"salt\" => println(\"pepper\")\n\tcase \"chips\" => println(\"salsa\")\n\tcase \"eggs\" => println(\"bacon\")\n\tcase _ =>println(\"huh?\")\n}\nprintln(friend)\n```\n- 这个例子中，match 表达式跟java的switch相比，有一些很重要的区别。其中一个区别是任何常量、字符串等都可以用作样例。另一个区别是，每个可选项后面没有break，因为scala中break是隐含的，不会出现某个可选项执行完又执行下一个的情况\n\n- match表达式会返回值，上例可以直接将匹配的结果打印出来\n\n- 一般不会用到continue和break\n\n- 例如一段java代码：\n```\nint i = 0;\nboolean foundIt = false;\nwhile (i < args.length){\n\tif(args[i].startsWith(\"-\")){\n\t\ti = i + 1;\n\t\tcontinue;\n\t}\n\tif(args[i].endsWith(\".scala\")){\n\t\tfoundIt = true;\n\t\tbreak;\n\t}\n\ti = i+ 1\n}\n```\n\n- scala可以写成：\n```\nvar i = 0\nvar foundIt : Boolean = false\nwhile (i < args.length && !foundIt){\n\tif(!args(i).startsWith(\"-\")){\n\t\tif(args(i).endsWith(\".scala\")\n\t\t\tfoundIt = true\n\t}\n\ti = i + 1\n}\n```\n\n- 或者用递归函数代替循环：\n```\ndef searchFrom(i: Int): Int = {\n\tif(i >= args.length) -1\t\t//未找到返回-1\n\telse if(args(i).startsWith(\"-\")) searchFrom(i + 1)\t//递归查找下一处\n\telse if(args(i).endsWith(\".scala\")) i\t//找到了就返回\n\telse searchFrom(i + 1)\n}\nval i = searchFrom(0)\n```\n- 这个递归去掉了循环，每一个continue都换成了一次以i+1为入参的递归调用\n\n## 第八章 函数和闭包\n---\n\n### 局部函数\n\n- 我们可以在某个函数内部定义函数，就像局部变量一样，这样局部函数只在包含他的代码块中可见，实现了与类中私有方法相同的效果。\n例：\n```\ndef processFile(filename: String, width: Int) = {\n\tdef processLine(line: String) = { //局部函数可以访问包含它们的函数的参数\n\t\tif(line.length > width)\n\t\t\tprintln(filename + \": \" + line.trim)\n\t}\n\tval source = Source.fromFile(filename) //从文件名创建一个名为source的Source对象\n\tfor (line <- source.getLines()){ //getLines()返回一个每次迭代从文件读取一行并去掉换行符的迭代器\n\t\tprocessLine(filename, width, line)\n\t}\n}\n```\n\n### 一等函数*\n\n- 函数字面量被编译成类，并在运行时实例化为函数值。因此，函数字面量和函数值的区别在于，函数字面量存在于，函数字面量存在于源码，而函数值以对象的形式存在于运行时\n\n- 一个函数字面量的简单示例：`(x: Int) => x + 1`\n\n- `=>`表示该函数将左侧的内容转换成右侧的内容，因此这是一个将任何整数x **映射** 成 (x + 1)的函数\n\n- 函数值是对象，所以还可以将他们存放在变量中。同时他们也是函数，也可以用常规的圆括号来调用他们：\n```\nvar increase = (x: Int) => x + 1 //可以将函数字面量赋值给变量\nval n = increase(10)  //可以像一般的函数一样调用\nincrease = (x: Int) => x + 999 //因为increase是var类型，还可以重新赋值\n```\n\n- 如果在函数字面量中有多于一条语句，可以将函数体用花括号括起来\n\n- 所有的集合类(List,Set,Array,Map)都提供了foreach方法，**它接受一个函数作为入参，并对它的每个元素调用这个函数**\n\n- 同时，集合类还有个filter方法。这个方法从集合中选出那些满足条件的元素。这个指定条件由函数表示,例如：`(x: Int) => x > 0`这个方法可以被用来过滤。 **这个函数将所有的正整数映射成true，所有其他的整数映射成false**\n\n### 函数字面量的简写形式\n\n- 一种更为简要的方法是省去参数类型声明：`someNumbers.filter((x) => x > 0)`\n\n- 同时圆括号也可以去掉，因为可以省略掉自动推断类型的参数的圆括号：`someNumbers.filter(x => x > 0)`\n\n### 占位符语法\n\n- 为了让函数字面量更加精简，还可以使用下划线作为占位符，用来表示一个或多个参数，只要满足每个参数只在函数字面量中出现一次即可。例如：`_ > 0` 是一个非常短的表示法，表示一个检查某个值是否大于0的函数\n\n- 例子：`someNumber.filter(_ > 0)`\n\n- 可以将下划线当成是表达式中需要被\"填\"的\"空\"。函数每次被调用，这个空都会被一个入参给填上\n\n- 如果someNumber被初始化为`List(11,10,9,8)`，那么filter方法首先把 `_ > 0`中的空替换成11，即 11 > 0，然后替换成10，以此类推，直到List末尾\n\n\n- 有时候当你用下划线作为参数占位时，编译器可能没有足够的信息来推断缺失的参数类型。\n\n- 例如：\n```\nscala> val f = _ + _\n<console> error: missing parameter type for expanded\nfunction ((x$1, x$2) => x$1.$plus(x$2))\n...\n```\n\n- 这种情况下，可以用冒号来给出类型，就像这样：\n```\nscala> val f = (_: Int) + (_: Int)\nf: (Int, Int) => Int = <function0>\nscala> f(5,10)\nres0: Int = 15\n```\n\n- 注意，`_ + _`将会展开成一个接收两个参数的函数字面量。这就是为什么只有当每个参数在函数字面量中出现不多不少正好一次的时候才能使用这样的精简写法。多个下划线意味着多个参数，而不是对单个参数的重复利用。\n\n### 部分应用的函数\n\n- 下划线还能替换掉整个参数列表，例如：\n```\nscala>def sum(a:Int, b:Int, c:Int) = a + b + c\nsum: (a:Int, b:Int, c:Int)Int\nscala>val a = sum _\na:(Int, Int, Int) => Int = <function3>\nscala> a(1,2,3)\nres0: Int = 6\n```\n\n- 后面的a 即是基于sum创建的一个部分应用函数\n\n\n### 特殊的函数调用形式\n\n#### 重复参数\n\n- scala允许你标示出的参数的最后一个参数可以被重复，这样我们可以对函数传入一个可变长度的参数列表。这样一个重复参数的表示，需要在参数的类型之后加上一个`*`号：\n```\nscala> def echo(args: String) =\n\tfor (arg <- args) println(arg)\necho: (args: String*)Unit\n```\n这样echo就可以接受任意多个String类型的参数(可以是0个)\n\n- 但是如果要将一个适合类型的数组以这种重复参数的形式传入的时候，需要写成如下形式：\n```\nscala> var arr = Array(\"a\",\"v\",\"gf\")\narr:Array[String] = Array(a,v,gf)\nscala> echo(arr: _*)\na\nv\ngf\n```\n这种表示法告诉编译器将arr的每个元素作为参数传给echo，而不是将所有元素放在一起作为单个实参传入\n\n#### 尾递归\n\n- 例子：\n```\ndef approximate(guess: Double): Double =\n\tif (isGoodEnough(guess)) guess\n\telse approximate(improve(guess))\n```\n在合适的isGoodEnough和improve函数的实现下，这个函数就是一个递归函数。而这个递归调用在最后一步的函数称为尾递归(tail recursive)函数\n\n- scala编译器对尾递归函数有特殊的优化，能够检测到尾递归并将他替换为跳转到函数的最开始，并在跳转之前更新参数的值\n\n- 也就是说，我们完全可以用尾递归的方法来代替循环而不用付出任何额外的开销\n\n- 尾递归不会在每次调用时构建一个新的栈，所有的调用都会在同一个栈中进行\n\n- 如下有个例子：\n```\ndef boom(x: Int): Int =\n\tif(x == 0) throw new Exception (\"boom!\")\n\telse boom(x - 1) + 1\n```\n这个函数不是一个尾递归的，因为 **它在递归调用之后还执行了一个递增操作**\n\n- 但是scala中尾递归是受限的，更高级形式的尾递归实现十分困难。scala只能对那些直接尾递归的函数做优化\n\n\n## 第九章 控制抽象\n---\n\n### 减少代码重复\n\n- 例子：\n```\ndef filesMatching(query: String,\n\tmatcher: (String, String) => Boolean) = {\n\tfor (file <- filesHere; if matcher(file.getName, query))\n\t\tyield file\n}\n```\n- 在这个方法中，if子句用matcher来检查文件名是否满足条件，这个检查具体做什么，取决于具体的matcher。matcher本身是一个函数，因此类型声明中有一个`=>`符号。这个函数接受两个字符串类型的参数(分别是文件名和查询条件)，返回一个布尔值，因此这个参数的类型为`(String, String) => Boolean`\n\n- 下面三个方法分别使用三种不同的参数matcher来实现不同的文件查找功能:\n```\ndef filesEnding(query: String) =\n\tfilesMatching(query, _.endsWith(_))\n```\n```\ndef filesContaning(query: String) =\n\tfilesMatching(query, _.contains(_))\n```\n```\ndef filesRegex(query: String) =\n\tfilesMatching(query, _.matches(_))\n```\n- 其中，`_.endsWith(_)`的含义与下面的代码是一样的`(fileName: String, query: String) => fileName.endsWith(query)` 两个下划线按顺序作为传入的两个参数的占位符\n\n\n\n\n\n\n\n\n\n<br>\n> 最后更新于2018.7.23\n","slug":"2018-07-19-scala-learning-02","published":1,"updated":"2018-09-03T13:10:44.611Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j5a00341m0otoj9jpjv","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><hr>\n<h3 id=\"序列\"><a href=\"#序列\" class=\"headerlink\" title=\"序列\"></a>序列</h3><ul>\n<li><p>Seq trait用于表示序列。所谓序列，指的是一类具有一定长度的可迭代访问的对象，其中每个元素均带有一个从0开始计数的固定索引位置。</p>\n</li>\n<li><p>常用线性序列有 <code>scala.collection.immutable.List</code>和<code>scala.collection.immutable.Stream</code>。常用索引序列有 <code>scala.Array scala.collection.mutable.ArrayBuffer</code>。Vector 类提供一个在索引访问和线性访问之间有趣的折中。它同时具有高效的恒定时间的索引开销，和恒定时间的线性访问开销。正因为如此，对于混合访问模式，vector是一个很好的基础。</p>\n</li>\n</ul>\n<h3 id=\"缓冲器\"><a href=\"#缓冲器\" class=\"headerlink\" title=\"缓冲器\"></a>缓冲器</h3><ul>\n<li>Buffers是可变序列一个重要的种类。它们不仅允许更新现有的元素，而且允许元素的插入、移除和在buffer尾部高效地添加新元素。buffer 支持的主要新方法有：用于在尾部添加元素的<code>+=</code> 和 <code>++=</code>；用于在前方添加元素的<code>+=:</code> 和 <code>++=:</code> ；用于插入元素的 <code>insert</code>和<code>insertAll</code>；以及用于删除元素的 <code>remove</code> 和 <code>-=</code>。</li>\n</ul>\n<h2 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h2><hr>\n<h3 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h3><ul>\n<li><p>在类定义中，我们会填入字段(field)和方法(method)，这些统称为成员(member)</p>\n</li>\n<li><p>保持健壮性，我们可以将字段声明为私有(在字段前面加上private修饰符)，访问和修改都通过方法来实现。<br>scala的默认访问级别是public</p>\n</li>\n<li><p>scala方法参数有一个特征，就是 <strong>它们都是<code>val</code>而不是<code>var</code></strong></p>\n</li>\n<li><p>一个类的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class test&#123;</span><br><span class=\"line\">\tprivate var sum = 0</span><br><span class=\"line\">\tdef add(b: Byte): Unit = &#123;</span><br><span class=\"line\">\t\tsum += b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdef checksum(): Int = &#123;</span><br><span class=\"line\">\t\treturn ~(sum &amp; 0xFF) + 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在方法中，没有任何显式的return语句时，<strong>scala返回的是该方法计算出的最后一个(表达式的)值</strong> ,因此上面这个例子的return语句可以省略不写</p>\n</li>\n<li><p>同时，另一种方法的简写方式是，当一个方法只会计算一个返回结果的表达式时，可以不写花括号。如果这个表达式很短，他甚至可以被放置在def的同一行。为了极致的精简，还可以省略掉结果类型。</p>\n</li>\n<li><p>更改后的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class test&#123;</span><br><span class=\"line\">\tprivate var sum = 0</span><br><span class=\"line\">\tdef add(b: Byte) = sum += b</span><br><span class=\"line\">\tdef checksum() = ~(sum &amp; 0xFF) + 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在这段代码中，scala能够正确地推断出add和checksum这两个方法的结果类型。但是最好的写法是显式地给出结果类型，这样便于代码的调试和维护</p>\n<ul>\n<li><p>本例中的add方法结果类型为Unit，执行它的目的就是产生副作用。对于那些仅仅为了其副作用而被执行的方法被称作<em>过程</em>。</p>\n</li>\n<li><p>一般分号是没有必要加的，但是如果一行写多个语句，则用分号间隔</p>\n</li>\n</ul>\n<h3 id=\"单例对象\"><a href=\"#单例对象\" class=\"headerlink\" title=\"单例对象\"></a>单例对象</h3><ul>\n<li><p>scala比Java更面向对象一点，是scala <strong>不允许有静态成员</strong>。<br>因此，scala提供了<em>单例对象</em>，单例对象与普通的类很像，只是将<code>class</code>关键字换成了<code>object</code></p>\n</li>\n<li><p>当单例对象跟某个类共用同一个名字时，它被称作这个类的 <strong>伴生对象(companion object)</strong></p>\n</li>\n<li><p>必须在同一个源码文件中定义类和类的伴生对象，同时，类又叫做这个单例对象的 <strong>伴生类(companion class)</strong></p>\n</li>\n<li><p>类和它的伴生对象可以互相访问对方的私有成员</p>\n</li>\n<li><p>单例对象当中的方法可以像Java中的静态方法一样直接通过类名来访问</p>\n</li>\n<li><p>单例对象不仅仅用来存放静态方法，他是一等的对象，可以把单例对象想象成附加在对象身上的“名字标签”</p>\n</li>\n<li><p>类和单例对象的区别是单例对象不能被实例化(即没法new一个单例对象，除非这个单例对象有伴生类)</p>\n</li>\n<li><p>单例对象在有代码首次访问时才会被初始化</p>\n</li>\n<li><p>没有同名的伴生类的单例对象称为 <em>孤立对象</em>(standalone object)，一般用来将工具方法归集在一起，或定义scala程序的入口。</p>\n</li>\n</ul>\n<h3 id=\"scala应用程序\"><a href=\"#scala应用程序\" class=\"headerlink\" title=\"scala应用程序\"></a>scala应用程序</h3><ul>\n<li>要运行一个scala程序，必须提供一个孤立对象，这个孤立对象需要包含一个main方法，该方法接收一个Array[String]作为参数，结果类型为Unit,例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object Test&#123;</span><br><span class=\"line\">\tdef main(args: Array[String]): Unit = &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>注意：scala在每一个源码文件都隐式地引入了java.lang和scala包的成员，以及名为Predef的单例对象的所有成员。例如使用的println和assert都是来自于Predef</p>\n</blockquote>\n<ul>\n<li>注意要运行这个程序，那么文件名需要与这个单例对象的名称相同。</li>\n</ul>\n<h3 id=\"App特质\"><a href=\"#App特质\" class=\"headerlink\" title=\"App特质\"></a>App特质</h3><ul>\n<li>scala提供了一个特质scala.App，我们可以不用编写main方法，而是将打算放在main方法里的代码直接写在单例对象的花括号里。不过首先要在单例对象名后加上<code>extends App</code>。例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object AppTest extends App&#123;</span><br><span class=\"line\">\tfor(i &lt;- 0 to 10)&#123;</span><br><span class=\"line\">\t\tprintln(&quot;...&quot;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>它可以像正常的scala程序一样运行</p>\n<h2 id=\"第五章\"><a href=\"#第五章\" class=\"headerlink\" title=\"第五章\"></a>第五章</h2><hr>\n<h3 id=\"基础类型和操作\"><a href=\"#基础类型和操作\" class=\"headerlink\" title=\"基础类型和操作\"></a>基础类型和操作</h3><h4 id=\"一些基础类型\"><a href=\"#一些基础类型\" class=\"headerlink\" title=\"一些基础类型\"></a>一些基础类型</h4><ul>\n<li><p>Byte、Short、Int、Long和Char类型统称为 <em>整数类型</em>，整数类型加上Float和Double类型统称为 <em>数值类型</em></p>\n</li>\n<li><p>String是java.lang包的成员</p>\n</li>\n<li><p>注意这些数据类型实际上都是封装好的类，所以首字母都是大写</p>\n</li>\n<li><p>Long类型以l或者L结尾</p>\n</li>\n<li><p>字符串插值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val name=&quot;reader&quot;</span><br><span class=\"line\">println(s&quot;Hello, $name&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这个的结果与<code>println(&quot;Hello&quot; + name)</code>是一样的</p>\n</li>\n<li><p>scala中raw可以屏蔽转义字符<code>/</code>，例如<code>println(raw&quot;abc\\n\\n&quot;)</code>其中斜杠和n将被原样输出</p>\n</li>\n<li><p>scala中判断任意两个对象都可以用<code>==</code>方法，甚至可以是与null值进行比较而不会报错，并且总能返回正确的比较结果。scala的<code>==</code> <strong>只比较值</strong>，而Java的引用类型的==比较的是引用是否相同。</p>\n</li>\n<li><p>赋值操作符<code>=</code>的优先级是最低的,而像<code>*=</code>这样的操作符也被当做赋值操作符，因此其优先级不如<code>+</code>操作符</p>\n</li>\n</ul>\n<h2 id=\"第六章-函数式对象\"><a href=\"#第六章-函数式对象\" class=\"headerlink\" title=\"第六章 函数式对象\"></a>第六章 函数式对象</h2><hr>\n<ul>\n<li><p>如果要在类中重新实现一个已经实现的方法，例如toString方法，要用到override关键字</p>\n</li>\n<li><p>例如<code>override def toString = {...}</code></p>\n</li>\n<li><p>一个例子：创建一个有理数的类，这是个不可变的类并且要求分母不为零</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Rational(n: Int, d:Int)&#123;</span><br><span class=\"line\">\trequire(d!=0)</span><br><span class=\"line\">\toverride def toString = n + &quot;/&quot; + d</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>require方法接受一个boolean的参数。如果传入的参数为true，require将会正常返回。否则,require将会抛出IllegalArgumentException来阻止对象的构建。</p>\n<h3 id=\"添加字段\"><a href=\"#添加字段\" class=\"headerlink\" title=\"添加字段\"></a>添加字段</h3><ul>\n<li>例如添加一个add方法：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def add(that: Rational): Rational = new(</span><br><span class=\"line\">\tnew Rational(n * that.d + that.n * d, d * that.d)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个方法是会报错的</p>\n<ul>\n<li><p>上面那个类如果要添加一个add方法，实现两个Rational类型的值的相加，此时add是不能直接调用this.n或者this.d的(虽然类参数n和d在add方法中是在作用域内的，但是编译器并不允许使用<code>that.n</code>和<code>that.d</code>，因为that并非指向调用add的那个对象，要访问that的d和n，需要将它做成字段(相当于成员变量))<br>我们需要添加字段才行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Rational(n: Int, d:Int)&#123;</span><br><span class=\"line\">\trequire(d != 0)</span><br><span class=\"line\">\tval numer: Int = n</span><br><span class=\"line\">\tval denom: Int = d</span><br><span class=\"line\">\toverride def toString = numer + &quot;/&quot; + denom</span><br><span class=\"line\">\tdef add(that: Rational): Rational =</span><br><span class=\"line\">\t\tnew Rational(</span><br><span class=\"line\">\t\t\tnumer * that.denom + that.numer * denom,</span><br><span class=\"line\">\t\t\tdenom * that.denom\t\t</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scala中 字段 默认的访问权限是public</p>\n</li>\n</ul>\n<h3 id=\"自引用\"><a href=\"#自引用\" class=\"headerlink\" title=\"自引用\"></a>自引用</h3><ul>\n<li><p>使用关键字this，写法为<code>this.字段名</code>，也可以直接写字段名，用法与C++和Java一致</p>\n</li>\n<li><p>辅助构造方法：<br><code>def this(...){...}</code></p>\n</li>\n<li><p>操作符也可以像方法一样定义，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def + (that: MyClass): MyClass =&#123;...&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scala支持方法重载，用法与C++和Java相同，通过定义多个参数不同的同名函数来实现重载</p>\n</li>\n</ul>\n<h2 id=\"第七章-内建的控制结构\"><a href=\"#第七章-内建的控制结构\" class=\"headerlink\" title=\"第七章 内建的控制结构\"></a>第七章 内建的控制结构</h2><hr>\n<ul>\n<li><p>scala的控制语句都有返回值，可以直接拿来用</p>\n</li>\n<li><p>例子：<code>println(if (!args.isEmoty) args(0) else &quot;default.txt&quot;)</code></p>\n</li>\n</ul>\n<ul>\n<li><p>形如 <code>a &lt;- b</code>的称为生成器语法</p>\n</li>\n<li><p><code>1 to 4</code> 包含上界 4</p>\n</li>\n<li><code>1 until 4</code> 不包含上界 4</li>\n</ul>\n<h3 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h3><ul>\n<li><p>有时候遍历集合的时候不想完整地遍历集合，而是先过滤成一个子集。这时可以给for表达式添加过滤器(filter)<br>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val filesHere = (new java.io.File(&quot;.&quot;)).listDiles</span><br><span class=\"line\">for(file &lt;- filesHere if file.getName.endsWith(&quot;.scala&quot;))</span><br><span class=\"line\">\tprintln(file)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>过滤器就是for表达式圆括号中的一个if子句，并且可以随意添加更多的过滤器，直接添加if子句即可</p>\n</li>\n</ul>\n<h3 id=\"嵌套迭代\"><a href=\"#嵌套迭代\" class=\"headerlink\" title=\"嵌套迭代\"></a>嵌套迭代</h3><ul>\n<li><p>如果添加多个<code>&lt;-</code>子句，将得到嵌套的循环<br>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fileLines(file: java.io.File) =</span><br><span class=\"line\">\tscala.io.Source.fromFile(file).getLines().toList</span><br><span class=\"line\">def grep(pattern: String) =</span><br><span class=\"line\">\tfor(</span><br><span class=\"line\">\t\tfile &lt;- filesHere</span><br><span class=\"line\">\t\tif file.getName.endsWith(&quot;.scala&quot;);</span><br><span class=\"line\">\t\ttrimed = line.trim</span><br><span class=\"line\">\t\tline &lt;- fileLines(file)</span><br><span class=\"line\">\t\tif trimed.matches(pattern)</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tprintln(file + &quot;: &quot; + line.trimed)</span><br><span class=\"line\">grep(&quot;.*gcd.*&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其中，外部循环遍历filesHere，内部循环遍历每个以.scala结尾的file的fileLines(file)</p>\n</li>\n<li>其中trimed作为中途变量绑定，用来保存line.trim的值，避免line.trim被重复计算两次</li>\n</ul>\n<h3 id=\"match表达式\"><a href=\"#match表达式\" class=\"headerlink\" title=\"match表达式\"></a>match表达式</h3><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val firstArg = if (args.length &gt; 0) args(0) else &quot;&quot;</span><br><span class=\"line\">val friend =</span><br><span class=\"line\">firstArg match &#123;</span><br><span class=\"line\">\tcase &quot;salt&quot; =&gt; println(&quot;pepper&quot;)</span><br><span class=\"line\">\tcase &quot;chips&quot; =&gt; println(&quot;salsa&quot;)</span><br><span class=\"line\">\tcase &quot;eggs&quot; =&gt; println(&quot;bacon&quot;)</span><br><span class=\"line\">\tcase _ =&gt;println(&quot;huh?&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println(friend)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这个例子中，match 表达式跟java的switch相比，有一些很重要的区别。其中一个区别是任何常量、字符串等都可以用作样例。另一个区别是，每个可选项后面没有break，因为scala中break是隐含的，不会出现某个可选项执行完又执行下一个的情况</p>\n</li>\n<li><p>match表达式会返回值，上例可以直接将匹配的结果打印出来</p>\n</li>\n<li><p>一般不会用到continue和break</p>\n</li>\n<li><p>例如一段java代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 0;</span><br><span class=\"line\">boolean foundIt = false;</span><br><span class=\"line\">while (i &lt; args.length)&#123;</span><br><span class=\"line\">\tif(args[i].startsWith(&quot;-&quot;))&#123;</span><br><span class=\"line\">\t\ti = i + 1;</span><br><span class=\"line\">\t\tcontinue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(args[i].endsWith(&quot;.scala&quot;))&#123;</span><br><span class=\"line\">\t\tfoundIt = true;</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ti = i+ 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scala可以写成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i = 0</span><br><span class=\"line\">var foundIt : Boolean = false</span><br><span class=\"line\">while (i &lt; args.length &amp;&amp; !foundIt)&#123;</span><br><span class=\"line\">\tif(!args(i).startsWith(&quot;-&quot;))&#123;</span><br><span class=\"line\">\t\tif(args(i).endsWith(&quot;.scala&quot;)</span><br><span class=\"line\">\t\t\tfoundIt = true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ti = i + 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>或者用递归函数代替循环：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def searchFrom(i: Int): Int = &#123;</span><br><span class=\"line\">\tif(i &gt;= args.length) -1\t\t//未找到返回-1</span><br><span class=\"line\">\telse if(args(i).startsWith(&quot;-&quot;)) searchFrom(i + 1)\t//递归查找下一处</span><br><span class=\"line\">\telse if(args(i).endsWith(&quot;.scala&quot;)) i\t//找到了就返回</span><br><span class=\"line\">\telse searchFrom(i + 1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">val i = searchFrom(0)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这个递归去掉了循环，每一个continue都换成了一次以i+1为入参的递归调用</p>\n</li>\n</ul>\n<h2 id=\"第八章-函数和闭包\"><a href=\"#第八章-函数和闭包\" class=\"headerlink\" title=\"第八章 函数和闭包\"></a>第八章 函数和闭包</h2><hr>\n<h3 id=\"局部函数\"><a href=\"#局部函数\" class=\"headerlink\" title=\"局部函数\"></a>局部函数</h3><ul>\n<li>我们可以在某个函数内部定义函数，就像局部变量一样，这样局部函数只在包含他的代码块中可见，实现了与类中私有方法相同的效果。<br>例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def processFile(filename: String, width: Int) = &#123;</span><br><span class=\"line\">\tdef processLine(line: String) = &#123; //局部函数可以访问包含它们的函数的参数</span><br><span class=\"line\">\t\tif(line.length &gt; width)</span><br><span class=\"line\">\t\t\tprintln(filename + &quot;: &quot; + line.trim)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tval source = Source.fromFile(filename) //从文件名创建一个名为source的Source对象</span><br><span class=\"line\">\tfor (line &lt;- source.getLines())&#123; //getLines()返回一个每次迭代从文件读取一行并去掉换行符的迭代器</span><br><span class=\"line\">\t\tprocessLine(filename, width, line)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"一等函数\"><a href=\"#一等函数\" class=\"headerlink\" title=\"一等函数*\"></a>一等函数*</h3><ul>\n<li><p>函数字面量被编译成类，并在运行时实例化为函数值。因此，函数字面量和函数值的区别在于，函数字面量存在于，函数字面量存在于源码，而函数值以对象的形式存在于运行时</p>\n</li>\n<li><p>一个函数字面量的简单示例：<code>(x: Int) =&gt; x + 1</code></p>\n</li>\n<li><p><code>=&gt;</code>表示该函数将左侧的内容转换成右侧的内容，因此这是一个将任何整数x <strong>映射</strong> 成 (x + 1)的函数</p>\n</li>\n<li><p>函数值是对象，所以还可以将他们存放在变量中。同时他们也是函数，也可以用常规的圆括号来调用他们：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var increase = (x: Int) =&gt; x + 1 //可以将函数字面量赋值给变量</span><br><span class=\"line\">val n = increase(10)  //可以像一般的函数一样调用</span><br><span class=\"line\">increase = (x: Int) =&gt; x + 999 //因为increase是var类型，还可以重新赋值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果在函数字面量中有多于一条语句，可以将函数体用花括号括起来</p>\n</li>\n<li><p>所有的集合类(List,Set,Array,Map)都提供了foreach方法，<strong>它接受一个函数作为入参，并对它的每个元素调用这个函数</strong></p>\n</li>\n<li><p>同时，集合类还有个filter方法。这个方法从集合中选出那些满足条件的元素。这个指定条件由函数表示,例如：<code>(x: Int) =&gt; x &gt; 0</code>这个方法可以被用来过滤。 <strong>这个函数将所有的正整数映射成true，所有其他的整数映射成false</strong></p>\n</li>\n</ul>\n<h3 id=\"函数字面量的简写形式\"><a href=\"#函数字面量的简写形式\" class=\"headerlink\" title=\"函数字面量的简写形式\"></a>函数字面量的简写形式</h3><ul>\n<li><p>一种更为简要的方法是省去参数类型声明：<code>someNumbers.filter((x) =&gt; x &gt; 0)</code></p>\n</li>\n<li><p>同时圆括号也可以去掉，因为可以省略掉自动推断类型的参数的圆括号：<code>someNumbers.filter(x =&gt; x &gt; 0)</code></p>\n</li>\n</ul>\n<h3 id=\"占位符语法\"><a href=\"#占位符语法\" class=\"headerlink\" title=\"占位符语法\"></a>占位符语法</h3><ul>\n<li><p>为了让函数字面量更加精简，还可以使用下划线作为占位符，用来表示一个或多个参数，只要满足每个参数只在函数字面量中出现一次即可。例如：<code>_ &gt; 0</code> 是一个非常短的表示法，表示一个检查某个值是否大于0的函数</p>\n</li>\n<li><p>例子：<code>someNumber.filter(_ &gt; 0)</code></p>\n</li>\n<li><p>可以将下划线当成是表达式中需要被”填”的”空”。函数每次被调用，这个空都会被一个入参给填上</p>\n</li>\n<li><p>如果someNumber被初始化为<code>List(11,10,9,8)</code>，那么filter方法首先把 <code>_ &gt; 0</code>中的空替换成11，即 11 &gt; 0，然后替换成10，以此类推，直到List末尾</p>\n</li>\n</ul>\n<ul>\n<li><p>有时候当你用下划线作为参数占位时，编译器可能没有足够的信息来推断缺失的参数类型。</p>\n</li>\n<li><p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; val f = _ + _</span><br><span class=\"line\">&lt;console&gt; error: missing parameter type for expanded</span><br><span class=\"line\">function ((x$1, x$2) =&gt; x$1.$plus(x$2))</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这种情况下，可以用冒号来给出类型，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; val f = (_: Int) + (_: Int)</span><br><span class=\"line\">f: (Int, Int) =&gt; Int = &lt;function0&gt;</span><br><span class=\"line\">scala&gt; f(5,10)</span><br><span class=\"line\">res0: Int = 15</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意，<code>_ + _</code>将会展开成一个接收两个参数的函数字面量。这就是为什么只有当每个参数在函数字面量中出现不多不少正好一次的时候才能使用这样的精简写法。多个下划线意味着多个参数，而不是对单个参数的重复利用。</p>\n</li>\n</ul>\n<h3 id=\"部分应用的函数\"><a href=\"#部分应用的函数\" class=\"headerlink\" title=\"部分应用的函数\"></a>部分应用的函数</h3><ul>\n<li><p>下划线还能替换掉整个参数列表，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt;def sum(a:Int, b:Int, c:Int) = a + b + c</span><br><span class=\"line\">sum: (a:Int, b:Int, c:Int)Int</span><br><span class=\"line\">scala&gt;val a = sum _</span><br><span class=\"line\">a:(Int, Int, Int) =&gt; Int = &lt;function3&gt;</span><br><span class=\"line\">scala&gt; a(1,2,3)</span><br><span class=\"line\">res0: Int = 6</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>后面的a 即是基于sum创建的一个部分应用函数</p>\n</li>\n</ul>\n<h3 id=\"特殊的函数调用形式\"><a href=\"#特殊的函数调用形式\" class=\"headerlink\" title=\"特殊的函数调用形式\"></a>特殊的函数调用形式</h3><h4 id=\"重复参数\"><a href=\"#重复参数\" class=\"headerlink\" title=\"重复参数\"></a>重复参数</h4><ul>\n<li>scala允许你标示出的参数的最后一个参数可以被重复，这样我们可以对函数传入一个可变长度的参数列表。这样一个重复参数的表示，需要在参数的类型之后加上一个<code>*</code>号：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; def echo(args: String) =</span><br><span class=\"line\">\tfor (arg &lt;- args) println(arg)</span><br><span class=\"line\">echo: (args: String*)Unit</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样echo就可以接受任意多个String类型的参数(可以是0个)</p>\n<ul>\n<li>但是如果要将一个适合类型的数组以这种重复参数的形式传入的时候，需要写成如下形式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; var arr = Array(&quot;a&quot;,&quot;v&quot;,&quot;gf&quot;)</span><br><span class=\"line\">arr:Array[String] = Array(a,v,gf)</span><br><span class=\"line\">scala&gt; echo(arr: _*)</span><br><span class=\"line\">a</span><br><span class=\"line\">v</span><br><span class=\"line\">gf</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这种表示法告诉编译器将arr的每个元素作为参数传给echo，而不是将所有元素放在一起作为单个实参传入</p>\n<h4 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h4><ul>\n<li>例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def approximate(guess: Double): Double =</span><br><span class=\"line\">\tif (isGoodEnough(guess)) guess</span><br><span class=\"line\">\telse approximate(improve(guess))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在合适的isGoodEnough和improve函数的实现下，这个函数就是一个递归函数。而这个递归调用在最后一步的函数称为尾递归(tail recursive)函数</p>\n<ul>\n<li><p>scala编译器对尾递归函数有特殊的优化，能够检测到尾递归并将他替换为跳转到函数的最开始，并在跳转之前更新参数的值</p>\n</li>\n<li><p>也就是说，我们完全可以用尾递归的方法来代替循环而不用付出任何额外的开销</p>\n</li>\n<li><p>尾递归不会在每次调用时构建一个新的栈，所有的调用都会在同一个栈中进行</p>\n</li>\n<li><p>如下有个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def boom(x: Int): Int =</span><br><span class=\"line\">\tif(x == 0) throw new Exception (&quot;boom!&quot;)</span><br><span class=\"line\">\telse boom(x - 1) + 1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个函数不是一个尾递归的，因为 <strong>它在递归调用之后还执行了一个递增操作</strong></p>\n<ul>\n<li>但是scala中尾递归是受限的，更高级形式的尾递归实现十分困难。scala只能对那些直接尾递归的函数做优化</li>\n</ul>\n<h2 id=\"第九章-控制抽象\"><a href=\"#第九章-控制抽象\" class=\"headerlink\" title=\"第九章 控制抽象\"></a>第九章 控制抽象</h2><hr>\n<h3 id=\"减少代码重复\"><a href=\"#减少代码重复\" class=\"headerlink\" title=\"减少代码重复\"></a>减少代码重复</h3><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def filesMatching(query: String,</span><br><span class=\"line\">\tmatcher: (String, String) =&gt; Boolean) = &#123;</span><br><span class=\"line\">\tfor (file &lt;- filesHere; if matcher(file.getName, query))</span><br><span class=\"line\">\t\tyield file</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在这个方法中，if子句用matcher来检查文件名是否满足条件，这个检查具体做什么，取决于具体的matcher。matcher本身是一个函数，因此类型声明中有一个<code>=&gt;</code>符号。这个函数接受两个字符串类型的参数(分别是文件名和查询条件)，返回一个布尔值，因此这个参数的类型为<code>(String, String) =&gt; Boolean</code></p>\n</li>\n<li><p>下面三个方法分别使用三种不同的参数matcher来实现不同的文件查找功能:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def filesEnding(query: String) =</span><br><span class=\"line\">\tfilesMatching(query, _.endsWith(_))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def filesContaning(query: String) =</span><br><span class=\"line\">\tfilesMatching(query, _.contains(_))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def filesRegex(query: String) =</span><br><span class=\"line\">\tfilesMatching(query, _.matches(_))</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其中，<code>_.endsWith(_)</code>的含义与下面的代码是一样的<code>(fileName: String, query: String) =&gt; fileName.endsWith(query)</code> 两个下划线按顺序作为传入的两个参数的占位符</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.23</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><hr>\n<h3 id=\"序列\"><a href=\"#序列\" class=\"headerlink\" title=\"序列\"></a>序列</h3><ul>\n<li><p>Seq trait用于表示序列。所谓序列，指的是一类具有一定长度的可迭代访问的对象，其中每个元素均带有一个从0开始计数的固定索引位置。</p>\n</li>\n<li><p>常用线性序列有 <code>scala.collection.immutable.List</code>和<code>scala.collection.immutable.Stream</code>。常用索引序列有 <code>scala.Array scala.collection.mutable.ArrayBuffer</code>。Vector 类提供一个在索引访问和线性访问之间有趣的折中。它同时具有高效的恒定时间的索引开销，和恒定时间的线性访问开销。正因为如此，对于混合访问模式，vector是一个很好的基础。</p>\n</li>\n</ul>\n<h3 id=\"缓冲器\"><a href=\"#缓冲器\" class=\"headerlink\" title=\"缓冲器\"></a>缓冲器</h3><ul>\n<li>Buffers是可变序列一个重要的种类。它们不仅允许更新现有的元素，而且允许元素的插入、移除和在buffer尾部高效地添加新元素。buffer 支持的主要新方法有：用于在尾部添加元素的<code>+=</code> 和 <code>++=</code>；用于在前方添加元素的<code>+=:</code> 和 <code>++=:</code> ；用于插入元素的 <code>insert</code>和<code>insertAll</code>；以及用于删除元素的 <code>remove</code> 和 <code>-=</code>。</li>\n</ul>\n<h2 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h2><hr>\n<h3 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h3><ul>\n<li><p>在类定义中，我们会填入字段(field)和方法(method)，这些统称为成员(member)</p>\n</li>\n<li><p>保持健壮性，我们可以将字段声明为私有(在字段前面加上private修饰符)，访问和修改都通过方法来实现。<br>scala的默认访问级别是public</p>\n</li>\n<li><p>scala方法参数有一个特征，就是 <strong>它们都是<code>val</code>而不是<code>var</code></strong></p>\n</li>\n<li><p>一个类的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class test&#123;</span><br><span class=\"line\">\tprivate var sum = 0</span><br><span class=\"line\">\tdef add(b: Byte): Unit = &#123;</span><br><span class=\"line\">\t\tsum += b</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdef checksum(): Int = &#123;</span><br><span class=\"line\">\t\treturn ~(sum &amp; 0xFF) + 1</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在方法中，没有任何显式的return语句时，<strong>scala返回的是该方法计算出的最后一个(表达式的)值</strong> ,因此上面这个例子的return语句可以省略不写</p>\n</li>\n<li><p>同时，另一种方法的简写方式是，当一个方法只会计算一个返回结果的表达式时，可以不写花括号。如果这个表达式很短，他甚至可以被放置在def的同一行。为了极致的精简，还可以省略掉结果类型。</p>\n</li>\n<li><p>更改后的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class test&#123;</span><br><span class=\"line\">\tprivate var sum = 0</span><br><span class=\"line\">\tdef add(b: Byte) = sum += b</span><br><span class=\"line\">\tdef checksum() = ~(sum &amp; 0xFF) + 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在这段代码中，scala能够正确地推断出add和checksum这两个方法的结果类型。但是最好的写法是显式地给出结果类型，这样便于代码的调试和维护</p>\n<ul>\n<li><p>本例中的add方法结果类型为Unit，执行它的目的就是产生副作用。对于那些仅仅为了其副作用而被执行的方法被称作<em>过程</em>。</p>\n</li>\n<li><p>一般分号是没有必要加的，但是如果一行写多个语句，则用分号间隔</p>\n</li>\n</ul>\n<h3 id=\"单例对象\"><a href=\"#单例对象\" class=\"headerlink\" title=\"单例对象\"></a>单例对象</h3><ul>\n<li><p>scala比Java更面向对象一点，是scala <strong>不允许有静态成员</strong>。<br>因此，scala提供了<em>单例对象</em>，单例对象与普通的类很像，只是将<code>class</code>关键字换成了<code>object</code></p>\n</li>\n<li><p>当单例对象跟某个类共用同一个名字时，它被称作这个类的 <strong>伴生对象(companion object)</strong></p>\n</li>\n<li><p>必须在同一个源码文件中定义类和类的伴生对象，同时，类又叫做这个单例对象的 <strong>伴生类(companion class)</strong></p>\n</li>\n<li><p>类和它的伴生对象可以互相访问对方的私有成员</p>\n</li>\n<li><p>单例对象当中的方法可以像Java中的静态方法一样直接通过类名来访问</p>\n</li>\n<li><p>单例对象不仅仅用来存放静态方法，他是一等的对象，可以把单例对象想象成附加在对象身上的“名字标签”</p>\n</li>\n<li><p>类和单例对象的区别是单例对象不能被实例化(即没法new一个单例对象，除非这个单例对象有伴生类)</p>\n</li>\n<li><p>单例对象在有代码首次访问时才会被初始化</p>\n</li>\n<li><p>没有同名的伴生类的单例对象称为 <em>孤立对象</em>(standalone object)，一般用来将工具方法归集在一起，或定义scala程序的入口。</p>\n</li>\n</ul>\n<h3 id=\"scala应用程序\"><a href=\"#scala应用程序\" class=\"headerlink\" title=\"scala应用程序\"></a>scala应用程序</h3><ul>\n<li>要运行一个scala程序，必须提供一个孤立对象，这个孤立对象需要包含一个main方法，该方法接收一个Array[String]作为参数，结果类型为Unit,例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object Test&#123;</span><br><span class=\"line\">\tdef main(args: Array[String]): Unit = &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>注意：scala在每一个源码文件都隐式地引入了java.lang和scala包的成员，以及名为Predef的单例对象的所有成员。例如使用的println和assert都是来自于Predef</p>\n</blockquote>\n<ul>\n<li>注意要运行这个程序，那么文件名需要与这个单例对象的名称相同。</li>\n</ul>\n<h3 id=\"App特质\"><a href=\"#App特质\" class=\"headerlink\" title=\"App特质\"></a>App特质</h3><ul>\n<li>scala提供了一个特质scala.App，我们可以不用编写main方法，而是将打算放在main方法里的代码直接写在单例对象的花括号里。不过首先要在单例对象名后加上<code>extends App</code>。例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object AppTest extends App&#123;</span><br><span class=\"line\">\tfor(i &lt;- 0 to 10)&#123;</span><br><span class=\"line\">\t\tprintln(&quot;...&quot;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>它可以像正常的scala程序一样运行</p>\n<h2 id=\"第五章\"><a href=\"#第五章\" class=\"headerlink\" title=\"第五章\"></a>第五章</h2><hr>\n<h3 id=\"基础类型和操作\"><a href=\"#基础类型和操作\" class=\"headerlink\" title=\"基础类型和操作\"></a>基础类型和操作</h3><h4 id=\"一些基础类型\"><a href=\"#一些基础类型\" class=\"headerlink\" title=\"一些基础类型\"></a>一些基础类型</h4><ul>\n<li><p>Byte、Short、Int、Long和Char类型统称为 <em>整数类型</em>，整数类型加上Float和Double类型统称为 <em>数值类型</em></p>\n</li>\n<li><p>String是java.lang包的成员</p>\n</li>\n<li><p>注意这些数据类型实际上都是封装好的类，所以首字母都是大写</p>\n</li>\n<li><p>Long类型以l或者L结尾</p>\n</li>\n<li><p>字符串插值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val name=&quot;reader&quot;</span><br><span class=\"line\">println(s&quot;Hello, $name&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这个的结果与<code>println(&quot;Hello&quot; + name)</code>是一样的</p>\n</li>\n<li><p>scala中raw可以屏蔽转义字符<code>/</code>，例如<code>println(raw&quot;abc\\n\\n&quot;)</code>其中斜杠和n将被原样输出</p>\n</li>\n<li><p>scala中判断任意两个对象都可以用<code>==</code>方法，甚至可以是与null值进行比较而不会报错，并且总能返回正确的比较结果。scala的<code>==</code> <strong>只比较值</strong>，而Java的引用类型的==比较的是引用是否相同。</p>\n</li>\n<li><p>赋值操作符<code>=</code>的优先级是最低的,而像<code>*=</code>这样的操作符也被当做赋值操作符，因此其优先级不如<code>+</code>操作符</p>\n</li>\n</ul>\n<h2 id=\"第六章-函数式对象\"><a href=\"#第六章-函数式对象\" class=\"headerlink\" title=\"第六章 函数式对象\"></a>第六章 函数式对象</h2><hr>\n<ul>\n<li><p>如果要在类中重新实现一个已经实现的方法，例如toString方法，要用到override关键字</p>\n</li>\n<li><p>例如<code>override def toString = {...}</code></p>\n</li>\n<li><p>一个例子：创建一个有理数的类，这是个不可变的类并且要求分母不为零</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Rational(n: Int, d:Int)&#123;</span><br><span class=\"line\">\trequire(d!=0)</span><br><span class=\"line\">\toverride def toString = n + &quot;/&quot; + d</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>require方法接受一个boolean的参数。如果传入的参数为true，require将会正常返回。否则,require将会抛出IllegalArgumentException来阻止对象的构建。</p>\n<h3 id=\"添加字段\"><a href=\"#添加字段\" class=\"headerlink\" title=\"添加字段\"></a>添加字段</h3><ul>\n<li>例如添加一个add方法：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def add(that: Rational): Rational = new(</span><br><span class=\"line\">\tnew Rational(n * that.d + that.n * d, d * that.d)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个方法是会报错的</p>\n<ul>\n<li><p>上面那个类如果要添加一个add方法，实现两个Rational类型的值的相加，此时add是不能直接调用this.n或者this.d的(虽然类参数n和d在add方法中是在作用域内的，但是编译器并不允许使用<code>that.n</code>和<code>that.d</code>，因为that并非指向调用add的那个对象，要访问that的d和n，需要将它做成字段(相当于成员变量))<br>我们需要添加字段才行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Rational(n: Int, d:Int)&#123;</span><br><span class=\"line\">\trequire(d != 0)</span><br><span class=\"line\">\tval numer: Int = n</span><br><span class=\"line\">\tval denom: Int = d</span><br><span class=\"line\">\toverride def toString = numer + &quot;/&quot; + denom</span><br><span class=\"line\">\tdef add(that: Rational): Rational =</span><br><span class=\"line\">\t\tnew Rational(</span><br><span class=\"line\">\t\t\tnumer * that.denom + that.numer * denom,</span><br><span class=\"line\">\t\t\tdenom * that.denom\t\t</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scala中 字段 默认的访问权限是public</p>\n</li>\n</ul>\n<h3 id=\"自引用\"><a href=\"#自引用\" class=\"headerlink\" title=\"自引用\"></a>自引用</h3><ul>\n<li><p>使用关键字this，写法为<code>this.字段名</code>，也可以直接写字段名，用法与C++和Java一致</p>\n</li>\n<li><p>辅助构造方法：<br><code>def this(...){...}</code></p>\n</li>\n<li><p>操作符也可以像方法一样定义，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def + (that: MyClass): MyClass =&#123;...&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scala支持方法重载，用法与C++和Java相同，通过定义多个参数不同的同名函数来实现重载</p>\n</li>\n</ul>\n<h2 id=\"第七章-内建的控制结构\"><a href=\"#第七章-内建的控制结构\" class=\"headerlink\" title=\"第七章 内建的控制结构\"></a>第七章 内建的控制结构</h2><hr>\n<ul>\n<li><p>scala的控制语句都有返回值，可以直接拿来用</p>\n</li>\n<li><p>例子：<code>println(if (!args.isEmoty) args(0) else &quot;default.txt&quot;)</code></p>\n</li>\n</ul>\n<ul>\n<li><p>形如 <code>a &lt;- b</code>的称为生成器语法</p>\n</li>\n<li><p><code>1 to 4</code> 包含上界 4</p>\n</li>\n<li><code>1 until 4</code> 不包含上界 4</li>\n</ul>\n<h3 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h3><ul>\n<li><p>有时候遍历集合的时候不想完整地遍历集合，而是先过滤成一个子集。这时可以给for表达式添加过滤器(filter)<br>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val filesHere = (new java.io.File(&quot;.&quot;)).listDiles</span><br><span class=\"line\">for(file &lt;- filesHere if file.getName.endsWith(&quot;.scala&quot;))</span><br><span class=\"line\">\tprintln(file)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>过滤器就是for表达式圆括号中的一个if子句，并且可以随意添加更多的过滤器，直接添加if子句即可</p>\n</li>\n</ul>\n<h3 id=\"嵌套迭代\"><a href=\"#嵌套迭代\" class=\"headerlink\" title=\"嵌套迭代\"></a>嵌套迭代</h3><ul>\n<li><p>如果添加多个<code>&lt;-</code>子句，将得到嵌套的循环<br>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fileLines(file: java.io.File) =</span><br><span class=\"line\">\tscala.io.Source.fromFile(file).getLines().toList</span><br><span class=\"line\">def grep(pattern: String) =</span><br><span class=\"line\">\tfor(</span><br><span class=\"line\">\t\tfile &lt;- filesHere</span><br><span class=\"line\">\t\tif file.getName.endsWith(&quot;.scala&quot;);</span><br><span class=\"line\">\t\ttrimed = line.trim</span><br><span class=\"line\">\t\tline &lt;- fileLines(file)</span><br><span class=\"line\">\t\tif trimed.matches(pattern)</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tprintln(file + &quot;: &quot; + line.trimed)</span><br><span class=\"line\">grep(&quot;.*gcd.*&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其中，外部循环遍历filesHere，内部循环遍历每个以.scala结尾的file的fileLines(file)</p>\n</li>\n<li>其中trimed作为中途变量绑定，用来保存line.trim的值，避免line.trim被重复计算两次</li>\n</ul>\n<h3 id=\"match表达式\"><a href=\"#match表达式\" class=\"headerlink\" title=\"match表达式\"></a>match表达式</h3><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val firstArg = if (args.length &gt; 0) args(0) else &quot;&quot;</span><br><span class=\"line\">val friend =</span><br><span class=\"line\">firstArg match &#123;</span><br><span class=\"line\">\tcase &quot;salt&quot; =&gt; println(&quot;pepper&quot;)</span><br><span class=\"line\">\tcase &quot;chips&quot; =&gt; println(&quot;salsa&quot;)</span><br><span class=\"line\">\tcase &quot;eggs&quot; =&gt; println(&quot;bacon&quot;)</span><br><span class=\"line\">\tcase _ =&gt;println(&quot;huh?&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">println(friend)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这个例子中，match 表达式跟java的switch相比，有一些很重要的区别。其中一个区别是任何常量、字符串等都可以用作样例。另一个区别是，每个可选项后面没有break，因为scala中break是隐含的，不会出现某个可选项执行完又执行下一个的情况</p>\n</li>\n<li><p>match表达式会返回值，上例可以直接将匹配的结果打印出来</p>\n</li>\n<li><p>一般不会用到continue和break</p>\n</li>\n<li><p>例如一段java代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 0;</span><br><span class=\"line\">boolean foundIt = false;</span><br><span class=\"line\">while (i &lt; args.length)&#123;</span><br><span class=\"line\">\tif(args[i].startsWith(&quot;-&quot;))&#123;</span><br><span class=\"line\">\t\ti = i + 1;</span><br><span class=\"line\">\t\tcontinue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif(args[i].endsWith(&quot;.scala&quot;))&#123;</span><br><span class=\"line\">\t\tfoundIt = true;</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ti = i+ 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scala可以写成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i = 0</span><br><span class=\"line\">var foundIt : Boolean = false</span><br><span class=\"line\">while (i &lt; args.length &amp;&amp; !foundIt)&#123;</span><br><span class=\"line\">\tif(!args(i).startsWith(&quot;-&quot;))&#123;</span><br><span class=\"line\">\t\tif(args(i).endsWith(&quot;.scala&quot;)</span><br><span class=\"line\">\t\t\tfoundIt = true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ti = i + 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>或者用递归函数代替循环：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def searchFrom(i: Int): Int = &#123;</span><br><span class=\"line\">\tif(i &gt;= args.length) -1\t\t//未找到返回-1</span><br><span class=\"line\">\telse if(args(i).startsWith(&quot;-&quot;)) searchFrom(i + 1)\t//递归查找下一处</span><br><span class=\"line\">\telse if(args(i).endsWith(&quot;.scala&quot;)) i\t//找到了就返回</span><br><span class=\"line\">\telse searchFrom(i + 1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">val i = searchFrom(0)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这个递归去掉了循环，每一个continue都换成了一次以i+1为入参的递归调用</p>\n</li>\n</ul>\n<h2 id=\"第八章-函数和闭包\"><a href=\"#第八章-函数和闭包\" class=\"headerlink\" title=\"第八章 函数和闭包\"></a>第八章 函数和闭包</h2><hr>\n<h3 id=\"局部函数\"><a href=\"#局部函数\" class=\"headerlink\" title=\"局部函数\"></a>局部函数</h3><ul>\n<li>我们可以在某个函数内部定义函数，就像局部变量一样，这样局部函数只在包含他的代码块中可见，实现了与类中私有方法相同的效果。<br>例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def processFile(filename: String, width: Int) = &#123;</span><br><span class=\"line\">\tdef processLine(line: String) = &#123; //局部函数可以访问包含它们的函数的参数</span><br><span class=\"line\">\t\tif(line.length &gt; width)</span><br><span class=\"line\">\t\t\tprintln(filename + &quot;: &quot; + line.trim)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tval source = Source.fromFile(filename) //从文件名创建一个名为source的Source对象</span><br><span class=\"line\">\tfor (line &lt;- source.getLines())&#123; //getLines()返回一个每次迭代从文件读取一行并去掉换行符的迭代器</span><br><span class=\"line\">\t\tprocessLine(filename, width, line)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"一等函数\"><a href=\"#一等函数\" class=\"headerlink\" title=\"一等函数*\"></a>一等函数*</h3><ul>\n<li><p>函数字面量被编译成类，并在运行时实例化为函数值。因此，函数字面量和函数值的区别在于，函数字面量存在于，函数字面量存在于源码，而函数值以对象的形式存在于运行时</p>\n</li>\n<li><p>一个函数字面量的简单示例：<code>(x: Int) =&gt; x + 1</code></p>\n</li>\n<li><p><code>=&gt;</code>表示该函数将左侧的内容转换成右侧的内容，因此这是一个将任何整数x <strong>映射</strong> 成 (x + 1)的函数</p>\n</li>\n<li><p>函数值是对象，所以还可以将他们存放在变量中。同时他们也是函数，也可以用常规的圆括号来调用他们：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var increase = (x: Int) =&gt; x + 1 //可以将函数字面量赋值给变量</span><br><span class=\"line\">val n = increase(10)  //可以像一般的函数一样调用</span><br><span class=\"line\">increase = (x: Int) =&gt; x + 999 //因为increase是var类型，还可以重新赋值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果在函数字面量中有多于一条语句，可以将函数体用花括号括起来</p>\n</li>\n<li><p>所有的集合类(List,Set,Array,Map)都提供了foreach方法，<strong>它接受一个函数作为入参，并对它的每个元素调用这个函数</strong></p>\n</li>\n<li><p>同时，集合类还有个filter方法。这个方法从集合中选出那些满足条件的元素。这个指定条件由函数表示,例如：<code>(x: Int) =&gt; x &gt; 0</code>这个方法可以被用来过滤。 <strong>这个函数将所有的正整数映射成true，所有其他的整数映射成false</strong></p>\n</li>\n</ul>\n<h3 id=\"函数字面量的简写形式\"><a href=\"#函数字面量的简写形式\" class=\"headerlink\" title=\"函数字面量的简写形式\"></a>函数字面量的简写形式</h3><ul>\n<li><p>一种更为简要的方法是省去参数类型声明：<code>someNumbers.filter((x) =&gt; x &gt; 0)</code></p>\n</li>\n<li><p>同时圆括号也可以去掉，因为可以省略掉自动推断类型的参数的圆括号：<code>someNumbers.filter(x =&gt; x &gt; 0)</code></p>\n</li>\n</ul>\n<h3 id=\"占位符语法\"><a href=\"#占位符语法\" class=\"headerlink\" title=\"占位符语法\"></a>占位符语法</h3><ul>\n<li><p>为了让函数字面量更加精简，还可以使用下划线作为占位符，用来表示一个或多个参数，只要满足每个参数只在函数字面量中出现一次即可。例如：<code>_ &gt; 0</code> 是一个非常短的表示法，表示一个检查某个值是否大于0的函数</p>\n</li>\n<li><p>例子：<code>someNumber.filter(_ &gt; 0)</code></p>\n</li>\n<li><p>可以将下划线当成是表达式中需要被”填”的”空”。函数每次被调用，这个空都会被一个入参给填上</p>\n</li>\n<li><p>如果someNumber被初始化为<code>List(11,10,9,8)</code>，那么filter方法首先把 <code>_ &gt; 0</code>中的空替换成11，即 11 &gt; 0，然后替换成10，以此类推，直到List末尾</p>\n</li>\n</ul>\n<ul>\n<li><p>有时候当你用下划线作为参数占位时，编译器可能没有足够的信息来推断缺失的参数类型。</p>\n</li>\n<li><p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; val f = _ + _</span><br><span class=\"line\">&lt;console&gt; error: missing parameter type for expanded</span><br><span class=\"line\">function ((x$1, x$2) =&gt; x$1.$plus(x$2))</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这种情况下，可以用冒号来给出类型，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; val f = (_: Int) + (_: Int)</span><br><span class=\"line\">f: (Int, Int) =&gt; Int = &lt;function0&gt;</span><br><span class=\"line\">scala&gt; f(5,10)</span><br><span class=\"line\">res0: Int = 15</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意，<code>_ + _</code>将会展开成一个接收两个参数的函数字面量。这就是为什么只有当每个参数在函数字面量中出现不多不少正好一次的时候才能使用这样的精简写法。多个下划线意味着多个参数，而不是对单个参数的重复利用。</p>\n</li>\n</ul>\n<h3 id=\"部分应用的函数\"><a href=\"#部分应用的函数\" class=\"headerlink\" title=\"部分应用的函数\"></a>部分应用的函数</h3><ul>\n<li><p>下划线还能替换掉整个参数列表，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt;def sum(a:Int, b:Int, c:Int) = a + b + c</span><br><span class=\"line\">sum: (a:Int, b:Int, c:Int)Int</span><br><span class=\"line\">scala&gt;val a = sum _</span><br><span class=\"line\">a:(Int, Int, Int) =&gt; Int = &lt;function3&gt;</span><br><span class=\"line\">scala&gt; a(1,2,3)</span><br><span class=\"line\">res0: Int = 6</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>后面的a 即是基于sum创建的一个部分应用函数</p>\n</li>\n</ul>\n<h3 id=\"特殊的函数调用形式\"><a href=\"#特殊的函数调用形式\" class=\"headerlink\" title=\"特殊的函数调用形式\"></a>特殊的函数调用形式</h3><h4 id=\"重复参数\"><a href=\"#重复参数\" class=\"headerlink\" title=\"重复参数\"></a>重复参数</h4><ul>\n<li>scala允许你标示出的参数的最后一个参数可以被重复，这样我们可以对函数传入一个可变长度的参数列表。这样一个重复参数的表示，需要在参数的类型之后加上一个<code>*</code>号：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; def echo(args: String) =</span><br><span class=\"line\">\tfor (arg &lt;- args) println(arg)</span><br><span class=\"line\">echo: (args: String*)Unit</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样echo就可以接受任意多个String类型的参数(可以是0个)</p>\n<ul>\n<li>但是如果要将一个适合类型的数组以这种重复参数的形式传入的时候，需要写成如下形式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; var arr = Array(&quot;a&quot;,&quot;v&quot;,&quot;gf&quot;)</span><br><span class=\"line\">arr:Array[String] = Array(a,v,gf)</span><br><span class=\"line\">scala&gt; echo(arr: _*)</span><br><span class=\"line\">a</span><br><span class=\"line\">v</span><br><span class=\"line\">gf</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这种表示法告诉编译器将arr的每个元素作为参数传给echo，而不是将所有元素放在一起作为单个实参传入</p>\n<h4 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h4><ul>\n<li>例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def approximate(guess: Double): Double =</span><br><span class=\"line\">\tif (isGoodEnough(guess)) guess</span><br><span class=\"line\">\telse approximate(improve(guess))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在合适的isGoodEnough和improve函数的实现下，这个函数就是一个递归函数。而这个递归调用在最后一步的函数称为尾递归(tail recursive)函数</p>\n<ul>\n<li><p>scala编译器对尾递归函数有特殊的优化，能够检测到尾递归并将他替换为跳转到函数的最开始，并在跳转之前更新参数的值</p>\n</li>\n<li><p>也就是说，我们完全可以用尾递归的方法来代替循环而不用付出任何额外的开销</p>\n</li>\n<li><p>尾递归不会在每次调用时构建一个新的栈，所有的调用都会在同一个栈中进行</p>\n</li>\n<li><p>如下有个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def boom(x: Int): Int =</span><br><span class=\"line\">\tif(x == 0) throw new Exception (&quot;boom!&quot;)</span><br><span class=\"line\">\telse boom(x - 1) + 1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个函数不是一个尾递归的，因为 <strong>它在递归调用之后还执行了一个递增操作</strong></p>\n<ul>\n<li>但是scala中尾递归是受限的，更高级形式的尾递归实现十分困难。scala只能对那些直接尾递归的函数做优化</li>\n</ul>\n<h2 id=\"第九章-控制抽象\"><a href=\"#第九章-控制抽象\" class=\"headerlink\" title=\"第九章 控制抽象\"></a>第九章 控制抽象</h2><hr>\n<h3 id=\"减少代码重复\"><a href=\"#减少代码重复\" class=\"headerlink\" title=\"减少代码重复\"></a>减少代码重复</h3><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def filesMatching(query: String,</span><br><span class=\"line\">\tmatcher: (String, String) =&gt; Boolean) = &#123;</span><br><span class=\"line\">\tfor (file &lt;- filesHere; if matcher(file.getName, query))</span><br><span class=\"line\">\t\tyield file</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在这个方法中，if子句用matcher来检查文件名是否满足条件，这个检查具体做什么，取决于具体的matcher。matcher本身是一个函数，因此类型声明中有一个<code>=&gt;</code>符号。这个函数接受两个字符串类型的参数(分别是文件名和查询条件)，返回一个布尔值，因此这个参数的类型为<code>(String, String) =&gt; Boolean</code></p>\n</li>\n<li><p>下面三个方法分别使用三种不同的参数matcher来实现不同的文件查找功能:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def filesEnding(query: String) =</span><br><span class=\"line\">\tfilesMatching(query, _.endsWith(_))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def filesContaning(query: String) =</span><br><span class=\"line\">\tfilesMatching(query, _.contains(_))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def filesRegex(query: String) =</span><br><span class=\"line\">\tfilesMatching(query, _.matches(_))</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其中，<code>_.endsWith(_)</code>的含义与下面的代码是一样的<code>(fileName: String, query: String) =&gt; fileName.endsWith(query)</code> 两个下划线按顺序作为传入的两个参数的占位符</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.23</p>\n</blockquote>\n"},{"layout":"post","title":"《Scala编程》阅读记录——类进阶","date":"2018-07-23T09:40:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n\n\n## 第十章 组合和继承  面向对象进阶\n\n### 抽象类\n\n- 例子：\n```\nabstract class Element{\n\tdef contents: Array[String]\n}\n```\n注意，Element类中content方法没有标上abstract修饰符。一个方法只要是没有实现的(即没有等号或方法体)，那么它就是抽象的。跟Java不同，我们不能对方法加上abstract修饰符\n\n\n### 定义无参方法\n\n- 例子：\n```\nabstract class Element {\n\tdef contents: Array[String]\n\tdef height: Int = contents.length\n\tdef width: Int = if(height == 0) 0 else contents(0).length\n}\n```\n\n- 这个无参方法的特点是，如果将`def`换成`val`，那么他就成了一个字段而不会有编译错误\n\n- 在这里无参方法和字段的区别是：字段的调用会更加快，但是每次实例化对象都要分配内存空间。具体取舍要看具体的用法。\n\n- 总结下来就是，scala推荐我们将那些没有参数也没有副作用的方法定义为无参方法，而对于无参数而有副作用的方法不应当省略空括号，例如：\n```\n\"hello\".length  //没有()，因为没有副作用\nprintln()\t//有()，因为有副作用\n```\n\n### 扩展类\n\n- 使用`extends`关键字，相当于继承\n\n- scala中所有类的默认父类是AnyRef\n\n- 继承的意思是超类的所有成员也是子类的成员，但是有两个例外：\n一个是超类的私有成员不会被子类继承；\n二是如果子类实现了相同名称和参数的成员，那么该成员不会被继承(重写，override)\n\n- scala只有两个命名空间用于定义：\n1. 值(字段，方法，包和单例对象)\n2. 类型(类和特质名)\n\n- 因此scala可以用val来重写一个无参方法(即将一个无参方法重写为一个字段)\n\n- 如果我们要在子类中重写父类的方法，则要在方法前加上override修饰符：`override def funcName(...){...}`\n\n- 使用final修饰符来确保某个成员不能被子类继承\n\n- scala的继承关系图\n![](/images/Scala/relation.jpg)\n\n## 第十二章 特质\n---\n\n- 特质的定义跟类定义很像，除了关键字trait\n\n- scala可以使用`extends`或者`with`关键字来 *混入* 特质，而不是继承。\n\n- 例子：`class Frog extends Animal with Philosophical with HasLegs{..}`\n混入多个特质用`with`连接\n\n### 要点如下:\n\n- **Scala中类只能继承一个超类, 可以扩展任意数量的特质**\n\n- 特质可以要求实现它们的类具备特定的字段, 方法和超类\n\n- 与Java接口不同, Scala特质可以提供方法和字段的实现\n\n- 当将多个特质叠加使用的时候, 顺序很重要\n\n- [scala特质详细解析](https://www.cnblogs.com/nowgood/p/scalatrait.html)\n\n- 重写特质的抽象方法时, 不需要`override`关键字\n\n- 可以为类和对象添加多个相互调用的特质时, 从最后一个开始调用. 这对于需要分阶段加工处理某个值的场景很有用.\n\n## 第十三章 包和引入\n---\n\n- scala的引入可以出现在任何地方，不仅仅是某个编译单元的开始\n\n- 例如，假设一个Fruit类，其中有有name和color字段。有如下的一个函数：\n```\ndef showFruit(fruit: Fruit) = {\n\timport Fruit._\n\tprintln(name + \"s are\" + color)\n}\n```\nshowFruit引入了其参数fruit(Fruit类)的所有成员。下面的name和color就相当于fruit.name和fruit.color\n\n## 第十四章 断言和测试\n---\n\n- 在scala中，断言的写法是对预定义方法assert的调用。\n\n- 表达式：`assert(condition)`。如果condition不满足则抛出AssertionError\n\n- 另一种：`assert(condition,explanation)`如果condition不满足则抛出指定的explanation的AssertionError\n\n## 第十五章 样例类和模式匹配\n---\n\n- 样例类使用case关键字修饰，scala编译器会自动创建工厂方法，即可以直接用`className(parameter1,parameter2,...)`而不用`new`关键字即可创建对象\n\n- 模式匹配，例子：\n```\nexpr match{\n\tcase BinOp(...) => println(...)\n\tcase _ =>  //处理器默认case,这一行是必须的，否则所有非满足第一个条件的case都会返回MatchError\n}\n```\n通配模式(`_`)会匹配任何对象\n\n## 第二十章 抽象成员\n---\n\n- 所有四种抽象成员：`val`，`var`，方法和类型\n\n- 例子：下面这个特质声明了四种抽象成员：一个抽象类型(T)，一个抽象方法(transform)，一个val(initial)和一个var(current)\n```\ntrait Anstract{\n\ttype T\n\tdef transform(x: T): T\n\tval initial: T\n\tvar current: T\n}\n```\n- scala的抽象类型指的是用type关键字声明为某个类或者特质的成员(但并不给出定义)的类型。类或者特质都不能够叫抽象类型，抽象类型永远是某个类或者特质的成员，比如Abstract特质中的T\n\n- `lazy`关键字：如果在`val`关键字前面加上`lazy`关键字，则该变量会在第一次被使用时被赋值。\n\n- T是指一个在声明时还未知的类型。不同的子类可以提供不同的T的实现\n\n\n<br>\n> 最后更新于2018.7.24\n","source":"_posts/2018-07-23-scala-learning-03.md","raw":"---\nlayout:     post\ntitle:      \"《Scala编程》阅读记录——类进阶\"\ndate:       2018-07-23 17:40:00\ncategories: Computer Programes\ntags:   ๑Scala\n---\n\n> 不适合人类阅读的学习笔记\n\n\n\n## 第十章 组合和继承  面向对象进阶\n\n### 抽象类\n\n- 例子：\n```\nabstract class Element{\n\tdef contents: Array[String]\n}\n```\n注意，Element类中content方法没有标上abstract修饰符。一个方法只要是没有实现的(即没有等号或方法体)，那么它就是抽象的。跟Java不同，我们不能对方法加上abstract修饰符\n\n\n### 定义无参方法\n\n- 例子：\n```\nabstract class Element {\n\tdef contents: Array[String]\n\tdef height: Int = contents.length\n\tdef width: Int = if(height == 0) 0 else contents(0).length\n}\n```\n\n- 这个无参方法的特点是，如果将`def`换成`val`，那么他就成了一个字段而不会有编译错误\n\n- 在这里无参方法和字段的区别是：字段的调用会更加快，但是每次实例化对象都要分配内存空间。具体取舍要看具体的用法。\n\n- 总结下来就是，scala推荐我们将那些没有参数也没有副作用的方法定义为无参方法，而对于无参数而有副作用的方法不应当省略空括号，例如：\n```\n\"hello\".length  //没有()，因为没有副作用\nprintln()\t//有()，因为有副作用\n```\n\n### 扩展类\n\n- 使用`extends`关键字，相当于继承\n\n- scala中所有类的默认父类是AnyRef\n\n- 继承的意思是超类的所有成员也是子类的成员，但是有两个例外：\n一个是超类的私有成员不会被子类继承；\n二是如果子类实现了相同名称和参数的成员，那么该成员不会被继承(重写，override)\n\n- scala只有两个命名空间用于定义：\n1. 值(字段，方法，包和单例对象)\n2. 类型(类和特质名)\n\n- 因此scala可以用val来重写一个无参方法(即将一个无参方法重写为一个字段)\n\n- 如果我们要在子类中重写父类的方法，则要在方法前加上override修饰符：`override def funcName(...){...}`\n\n- 使用final修饰符来确保某个成员不能被子类继承\n\n- scala的继承关系图\n![](/images/Scala/relation.jpg)\n\n## 第十二章 特质\n---\n\n- 特质的定义跟类定义很像，除了关键字trait\n\n- scala可以使用`extends`或者`with`关键字来 *混入* 特质，而不是继承。\n\n- 例子：`class Frog extends Animal with Philosophical with HasLegs{..}`\n混入多个特质用`with`连接\n\n### 要点如下:\n\n- **Scala中类只能继承一个超类, 可以扩展任意数量的特质**\n\n- 特质可以要求实现它们的类具备特定的字段, 方法和超类\n\n- 与Java接口不同, Scala特质可以提供方法和字段的实现\n\n- 当将多个特质叠加使用的时候, 顺序很重要\n\n- [scala特质详细解析](https://www.cnblogs.com/nowgood/p/scalatrait.html)\n\n- 重写特质的抽象方法时, 不需要`override`关键字\n\n- 可以为类和对象添加多个相互调用的特质时, 从最后一个开始调用. 这对于需要分阶段加工处理某个值的场景很有用.\n\n## 第十三章 包和引入\n---\n\n- scala的引入可以出现在任何地方，不仅仅是某个编译单元的开始\n\n- 例如，假设一个Fruit类，其中有有name和color字段。有如下的一个函数：\n```\ndef showFruit(fruit: Fruit) = {\n\timport Fruit._\n\tprintln(name + \"s are\" + color)\n}\n```\nshowFruit引入了其参数fruit(Fruit类)的所有成员。下面的name和color就相当于fruit.name和fruit.color\n\n## 第十四章 断言和测试\n---\n\n- 在scala中，断言的写法是对预定义方法assert的调用。\n\n- 表达式：`assert(condition)`。如果condition不满足则抛出AssertionError\n\n- 另一种：`assert(condition,explanation)`如果condition不满足则抛出指定的explanation的AssertionError\n\n## 第十五章 样例类和模式匹配\n---\n\n- 样例类使用case关键字修饰，scala编译器会自动创建工厂方法，即可以直接用`className(parameter1,parameter2,...)`而不用`new`关键字即可创建对象\n\n- 模式匹配，例子：\n```\nexpr match{\n\tcase BinOp(...) => println(...)\n\tcase _ =>  //处理器默认case,这一行是必须的，否则所有非满足第一个条件的case都会返回MatchError\n}\n```\n通配模式(`_`)会匹配任何对象\n\n## 第二十章 抽象成员\n---\n\n- 所有四种抽象成员：`val`，`var`，方法和类型\n\n- 例子：下面这个特质声明了四种抽象成员：一个抽象类型(T)，一个抽象方法(transform)，一个val(initial)和一个var(current)\n```\ntrait Anstract{\n\ttype T\n\tdef transform(x: T): T\n\tval initial: T\n\tvar current: T\n}\n```\n- scala的抽象类型指的是用type关键字声明为某个类或者特质的成员(但并不给出定义)的类型。类或者特质都不能够叫抽象类型，抽象类型永远是某个类或者特质的成员，比如Abstract特质中的T\n\n- `lazy`关键字：如果在`val`关键字前面加上`lazy`关键字，则该变量会在第一次被使用时被赋值。\n\n- T是指一个在声明时还未知的类型。不同的子类可以提供不同的T的实现\n\n\n<br>\n> 最后更新于2018.7.24\n","slug":"2018-07-23-scala-learning-03","published":1,"updated":"2018-09-03T13:37:06.158Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j5b00371m0oy3minyyg","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"第十章-组合和继承-面向对象进阶\"><a href=\"#第十章-组合和继承-面向对象进阶\" class=\"headerlink\" title=\"第十章 组合和继承  面向对象进阶\"></a>第十章 组合和继承  面向对象进阶</h2><h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li>例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class Element&#123;</span><br><span class=\"line\">\tdef contents: Array[String]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意，Element类中content方法没有标上abstract修饰符。一个方法只要是没有实现的(即没有等号或方法体)，那么它就是抽象的。跟Java不同，我们不能对方法加上abstract修饰符</p>\n<h3 id=\"定义无参方法\"><a href=\"#定义无参方法\" class=\"headerlink\" title=\"定义无参方法\"></a>定义无参方法</h3><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class Element &#123;</span><br><span class=\"line\">\tdef contents: Array[String]</span><br><span class=\"line\">\tdef height: Int = contents.length</span><br><span class=\"line\">\tdef width: Int = if(height == 0) 0 else contents(0).length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这个无参方法的特点是，如果将<code>def</code>换成<code>val</code>，那么他就成了一个字段而不会有编译错误</p>\n</li>\n<li><p>在这里无参方法和字段的区别是：字段的调用会更加快，但是每次实例化对象都要分配内存空间。具体取舍要看具体的用法。</p>\n</li>\n<li><p>总结下来就是，scala推荐我们将那些没有参数也没有副作用的方法定义为无参方法，而对于无参数而有副作用的方法不应当省略空括号，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;hello&quot;.length  //没有()，因为没有副作用</span><br><span class=\"line\">println()\t//有()，因为有副作用</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"扩展类\"><a href=\"#扩展类\" class=\"headerlink\" title=\"扩展类\"></a>扩展类</h3><ul>\n<li><p>使用<code>extends</code>关键字，相当于继承</p>\n</li>\n<li><p>scala中所有类的默认父类是AnyRef</p>\n</li>\n<li><p>继承的意思是超类的所有成员也是子类的成员，但是有两个例外：<br>一个是超类的私有成员不会被子类继承；<br>二是如果子类实现了相同名称和参数的成员，那么该成员不会被继承(重写，override)</p>\n</li>\n<li><p>scala只有两个命名空间用于定义：</p>\n</li>\n</ul>\n<ol>\n<li>值(字段，方法，包和单例对象)</li>\n<li>类型(类和特质名)</li>\n</ol>\n<ul>\n<li><p>因此scala可以用val来重写一个无参方法(即将一个无参方法重写为一个字段)</p>\n</li>\n<li><p>如果我们要在子类中重写父类的方法，则要在方法前加上override修饰符：<code>override def funcName(...){...}</code></p>\n</li>\n<li><p>使用final修饰符来确保某个成员不能被子类继承</p>\n</li>\n<li><p>scala的继承关系图<br><img src=\"/images/Scala/relation.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"第十二章-特质\"><a href=\"#第十二章-特质\" class=\"headerlink\" title=\"第十二章 特质\"></a>第十二章 特质</h2><hr>\n<ul>\n<li><p>特质的定义跟类定义很像，除了关键字trait</p>\n</li>\n<li><p>scala可以使用<code>extends</code>或者<code>with</code>关键字来 <em>混入</em> 特质，而不是继承。</p>\n</li>\n<li><p>例子：<code>class Frog extends Animal with Philosophical with HasLegs{..}</code><br>混入多个特质用<code>with</code>连接</p>\n</li>\n</ul>\n<h3 id=\"要点如下\"><a href=\"#要点如下\" class=\"headerlink\" title=\"要点如下:\"></a>要点如下:</h3><ul>\n<li><p><strong>Scala中类只能继承一个超类, 可以扩展任意数量的特质</strong></p>\n</li>\n<li><p>特质可以要求实现它们的类具备特定的字段, 方法和超类</p>\n</li>\n<li><p>与Java接口不同, Scala特质可以提供方法和字段的实现</p>\n</li>\n<li><p>当将多个特质叠加使用的时候, 顺序很重要</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/nowgood/p/scalatrait.html\" target=\"_blank\" rel=\"noopener\">scala特质详细解析</a></p>\n</li>\n<li><p>重写特质的抽象方法时, 不需要<code>override</code>关键字</p>\n</li>\n<li><p>可以为类和对象添加多个相互调用的特质时, 从最后一个开始调用. 这对于需要分阶段加工处理某个值的场景很有用.</p>\n</li>\n</ul>\n<h2 id=\"第十三章-包和引入\"><a href=\"#第十三章-包和引入\" class=\"headerlink\" title=\"第十三章 包和引入\"></a>第十三章 包和引入</h2><hr>\n<ul>\n<li><p>scala的引入可以出现在任何地方，不仅仅是某个编译单元的开始</p>\n</li>\n<li><p>例如，假设一个Fruit类，其中有有name和color字段。有如下的一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def showFruit(fruit: Fruit) = &#123;</span><br><span class=\"line\">\timport Fruit._</span><br><span class=\"line\">\tprintln(name + &quot;s are&quot; + color)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>showFruit引入了其参数fruit(Fruit类)的所有成员。下面的name和color就相当于fruit.name和fruit.color</p>\n<h2 id=\"第十四章-断言和测试\"><a href=\"#第十四章-断言和测试\" class=\"headerlink\" title=\"第十四章 断言和测试\"></a>第十四章 断言和测试</h2><hr>\n<ul>\n<li><p>在scala中，断言的写法是对预定义方法assert的调用。</p>\n</li>\n<li><p>表达式：<code>assert(condition)</code>。如果condition不满足则抛出AssertionError</p>\n</li>\n<li><p>另一种：<code>assert(condition,explanation)</code>如果condition不满足则抛出指定的explanation的AssertionError</p>\n</li>\n</ul>\n<h2 id=\"第十五章-样例类和模式匹配\"><a href=\"#第十五章-样例类和模式匹配\" class=\"headerlink\" title=\"第十五章 样例类和模式匹配\"></a>第十五章 样例类和模式匹配</h2><hr>\n<ul>\n<li><p>样例类使用case关键字修饰，scala编译器会自动创建工厂方法，即可以直接用<code>className(parameter1,parameter2,...)</code>而不用<code>new</code>关键字即可创建对象</p>\n</li>\n<li><p>模式匹配，例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expr match&#123;</span><br><span class=\"line\">\tcase BinOp(...) =&gt; println(...)</span><br><span class=\"line\">\tcase _ =&gt;  //处理器默认case,这一行是必须的，否则所有非满足第一个条件的case都会返回MatchError</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>通配模式(<code>_</code>)会匹配任何对象</p>\n<h2 id=\"第二十章-抽象成员\"><a href=\"#第二十章-抽象成员\" class=\"headerlink\" title=\"第二十章 抽象成员\"></a>第二十章 抽象成员</h2><hr>\n<ul>\n<li><p>所有四种抽象成员：<code>val</code>，<code>var</code>，方法和类型</p>\n</li>\n<li><p>例子：下面这个特质声明了四种抽象成员：一个抽象类型(T)，一个抽象方法(transform)，一个val(initial)和一个var(current)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trait Anstract&#123;</span><br><span class=\"line\">\ttype T</span><br><span class=\"line\">\tdef transform(x: T): T</span><br><span class=\"line\">\tval initial: T</span><br><span class=\"line\">\tvar current: T</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scala的抽象类型指的是用type关键字声明为某个类或者特质的成员(但并不给出定义)的类型。类或者特质都不能够叫抽象类型，抽象类型永远是某个类或者特质的成员，比如Abstract特质中的T</p>\n</li>\n<li><p><code>lazy</code>关键字：如果在<code>val</code>关键字前面加上<code>lazy</code>关键字，则该变量会在第一次被使用时被赋值。</p>\n</li>\n<li><p>T是指一个在声明时还未知的类型。不同的子类可以提供不同的T的实现</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.24</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"第十章-组合和继承-面向对象进阶\"><a href=\"#第十章-组合和继承-面向对象进阶\" class=\"headerlink\" title=\"第十章 组合和继承  面向对象进阶\"></a>第十章 组合和继承  面向对象进阶</h2><h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li>例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class Element&#123;</span><br><span class=\"line\">\tdef contents: Array[String]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意，Element类中content方法没有标上abstract修饰符。一个方法只要是没有实现的(即没有等号或方法体)，那么它就是抽象的。跟Java不同，我们不能对方法加上abstract修饰符</p>\n<h3 id=\"定义无参方法\"><a href=\"#定义无参方法\" class=\"headerlink\" title=\"定义无参方法\"></a>定义无参方法</h3><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class Element &#123;</span><br><span class=\"line\">\tdef contents: Array[String]</span><br><span class=\"line\">\tdef height: Int = contents.length</span><br><span class=\"line\">\tdef width: Int = if(height == 0) 0 else contents(0).length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这个无参方法的特点是，如果将<code>def</code>换成<code>val</code>，那么他就成了一个字段而不会有编译错误</p>\n</li>\n<li><p>在这里无参方法和字段的区别是：字段的调用会更加快，但是每次实例化对象都要分配内存空间。具体取舍要看具体的用法。</p>\n</li>\n<li><p>总结下来就是，scala推荐我们将那些没有参数也没有副作用的方法定义为无参方法，而对于无参数而有副作用的方法不应当省略空括号，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;hello&quot;.length  //没有()，因为没有副作用</span><br><span class=\"line\">println()\t//有()，因为有副作用</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"扩展类\"><a href=\"#扩展类\" class=\"headerlink\" title=\"扩展类\"></a>扩展类</h3><ul>\n<li><p>使用<code>extends</code>关键字，相当于继承</p>\n</li>\n<li><p>scala中所有类的默认父类是AnyRef</p>\n</li>\n<li><p>继承的意思是超类的所有成员也是子类的成员，但是有两个例外：<br>一个是超类的私有成员不会被子类继承；<br>二是如果子类实现了相同名称和参数的成员，那么该成员不会被继承(重写，override)</p>\n</li>\n<li><p>scala只有两个命名空间用于定义：</p>\n</li>\n</ul>\n<ol>\n<li>值(字段，方法，包和单例对象)</li>\n<li>类型(类和特质名)</li>\n</ol>\n<ul>\n<li><p>因此scala可以用val来重写一个无参方法(即将一个无参方法重写为一个字段)</p>\n</li>\n<li><p>如果我们要在子类中重写父类的方法，则要在方法前加上override修饰符：<code>override def funcName(...){...}</code></p>\n</li>\n<li><p>使用final修饰符来确保某个成员不能被子类继承</p>\n</li>\n<li><p>scala的继承关系图<br><img src=\"/images/Scala/relation.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"第十二章-特质\"><a href=\"#第十二章-特质\" class=\"headerlink\" title=\"第十二章 特质\"></a>第十二章 特质</h2><hr>\n<ul>\n<li><p>特质的定义跟类定义很像，除了关键字trait</p>\n</li>\n<li><p>scala可以使用<code>extends</code>或者<code>with</code>关键字来 <em>混入</em> 特质，而不是继承。</p>\n</li>\n<li><p>例子：<code>class Frog extends Animal with Philosophical with HasLegs{..}</code><br>混入多个特质用<code>with</code>连接</p>\n</li>\n</ul>\n<h3 id=\"要点如下\"><a href=\"#要点如下\" class=\"headerlink\" title=\"要点如下:\"></a>要点如下:</h3><ul>\n<li><p><strong>Scala中类只能继承一个超类, 可以扩展任意数量的特质</strong></p>\n</li>\n<li><p>特质可以要求实现它们的类具备特定的字段, 方法和超类</p>\n</li>\n<li><p>与Java接口不同, Scala特质可以提供方法和字段的实现</p>\n</li>\n<li><p>当将多个特质叠加使用的时候, 顺序很重要</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/nowgood/p/scalatrait.html\" target=\"_blank\" rel=\"noopener\">scala特质详细解析</a></p>\n</li>\n<li><p>重写特质的抽象方法时, 不需要<code>override</code>关键字</p>\n</li>\n<li><p>可以为类和对象添加多个相互调用的特质时, 从最后一个开始调用. 这对于需要分阶段加工处理某个值的场景很有用.</p>\n</li>\n</ul>\n<h2 id=\"第十三章-包和引入\"><a href=\"#第十三章-包和引入\" class=\"headerlink\" title=\"第十三章 包和引入\"></a>第十三章 包和引入</h2><hr>\n<ul>\n<li><p>scala的引入可以出现在任何地方，不仅仅是某个编译单元的开始</p>\n</li>\n<li><p>例如，假设一个Fruit类，其中有有name和color字段。有如下的一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def showFruit(fruit: Fruit) = &#123;</span><br><span class=\"line\">\timport Fruit._</span><br><span class=\"line\">\tprintln(name + &quot;s are&quot; + color)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>showFruit引入了其参数fruit(Fruit类)的所有成员。下面的name和color就相当于fruit.name和fruit.color</p>\n<h2 id=\"第十四章-断言和测试\"><a href=\"#第十四章-断言和测试\" class=\"headerlink\" title=\"第十四章 断言和测试\"></a>第十四章 断言和测试</h2><hr>\n<ul>\n<li><p>在scala中，断言的写法是对预定义方法assert的调用。</p>\n</li>\n<li><p>表达式：<code>assert(condition)</code>。如果condition不满足则抛出AssertionError</p>\n</li>\n<li><p>另一种：<code>assert(condition,explanation)</code>如果condition不满足则抛出指定的explanation的AssertionError</p>\n</li>\n</ul>\n<h2 id=\"第十五章-样例类和模式匹配\"><a href=\"#第十五章-样例类和模式匹配\" class=\"headerlink\" title=\"第十五章 样例类和模式匹配\"></a>第十五章 样例类和模式匹配</h2><hr>\n<ul>\n<li><p>样例类使用case关键字修饰，scala编译器会自动创建工厂方法，即可以直接用<code>className(parameter1,parameter2,...)</code>而不用<code>new</code>关键字即可创建对象</p>\n</li>\n<li><p>模式匹配，例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expr match&#123;</span><br><span class=\"line\">\tcase BinOp(...) =&gt; println(...)</span><br><span class=\"line\">\tcase _ =&gt;  //处理器默认case,这一行是必须的，否则所有非满足第一个条件的case都会返回MatchError</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>通配模式(<code>_</code>)会匹配任何对象</p>\n<h2 id=\"第二十章-抽象成员\"><a href=\"#第二十章-抽象成员\" class=\"headerlink\" title=\"第二十章 抽象成员\"></a>第二十章 抽象成员</h2><hr>\n<ul>\n<li><p>所有四种抽象成员：<code>val</code>，<code>var</code>，方法和类型</p>\n</li>\n<li><p>例子：下面这个特质声明了四种抽象成员：一个抽象类型(T)，一个抽象方法(transform)，一个val(initial)和一个var(current)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trait Anstract&#123;</span><br><span class=\"line\">\ttype T</span><br><span class=\"line\">\tdef transform(x: T): T</span><br><span class=\"line\">\tval initial: T</span><br><span class=\"line\">\tvar current: T</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scala的抽象类型指的是用type关键字声明为某个类或者特质的成员(但并不给出定义)的类型。类或者特质都不能够叫抽象类型，抽象类型永远是某个类或者特质的成员，比如Abstract特质中的T</p>\n</li>\n<li><p><code>lazy</code>关键字：如果在<code>val</code>关键字前面加上<code>lazy</code>关键字，则该变量会在第一次被使用时被赋值。</p>\n</li>\n<li><p>T是指一个在声明时还未知的类型。不同的子类可以提供不同的T的实现</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.24</p>\n</blockquote>\n"},{"layout":"post","title":"Windows10使用过程中遇到的一些坑","date":"2018-07-23T12:40:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n## 解决windows下atom字体模糊的问题\n---\n\n- 这种情况是由windows下GPU的一些优化带来的问题，主要是会导致字体模糊。\n\n- 也有人说是由于抗锯齿导致的问题\n\n- 更改方法如下：\n\n![](/images/Windows/atom.jpg)\n","source":"_posts/2018-07-23-windows-realated.md","raw":"---\nlayout:     post\ntitle:      \"Windows10使用过程中遇到的一些坑\"\ndate:       2018-07-23 20:40:00\ncategories: Computer System\ntags:   ๑Windows\n---\n\n> 不适合人类阅读的学习笔记\n\n## 解决windows下atom字体模糊的问题\n---\n\n- 这种情况是由windows下GPU的一些优化带来的问题，主要是会导致字体模糊。\n\n- 也有人说是由于抗锯齿导致的问题\n\n- 更改方法如下：\n\n![](/images/Windows/atom.jpg)\n","slug":"2018-07-23-windows-realated","published":1,"updated":"2018-09-03T08:51:43.173Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j5c003a1m0oanivc7vz","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"解决windows下atom字体模糊的问题\"><a href=\"#解决windows下atom字体模糊的问题\" class=\"headerlink\" title=\"解决windows下atom字体模糊的问题\"></a>解决windows下atom字体模糊的问题</h2><hr>\n<ul>\n<li><p>这种情况是由windows下GPU的一些优化带来的问题，主要是会导致字体模糊。</p>\n</li>\n<li><p>也有人说是由于抗锯齿导致的问题</p>\n</li>\n<li><p>更改方法如下：</p>\n</li>\n</ul>\n<p><img src=\"/images/Windows/atom.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"解决windows下atom字体模糊的问题\"><a href=\"#解决windows下atom字体模糊的问题\" class=\"headerlink\" title=\"解决windows下atom字体模糊的问题\"></a>解决windows下atom字体模糊的问题</h2><hr>\n<ul>\n<li><p>这种情况是由windows下GPU的一些优化带来的问题，主要是会导致字体模糊。</p>\n</li>\n<li><p>也有人说是由于抗锯齿导致的问题</p>\n</li>\n<li><p>更改方法如下：</p>\n</li>\n</ul>\n<p><img src=\"/images/Windows/atom.jpg\" alt=\"\"></p>\n"},{"layout":"post","title":"《Scala编程》阅读记录——列表进阶","date":"2018-07-24T03:25:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n## 第十六章 使用列表\n---\n\n- [列表的使用方法表格见另一篇博客](https://fleschier.github.io/2018/07/Scala-infos/)\n\n- 列表跟数组非常像，但是有两个重要的区别：\n1. 列表是不可变的，也就是说列表的元素不能通过赋值改变\n2. 列表是递归的(即链表)，而数组是平的\n\n- `init`和`last`要消耗的时间与列表的长度成正比，而`head`和`tail`消耗常量级别的时间\n\n- `indices`方法返回包含了指定列表所有有效的下标，所以一般用在for表达式遍历列表时：\n```\nval lst = new List(\"af\",\"g3g\",\"g53v\")\nfor( i <- lst.indices){ //这里i即是从lst的第一个有效下标开始直到最后一个下标\n  ...\n}\n```\n\n### `flatten`方法：接受一个列表的列表并返回单个列表\n\n- 例子：\n```\nscala> List(List(1,2),List(3),List(),List(4,5)).flatten\nres0: List[Int] = List(1,2,3,4,5)\n```\n\n- 例子：\n![](/images/Scala/flatten_test.jpg)\n\n### `zip`和`unzip`\n\n- zip操作接受两个列表，返回一个有对偶组成的列表\n\n- 如果两个列表的元素个数不同，那么任何没有配对上的元素将被丢弃\n\n#### `zipWithIndex`方法\n\n- 例子：\n```\nscala> val abcde = List('a','b','c','d','e')\nabcde: List[Char] = List(a,b,c,d,e)\nscala> abcde.zipWithIndex\nres0: List[(Char,Int)] = List((a,0),(b,1),(c,2),(d,3),(e,4))\n```\n\n- 任何元组的列表都可以通过unzip方法转换回由列表组成的元组\n\n### 显示列表\n\n- 下面一些例子：\n```\nscala> abcde mkString(\"[\", \",\", \"]\")\nres0: String = [a,b,c,d,e]\nscala> abcde mkString \"\"\nres1: String = abcde\nscala> abcde.mkString\nres2: String = abcde\nscala> abcde mkString (\"List(\", \", \", \")\")\nres3: String = List(a,b,c,d,e)\n```\n\n### 过滤列表\n\n- `filter`，`partition`，`find`，`takeWhile`，`dropWhile`和`span`\n\n- 这些过滤函数的参数都是`T => Boolean`类型的\n\n- `x.takeWhile(p)`返回x列表中连续满足p的最长前缀，例：`nums.takeWhile(_ > 0)`\n\n- `x.dropWhile`将去除列表x中连续满足p的最长前缀，例：`words.dropWhile(_.startsWith(\"t\"))`\n\n### 对列表前提条件的检查\n\n- `forall`和`exists`\n\n- `xs.forall(p)`，如果列表中所有元素都满足p则返回true\n\n- `xs.exists(p)`，如果列表中有至少一个元素满足p则返回true\n\n\n<br>\n> 最后更新于2018.7.24\n","source":"_posts/2018-07-24-scala-learning-04.md","raw":"---\nlayout:     post\ntitle:      \"《Scala编程》阅读记录——列表进阶\"\ndate:       2018-07-24 11:25:00\ncategories: Computer Programes\ntags:   ๑Scala\n---\n\n> 不适合人类阅读的学习笔记\n\n## 第十六章 使用列表\n---\n\n- [列表的使用方法表格见另一篇博客](https://fleschier.github.io/2018/07/Scala-infos/)\n\n- 列表跟数组非常像，但是有两个重要的区别：\n1. 列表是不可变的，也就是说列表的元素不能通过赋值改变\n2. 列表是递归的(即链表)，而数组是平的\n\n- `init`和`last`要消耗的时间与列表的长度成正比，而`head`和`tail`消耗常量级别的时间\n\n- `indices`方法返回包含了指定列表所有有效的下标，所以一般用在for表达式遍历列表时：\n```\nval lst = new List(\"af\",\"g3g\",\"g53v\")\nfor( i <- lst.indices){ //这里i即是从lst的第一个有效下标开始直到最后一个下标\n  ...\n}\n```\n\n### `flatten`方法：接受一个列表的列表并返回单个列表\n\n- 例子：\n```\nscala> List(List(1,2),List(3),List(),List(4,5)).flatten\nres0: List[Int] = List(1,2,3,4,5)\n```\n\n- 例子：\n![](/images/Scala/flatten_test.jpg)\n\n### `zip`和`unzip`\n\n- zip操作接受两个列表，返回一个有对偶组成的列表\n\n- 如果两个列表的元素个数不同，那么任何没有配对上的元素将被丢弃\n\n#### `zipWithIndex`方法\n\n- 例子：\n```\nscala> val abcde = List('a','b','c','d','e')\nabcde: List[Char] = List(a,b,c,d,e)\nscala> abcde.zipWithIndex\nres0: List[(Char,Int)] = List((a,0),(b,1),(c,2),(d,3),(e,4))\n```\n\n- 任何元组的列表都可以通过unzip方法转换回由列表组成的元组\n\n### 显示列表\n\n- 下面一些例子：\n```\nscala> abcde mkString(\"[\", \",\", \"]\")\nres0: String = [a,b,c,d,e]\nscala> abcde mkString \"\"\nres1: String = abcde\nscala> abcde.mkString\nres2: String = abcde\nscala> abcde mkString (\"List(\", \", \", \")\")\nres3: String = List(a,b,c,d,e)\n```\n\n### 过滤列表\n\n- `filter`，`partition`，`find`，`takeWhile`，`dropWhile`和`span`\n\n- 这些过滤函数的参数都是`T => Boolean`类型的\n\n- `x.takeWhile(p)`返回x列表中连续满足p的最长前缀，例：`nums.takeWhile(_ > 0)`\n\n- `x.dropWhile`将去除列表x中连续满足p的最长前缀，例：`words.dropWhile(_.startsWith(\"t\"))`\n\n### 对列表前提条件的检查\n\n- `forall`和`exists`\n\n- `xs.forall(p)`，如果列表中所有元素都满足p则返回true\n\n- `xs.exists(p)`，如果列表中有至少一个元素满足p则返回true\n\n\n<br>\n> 最后更新于2018.7.24\n","slug":"2018-07-24-scala-learning-04","published":1,"updated":"2018-09-03T13:09:04.291Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j5d003e1m0ovepoz6yt","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"第十六章-使用列表\"><a href=\"#第十六章-使用列表\" class=\"headerlink\" title=\"第十六章 使用列表\"></a>第十六章 使用列表</h2><hr>\n<ul>\n<li><p><a href=\"https://fleschier.github.io/2018/07/Scala-infos/\" target=\"_blank\" rel=\"noopener\">列表的使用方法表格见另一篇博客</a></p>\n</li>\n<li><p>列表跟数组非常像，但是有两个重要的区别：</p>\n</li>\n</ul>\n<ol>\n<li>列表是不可变的，也就是说列表的元素不能通过赋值改变</li>\n<li>列表是递归的(即链表)，而数组是平的</li>\n</ol>\n<ul>\n<li><p><code>init</code>和<code>last</code>要消耗的时间与列表的长度成正比，而<code>head</code>和<code>tail</code>消耗常量级别的时间</p>\n</li>\n<li><p><code>indices</code>方法返回包含了指定列表所有有效的下标，所以一般用在for表达式遍历列表时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val lst = new List(&quot;af&quot;,&quot;g3g&quot;,&quot;g53v&quot;)</span><br><span class=\"line\">for( i &lt;- lst.indices)&#123; //这里i即是从lst的第一个有效下标开始直到最后一个下标</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"flatten方法：接受一个列表的列表并返回单个列表\"><a href=\"#flatten方法：接受一个列表的列表并返回单个列表\" class=\"headerlink\" title=\"flatten方法：接受一个列表的列表并返回单个列表\"></a><code>flatten</code>方法：接受一个列表的列表并返回单个列表</h3><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; List(List(1,2),List(3),List(),List(4,5)).flatten</span><br><span class=\"line\">res0: List[Int] = List(1,2,3,4,5)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例子：<br><img src=\"/images/Scala/flatten_test.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"zip和unzip\"><a href=\"#zip和unzip\" class=\"headerlink\" title=\"zip和unzip\"></a><code>zip</code>和<code>unzip</code></h3><ul>\n<li><p>zip操作接受两个列表，返回一个有对偶组成的列表</p>\n</li>\n<li><p>如果两个列表的元素个数不同，那么任何没有配对上的元素将被丢弃</p>\n</li>\n</ul>\n<h4 id=\"zipWithIndex方法\"><a href=\"#zipWithIndex方法\" class=\"headerlink\" title=\"zipWithIndex方法\"></a><code>zipWithIndex</code>方法</h4><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; val abcde = List(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;)</span><br><span class=\"line\">abcde: List[Char] = List(a,b,c,d,e)</span><br><span class=\"line\">scala&gt; abcde.zipWithIndex</span><br><span class=\"line\">res0: List[(Char,Int)] = List((a,0),(b,1),(c,2),(d,3),(e,4))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>任何元组的列表都可以通过unzip方法转换回由列表组成的元组</p>\n</li>\n</ul>\n<h3 id=\"显示列表\"><a href=\"#显示列表\" class=\"headerlink\" title=\"显示列表\"></a>显示列表</h3><ul>\n<li>下面一些例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; abcde mkString(&quot;[&quot;, &quot;,&quot;, &quot;]&quot;)</span><br><span class=\"line\">res0: String = [a,b,c,d,e]</span><br><span class=\"line\">scala&gt; abcde mkString &quot;&quot;</span><br><span class=\"line\">res1: String = abcde</span><br><span class=\"line\">scala&gt; abcde.mkString</span><br><span class=\"line\">res2: String = abcde</span><br><span class=\"line\">scala&gt; abcde mkString (&quot;List(&quot;, &quot;, &quot;, &quot;)&quot;)</span><br><span class=\"line\">res3: String = List(a,b,c,d,e)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"过滤列表\"><a href=\"#过滤列表\" class=\"headerlink\" title=\"过滤列表\"></a>过滤列表</h3><ul>\n<li><p><code>filter</code>，<code>partition</code>，<code>find</code>，<code>takeWhile</code>，<code>dropWhile</code>和<code>span</code></p>\n</li>\n<li><p>这些过滤函数的参数都是<code>T =&gt; Boolean</code>类型的</p>\n</li>\n<li><p><code>x.takeWhile(p)</code>返回x列表中连续满足p的最长前缀，例：<code>nums.takeWhile(_ &gt; 0)</code></p>\n</li>\n<li><p><code>x.dropWhile</code>将去除列表x中连续满足p的最长前缀，例：<code>words.dropWhile(_.startsWith(&quot;t&quot;))</code></p>\n</li>\n</ul>\n<h3 id=\"对列表前提条件的检查\"><a href=\"#对列表前提条件的检查\" class=\"headerlink\" title=\"对列表前提条件的检查\"></a>对列表前提条件的检查</h3><ul>\n<li><p><code>forall</code>和<code>exists</code></p>\n</li>\n<li><p><code>xs.forall(p)</code>，如果列表中所有元素都满足p则返回true</p>\n</li>\n<li><p><code>xs.exists(p)</code>，如果列表中有至少一个元素满足p则返回true</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.24</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"第十六章-使用列表\"><a href=\"#第十六章-使用列表\" class=\"headerlink\" title=\"第十六章 使用列表\"></a>第十六章 使用列表</h2><hr>\n<ul>\n<li><p><a href=\"https://fleschier.github.io/2018/07/Scala-infos/\" target=\"_blank\" rel=\"noopener\">列表的使用方法表格见另一篇博客</a></p>\n</li>\n<li><p>列表跟数组非常像，但是有两个重要的区别：</p>\n</li>\n</ul>\n<ol>\n<li>列表是不可变的，也就是说列表的元素不能通过赋值改变</li>\n<li>列表是递归的(即链表)，而数组是平的</li>\n</ol>\n<ul>\n<li><p><code>init</code>和<code>last</code>要消耗的时间与列表的长度成正比，而<code>head</code>和<code>tail</code>消耗常量级别的时间</p>\n</li>\n<li><p><code>indices</code>方法返回包含了指定列表所有有效的下标，所以一般用在for表达式遍历列表时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val lst = new List(&quot;af&quot;,&quot;g3g&quot;,&quot;g53v&quot;)</span><br><span class=\"line\">for( i &lt;- lst.indices)&#123; //这里i即是从lst的第一个有效下标开始直到最后一个下标</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"flatten方法：接受一个列表的列表并返回单个列表\"><a href=\"#flatten方法：接受一个列表的列表并返回单个列表\" class=\"headerlink\" title=\"flatten方法：接受一个列表的列表并返回单个列表\"></a><code>flatten</code>方法：接受一个列表的列表并返回单个列表</h3><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; List(List(1,2),List(3),List(),List(4,5)).flatten</span><br><span class=\"line\">res0: List[Int] = List(1,2,3,4,5)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例子：<br><img src=\"/images/Scala/flatten_test.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"zip和unzip\"><a href=\"#zip和unzip\" class=\"headerlink\" title=\"zip和unzip\"></a><code>zip</code>和<code>unzip</code></h3><ul>\n<li><p>zip操作接受两个列表，返回一个有对偶组成的列表</p>\n</li>\n<li><p>如果两个列表的元素个数不同，那么任何没有配对上的元素将被丢弃</p>\n</li>\n</ul>\n<h4 id=\"zipWithIndex方法\"><a href=\"#zipWithIndex方法\" class=\"headerlink\" title=\"zipWithIndex方法\"></a><code>zipWithIndex</code>方法</h4><ul>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; val abcde = List(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;)</span><br><span class=\"line\">abcde: List[Char] = List(a,b,c,d,e)</span><br><span class=\"line\">scala&gt; abcde.zipWithIndex</span><br><span class=\"line\">res0: List[(Char,Int)] = List((a,0),(b,1),(c,2),(d,3),(e,4))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>任何元组的列表都可以通过unzip方法转换回由列表组成的元组</p>\n</li>\n</ul>\n<h3 id=\"显示列表\"><a href=\"#显示列表\" class=\"headerlink\" title=\"显示列表\"></a>显示列表</h3><ul>\n<li>下面一些例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scala&gt; abcde mkString(&quot;[&quot;, &quot;,&quot;, &quot;]&quot;)</span><br><span class=\"line\">res0: String = [a,b,c,d,e]</span><br><span class=\"line\">scala&gt; abcde mkString &quot;&quot;</span><br><span class=\"line\">res1: String = abcde</span><br><span class=\"line\">scala&gt; abcde.mkString</span><br><span class=\"line\">res2: String = abcde</span><br><span class=\"line\">scala&gt; abcde mkString (&quot;List(&quot;, &quot;, &quot;, &quot;)&quot;)</span><br><span class=\"line\">res3: String = List(a,b,c,d,e)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"过滤列表\"><a href=\"#过滤列表\" class=\"headerlink\" title=\"过滤列表\"></a>过滤列表</h3><ul>\n<li><p><code>filter</code>，<code>partition</code>，<code>find</code>，<code>takeWhile</code>，<code>dropWhile</code>和<code>span</code></p>\n</li>\n<li><p>这些过滤函数的参数都是<code>T =&gt; Boolean</code>类型的</p>\n</li>\n<li><p><code>x.takeWhile(p)</code>返回x列表中连续满足p的最长前缀，例：<code>nums.takeWhile(_ &gt; 0)</code></p>\n</li>\n<li><p><code>x.dropWhile</code>将去除列表x中连续满足p的最长前缀，例：<code>words.dropWhile(_.startsWith(&quot;t&quot;))</code></p>\n</li>\n</ul>\n<h3 id=\"对列表前提条件的检查\"><a href=\"#对列表前提条件的检查\" class=\"headerlink\" title=\"对列表前提条件的检查\"></a>对列表前提条件的检查</h3><ul>\n<li><p><code>forall</code>和<code>exists</code></p>\n</li>\n<li><p><code>xs.forall(p)</code>，如果列表中所有元素都满足p则返回true</p>\n</li>\n<li><p><code>xs.exists(p)</code>，如果列表中有至少一个元素满足p则返回true</p>\n</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.24</p>\n</blockquote>\n"},{"layout":"post","title":"《Scala编程》阅读记录——集合类进阶","date":"2018-07-24T03:25:00.000Z","_content":"\n> 不适合人类阅读的学习笔记\n\n## 第十七章 使用集合类\n---\n\n### 序列\n\n#### 列表\n\n- List类是不可变 **链表**, 因此支持在头部快速添加和移除条目，但是不提供按下标快速访问的功能，因为实现这个功能需要线性地遍历列表。\n\n#### 列表缓冲(ListBuffer)\n\n- List类提供对列表头部的快速访问，但是对尾部就不那么高效，因此在尾部添加元素时我们经常需要用到reverse方法，在头部添加元素最后再reverse来获得我们想要的顺序\n\n- ListBuffer是一个可变对象(包含在scala.collection.mutable中)，帮助我们在需要追加元素来构建列表时能够更加高效。ListBuffer提供了常量时间的往前和往后追加元素的操作。\n\n- 可以使用`+=`来往后追加元素，使用`+=:`来往前追加元素\n\n- 最后可以使用`toList`方法来转换成List类型\n\n- 使用ListBuffer的另一个原因是可以防止可能的栈溢出\n\n#### 数组缓冲(ArrayBuffer)\n\n- 创建数组缓冲的时候不需要指定长度，只要给定类型\n```\nimport scala.collection.mutable.ArrayBuffer\nval buf = new ArrayBuffer[Int]()\n```\n\n- 使用`+=`方法来追加元素\n\n- 所有的数组的常规操作都是可以用的\n\n#### 字符串(通过StringOps)\n\n- StringOps实现了很多序列的方法。由于Predef有一个从String到StringOps的隐式转换，可以将任何字符串当做序列来处理\n\n- 例如:\n```\ndef hasUpperCase(s: String) = s.exists(_.isUpper)\nhasUpperCase(\"Robert Frost\")\n```\n这里由于String类本身并没有任何名为`exists`的方法，但是StringOps有，通过隐式转换将s转换成StringOps来实现\n\n### 集和映射\n---\n\n#### 使用集\n\n- 集的关键特征是它们会确保在同一时刻，以`==`为标准，集里的每个对象都最多出现一次\n\n- 集的方法见博客[方法查询](https://fleschier.github.io/2018/07/Scala-infos/)\n\n#### 使用映射\n\n- 映射使用键来索引对应的值\n\n- 下面是一个统计每个单词在字符串中出现次数的方法：\n```\ndef countWords(text: String) = {\n  val counts = mutable.Map.empty[String,Int]\n  for (rawWord <- text.split(\"[ ,!.]+\")){\n    val word = rawWord.toLowerCase // 统一变为小写字母\n    val oldCount =\n      if(counts.contains(word)) counts(word)\n      else 0\n    counts += (word -> (oldCount + 1))\n  }\n  counts\n}\n```\n\n- 映射的方法见博客[方法查询](https://fleschier.github.io/2018/07/Scala-infos/)\n\n- 可变集合和可变映射的工厂方法都采用了hash的技术。例如`scala.collection.mutable.Set()`这个工厂方法返回一个`scala.collection.mutable.HashSet`。同理， `scala.collection.mutable.Map()`这个工厂方法返回一个`scala.collection.mutable.HashMap`\n\n### 元组\n---\n\n- 元组帮助我们省去定义那些简单的主要承载数据的类的麻烦。**元组的一个常见的应用场景是从方法返回多个值**\n\n\n<br>\n> 最后更新于2018.7.24\n","source":"_posts/2018-07-24-scala-learning-05.md","raw":"---\nlayout:     post\ntitle:      \"《Scala编程》阅读记录——集合类进阶\"\ndate:       2018-07-24 11:25:00\ncategories: Computer Programes\ntags:   ๑Scala\n---\n\n> 不适合人类阅读的学习笔记\n\n## 第十七章 使用集合类\n---\n\n### 序列\n\n#### 列表\n\n- List类是不可变 **链表**, 因此支持在头部快速添加和移除条目，但是不提供按下标快速访问的功能，因为实现这个功能需要线性地遍历列表。\n\n#### 列表缓冲(ListBuffer)\n\n- List类提供对列表头部的快速访问，但是对尾部就不那么高效，因此在尾部添加元素时我们经常需要用到reverse方法，在头部添加元素最后再reverse来获得我们想要的顺序\n\n- ListBuffer是一个可变对象(包含在scala.collection.mutable中)，帮助我们在需要追加元素来构建列表时能够更加高效。ListBuffer提供了常量时间的往前和往后追加元素的操作。\n\n- 可以使用`+=`来往后追加元素，使用`+=:`来往前追加元素\n\n- 最后可以使用`toList`方法来转换成List类型\n\n- 使用ListBuffer的另一个原因是可以防止可能的栈溢出\n\n#### 数组缓冲(ArrayBuffer)\n\n- 创建数组缓冲的时候不需要指定长度，只要给定类型\n```\nimport scala.collection.mutable.ArrayBuffer\nval buf = new ArrayBuffer[Int]()\n```\n\n- 使用`+=`方法来追加元素\n\n- 所有的数组的常规操作都是可以用的\n\n#### 字符串(通过StringOps)\n\n- StringOps实现了很多序列的方法。由于Predef有一个从String到StringOps的隐式转换，可以将任何字符串当做序列来处理\n\n- 例如:\n```\ndef hasUpperCase(s: String) = s.exists(_.isUpper)\nhasUpperCase(\"Robert Frost\")\n```\n这里由于String类本身并没有任何名为`exists`的方法，但是StringOps有，通过隐式转换将s转换成StringOps来实现\n\n### 集和映射\n---\n\n#### 使用集\n\n- 集的关键特征是它们会确保在同一时刻，以`==`为标准，集里的每个对象都最多出现一次\n\n- 集的方法见博客[方法查询](https://fleschier.github.io/2018/07/Scala-infos/)\n\n#### 使用映射\n\n- 映射使用键来索引对应的值\n\n- 下面是一个统计每个单词在字符串中出现次数的方法：\n```\ndef countWords(text: String) = {\n  val counts = mutable.Map.empty[String,Int]\n  for (rawWord <- text.split(\"[ ,!.]+\")){\n    val word = rawWord.toLowerCase // 统一变为小写字母\n    val oldCount =\n      if(counts.contains(word)) counts(word)\n      else 0\n    counts += (word -> (oldCount + 1))\n  }\n  counts\n}\n```\n\n- 映射的方法见博客[方法查询](https://fleschier.github.io/2018/07/Scala-infos/)\n\n- 可变集合和可变映射的工厂方法都采用了hash的技术。例如`scala.collection.mutable.Set()`这个工厂方法返回一个`scala.collection.mutable.HashSet`。同理， `scala.collection.mutable.Map()`这个工厂方法返回一个`scala.collection.mutable.HashMap`\n\n### 元组\n---\n\n- 元组帮助我们省去定义那些简单的主要承载数据的类的麻烦。**元组的一个常见的应用场景是从方法返回多个值**\n\n\n<br>\n> 最后更新于2018.7.24\n","slug":"2018-07-24-scala-learning-05","published":1,"updated":"2018-09-03T13:08:32.348Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j5e003h1m0o6e21035b","content":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"第十七章-使用集合类\"><a href=\"#第十七章-使用集合类\" class=\"headerlink\" title=\"第十七章 使用集合类\"></a>第十七章 使用集合类</h2><hr>\n<h3 id=\"序列\"><a href=\"#序列\" class=\"headerlink\" title=\"序列\"></a>序列</h3><h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><ul>\n<li>List类是不可变 <strong>链表</strong>, 因此支持在头部快速添加和移除条目，但是不提供按下标快速访问的功能，因为实现这个功能需要线性地遍历列表。</li>\n</ul>\n<h4 id=\"列表缓冲-ListBuffer\"><a href=\"#列表缓冲-ListBuffer\" class=\"headerlink\" title=\"列表缓冲(ListBuffer)\"></a>列表缓冲(ListBuffer)</h4><ul>\n<li><p>List类提供对列表头部的快速访问，但是对尾部就不那么高效，因此在尾部添加元素时我们经常需要用到reverse方法，在头部添加元素最后再reverse来获得我们想要的顺序</p>\n</li>\n<li><p>ListBuffer是一个可变对象(包含在scala.collection.mutable中)，帮助我们在需要追加元素来构建列表时能够更加高效。ListBuffer提供了常量时间的往前和往后追加元素的操作。</p>\n</li>\n<li><p>可以使用<code>+=</code>来往后追加元素，使用<code>+=:</code>来往前追加元素</p>\n</li>\n<li><p>最后可以使用<code>toList</code>方法来转换成List类型</p>\n</li>\n<li><p>使用ListBuffer的另一个原因是可以防止可能的栈溢出</p>\n</li>\n</ul>\n<h4 id=\"数组缓冲-ArrayBuffer\"><a href=\"#数组缓冲-ArrayBuffer\" class=\"headerlink\" title=\"数组缓冲(ArrayBuffer)\"></a>数组缓冲(ArrayBuffer)</h4><ul>\n<li><p>创建数组缓冲的时候不需要指定长度，只要给定类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import scala.collection.mutable.ArrayBuffer</span><br><span class=\"line\">val buf = new ArrayBuffer[Int]()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>+=</code>方法来追加元素</p>\n</li>\n<li><p>所有的数组的常规操作都是可以用的</p>\n</li>\n</ul>\n<h4 id=\"字符串-通过StringOps\"><a href=\"#字符串-通过StringOps\" class=\"headerlink\" title=\"字符串(通过StringOps)\"></a>字符串(通过StringOps)</h4><ul>\n<li><p>StringOps实现了很多序列的方法。由于Predef有一个从String到StringOps的隐式转换，可以将任何字符串当做序列来处理</p>\n</li>\n<li><p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def hasUpperCase(s: String) = s.exists(_.isUpper)</span><br><span class=\"line\">hasUpperCase(&quot;Robert Frost&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里由于String类本身并没有任何名为<code>exists</code>的方法，但是StringOps有，通过隐式转换将s转换成StringOps来实现</p>\n<h3 id=\"集和映射\"><a href=\"#集和映射\" class=\"headerlink\" title=\"集和映射\"></a>集和映射</h3><hr>\n<h4 id=\"使用集\"><a href=\"#使用集\" class=\"headerlink\" title=\"使用集\"></a>使用集</h4><ul>\n<li><p>集的关键特征是它们会确保在同一时刻，以<code>==</code>为标准，集里的每个对象都最多出现一次</p>\n</li>\n<li><p>集的方法见博客<a href=\"https://fleschier.github.io/2018/07/Scala-infos/\" target=\"_blank\" rel=\"noopener\">方法查询</a></p>\n</li>\n</ul>\n<h4 id=\"使用映射\"><a href=\"#使用映射\" class=\"headerlink\" title=\"使用映射\"></a>使用映射</h4><ul>\n<li><p>映射使用键来索引对应的值</p>\n</li>\n<li><p>下面是一个统计每个单词在字符串中出现次数的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def countWords(text: String) = &#123;</span><br><span class=\"line\">  val counts = mutable.Map.empty[String,Int]</span><br><span class=\"line\">  for (rawWord &lt;- text.split(&quot;[ ,!.]+&quot;))&#123;</span><br><span class=\"line\">    val word = rawWord.toLowerCase // 统一变为小写字母</span><br><span class=\"line\">    val oldCount =</span><br><span class=\"line\">      if(counts.contains(word)) counts(word)</span><br><span class=\"line\">      else 0</span><br><span class=\"line\">    counts += (word -&gt; (oldCount + 1))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  counts</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>映射的方法见博客<a href=\"https://fleschier.github.io/2018/07/Scala-infos/\" target=\"_blank\" rel=\"noopener\">方法查询</a></p>\n</li>\n<li><p>可变集合和可变映射的工厂方法都采用了hash的技术。例如<code>scala.collection.mutable.Set()</code>这个工厂方法返回一个<code>scala.collection.mutable.HashSet</code>。同理， <code>scala.collection.mutable.Map()</code>这个工厂方法返回一个<code>scala.collection.mutable.HashMap</code></p>\n</li>\n</ul>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><hr>\n<ul>\n<li>元组帮助我们省去定义那些简单的主要承载数据的类的麻烦。<strong>元组的一个常见的应用场景是从方法返回多个值</strong></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.24</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不适合人类阅读的学习笔记</p>\n</blockquote>\n<h2 id=\"第十七章-使用集合类\"><a href=\"#第十七章-使用集合类\" class=\"headerlink\" title=\"第十七章 使用集合类\"></a>第十七章 使用集合类</h2><hr>\n<h3 id=\"序列\"><a href=\"#序列\" class=\"headerlink\" title=\"序列\"></a>序列</h3><h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><ul>\n<li>List类是不可变 <strong>链表</strong>, 因此支持在头部快速添加和移除条目，但是不提供按下标快速访问的功能，因为实现这个功能需要线性地遍历列表。</li>\n</ul>\n<h4 id=\"列表缓冲-ListBuffer\"><a href=\"#列表缓冲-ListBuffer\" class=\"headerlink\" title=\"列表缓冲(ListBuffer)\"></a>列表缓冲(ListBuffer)</h4><ul>\n<li><p>List类提供对列表头部的快速访问，但是对尾部就不那么高效，因此在尾部添加元素时我们经常需要用到reverse方法，在头部添加元素最后再reverse来获得我们想要的顺序</p>\n</li>\n<li><p>ListBuffer是一个可变对象(包含在scala.collection.mutable中)，帮助我们在需要追加元素来构建列表时能够更加高效。ListBuffer提供了常量时间的往前和往后追加元素的操作。</p>\n</li>\n<li><p>可以使用<code>+=</code>来往后追加元素，使用<code>+=:</code>来往前追加元素</p>\n</li>\n<li><p>最后可以使用<code>toList</code>方法来转换成List类型</p>\n</li>\n<li><p>使用ListBuffer的另一个原因是可以防止可能的栈溢出</p>\n</li>\n</ul>\n<h4 id=\"数组缓冲-ArrayBuffer\"><a href=\"#数组缓冲-ArrayBuffer\" class=\"headerlink\" title=\"数组缓冲(ArrayBuffer)\"></a>数组缓冲(ArrayBuffer)</h4><ul>\n<li><p>创建数组缓冲的时候不需要指定长度，只要给定类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import scala.collection.mutable.ArrayBuffer</span><br><span class=\"line\">val buf = new ArrayBuffer[Int]()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>+=</code>方法来追加元素</p>\n</li>\n<li><p>所有的数组的常规操作都是可以用的</p>\n</li>\n</ul>\n<h4 id=\"字符串-通过StringOps\"><a href=\"#字符串-通过StringOps\" class=\"headerlink\" title=\"字符串(通过StringOps)\"></a>字符串(通过StringOps)</h4><ul>\n<li><p>StringOps实现了很多序列的方法。由于Predef有一个从String到StringOps的隐式转换，可以将任何字符串当做序列来处理</p>\n</li>\n<li><p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def hasUpperCase(s: String) = s.exists(_.isUpper)</span><br><span class=\"line\">hasUpperCase(&quot;Robert Frost&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里由于String类本身并没有任何名为<code>exists</code>的方法，但是StringOps有，通过隐式转换将s转换成StringOps来实现</p>\n<h3 id=\"集和映射\"><a href=\"#集和映射\" class=\"headerlink\" title=\"集和映射\"></a>集和映射</h3><hr>\n<h4 id=\"使用集\"><a href=\"#使用集\" class=\"headerlink\" title=\"使用集\"></a>使用集</h4><ul>\n<li><p>集的关键特征是它们会确保在同一时刻，以<code>==</code>为标准，集里的每个对象都最多出现一次</p>\n</li>\n<li><p>集的方法见博客<a href=\"https://fleschier.github.io/2018/07/Scala-infos/\" target=\"_blank\" rel=\"noopener\">方法查询</a></p>\n</li>\n</ul>\n<h4 id=\"使用映射\"><a href=\"#使用映射\" class=\"headerlink\" title=\"使用映射\"></a>使用映射</h4><ul>\n<li><p>映射使用键来索引对应的值</p>\n</li>\n<li><p>下面是一个统计每个单词在字符串中出现次数的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def countWords(text: String) = &#123;</span><br><span class=\"line\">  val counts = mutable.Map.empty[String,Int]</span><br><span class=\"line\">  for (rawWord &lt;- text.split(&quot;[ ,!.]+&quot;))&#123;</span><br><span class=\"line\">    val word = rawWord.toLowerCase // 统一变为小写字母</span><br><span class=\"line\">    val oldCount =</span><br><span class=\"line\">      if(counts.contains(word)) counts(word)</span><br><span class=\"line\">      else 0</span><br><span class=\"line\">    counts += (word -&gt; (oldCount + 1))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  counts</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>映射的方法见博客<a href=\"https://fleschier.github.io/2018/07/Scala-infos/\" target=\"_blank\" rel=\"noopener\">方法查询</a></p>\n</li>\n<li><p>可变集合和可变映射的工厂方法都采用了hash的技术。例如<code>scala.collection.mutable.Set()</code>这个工厂方法返回一个<code>scala.collection.mutable.HashSet</code>。同理， <code>scala.collection.mutable.Map()</code>这个工厂方法返回一个<code>scala.collection.mutable.HashMap</code></p>\n</li>\n</ul>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><hr>\n<ul>\n<li>元组帮助我们省去定义那些简单的主要承载数据的类的麻烦。<strong>元组的一个常见的应用场景是从方法返回多个值</strong></li>\n</ul>\n<p><br></p>\n<blockquote>\n<p>最后更新于2018.7.24</p>\n</blockquote>\n"},{"layout":"post","title":"hexo重新构建博客","date":"2018-09-03T09:25:00.000Z","_content":"\n## 环境搭建\n---\n\n- 在使用hexo搭建博客之前，需要搭建好环境。需要git、node.js和hexo\n\n- 详细搭建见——[链接](https://neveryu.github.io/2016/09/03/hexo-next-one/)\n\n## hexo\n---\n\n- hexo有大量的主题可供选择，而且支持一键部署\n\n- 但是hexo每次预览要重新生成页面，而jekyll是即时体现更改\n\n### 安装\n\n- `npm install -g hexo-cli`\n\n### 常用命令\n\n- 初始化： `hexo init  //在一个空文件夹下初始化`\n\n- hexo一些命令：\n```\n$ hexo new \"postName\"  #新建文章\n$ hexo new page \"pageName\" # 新建页面\n$ hexo generate # 生成静态页面至public目录 =hexo g\n$ hexo server # 开启预览访问端口(默认端口4000，'ctrl+c'关闭server) = hexo s\n$ hexo deploy # 项目部署 = hexo d\n$ hexo help # 查看帮助\n$ hexo version # 查看Hexo的版本\n```\n\n## 一些问题记录\n---\n\n### 无法'hexo d':缺少插件\n\n- 使用命令：`npm install hexo-deployer-git --save` (在博客的根目录下执行)\n\n### 侧边栏文章索引错乱\n\n- 尽量不要使用跳跃式的标题，比如使用了一个一号标题，然后使用了一个三号标题，接着又使用了一个一号标题，这样很容易就会出现错乱的现象。\n\n- 标题应当逐级递增逐级递减，这样规范之后才会有清晰美观的显示效果。\n\n#### 部署到git\n\n- 部署到Github前需要配置`_config.yml`文件:\n```\ndeploy:\n\ttype: git\n\trepository: git@github.com:Fleschier/Fleschier.github.io.git\n\tbranch: master\n```\n\n- 然后输入:`hexo d`\n\n## 三部曲\n---\n\n- 修改然后预览\n```\nhexo clean\nhexo g\nhexo s --debug //运行预览同时实时生成错误报告\n```\n\n- 修改然后部署\n```\nhexo clean\nhexo g\nhexo d\n```\n","source":"_posts/2018-09-03-Hexo-rebuild.md","raw":"---\nlayout:     post\ntitle:      \"hexo重新构建博客\"\ndate:       2018-09-03 17:25:00\ncategories: Personal Blog\ntags:  ๑Blog\n---\n\n## 环境搭建\n---\n\n- 在使用hexo搭建博客之前，需要搭建好环境。需要git、node.js和hexo\n\n- 详细搭建见——[链接](https://neveryu.github.io/2016/09/03/hexo-next-one/)\n\n## hexo\n---\n\n- hexo有大量的主题可供选择，而且支持一键部署\n\n- 但是hexo每次预览要重新生成页面，而jekyll是即时体现更改\n\n### 安装\n\n- `npm install -g hexo-cli`\n\n### 常用命令\n\n- 初始化： `hexo init  //在一个空文件夹下初始化`\n\n- hexo一些命令：\n```\n$ hexo new \"postName\"  #新建文章\n$ hexo new page \"pageName\" # 新建页面\n$ hexo generate # 生成静态页面至public目录 =hexo g\n$ hexo server # 开启预览访问端口(默认端口4000，'ctrl+c'关闭server) = hexo s\n$ hexo deploy # 项目部署 = hexo d\n$ hexo help # 查看帮助\n$ hexo version # 查看Hexo的版本\n```\n\n## 一些问题记录\n---\n\n### 无法'hexo d':缺少插件\n\n- 使用命令：`npm install hexo-deployer-git --save` (在博客的根目录下执行)\n\n### 侧边栏文章索引错乱\n\n- 尽量不要使用跳跃式的标题，比如使用了一个一号标题，然后使用了一个三号标题，接着又使用了一个一号标题，这样很容易就会出现错乱的现象。\n\n- 标题应当逐级递增逐级递减，这样规范之后才会有清晰美观的显示效果。\n\n#### 部署到git\n\n- 部署到Github前需要配置`_config.yml`文件:\n```\ndeploy:\n\ttype: git\n\trepository: git@github.com:Fleschier/Fleschier.github.io.git\n\tbranch: master\n```\n\n- 然后输入:`hexo d`\n\n## 三部曲\n---\n\n- 修改然后预览\n```\nhexo clean\nhexo g\nhexo s --debug //运行预览同时实时生成错误报告\n```\n\n- 修改然后部署\n```\nhexo clean\nhexo g\nhexo d\n```\n","slug":"2018-09-03-Hexo-rebuild","published":1,"updated":"2018-09-03T14:16:04.187Z","comments":1,"photos":[],"link":"","_id":"cjlnr0j5f003l1m0onq66wk66","content":"<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><hr>\n<ul>\n<li><p>在使用hexo搭建博客之前，需要搭建好环境。需要git、node.js和hexo</p>\n</li>\n<li><p>详细搭建见——<a href=\"https://neveryu.github.io/2016/09/03/hexo-next-one/\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n</li>\n</ul>\n<h2 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h2><hr>\n<ul>\n<li><p>hexo有大量的主题可供选择，而且支持一键部署</p>\n</li>\n<li><p>但是hexo每次预览要重新生成页面，而jekyll是即时体现更改</p>\n</li>\n</ul>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li><code>npm install -g hexo-cli</code></li>\n</ul>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li><p>初始化： <code>hexo init  //在一个空文件夹下初始化</code></p>\n</li>\n<li><p>hexo一些命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &quot;postName&quot;  #新建文章</span><br><span class=\"line\">$ hexo new page &quot;pageName&quot; # 新建页面</span><br><span class=\"line\">$ hexo generate # 生成静态页面至public目录 =hexo g</span><br><span class=\"line\">$ hexo server # 开启预览访问端口(默认端口4000，&apos;ctrl+c&apos;关闭server) = hexo s</span><br><span class=\"line\">$ hexo deploy # 项目部署 = hexo d</span><br><span class=\"line\">$ hexo help # 查看帮助</span><br><span class=\"line\">$ hexo version # 查看Hexo的版本</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"一些问题记录\"><a href=\"#一些问题记录\" class=\"headerlink\" title=\"一些问题记录\"></a>一些问题记录</h2><hr>\n<h3 id=\"无法’hexo-d’-缺少插件\"><a href=\"#无法’hexo-d’-缺少插件\" class=\"headerlink\" title=\"无法’hexo d’:缺少插件\"></a>无法’hexo d’:缺少插件</h3><ul>\n<li>使用命令：<code>npm install hexo-deployer-git --save</code> (在博客的根目录下执行)</li>\n</ul>\n<h3 id=\"侧边栏文章索引错乱\"><a href=\"#侧边栏文章索引错乱\" class=\"headerlink\" title=\"侧边栏文章索引错乱\"></a>侧边栏文章索引错乱</h3><ul>\n<li><p>尽量不要使用跳跃式的标题，比如使用了一个一号标题，然后使用了一个三号标题，接着又使用了一个一号标题，这样很容易就会出现错乱的现象。</p>\n</li>\n<li><p>标题应当逐级递增逐级递减，这样规范之后才会有清晰美观的显示效果。</p>\n</li>\n</ul>\n<h4 id=\"部署到git\"><a href=\"#部署到git\" class=\"headerlink\" title=\"部署到git\"></a>部署到git</h4><ul>\n<li><p>部署到Github前需要配置<code>_config.yml</code>文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">\ttype: git</span><br><span class=\"line\">\trepository: git@github.com:Fleschier/Fleschier.github.io.git</span><br><span class=\"line\">\tbranch: master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后输入:<code>hexo d</code></p>\n</li>\n</ul>\n<h2 id=\"三部曲\"><a href=\"#三部曲\" class=\"headerlink\" title=\"三部曲\"></a>三部曲</h2><hr>\n<ul>\n<li><p>修改然后预览</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s --debug //运行预览同时实时生成错误报告</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改然后部署</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><hr>\n<ul>\n<li><p>在使用hexo搭建博客之前，需要搭建好环境。需要git、node.js和hexo</p>\n</li>\n<li><p>详细搭建见——<a href=\"https://neveryu.github.io/2016/09/03/hexo-next-one/\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n</li>\n</ul>\n<h2 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h2><hr>\n<ul>\n<li><p>hexo有大量的主题可供选择，而且支持一键部署</p>\n</li>\n<li><p>但是hexo每次预览要重新生成页面，而jekyll是即时体现更改</p>\n</li>\n</ul>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li><code>npm install -g hexo-cli</code></li>\n</ul>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li><p>初始化： <code>hexo init  //在一个空文件夹下初始化</code></p>\n</li>\n<li><p>hexo一些命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &quot;postName&quot;  #新建文章</span><br><span class=\"line\">$ hexo new page &quot;pageName&quot; # 新建页面</span><br><span class=\"line\">$ hexo generate # 生成静态页面至public目录 =hexo g</span><br><span class=\"line\">$ hexo server # 开启预览访问端口(默认端口4000，&apos;ctrl+c&apos;关闭server) = hexo s</span><br><span class=\"line\">$ hexo deploy # 项目部署 = hexo d</span><br><span class=\"line\">$ hexo help # 查看帮助</span><br><span class=\"line\">$ hexo version # 查看Hexo的版本</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"一些问题记录\"><a href=\"#一些问题记录\" class=\"headerlink\" title=\"一些问题记录\"></a>一些问题记录</h2><hr>\n<h3 id=\"无法’hexo-d’-缺少插件\"><a href=\"#无法’hexo-d’-缺少插件\" class=\"headerlink\" title=\"无法’hexo d’:缺少插件\"></a>无法’hexo d’:缺少插件</h3><ul>\n<li>使用命令：<code>npm install hexo-deployer-git --save</code> (在博客的根目录下执行)</li>\n</ul>\n<h3 id=\"侧边栏文章索引错乱\"><a href=\"#侧边栏文章索引错乱\" class=\"headerlink\" title=\"侧边栏文章索引错乱\"></a>侧边栏文章索引错乱</h3><ul>\n<li><p>尽量不要使用跳跃式的标题，比如使用了一个一号标题，然后使用了一个三号标题，接着又使用了一个一号标题，这样很容易就会出现错乱的现象。</p>\n</li>\n<li><p>标题应当逐级递增逐级递减，这样规范之后才会有清晰美观的显示效果。</p>\n</li>\n</ul>\n<h4 id=\"部署到git\"><a href=\"#部署到git\" class=\"headerlink\" title=\"部署到git\"></a>部署到git</h4><ul>\n<li><p>部署到Github前需要配置<code>_config.yml</code>文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">\ttype: git</span><br><span class=\"line\">\trepository: git@github.com:Fleschier/Fleschier.github.io.git</span><br><span class=\"line\">\tbranch: master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后输入:<code>hexo d</code></p>\n</li>\n</ul>\n<h2 id=\"三部曲\"><a href=\"#三部曲\" class=\"headerlink\" title=\"三部曲\"></a>三部曲</h2><hr>\n<ul>\n<li><p>修改然后预览</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s --debug //运行预览同时实时生成错误报告</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改然后部署</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjlnr0j4400091m0or4lk3dgw","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j4a000g1m0om503mxo4"},{"post_id":"cjlnr0j3t00021m0o0wsj412v","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j4d000k1m0o6p81fh83"},{"post_id":"cjlnr0j45000a1m0oydwqvu8e","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j4e000n1m0o0pliyca2"},{"post_id":"cjlnr0j47000e1m0opao1y8ap","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j4g000q1m0oozwlvswg"},{"post_id":"cjlnr0j3z00041m0of12ix1u1","category_id":"cjlnr0j46000b1m0ouq8gppxy","_id":"cjlnr0j4h000u1m0orubhzs4p"},{"post_id":"cjlnr0j49000f1m0oz0e4vjji","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j4i000x1m0o6xebwg6j"},{"post_id":"cjlnr0j4b000j1m0osyn6stvu","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j4j00111m0ovkqc18un"},{"post_id":"cjlnr0j4300081m0o0ybtww4y","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j4k00141m0olij73g1a"},{"post_id":"cjlnr0j4h000w1m0o95rf8yug","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j4m00181m0o2us00jna"},{"post_id":"cjlnr0j4d000m1m0obul5h5ek","category_id":"cjlnr0j4g000s1m0os6mya4qp","_id":"cjlnr0j4n001b1m0ohftx0pnr"},{"post_id":"cjlnr0j4k00131m0o06n1w2gr","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j4o001f1m0oz0ghmi3p"},{"post_id":"cjlnr0j4f000p1m0oe85wkwsn","category_id":"cjlnr0j4g000s1m0os6mya4qp","_id":"cjlnr0j4p001h1m0ozz79nesd"},{"post_id":"cjlnr0j4l00161m0oqgamtr6z","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j4r001l1m0otjo9p5bq"},{"post_id":"cjlnr0j4g000t1m0o6y2vwebi","category_id":"cjlnr0j4g000s1m0os6mya4qp","_id":"cjlnr0j4s001o1m0o646mmf0i"},{"post_id":"cjlnr0j4i000z1m0o95shftfw","category_id":"cjlnr0j4o001e1m0om6licqzg","_id":"cjlnr0j4t001t1m0ot799vz64"},{"post_id":"cjlnr0j4q001k1m0o8rqiudyq","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j4u001w1m0omwagl5xe"},{"post_id":"cjlnr0j4m001a1m0ogmjoywts","category_id":"cjlnr0j4o001e1m0om6licqzg","_id":"cjlnr0j4w00201m0oit5ncocp"},{"post_id":"cjlnr0j4t001r1m0orcj3g1z4","category_id":"cjlnr0j4g000s1m0os6mya4qp","_id":"cjlnr0j4w00221m0oo7yelouc"},{"post_id":"cjlnr0j4u001v1m0o9cbrml0u","category_id":"cjlnr0j4o001e1m0om6licqzg","_id":"cjlnr0j4y00251m0outdo7yrt"},{"post_id":"cjlnr0j4n001d1m0o8aftp9aj","category_id":"cjlnr0j4o001e1m0om6licqzg","_id":"cjlnr0j4z00291m0o1d3ceji0"},{"post_id":"cjlnr0j4w00211m0o5030n2jt","category_id":"cjlnr0j4o001e1m0om6licqzg","_id":"cjlnr0j51002d1m0o0ta5atjp"},{"post_id":"cjlnr0j4o001g1m0ot7nopieo","category_id":"cjlnr0j4v001z1m0osyp1i4fn","_id":"cjlnr0j52002g1m0o2pu0o29m"},{"post_id":"cjlnr0j4r001n1m0o2bmglss0","category_id":"cjlnr0j4v001z1m0osyp1i4fn","_id":"cjlnr0j55002k1m0oe41x49f7"},{"post_id":"cjlnr0j50002c1m0obnc7wexm","category_id":"cjlnr0j4g000s1m0os6mya4qp","_id":"cjlnr0j56002o1m0oowpf1wf9"},{"post_id":"cjlnr0j51002f1m0ournd36lq","category_id":"cjlnr0j51002e1m0ois8ngr37","_id":"cjlnr0j57002r1m0o5qymho8a"},{"post_id":"cjlnr0j4v001y1m0oc1tkgvia","category_id":"cjlnr0j51002e1m0ois8ngr37","_id":"cjlnr0j58002u1m0ohb8gwwi3"},{"post_id":"cjlnr0j52002i1m0o9i2osr1i","category_id":"cjlnr0j51002e1m0ois8ngr37","_id":"cjlnr0j59002y1m0olljzsc84"},{"post_id":"cjlnr0j55002m1m0o7dvqsb33","category_id":"cjlnr0j51002e1m0ois8ngr37","_id":"cjlnr0j5a00311m0oyz7wouf4"},{"post_id":"cjlnr0j56002q1m0osla929td","category_id":"cjlnr0j46000b1m0ouq8gppxy","_id":"cjlnr0j5b00351m0octf1knty"},{"post_id":"cjlnr0j4x00241m0og0s91nps","category_id":"cjlnr0j55002l1m0omf9ikx7y","_id":"cjlnr0j5c00381m0ow3lgs67g"},{"post_id":"cjlnr0j57002s1m0oslzl5qcn","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j5d003c1m0ov1ds3yae"},{"post_id":"cjlnr0j58002x1m0o3htf7kdo","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j5e003f1m0oqd3katub"},{"post_id":"cjlnr0j4y00281m0obiw20ezk","category_id":"cjlnr0j57002t1m0oguba0ubw","_id":"cjlnr0j5f003j1m0ouby9v2ih"},{"post_id":"cjlnr0j5900301m0ojqsav55x","category_id":"cjlnr0j57002t1m0oguba0ubw","_id":"cjlnr0j5g003m1m0oyonlc5gt"},{"post_id":"cjlnr0j5a00341m0otoj9jpjv","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j5h003p1m0ot49kic4g"},{"post_id":"cjlnr0j5b00371m0oy3minyyg","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j5h003r1m0oyk27upu9"},{"post_id":"cjlnr0j5c003a1m0oanivc7vz","category_id":"cjlnr0j4g000s1m0os6mya4qp","_id":"cjlnr0j5h003u1m0o83n5oy25"},{"post_id":"cjlnr0j5d003e1m0ovepoz6yt","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j5i003w1m0o0nvbut4q"},{"post_id":"cjlnr0j5e003h1m0o6e21035b","category_id":"cjlnr0j4100061m0okb7hgbbz","_id":"cjlnr0j5i003y1m0osxhsnr0j"},{"post_id":"cjlnr0j5f003l1m0onq66wk66","category_id":"cjlnr0j46000b1m0ouq8gppxy","_id":"cjlnr0j5i00411m0okp9vilbf"}],"PostTag":[{"post_id":"cjlnr0j3t00021m0o0wsj412v","tag_id":"cjlnr0j4300071m0o1hbl9zry","_id":"cjlnr0j47000d1m0ovndvq7s1"},{"post_id":"cjlnr0j3z00041m0of12ix1u1","tag_id":"cjlnr0j46000c1m0os9smxain","_id":"cjlnr0j4d000l1m0odhw1vgxx"},{"post_id":"cjlnr0j4300081m0o0ybtww4y","tag_id":"cjlnr0j4a000i1m0opsu4re0m","_id":"cjlnr0j4g000r1m0oryp5x2p2"},{"post_id":"cjlnr0j4400091m0or4lk3dgw","tag_id":"cjlnr0j4a000i1m0opsu4re0m","_id":"cjlnr0j4i000y1m0o85pxdr56"},{"post_id":"cjlnr0j45000a1m0oydwqvu8e","tag_id":"cjlnr0j4h000v1m0olpyerbru","_id":"cjlnr0j4l00151m0org3k7duh"},{"post_id":"cjlnr0j47000e1m0opao1y8ap","tag_id":"cjlnr0j4a000i1m0opsu4re0m","_id":"cjlnr0j4n001c1m0otcpt2879"},{"post_id":"cjlnr0j49000f1m0oz0e4vjji","tag_id":"cjlnr0j4m00191m0okfjzir17","_id":"cjlnr0j4q001j1m0ouu0e6916"},{"post_id":"cjlnr0j4q001k1m0o8rqiudyq","tag_id":"cjlnr0j4h000v1m0olpyerbru","_id":"cjlnr0j4s001q1m0oenxckvn8"},{"post_id":"cjlnr0j4b000j1m0osyn6stvu","tag_id":"cjlnr0j4m00191m0okfjzir17","_id":"cjlnr0j4u001u1m0o2dr0i6of"},{"post_id":"cjlnr0j4d000m1m0obul5h5ek","tag_id":"cjlnr0j4s001p1m0ojylcojq5","_id":"cjlnr0j4y00261m0od2p5su54"},{"post_id":"cjlnr0j4d000m1m0obul5h5ek","tag_id":"cjlnr0j4v001x1m0otaixvb8l","_id":"cjlnr0j4z002a1m0oyva7h6ek"},{"post_id":"cjlnr0j4f000p1m0oe85wkwsn","tag_id":"cjlnr0j4s001p1m0ojylcojq5","_id":"cjlnr0j54002j1m0oq6tpl62v"},{"post_id":"cjlnr0j4f000p1m0oe85wkwsn","tag_id":"cjlnr0j4v001x1m0otaixvb8l","_id":"cjlnr0j55002n1m0obvuf7cvv"},{"post_id":"cjlnr0j56002q1m0osla929td","tag_id":"cjlnr0j46000c1m0os9smxain","_id":"cjlnr0j58002v1m0oi1k1ixtl"},{"post_id":"cjlnr0j57002s1m0oslzl5qcn","tag_id":"cjlnr0j4m00191m0okfjzir17","_id":"cjlnr0j59002z1m0o91qgal4r"},{"post_id":"cjlnr0j58002x1m0o3htf7kdo","tag_id":"cjlnr0j4m00191m0okfjzir17","_id":"cjlnr0j5a00321m0o4myj4dg2"},{"post_id":"cjlnr0j4g000t1m0o6y2vwebi","tag_id":"cjlnr0j52002h1m0oxezofjkc","_id":"cjlnr0j5b00361m0os3aonvpo"},{"post_id":"cjlnr0j4g000t1m0o6y2vwebi","tag_id":"cjlnr0j4s001p1m0ojylcojq5","_id":"cjlnr0j5c00391m0owzgxb4l2"},{"post_id":"cjlnr0j4g000t1m0o6y2vwebi","tag_id":"cjlnr0j4v001x1m0otaixvb8l","_id":"cjlnr0j5d003d1m0oqj43samw"},{"post_id":"cjlnr0j5a00341m0otoj9jpjv","tag_id":"cjlnr0j4m00191m0okfjzir17","_id":"cjlnr0j5e003g1m0oy5jwhgkh"},{"post_id":"cjlnr0j5b00371m0oy3minyyg","tag_id":"cjlnr0j4m00191m0okfjzir17","_id":"cjlnr0j5f003k1m0oyohed2n0"},{"post_id":"cjlnr0j4h000w1m0o95rf8yug","tag_id":"cjlnr0j5a00331m0obmbw6u3b","_id":"cjlnr0j5g003n1m0otc5c1l05"},{"post_id":"cjlnr0j5d003e1m0ovepoz6yt","tag_id":"cjlnr0j4m00191m0okfjzir17","_id":"cjlnr0j5h003q1m0oz4wum6ty"},{"post_id":"cjlnr0j5e003h1m0o6e21035b","tag_id":"cjlnr0j4m00191m0okfjzir17","_id":"cjlnr0j5h003s1m0oru24gya5"},{"post_id":"cjlnr0j5f003l1m0onq66wk66","tag_id":"cjlnr0j46000c1m0os9smxain","_id":"cjlnr0j5i003v1m0o5fla9nl9"},{"post_id":"cjlnr0j4i000z1m0o95shftfw","tag_id":"cjlnr0j5d003b1m0ovzwe6jcc","_id":"cjlnr0j5i003x1m0op2sng6bh"},{"post_id":"cjlnr0j4i000z1m0o95shftfw","tag_id":"cjlnr0j4s001p1m0ojylcojq5","_id":"cjlnr0j5i00401m0om0l6bsya"},{"post_id":"cjlnr0j4i000z1m0o95shftfw","tag_id":"cjlnr0j4v001x1m0otaixvb8l","_id":"cjlnr0j5i00421m0oyqe73wqr"},{"post_id":"cjlnr0j4k00131m0o06n1w2gr","tag_id":"cjlnr0j5h003t1m0on64op8vk","_id":"cjlnr0j5j00441m0om8789bo3"},{"post_id":"cjlnr0j4k00131m0o06n1w2gr","tag_id":"cjlnr0j5i003z1m0oq7kmrg3d","_id":"cjlnr0j5j00451m0orbrvhu3z"},{"post_id":"cjlnr0j4l00161m0oqgamtr6z","tag_id":"cjlnr0j5h003t1m0on64op8vk","_id":"cjlnr0j5k00481m0oqyneysm8"},{"post_id":"cjlnr0j4l00161m0oqgamtr6z","tag_id":"cjlnr0j5i003z1m0oq7kmrg3d","_id":"cjlnr0j5k00491m0o1cs67lsx"},{"post_id":"cjlnr0j4m001a1m0ogmjoywts","tag_id":"cjlnr0j5k00471m0oz35uroym","_id":"cjlnr0j5k004b1m0o5aen9bmu"},{"post_id":"cjlnr0j4n001d1m0o8aftp9aj","tag_id":"cjlnr0j5k004a1m0ow279fxeg","_id":"cjlnr0j5l004d1m0obq5h7cxz"},{"post_id":"cjlnr0j4o001g1m0ot7nopieo","tag_id":"cjlnr0j5k004c1m0oj65necey","_id":"cjlnr0j5m004h1m0oqvkq15sc"},{"post_id":"cjlnr0j4o001g1m0ot7nopieo","tag_id":"cjlnr0j4s001p1m0ojylcojq5","_id":"cjlnr0j5m004i1m0om10iw3h3"},{"post_id":"cjlnr0j4o001g1m0ot7nopieo","tag_id":"cjlnr0j4v001x1m0otaixvb8l","_id":"cjlnr0j5m004k1m0o63zyi3qv"},{"post_id":"cjlnr0j4r001n1m0o2bmglss0","tag_id":"cjlnr0j5k004c1m0oj65necey","_id":"cjlnr0j5m004l1m0og03ri6ii"},{"post_id":"cjlnr0j4t001r1m0orcj3g1z4","tag_id":"cjlnr0j4s001p1m0ojylcojq5","_id":"cjlnr0j5n004n1m0oiwz38udb"},{"post_id":"cjlnr0j4t001r1m0orcj3g1z4","tag_id":"cjlnr0j4v001x1m0otaixvb8l","_id":"cjlnr0j5n004o1m0o5ibbiu98"},{"post_id":"cjlnr0j4u001v1m0o9cbrml0u","tag_id":"cjlnr0j5k00471m0oz35uroym","_id":"cjlnr0j5n004q1m0o4qm3z6y9"},{"post_id":"cjlnr0j4v001y1m0oc1tkgvia","tag_id":"cjlnr0j5n004p1m0o3fligr1v","_id":"cjlnr0j5n004t1m0obwct6pf6"},{"post_id":"cjlnr0j4v001y1m0oc1tkgvia","tag_id":"cjlnr0j5n004r1m0ojxvf6vcy","_id":"cjlnr0j5o004u1m0o40ug2xny"},{"post_id":"cjlnr0j4w00211m0o5030n2jt","tag_id":"cjlnr0j5k00471m0oz35uroym","_id":"cjlnr0j5o004w1m0owgo88yjs"},{"post_id":"cjlnr0j4x00241m0og0s91nps","tag_id":"cjlnr0j5o004v1m0osem49oeq","_id":"cjlnr0j5o004z1m0o3d9jl9yn"},{"post_id":"cjlnr0j4x00241m0og0s91nps","tag_id":"cjlnr0j5n004p1m0o3fligr1v","_id":"cjlnr0j5o00501m0ov4eb0re6"},{"post_id":"cjlnr0j4y00281m0obiw20ezk","tag_id":"cjlnr0j5o004y1m0oojckryb3","_id":"cjlnr0j5p00531m0o5v97v1ub"},{"post_id":"cjlnr0j4y00281m0obiw20ezk","tag_id":"cjlnr0j5i003z1m0oq7kmrg3d","_id":"cjlnr0j5p00541m0o3r72s0do"},{"post_id":"cjlnr0j50002c1m0obnc7wexm","tag_id":"cjlnr0j5o004y1m0oojckryb3","_id":"cjlnr0j5r00591m0ox4e44jue"},{"post_id":"cjlnr0j50002c1m0obnc7wexm","tag_id":"cjlnr0j5i003z1m0oq7kmrg3d","_id":"cjlnr0j5r005a1m0of8rvplyg"},{"post_id":"cjlnr0j50002c1m0obnc7wexm","tag_id":"cjlnr0j5q00561m0otpsbp0pl","_id":"cjlnr0j5r005c1m0o5pk978p1"},{"post_id":"cjlnr0j50002c1m0obnc7wexm","tag_id":"cjlnr0j5h003t1m0on64op8vk","_id":"cjlnr0j5r005d1m0ota67imo1"},{"post_id":"cjlnr0j51002f1m0ournd36lq","tag_id":"cjlnr0j5n004r1m0ojxvf6vcy","_id":"cjlnr0j5r005f1m0owguhoief"},{"post_id":"cjlnr0j51002f1m0ournd36lq","tag_id":"cjlnr0j5r005b1m0ooqctionk","_id":"cjlnr0j5r005g1m0ouiyd0f8h"},{"post_id":"cjlnr0j52002i1m0o9i2osr1i","tag_id":"cjlnr0j5n004r1m0ojxvf6vcy","_id":"cjlnr0j5s005j1m0o5mh90w4g"},{"post_id":"cjlnr0j52002i1m0o9i2osr1i","tag_id":"cjlnr0j5r005h1m0obb86tc38","_id":"cjlnr0j5s005k1m0obvxyejce"},{"post_id":"cjlnr0j55002m1m0o7dvqsb33","tag_id":"cjlnr0j5n004r1m0ojxvf6vcy","_id":"cjlnr0j5t005n1m0oiiujug8s"},{"post_id":"cjlnr0j55002m1m0o7dvqsb33","tag_id":"cjlnr0j5s005l1m0obg9gxqa7","_id":"cjlnr0j5t005o1m0ozzpdsxe5"},{"post_id":"cjlnr0j5900301m0ojqsav55x","tag_id":"cjlnr0j5o004y1m0oojckryb3","_id":"cjlnr0j5t005r1m0owfbgpcq4"},{"post_id":"cjlnr0j5900301m0ojqsav55x","tag_id":"cjlnr0j4v001x1m0otaixvb8l","_id":"cjlnr0j5t005s1m0oos10p0mf"},{"post_id":"cjlnr0j5900301m0ojqsav55x","tag_id":"cjlnr0j5t005p1m0onps2d05d","_id":"cjlnr0j5t005t1m0o0gzngmzc"},{"post_id":"cjlnr0j5c003a1m0oanivc7vz","tag_id":"cjlnr0j5t005q1m0o99m6dduy","_id":"cjlnr0j5t005u1m0obterbwbp"}],"Tag":[{"name":"๑C++","_id":"cjlnr0j4300071m0o1hbl9zry"},{"name":"๑Blog","_id":"cjlnr0j46000c1m0os9smxain"},{"name":"๑Java","_id":"cjlnr0j4a000i1m0opsu4re0m"},{"name":"๑Python","_id":"cjlnr0j4h000v1m0olpyerbru"},{"name":"๑Scala","_id":"cjlnr0j4m00191m0okfjzir17"},{"name":"๑Ubuntu","_id":"cjlnr0j4s001p1m0ojylcojq5"},{"name":"๑Linux","_id":"cjlnr0j4v001x1m0otaixvb8l"},{"name":"๑DualSystem","_id":"cjlnr0j52002h1m0oxezofjkc"},{"name":"๑SQL","_id":"cjlnr0j5a00331m0obmbw6u3b"},{"name":"๑Git","_id":"cjlnr0j5d003b1m0ovzwe6jcc"},{"name":"๑Spark","_id":"cjlnr0j5h003t1m0on64op8vk"},{"name":"๑BigData","_id":"cjlnr0j5i003z1m0oq7kmrg3d"},{"name":"๑BlockChain","_id":"cjlnr0j5k00471m0oz35uroym"},{"name":"๑FileTypes","_id":"cjlnr0j5k004a1m0ow279fxeg"},{"name":"๑ScientificSurfing","_id":"cjlnr0j5k004c1m0oj65necey"},{"name":"๑JS","_id":"cjlnr0j5n004p1m0o3fligr1v"},{"name":"๑FrontEnd","_id":"cjlnr0j5n004r1m0ojxvf6vcy"},{"name":"๑JetBrains","_id":"cjlnr0j5o004v1m0osem49oeq"},{"name":"๑Hadoop","_id":"cjlnr0j5o004y1m0oojckryb3"},{"name":"๑HDFS","_id":"cjlnr0j5q00561m0otpsbp0pl"},{"name":"๑CSS","_id":"cjlnr0j5r005b1m0ooqctionk"},{"name":"๑Html","_id":"cjlnr0j5r005h1m0obb86tc38"},{"name":"๑JavaScrpt","_id":"cjlnr0j5s005l1m0obg9gxqa7"},{"name":"๑CLuster","_id":"cjlnr0j5t005p1m0onps2d05d"},{"name":"๑Windows","_id":"cjlnr0j5t005q1m0o99m6dduy"}]}}